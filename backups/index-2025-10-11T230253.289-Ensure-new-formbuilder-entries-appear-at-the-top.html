<!doctype html> 
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" id="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
  <title>Events Platform</title>
  <link rel="apple-touch-icon" sizes="180x180" href="assets/favicons/apple-touch-icon.png" />
  <link rel="icon" type="image/png" sizes="32x32" href="assets/favicons/favicon-32x32.png" />
  <link rel="icon" type="image/png" sizes="16x16" href="assets/favicons/favicon-16x16.png" />
  <link rel="icon" type="image/png" sizes="192x192" href="assets/favicons/android-chrome-192x192.png" />
  <link rel="icon" type="image/png" sizes="512x512" href="assets/favicons/android-chrome-512x512.png" />
  <link rel="manifest" href="assets/favicons/site.webmanifest" />
  <link rel="shortcut icon" href="assets/favicons/favicon.ico" />
  <link id="mapbox-gl-css" rel="stylesheet"
        href="https://api.mapbox.com/mapbox-gl-js/v3.15.0/mapbox-gl.css" />

  <style id="hotfixes">
    /* Hand cursor for DOM-based Mapbox markers */
    .mapboxgl-marker,
    .marker,
    .is-clickable {
      cursor: pointer;
    }

    .mapboxgl-popup-track-pointer * {
      -webkit-user-select: none;
      user-select: none;
    }

    .logo img.is-loading {
      animation: logo-rotate 1s linear infinite;
      transform-origin: 50% 50%;
    }

    @keyframes logo-rotate {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }

    /* Menus stay clickable above overlays */
    .options-menu { z-index: 10000; }

    /* Cards stay clickable on narrow screens */
    @media (max-width: 600px){
      .post-card, .post { position: relative; z-index: 2; }
    }
  </style>

  <style>
    .big-map-card{
      position: relative;
      width: 225px;
      height: 60px;
      transform: translate3d(0, 0, 0);
      will-change: transform;
      pointer-events: auto;
      isolation: isolate;
      touch-action: none;
      border-radius: 999px;
    }
    .mapmarker-overlay{
      position: relative;
      width: 0;
      height: 0;
      transform: translateZ(0);
      pointer-events: none;
      isolation: isolate;
      touch-action: none;
      background: transparent;
      border-radius: 999px;
      box-shadow: none;
      z-index: 5;
      will-change: transform;
    }
    .mapmarker-overlay > .big-map-card{
      position: absolute;
      left: 0;
      top: 0;
      transform: translate3d(-30px, -30px, 0);
      pointer-events: auto;
      z-index: 30;
    }
    .mapmarker-overlay.is-card-visible > .small-map-card{
      opacity: 0;
      visibility: hidden;
    }
    .mapmarker-overlay.is-card-visible{
      pointer-events: auto;
      z-index: 20000;
    }
    .big-map-card img,
    .small-map-card img{ display:block; }
    .map-card-pill{
      position: absolute;
      inset: auto;
      left: 5px;
      top: 5px;
      right: 5px;
      bottom: 5px;
      object-fit: contain;
      pointer-events: none;
      opacity: 0 !important;
      visibility: hidden;
      mix-blend-mode: normal;
      z-index: 0;
    }
    .small-map-card{
      position: absolute;
      left: 0;
      top: 0;
      width: 150px;
      height: 40px;
      transform: translate3d(-20px, -20px, 0);
      pointer-events: none;
      border-radius: 999px;
      background: rgba(0, 0, 0, 0.9);
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 5px 10px 5px 5px;
      box-sizing: border-box;
      transition: background-color 0.2s ease;
    }
    .small-multi-post-map-card{
      gap: 5px;
      padding-right: 10px;
    }
    .small-multi-post-map-card .mapmarker{
      flex: 0 0 30px;
      width: 30px;
      height: 30px;
      object-fit: contain;
    }
    .small-multi-post-map-card .mapmarker-label{
      position: static;
      left: auto;
      top: auto;
      width: auto;
      height: auto;
      padding: 0;
      gap: 2px;
      align-items: flex-start;
    }
    .small-multi-post-map-card .mapmarker-label-line{
      width: auto;
      text-align: left;
    }
    .small-multi-post-map-card .mapmarker-label-line:first-child{
      font-weight: 600;
    }
    .mapmarker{
      position: relative;
      left: auto;
      top: auto;
      width: 30px;
      height: 30px;
      pointer-events: none;
      z-index: 2;
      flex: 0 0 30px;
    }
    .map--midzoom-markers .mapmarker{
      border-radius: 50%;
      box-shadow: 0 0 0 3px #000;
      box-sizing: border-box;
    }
    .mapmarker-pill{
      position: absolute;
      left: 0;
      top: 0;
      width: 150px;
      height: 40px;
      object-fit: contain;
      pointer-events: none;
      opacity: 0;
      visibility: hidden;
      mix-blend-mode: normal;
      z-index: 0;
    }
    .big-map-card--popup{
      background-color: rgba(0, 0, 0, 0.88);
      transition: background-color 0.2s ease;
    }
    .big-map-card--popup.is-map-highlight,
    .mapmarker-overlay:hover .big-map-card--popup{
      background-color: #2e3a72;
    }
    .open-post .post-header.is-map-highlight{
      background-color: #2e3a72;
    }
    .small-map-card.is-pill-highlight{
      background-color: #2e3a72;
    }
    .mapmarker-overlay:hover .small-map-card{
      background-color: #2e3a72;
    }
    .map-card-thumb{
      position: absolute;
      left: 5px;
      top: 5px;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      object-fit: cover;
      box-shadow: 0 2px 6px rgba(0,0,0,0.35);
      z-index: 40;
    }
    .big-multi-post-map-card .map-card-thumb{
      border-radius: 12px;
      object-fit: contain;
      background: transparent;
      box-shadow: none;
    }
    .map-card-label,
    .mapmarker-label{
      position: absolute;
      left: 60px;
      top: 5px;
      width: calc(100% - 65px);
      height: 50px;
      padding: 0 5px 0 0;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: flex-start;
      gap: 2px;
      color: #fff;
      font-size: 12px;
      font-weight: 400;
      line-height: 1.2;
      white-space: normal;
      overflow: hidden;
      text-overflow: ellipsis;
      text-shadow: 0 1px 2px rgba(0,0,0,0.35);
      z-index: 1;
      pointer-events: auto;
    }

    .mapmarker-label{
      position: relative;
      left: auto;
      top: auto;
      width: auto;
      height: auto;
      padding: 0;
      pointer-events: none;
      color: #fff;
      gap: 1px;
      text-shadow: 0 1px 2px rgba(0,0,0,0.4);
      white-space: normal;
      z-index: 3;
      text-align: left;
      flex: 1 1 auto;
      min-width: 0;
      justify-content: center;
      align-items: flex-start;
    }

    .mapmarker-label-line{
      width: 100%;
      display: block;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .mapmarker-label-line:first-child{ font-weight: 600; }
    .mapmarker-label-line:not(:first-child){ font-weight: 400; }

    .post-location-marker{
      width: 32px;
      height: 32px;
      border-radius: 50%;
      box-shadow: 0 2px 4px rgba(0,0,0,0.4);
      transition: transform 0.2s ease, filter 0.2s ease, opacity 0.2s ease;
      cursor: pointer;
      display: block;
    }
    .post-location-marker.is-dimmed{
      filter: grayscale(100%);
      opacity: 0.5;
      transform: scale(0.9);
    }
    .post-location-marker.is-selected{
      filter: none;
      opacity: 1;
      transform: scale(1.1);
    }

    .map-card-label{
      justify-content: center;
    }

    .map-card-title{
      display: flex;
      flex-direction: column;
      gap: 1px;
      width: 100%;
    }

    .map-card-title-line{
      width: 100%;
      display: block;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      font-size: 12px;
      line-height: 1.2;
      font-weight: 400;
    }

    .map-card-venue{
      font-weight: 400;
      font-size: 12px;
      line-height: 1.2;
      opacity: 0.9;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      width: 100%;
      margin-top: 0;
      color: #d0d0d0;
    }
    .big-map-card--list{
      position: relative;
      width: 100%;
      height: auto;
      display: flex;
      align-items: center;
      gap: 12px;
      transform: none;
      background: none;
      border-radius: 0;
      box-shadow: none;
    }
    .big-map-card--list .map-card-thumb{
      position: static;
      width: 64px;
      height: 64px;
      border-radius: 8px;
      box-shadow: none;
      flex: 0 0 64px;
    }
    .big-map-card--list .map-card-label{
      position: static;
      width: auto;
      height: auto;
      padding: 0;
      gap: 4px;
      text-shadow: none;
    }
    .big-map-card--list .map-card-title{
      white-space: normal;
    }
    .big-map-card--list .map-card-title-line{
      white-space: normal;
    }
    .big-map-card--list .map-card-venue{
      white-space: nowrap;
    }
  </style>

  <script>
    (function(){
      const LOADING_CLASS = 'is-loading';
      let pendingCount = 0;
      let logoImg = null;
      let updatePending = false;
      let stopRequested = false;
      let stopTimeoutId = null;

      function handleAnimationLoop(){
        if(stopRequested && pendingCount === 0){
          finalizeStop();
        }
      }

      function ensureLogo(){
        if(!logoImg){
          logoImg = document.querySelector('.logo img');
          if(logoImg && !logoImg.__logoAnimationBound){
            try{
              logoImg.addEventListener('animationiteration', handleAnimationLoop);
              logoImg.addEventListener('animationend', handleAnimationLoop);
            }catch(err){}
            logoImg.__logoAnimationBound = true;
          }
        }
        return logoImg;
      }

      function finalizeStop(){
        const img = ensureLogo();
        if(!img){
          return;
        }
        stopRequested = false;
        if(stopTimeoutId){
          clearTimeout(stopTimeoutId);
          stopTimeoutId = null;
        }
        if(img.classList && img.classList.contains(LOADING_CLASS)){
          img.classList.remove(LOADING_CLASS);
        } else if(!img.classList && img.style){
          img.style.animation = '';
        }
      }

      function requestStop(){
        const img = ensureLogo();
        if(!img){
          return;
        }
        if(pendingCount > 0){
          return;
        }
        let isAnimating = false;
        if(img.classList){
          isAnimating = img.classList.contains(LOADING_CLASS);
        } else if(img.style){
          isAnimating = typeof img.style.animation === 'string' && img.style.animation !== '';
        }
        if(!isAnimating){
          finalizeStop();
          return;
        }
        if(stopRequested){
          return;
        }
        stopRequested = true;
        if(stopTimeoutId){
          clearTimeout(stopTimeoutId);
        }
        stopTimeoutId = setTimeout(()=>{
          if(stopRequested && pendingCount === 0){
            finalizeStop();
          }
        }, 1200);
      }

      function applyState(){
        updatePending = false;
        const img = ensureLogo();
        if(!img){
          return;
        }
        if(pendingCount > 0){
          stopRequested = false;
          if(stopTimeoutId){
            clearTimeout(stopTimeoutId);
            stopTimeoutId = null;
          }
          if(img.classList && !img.classList.contains(LOADING_CLASS)){
            img.classList.add(LOADING_CLASS);
          } else if(!img.classList){
            img.style.animation = 'logo-rotate 1s linear infinite';
          }
        } else {
          requestStop();
        }
      }

      function scheduleUpdate(){
        if(updatePending){
          return;
        }
        updatePending = true;
        if(typeof requestAnimationFrame === 'function'){
          requestAnimationFrame(applyState);
        } else {
          setTimeout(applyState, 0);
        }
      }

      function begin(){
        pendingCount++;
        scheduleUpdate();
      }

      function end(){
        if(pendingCount > 0){
          pendingCount--;
        }
        scheduleUpdate();
      }

      if(document.readyState === 'complete' || document.readyState === 'interactive'){
        ensureLogo();
        scheduleUpdate();
      } else {
        document.addEventListener('DOMContentLoaded', () => {
          ensureLogo();
          scheduleUpdate();
        });
      }

      window.addEventListener('pageshow', () => {
        ensureLogo();
        scheduleUpdate();
      });

      const originalFetch = window.fetch;
      if(typeof originalFetch === 'function'){
        window.fetch = function(...args){
          begin();
          let finished = false;
          const finalize = () => {
            if(finished) return;
            finished = true;
            end();
          };
          try{
            const response = originalFetch.apply(this, args);
            Promise.resolve(response).then(finalize, finalize);
            return response;
          } catch(err){
            finalize();
            throw err;
          }
        };
      }

      if('XMLHttpRequest' in window && XMLHttpRequest.prototype){
        const originalSend = XMLHttpRequest.prototype.send;
        if(typeof originalSend === 'function'){
          XMLHttpRequest.prototype.send = function(...args){
            begin();
            let finalized = false;
            const finalize = () => {
              if(finalized) return;
              finalized = true;
              this.removeEventListener('loadend', finalize);
              end();
            };
            this.addEventListener('loadend', finalize);
            try{
              return originalSend.apply(this, args);
            } catch(err){
              finalize();
              throw err;
            }
          };
        }
      }

      const loaderApi = (()=>{
        const api = {
          begin(){ begin(); },
          end(){ end(); },
          track(promise){
            if(!promise || typeof promise.then !== 'function'){
              return promise;
            }
            let settled = false;
            begin();
            const finalize = () => {
              if(settled) return;
              settled = true;
              end();
            };
            Promise.resolve(promise).then(finalize, finalize);
            return promise;
          }
        };
        return api;
      })();

      const existingLoader = window.__logoLoading && typeof window.__logoLoading === 'object'
        ? window.__logoLoading
        : {};
      existingLoader.begin = loaderApi.begin;
      existingLoader.end = loaderApi.end;
      existingLoader.track = loaderApi.track;
      existingLoader.trackPromise = loaderApi.track;
      window.__logoLoading = existingLoader;
    })();
  </script>

  <style id="mapboxgl-critical-css">
    .mapboxgl-map{position:relative;width:100%;height:100%}
    .mapboxgl-canvas{position:absolute;left:0;top:0}
    .mapboxgl-canvas-container{position:absolute;inset:0}
    .mapboxgl-ctrl{box-sizing:border-box}
  </style>
  <link
    rel="stylesheet"
    href="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-geocoder/v5.0.0/mapbox-gl-geocoder.css"
    data-fallback="https://unpkg.com/@mapbox/mapbox-gl-geocoder@5.0.0/dist/mapbox-gl-geocoder.css"
    onerror="if(this.dataset.fallback && this.href !== this.dataset.fallback){this.dataset.fallbackState='retry';this.href=this.dataset.fallback;}else{this.dataset.fallbackState='failed';}"
  />
  <style>:root{
  --header-h: 56px;
  --subheader-h: 0;
  --panel-w: 440px;
  --results-w: 530px;
  --post-board-max-w: 530px;
  --gap: 10px;
  --logo-size: 40px;
    --filter-panel-offset: 0px;
    --panel-transition-duration: 0.3s;
    --panel-area-height: calc((var(--vh, 1vh) * 100) - var(--header-h) - var(--safe-top) - var(--footer-h));
    --media-h: 200px;
    --calendar-scale: 1;
    --ink: #ffffff;
    --ink-d: #ececec;
    --gold: #ffc107; 
    --muted: #777;
      --primary: #3E5393;
      --secondary: #000000;
      --accent: #5C6FB1;
      --active: #2E3A72;
      --background: rgba(41,41,41,1);
      --text: #ffffff;
      --button-text: #ffffff;
      --button-hover-text: #ffffff;
      --button-active-text: #ffffff;
      --button-disabled-text: #666666;
      --btn: #333333;
      --btn-hover: #4d4d4d;
      --btn-active: #1a1a1a;
      --btn-selected: #2e3a72;
      --btn-selected-hover: #3c4b8a;
      --btn-selected-active: #232e59;
      --btn-disabled: #bbbbbb;
      --panel-bg: rgba(0,0,0,1);
      --panel-text: #000000;
      --footer-h: 0px;
      --list-background: rgba(0,0,0,0.37);
      --closed-card-bg: rgba(0,0,0,0.37);
      --scrollbar-track: rgba(0,0,0,0);
      --scrollbar-thumb: rgba(0,0,0,0.3);
      --scrollbar-thumb-hover: rgba(0,0,0,0.5);
      --scrollbar-h: 8px;
      --border: rgba(173,173,173,0.31);
      --border-hover: rgba(255,136,0,0.43);
      --border-active: rgba(255,200,0,0.45);
      --placeholder-text: gray;
      --filter-placeholder-text: var(--placeholder-text);
      --popup-bg: rgba(0,0,0,1);
      --popup-text: #ffffff;
      --dropdown-title: #000000;
      --dropdown-selected-bg: #7c4dff;
      --dropdown-selected-text: #ffffff;
      --dropdown-text: #000000;
      --dropdown-bg: rgba(255,255,255,1);
      --dropdown-hover-bg: rgba(224,224,224,1);
      --dropdown-hover-text: #000000;
        --dropdown-venue-text: #000000;
        --dropdown-radius: 8px;
        --calendar-width: 250px;
        --calendar-height: 200px;
        --calendar-cell-w: calc(var(--calendar-width) / 7);
        --calendar-header-h: 20px;
        --calendar-cell-h: calc((var(--calendar-height) - var(--calendar-header-h)) / 7);
        --calendar-past-bg: #f0f0f0;
        --calendar-future-bg: #ffffff;
        --session-available: #888888;
        --session-selected: #2e3a72;
        --today: #ff0000;
        --image-panel-bg: rgba(0,0,0,0.7);
      --filter-active-color: #7c4dff;
      --category-switch-active: #00b050;
      --keyword-bg: #FFFFFF;
      --date-range-bg: rgba(74,74,74,0.9);
      --date-range-text: rgba(255,255,255,1);
      --control-h: 35px;
      --geocoder-h: var(--control-h);
      --panel-label-font: system-ui, sans-serif;
      --panel-label-size: 14px;
      --panel-label-color: #ffffff;
      --panel-title-font: system-ui, sans-serif;
      --panel-title-size: 16px;
      --panel-title-color: #ffffff;
      --post-mode-bg-color: 0,0,0;
      --post-mode-bg-opacity: 0;
      --safe-top: env(safe-area-inset-top, 0px);
}

*:not([class*="mapboxgl-"]){
  box-sizing: border-box;
  border-color: var(--border) !important;
}

@supports (scrollbar-width: thin){
  *:not([class*="mapboxgl-"]){
    scrollbar-width: thin;
  }
}

@supports (scrollbar-color: #000 #fff){
  *:not([class*="mapboxgl-"]){
    scrollbar-color: var(--scrollbar-thumb) var(--scrollbar-track);
  }
}

fieldset{
  margin:0;
  padding:6px 0 0;
  border:0 !important;
}

*:not([class*="mapboxgl-"]):hover{
  border-color: var(--border-hover) !important;
}

*:not([class*="mapboxgl-"]):active{
  border-color: var(--border-active) !important;
}

*[aria-pressed="true"]:not([class*="mapboxgl-"]),
*[aria-current="page"]:not([class*="mapboxgl-"]),
.selected:not([class*="mapboxgl-"]),
.on:not([class*="mapboxgl-"]){
  border-color: var(--border-active) !important;
  color: var(--active);
}

*[aria-selected="true"]:not([class*="mapboxgl-"]){
  border-color: var(--border-active) !important;
}

html,body{
  height: 100%;
}

*:not([class*="mapboxgl-"])::-webkit-scrollbar{
  width:var(--scrollbar-h);
  height:var(--scrollbar-h);
}
*:not([class*="mapboxgl-"])::-webkit-scrollbar-track{
  background:var(--scrollbar-track);
}
*:not([class*="mapboxgl-"])::-webkit-scrollbar-thumb{
  background:var(--scrollbar-thumb);
  border-radius:0;
}
*:not([class*="mapboxgl-"])::-webkit-scrollbar-thumb:hover{
  background:var(--scrollbar-thumb-hover);
}

  body{
    margin: 0;
    font: 13px system-ui, sans-serif;
    background: var(--background);
    color: var(--text);
    overflow: hidden;
    cursor: auto;
    caret-color: transparent;
    display: flex;
    flex-direction: column;
    min-height: calc(var(--vh, 1vh) * 100);
    -webkit-user-select: text;
    user-select: text;
    touch-action: manipulation;
  }

  body, .post-board, .post-body{
    overscroll-behavior: contain;
  }
  .panel-content, .options-menu, .calendar-scroll{
    overscroll-behavior: contain;
  }

  h1, h2, h3, h4, h5, h6{
    font-size: 16px;
    font-weight: bold;
  }

input,
textarea,
.wysiwyg{
  caret-color: auto;
  -webkit-user-select: text;
  user-select: text;
}

button:not([class*="mapboxgl-"]),
[role="button"]:not([class*="mapboxgl-"]){
  background: var(--btn);
  border: 1px solid var(--btn);
  color: var(--button-text);
  font-size: 13px;
  padding: 0 10px;
  height: var(--control-h);
  min-width: 35px;
  border-radius: 8px;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  text-align: center;
  cursor: pointer;
  transition: background .2s,border-color .2s,color .2s,transform .05s;
}

button:not([class*="mapboxgl-"]):hover,
[role="button"]:not([class*="mapboxgl-"]):hover{
  background: var(--btn-hover);
  border-color: var(--btn-hover);
  color: var(--button-hover-text);
}

button:not([class*="mapboxgl-"]):active,
[role="button"]:not([class*="mapboxgl-"]):active{
  background: var(--btn-active);
  border-color: var(--btn-active);
  color: var(--button-active-text);
}

button:not([class*="mapboxgl-"])[aria-pressed="true"],
[role="button"]:not([class*="mapboxgl-"])[aria-pressed="true"],
button:not([class*="mapboxgl-"])[aria-current="page"],
[role="button"]:not([class*="mapboxgl-"])[aria-current="page"],
button:not([class*="mapboxgl-"])[aria-selected="true"],
[role="button"]:not([class*="mapboxgl-"])[aria-selected="true"],
button:not([class*="mapboxgl-"]).selected,
[role="button"]:not([class*="mapboxgl-"]).selected,
button:not([class*="mapboxgl-"]).on,
[role="button"]:not([class*="mapboxgl-"]).on{
  background: var(--button-selected-bg, var(--btn-selected));
  border-color: var(--button-selected-border, var(--button-selected-bg, var(--btn-selected))) !important;
  color: var(--button-selected-text, var(--button-active-text)) !important;
}

button:not([class*="mapboxgl-"])[aria-pressed="true"]:hover,
[role="button"]:not([class*="mapboxgl-"])[aria-pressed="true"]:hover,
button:not([class*="mapboxgl-"])[aria-current="page"]:hover,
[role="button"]:not([class*="mapboxgl-"])[aria-current="page"]:hover,
button:not([class*="mapboxgl-"])[aria-selected="true"]:hover,
[role="button"]:not([class*="mapboxgl-"])[aria-selected="true"]:hover,
button:not([class*="mapboxgl-"]).selected:hover,
[role="button"]:not([class*="mapboxgl-"]).selected:hover,
button:not([class*="mapboxgl-"]).on:hover,
[role="button"]:not([class*="mapboxgl-"]).on:hover{
  background: var(--button-selected-hover, var(--btn-selected-hover));
  border-color: var(--button-selected-hover-border, var(--button-selected-hover, var(--btn-selected-hover))) !important;
  color: var(--button-selected-hover-text, var(--button-selected-text, var(--button-active-text))) !important;
}

button:not([class*="mapboxgl-"])[aria-pressed="true"]:active,
[role="button"]:not([class*="mapboxgl-"])[aria-pressed="true"]:active,
button:not([class*="mapboxgl-"])[aria-current="page"]:active,
[role="button"]:not([class*="mapboxgl-"])[aria-current="page"]:active,
button:not([class*="mapboxgl-"])[aria-selected="true"]:active,
[role="button"]:not([class*="mapboxgl-"])[aria-selected="true"]:active,
button:not([class*="mapboxgl-"]).selected:active,
[role="button"]:not([class*="mapboxgl-"]).selected:active,
button:not([class*="mapboxgl-"]).on:active,
[role="button"]:not([class*="mapboxgl-"]).on:active{
  background: var(--button-selected-active, var(--btn-selected-active));
  border-color: var(--button-selected-active-border, var(--button-selected-active, var(--btn-selected-active))) !important;
  color: var(--button-selected-active-text, var(--button-selected-text, var(--button-active-text))) !important;
}

a{
  color: var(--primary);
}

a:hover{
  color: var(--accent);
}

a:active{
  color: var(--active);
}
button:not([class*="mapboxgl-"]):active,
[role="button"]:not([class*="mapboxgl-"]):active{
  transform: scale(0.97);
}
button:not([class*="mapboxgl-"]):focus-visible,
[role="button"]:not([class*="mapboxgl-"]):focus-visible{
  outline:2px solid #ffffff;
  outline-offset:2px;
}

button:not([class*="mapboxgl-"]):disabled,
[role="button"]:not([class*="mapboxgl-"])[aria-disabled="true"],
button:not([class*="mapboxgl-"]).disabled,
[role="button"]:not([class*="mapboxgl-"]).disabled{
  background: var(--btn-disabled);
  border-color: var(--btn-disabled);
  color: var(--button-disabled-text);
  cursor: not-allowed;
  opacity: 0.6;
}

button:not([class*="mapboxgl-"]):disabled:hover,
[role="button"]:not([class*="mapboxgl-"])[aria-disabled="true"]:hover,
button:not([class*="mapboxgl-"]).disabled:hover,
[role="button"]:not([class*="mapboxgl-"]).disabled:hover{
  background: var(--btn-disabled);
  border-color: var(--btn-disabled);
  color: var(--button-disabled-text);
}

input::placeholder,
textarea::placeholder{
  color: var(--placeholder-text);
  font-size: inherit;
}
#filterPanel #keyword-textbox::placeholder{
  color: var(--filter-placeholder-text);
  font-size: inherit;
}
#filterPanel #daterange-textbox::placeholder{
  color: var(--filter-placeholder-text);
  font-size: inherit;
}

.field label{
  color: var(--panel-label-color);
  font-size: var(--panel-label-size);
}

.panel-content .title,
.panel-content .t{
  color: var(--panel-title-color);
  font-size: var(--panel-title-size);
}

select{
  background: var(--dropdown-bg);
  color: var(--dropdown-text);
  border-radius: var(--dropdown-radius);
}
.venue-select{
  color: var(--dropdown-venue-text);
}
select option{
  background: var(--dropdown-bg);
  color: var(--dropdown-text);
}
select option:checked{
  background: var(--dropdown-selected-bg);
  color: var(--dropdown-selected-text);
}
select option:hover{
  background: var(--dropdown-hover-bg);
  color: var(--dropdown-hover-text);
}

input[type="text"],
input[type="email"],
input[type="password"],
input[type="search"],
input[type="tel"],
input[type="url"],
textarea,
select{
  height: var(--control-h);
  border-radius: 8px;
}
input[type="checkbox"]{
  width: var(--control-h);
  height: var(--control-h);
  border-radius: 8px;
}

  .header{
    height: calc(var(--header-h) + var(--safe-top));
    min-height: calc(var(--header-h) + var(--safe-top));
    max-height: calc(var(--header-h) + var(--safe-top));
    display: flex;
    align-items: center;
    justify-content: flex-end;
    padding: var(--safe-top) var(--gap) 0 var(--gap);
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    z-index: 20;
    background: rgba(0,0,0,0.7);
  }

  .logo{
    position: absolute;
    left: var(--gap);
    top: 50%;
    transform: translateY(-50%);
    display: flex;
    align-items: center;
    gap: var(--gap);
    font-weight: 800;
    letter-spacing: .4px;
    -webkit-user-select: none;
    user-select: none;
    cursor: pointer;
  }

.logo img{
  width: var(--logo-size);
  height: var(--logo-size);
  display: block;
}

  .view-toggle{
  position: absolute;
  left: calc(var(--gap) * 2 + var(--logo-size));
  right: var(--gap);
  top: 50%;
  transform: translateY(-50%);
  display: flex;
  height: 40px;
  gap: 10px;
  }

.view-toggle button{
  border: 1px solid var(--btn);
  border-radius: 8px;
  padding: 0;
  width: 40px;
  background: var(--btn);
  color: var(--button-text);
  font-weight: 600;
  cursor: pointer;
  transition: background .2s,border-color .2s,color .2s;
}

.view-toggle button[aria-pressed="true"]{
  background: var(--btn-selected);
  border-color: var(--btn-selected) !important;
  color: var(--button-active-text) !important;
}

.header-buttons{display:flex;gap:10px;position:relative;z-index:1;}

.header-buttons button{width:40px;}

.header button,
.options-menu button:not([class*="mapboxgl-ctrl"]){
  height:40px;
  display:flex;
  align-items:center;
  justify-content:center;
  gap:6px;
  line-height:1;
}
.header button{
  border-radius:8px;
}
.options-menu button:not([class*="mapboxgl-ctrl"]){
  border-radius:0;
}
.header .gear,
.header a{
  border-radius:8px;
}

.results-arrow,
.dropdown-arrow{
  display:inline-block;
  width:8px;
  height:8px;
  border-style:solid;
  border-width:0 2px 2px 0;
  border-color:currentColor !important;
  color:inherit;
  transition:transform .3s;
}

.options-dropdown > button{
  position:relative;
  padding-right:30px;
}
.results-arrow{
  transform:rotate(45deg);
  transition:transform .3s;
  vertical-align:middle;
}

.options-dropdown .dropdown-arrow,
.options-dropdown .results-arrow{
  position:absolute;
  top:50%;
  right:10px;
  transform:translateY(-50%) rotate(45deg);
  margin-right:0;
}

button[aria-expanded="true"] .dropdown-arrow,
button[aria-expanded="true"] .results-arrow{
  transform:translateY(-50%) rotate(-135deg);
}

/* Spin controls */
#adminPanel .range-wrap{
  display:flex;
  align-items:center;
  gap:8px;
}
#adminPanel .range-wrap input[type="range"]{
  width:300px;
}
#adminPanel .range-wrap span{
  width:40px;
  text-align:right;
}
#adminPanel #balloonSize{
  width:300px;
}
#adminPanel #balloonSizeValue{
  display:inline-block;
  width:40px;
  text-align:right;
  margin-left:8px;
}
  #spinType{
    display:flex;
    gap:6px;
    margin-top:6px;
  }
  #spinType label{
    flex:1;
    border-radius:8px;
    overflow:hidden;
  }
  #spinType input{
    display:none;
  }
  #spinType span{
    display:block;
    padding:0 10px;
    height:35px;
    line-height:35px;
    background:var(--btn);
    color:var(--button-text);
    font-weight:600;
    cursor:pointer;
    text-align:center;
    transition:background .2s,border-color .2s,color .2s;
    border:1px solid var(--btn);
    border-radius:8px;
  }

.gear{
  width: 36px;
  height: 36px;
  border-radius: 8px;
  background: rgba(255,255,255,0.2);
  display: grid;
  place-items: center;
  border:1px solid rgba(255,255,255,0.4);
  color: #fff;
}

.gear svg{
  width: 18px;
  height: 18px;
  opacity: .9;
}

.panel{
  position:fixed;
  top:0;
  left:0;
  right:0;
  width:100%;
  height:calc(var(--vh, 1vh) * 100);
  background:transparent;
  display:none;
  z-index:2000;
  pointer-events:none;
}
.panel.show{
  display:block;
}
.modal{
  position:fixed;
  top:0;
  left:0;
  right:0;
  width:100%;
  height:calc(var(--vh, 1vh) * 100);
  background:transparent;
  display:none;
  z-index:2000;
  pointer-events:none;
}
.modal.show{
  display:block;
}
.panel-content{
  position:absolute;
  left:50%;
  top:calc(var(--header-h) + var(--safe-top));
  bottom:auto;
  width:440px;
  max-width:440px;
  height:var(--panel-area-height, calc((var(--vh, 1vh) * 100) - var(--header-h) - var(--safe-top) - var(--footer-h)));
  max-height:var(--panel-area-height, calc((var(--vh, 1vh) * 100) - var(--header-h) - var(--safe-top) - var(--footer-h)));
  min-height:var(--panel-area-height, calc((var(--vh, 1vh) * 100) - var(--header-h) - var(--safe-top) - var(--footer-h)));
  border-radius:0;
  display:flex;
  flex-direction:column;
  overflow:hidden;
  pointer-events:auto;
  transition:transform var(--panel-transition-duration, 0.3s) ease;
  will-change:transform;
  box-sizing:border-box;
}

.panel-content[data-side='left']{
  transform:translateX(-100%);
}

.panel-content[data-side='right']{
  transform:translateX(100%);
}

.panel-content[data-side]:not(.panel-visible){
  pointer-events:none;
}

.panel-content[data-side].panel-visible{
  pointer-events:auto;
  transform:translateX(0);
}

.panel-content .resizer{position:absolute;z-index:10;background:transparent;display:none;}
.panel-content .resizer.n{top:0;left:0;right:0;height:6px;cursor:n-resize;}
.panel-content .resizer.s{bottom:0;left:0;right:0;height:6px;cursor:s-resize;}
.panel-content .resizer.e{top:0;right:0;bottom:0;width:6px;cursor:e-resize;}
.panel-content .resizer.w{top:0;left:0;bottom:0;width:6px;cursor:w-resize;}
.panel-content .resizer.ne{top:0;right:0;width:10px;height:10px;cursor:ne-resize;}
.panel-content .resizer.nw{top:0;left:0;width:10px;height:10px;cursor:nw-resize;}
.panel-content .resizer.se{bottom:0;right:0;width:10px;height:10px;cursor:se-resize;}
.panel-content .resizer.sw{bottom:0;left:0;width:10px;height:10px;cursor:sw-resize;}
.panel-body{
  flex:1 1 auto;
  min-height:0;
  overflow-y:auto;
  overflow-y:overlay;
  overflow-x:hidden;
  padding:20px 10px;
  --panel-scrollbar-overlay: 0px;
  --panel-scrollbar-size: 10px;
  --panel-scrollbar-thumb: rgba(255,255,255,0.35);
  --panel-scrollbar-thumb-hover: rgba(255,255,255,0.55);
  --panel-base-padding-end: 10px;
  padding-right:calc(var(--panel-base-padding-end) + var(--panel-scrollbar-overlay));
  margin-right:calc(-1 * var(--panel-scrollbar-overlay));
  width:calc(100% + var(--panel-scrollbar-overlay));
  overscroll-behavior:contain;
  display:flex;
  flex-direction:column;
  align-items:stretch;
  gap:20px;
}
.panel-body{
  scrollbar-width: thin;
  scrollbar-color: var(--panel-scrollbar-thumb) transparent;
}
.panel-body::-webkit-scrollbar{
  width: var(--panel-scrollbar-size);
}
.panel-body::-webkit-scrollbar-track{
  background: transparent;
}
.panel-body::-webkit-scrollbar-thumb{
  background-color: var(--panel-scrollbar-thumb);
  border-radius: 999px;
  border: 3px solid transparent;
  background-clip: padding-box;
}
.panel-body::-webkit-scrollbar-thumb:hover{
  background-color: var(--panel-scrollbar-thumb-hover);
}
.panel-body::-webkit-scrollbar-corner{
  background: transparent;
}
.panel-body > *{
  width:100%;
  max-width:420px;
  box-sizing:border-box;
  margin:0 auto;
  min-width:0;
}
.panel-body > *:last-child{
  margin-bottom:0;
}
.panel-body > *:not(.map-control-row) > *{
  width:100%;
  max-width:100%;
  min-width:0;
}
#adminPanel #styleControls{
  display:flex;
  flex-direction:column;
  align-items:flex-start;
  gap:12px;
}
#adminPanel #styleControls > *{
  width:100%;
  max-width:420px;
}
#adminPanel .admin-fieldset,
.admin-fieldset{
  margin:0 auto;
  border:0;
  border-radius:8px;
  padding:0;
  width:100%;
  max-width:420px;
  box-sizing:border-box;
}
#adminPanel .admin-fieldset.collapsed{
  padding:0;
}
  #adminPanel .panel-content,
  #memberPanel .panel-content{
    width:min(440px, 100%);
    max-width:100%;
    height:var(--panel-area-height, calc((var(--vh, 1vh) * 100) - var(--header-h) - var(--safe-top) - var(--footer-h)));
    max-height:var(--panel-area-height, calc((var(--vh, 1vh) * 100) - var(--header-h) - var(--safe-top) - var(--footer-h)));
    min-height:var(--panel-area-height, calc((var(--vh, 1vh) * 100) - var(--header-h) - var(--safe-top) - var(--footer-h)));
    display:flex;
    flex-direction:column;
    overflow-y:auto;
    overflow-y:overlay;
    left:auto;
    right:0;
  }

  #adminPanel .panel-content{
    background:#222222;
    color:#fff;
  }

  #memberPanel .panel-content{
    background:#222222;
    color:#fff;
  }
#filterPanel .panel-content{
  width:100%;
  max-width:380px;
  background:#555555;
  color:#fff;
  display:flex;
  flex-direction:column;
  overflow-y:auto;
  overflow-y:overlay;
  padding-bottom:calc(10px + env(safe-area-inset-bottom, 0px));
}

#filterPanel .panel-body{
  gap:var(--gap);
  padding:0 10px calc(var(--gap) + env(safe-area-inset-bottom, 0px));
}

#filterPanel button:not([class*="mapboxgl-"]),
#filterPanel .sq,
#filterPanel .tiny{
  background:#333333;
  border: none;
}
#adminPanel button,
#memberPanel button{
  background:#333333;
  color: var(--ink);
  border: none;
}
#adminPanel button{
  height:35px;
  line-height:35px;
}
#adminPanel input[type="color"]{
  width:35px;
  height:35px;
}
#filterPanel input[type="text"]{
  background: var(--panel-bg);
  color: var(--panel-text);
}
#filterPanel .calendar-container{
  background: var(--dropdown-bg);
  position:absolute;
  top:0;
  left:0;
  display:flex;
  align-items:stretch;
  overflow-x:auto;
  overflow-y:hidden;
  padding-bottom:var(--scrollbar-h);
  box-sizing:content-box;
  width:340px;
  height:var(--calendar-height);
  max-width:100%;
  border:1px solid var(--border);
  border-radius:8px;
  box-shadow:0 12px 32px rgba(0,0,0,0.4);
  overscroll-behavior:contain;
  -webkit-overflow-scrolling:touch;
  touch-action:pan-x pan-y;
  opacity:0;
  visibility:hidden;
  pointer-events:none;
  transform:translateY(4px);
  transition:opacity 0.2s ease, transform 0.2s ease, visibility 0.2s ease;
  z-index:5000;
}
#filterPanel .calendar-container.is-visible{
  opacity:1;
  visibility:visible;
  pointer-events:auto;
  transform:translateY(0);
}
#filterPanel .calendar-container .today-marker{
  position:absolute;
  bottom:0;
  width:8px;
  height:8px;
  border-radius:50%;
  background:var(--today);
  cursor:pointer;
}
#filterPanel #datePicker{
  width:var(--calendar-width);
  flex:0 0 auto;
}
#filterPanel .calendar{
  display:flex;
  width:max-content;
  transform:scale(var(--calendar-scale));
  transform-origin:top left;
  background:var(--dropdown-bg);
  color:var(--dropdown-text);
}
.calendar .month{
  flex:0 0 auto;
  width:var(--calendar-width);
  height:var(--calendar-height);
}
.calendar .month:not(:first-child){
  border-left:1px solid var(--calendar-past-bg);
}
.calendar .grid{
  width:100%;
  height:calc(var(--calendar-height) - var(--calendar-header-h));
  display:grid;
  grid-template-columns:repeat(7,var(--calendar-cell-w));
  grid-template-rows:repeat(7,var(--calendar-cell-h));
}
.calendar .calendar-header{
  height:var(--calendar-header-h);
  line-height:var(--calendar-header-h);
  text-align:center;
  font-size:inherit;
  color:#fff;
  background:#2e3a72;
}
.calendar .weekday,
.calendar .day{
  width:var(--calendar-cell-w);
  height:var(--calendar-cell-h);
  line-height:var(--calendar-cell-h);
  text-align:center;
  font-size:inherit;
  border-radius:8px;
}
#filterPanel .calendar .weekday,
#filterPanel .calendar .day{
  border-radius:0;
}
#filterPanel .calendar .day.range-start{
  border-top-left-radius:8px;
  border-bottom-left-radius:8px;
}
#filterPanel .calendar .day.range-end{
  border-top-right-radius:8px;
  border-bottom-right-radius:8px;
}
#filterPanel .calendar .day.range-start.range-end{
  border-radius:8px;
}
.calendar .weekday{font-weight:bold;}
.calendar .day{cursor:pointer;}
.calendar .day.empty{cursor:default;background:var(--calendar-future-bg);}
.calendar .day.past{background:var(--calendar-past-bg);color:#b3b3b3;}
.calendar .day.future{background:var(--calendar-future-bg);}
.calendar .day.today{color:var(--today) !important;font-weight:bold;}
.calendar .day.in-range{background:#add8e6;}
.calendar .day.selected{background:var(--session-selected);color:#fff;}
.calendar .day.selected.today{color:var(--today) !important;}
.calendar .day.range-start{border-radius:8px 0 0 8px;}
.calendar .day.range-end{border-radius:0 8px 8px 0;}
.calendar .day.range-start.range-end{border-radius:8px;}
#memberPanel input[type=color]{
  border-radius:8px;
  padding:0;
  height:40px;
  display:block;
}
#welcomeBody{
  display:flex;
  flex-direction:column;
  align-items:center;
  text-align:center;
  padding:0;
  gap:var(--gap);
}
#welcomeBody > :not(.map-control-row){
  pointer-events:none;
}
#welcomeBody .welcome-logo{
  max-width:100%;
  width:min(100%, 600px);
  max-height:300px;
  height:auto;
  margin:0;
}
#welcomeBody .welcome-illustration{
  max-width:280px;
  width:100%;
  height:auto;
  margin:0;
  border-radius:8px;
}
#welcome-modal{background:rgba(0,0,0,0.7);}
#welcome-modal .modal-content{
  position:absolute;
  width:min(600px, 90vw);
  max-width:90vw;
  background:none;
  border-radius:0;
  display:flex;
  flex-direction:column;
  overflow:visible;
  pointer-events:auto;
}
  @media (max-width:440px){
  #adminPanel .panel-content,
  #memberPanel .panel-content,
  #filterPanel .panel-content{
    width:100%;
    max-width:100%;
    max-height:none;
  }
}
#adminPanel legend{font-weight:600;padding:0 6px;display:flex;align-items:center;gap:6px;justify-content:space-between;cursor:pointer;-webkit-user-select:none;user-select:none;width:100%;max-width:420px;height:35px;background:var(--btn);border:1px solid var(--btn);border-radius:var(--dropdown-radius);box-sizing:border-box;margin:0 auto;}
#adminPanel legend::after{content:'\25BC';margin-left:auto;font-size:14px;}
#adminPanel fieldset.collapsed legend::after{content:'\25B6';}
#adminPanel fieldset.collapsed > :not(legend){display:none;}
#adminPanel .fieldset-actions{display:flex;gap:4px;margin:4px 6px;}
#adminPanel .fieldset-actions .same-btn{flex:1 1 0;padding:6px;}
#adminPanel .control-row{display:flex;align-items:center;justify-content:space-between;gap:6px;margin:0 auto;padding:10px 0;width:100%;max-width:420px;}
#adminPanel .control-row label:first-child{min-width:80px;font-size:14px;cursor:pointer;-webkit-user-select:none;user-select:none;}
.control-row > *:last-child{margin-left:auto;width:200px;}
#post-mode-background-field{
  width:100%;
  max-width:420px;
  margin:0 auto;
}
#post-mode-background-row{
  display:flex;
  align-items:center;
  width:100%;
  gap:8px;
  row-gap:8px;
  flex-wrap:wrap;
}
#post-mode-background-row input[type="color"]{
  width:40px;
  height:40px;
  padding:0;
  border-radius:8px;
  flex:0 0 40px;
}
#post-mode-background-row input[type="range"]{
  flex:1 1 160px;
  width:100%;
  max-width:none;
}
#post-mode-background-row span{
  flex:0 0 auto;
  min-width:40px;
  text-align:right;
}

.map-theme-container,
.map-balloon-container,
.map-spin-container{
  background:#444444;
  width:100%;
  max-width:420px;
  padding:10px;
  border-radius:8px;
  display:flex;
  flex-direction:column;
  gap:8px;
}
.map-theme-container .panel-field,
.map-balloon-container .panel-field,
.map-spin-container .panel-field{
  width:100%;
}

.settings-style-container,
.settings-welcome-container{
  background:#444444;
  width:100%;
  max-width:420px;
  padding:10px;
  border-radius:8px;
}

.sub-icon svg{
  width:18px;
  height:18px;
  vertical-align:middle;
}
.cat-line{
  display:flex;
  align-items:center;
}
.cat-line .sub-icon{
  display:inline-flex;
  align-items:center;
  justify-content:center;
  flex:0 0 auto;
  padding-right:5px;
}
.cat-line .sub-icon:empty{
  display:none;
  padding-right:0;
}
.post-card .sub-icon img,
.post-card .sub-icon svg,
.recents-card .sub-icon img,
.recents-card .sub-icon svg{
  width:18px;
  height:18px;
}
#adminPanel .color-group{
  flex:0 0 200px;
  width:100%;
  max-width:200px;
  display:flex;
  flex-direction:column;
  align-items:stretch;
  position:relative;
}
#autoTheme-row{
  flex-direction:row;
  align-items:center;
  gap:8px;
  margin-left:0;
  width:440px;
  max-width:440px;
}
#autoTheme-row button{
  flex:0 0 auto;
  height:35px;
  padding:0 8px;
  min-width:0;
}
#autoTheme-row input[type=color]{
  flex:0 0 35px;
  width:35px;
  height:35px;
  padding:0;
}
#adminPanel .shadow-group{
  flex:0 0 200px;
  width:100%;
  max-width:200px;
  display:flex;
  gap:4px;
  align-items:center;
}
#adminPanel .shadow-group input[type=color]{
  width:40px;
  height:40px;
  padding:0;
  border-radius:8px;
}
#adminPanel .shadow-group input[type=number]{
  flex:1 1 0;
}
#adminPanel .textpicker{
  flex:0 0 200px;
  width:200px;
  position:relative;
}
#adminPanel .textpicker .text-preview{
  width:100%;
  height:35px;
  border-radius:8px;
  display:flex;
  align-items:center;
  justify-content:center;
  cursor:pointer;
}
#adminPanel .textpicker .text-popup{
  display:none;
  position:absolute;
  top:44px;
  left:0;
  z-index:20;
  background:#fff;
  border:1px solid #ccc;
  border-radius:8px;
  padding:8px;
  width:200px;
}
#adminPanel .textpicker.open .text-popup{display:block;}
#adminPanel .textpicker .text-popup select,
#adminPanel .textpicker .text-popup input[type=color]{
  width:100%;
  margin-top:4px;
  border-radius:var(--dropdown-radius);
  padding:4px;
  box-sizing:border-box;
  height:35px;
}
#adminPanel .textpicker .text-popup input[type=color]{padding:0;}
#adminPanel .textpicker .text-popup .shadow-group{
  display:grid;
  grid-template-columns:repeat(4,1fr);
  gap:4px;
  margin-top:4px;
}
#adminPanel .textpicker .text-popup .shadow-group input[type=color],
#adminPanel .textpicker .text-popup .shadow-group input[type=number]{
  width:100%;
  height:40px;
  border-radius:var(--dropdown-radius);
  padding:0;
  box-sizing:border-box;
}
#adminPanel .admin-fieldset input,
#adminPanel .admin-fieldset select,
#adminPanel .admin-fieldset textarea{
  max-width:200px;
  box-sizing:border-box;
}
#adminPanel .control-row select{
  flex:0 0 200px;
  width:200px;
  max-width:200px;
  margin-left:auto;
  border-radius:var(--dropdown-radius);
  padding:4px;
}
#adminPanel .color-group input[type=color],
#adminPanel .color-group input[type=range]{
  width:100%;
}
#adminPanel .color-group input[type=color]{
  border-radius:8px;
  padding:0;
  height:35px;
  display:block;
  cursor:pointer;
  pointer-events:auto;
}
#adminPanel .range-group{
  display:flex;
  align-items:center;
  gap:4px;
}
#adminPanel .range-group input[type=range]{
  flex:1;
  width:auto;
}
#adminPanel .range-group span{
  min-width:32px;
  text-align:right;
  font-size:14px;
}
#adminPanel .tab-bar{display:flex;gap:6px;}
#adminPanel .tab-bar button{
  flex:1;
  padding:6px 10px;
  border-radius:8px;
  background:var(--btn);
  border:1px solid var(--btn);
  color:var(--button-text);
  cursor:pointer;
}
#adminPanel .tab-panel{display:none;}
#adminPanel .tab-panel.active{display:flex;flex-direction:column;align-items:flex-start;gap:12px;}
#adminPanel .marker-grid{display:flex;flex-direction:column;gap:8px;}
#adminPanel .marker-grid select{min-width:120px;}
#adminPanel .marker-options{display:flex;gap:8px;align-items:center;}
#adminPanel .marker-set{display:grid;grid-template-columns:repeat(10,max-content);gap:4px;}
#adminPanel .marker-set svg.outline *{stroke:#000;stroke-width:1;}
#adminPanel input[type=range]{width:100%;}
.panel-field{
  margin:8px auto;
  display:flex;
  flex-direction:column;
  gap:8px;
  width:100%;
  max-width:420px;
  min-width:0;
}
#adminPanel .panel-field{margin:8px auto;}
#adminPanel h3{margin:0;}
.admin-section{display:flex;flex-direction:column;gap:var(--gap);}
#tab-forms .panel-field{max-width:none;}
.history-group,
.color-group{display:flex;align-items:center;gap:8px;flex-wrap:wrap;}
.option-label{
  display:flex;
  align-items:center;
  gap:8px;
  flex-wrap:wrap;
}
.option-group{
  display:flex;
  gap:10px;
  flex-wrap:wrap;
}
.option-label > *,
.option-group > *{
  min-width:0;
}
.wysiwyg{
  border:1px solid #ccc;
  min-height:80px;
  padding:8px;
}
.wysiwyg:empty:before{
  content:attr(data-placeholder);
  color:#999;
}
.wysiwyg-toolbar{
  display:flex;
  gap:4px;
}
.wysiwyg-toolbar button{
  padding:4px 6px;
}
.panel-field input,
.panel-field textarea,
.panel-field select{
  padding:8px;
  border-radius:var(--dropdown-radius);
  border:none;
  width:100%;
  max-width:100%;
}
.panel-actions{
  margin-top:10px;
  display:flex;
  gap:10px;
}
.panel-header{
  position:sticky;
  top:0;
  padding:10px;
  border-top-left-radius:0;
  border-top-right-radius:0;
  z-index:1;
  cursor:move;
  display:flex;
  flex-direction:column;
  gap:10px;
  flex-shrink:0;
}
.panel-header .header-top{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
  width:100%;
}
.panel-header .panel-actions{
  margin-top:0;
  margin-left:auto;
  justify-content:flex-end;
}
#adminPanel .panel-actions .save-changes,
#adminPanel .panel-actions .discard-changes,
#memberPanel .panel-actions .save-changes,
#memberPanel .panel-actions .discard-changes{
  min-width:90px;
}
#adminPanel .panel-actions .primary-action,
#memberPanel .panel-actions .primary-action,
#adminUnsavedPrompt .primary-action,
#memberUnsavedPrompt .primary-action{
  background:var(--button-selected-bg, var(--btn-selected));
  border-color:var(--button-selected-border, var(--button-selected-bg, var(--btn-selected)));
  color:var(--button-selected-text, var(--button-active-text));
}
#adminPanel .panel-actions .primary-action:hover,
#memberPanel .panel-actions .primary-action:hover,
#adminUnsavedPrompt .primary-action:hover,
#memberUnsavedPrompt .primary-action:hover{
  background:var(--button-selected-hover, var(--btn-selected-hover));
  border-color:var(--button-selected-hover-border, var(--button-selected-hover, var(--btn-selected-hover)));
  color:var(--button-selected-hover-text, var(--button-selected-text, var(--button-active-text)));
}
#adminPanel .panel-actions .discard-changes[disabled],
#memberPanel .panel-actions .discard-changes[disabled],
#adminUnsavedPrompt .confirm-discard[disabled],
#memberUnsavedPrompt .confirm-discard[disabled]{
  opacity:0.5;
  cursor:not-allowed;
}
#adminUnsavedPrompt{
  position:fixed;
  inset:0;
  display:flex;
  align-items:center;
  justify-content:center;
  background:rgba(0,0,0,0.65);
  z-index:12000;
  opacity:0;
  pointer-events:none;
  transition:opacity 0.2s ease;
}
#adminUnsavedPrompt.show{
  opacity:1;
  pointer-events:auto;
}
#adminUnsavedPrompt .admin-unsaved-dialog{
  background:var(--dropdown-bg, rgba(17,17,17,0.96));
  border:1px solid var(--border);
  border-radius:12px;
  padding:20px;
  max-width:360px;
  width:calc(100% - 40px);
  display:flex;
  flex-direction:column;
  gap:14px;
  box-shadow:0 18px 60px rgba(0,0,0,0.55);
}
#adminUnsavedPrompt .admin-unsaved-actions{
  display:flex;
  justify-content:flex-end;
  gap:10px;
}
#memberUnsavedPrompt{
  position:fixed;
  inset:0;
  display:flex;
  align-items:center;
  justify-content:center;
  background:rgba(0,0,0,0.65);
  z-index:12000;
  opacity:0;
  pointer-events:none;
  transition:opacity 0.2s ease;
}
#memberUnsavedPrompt.show{
  opacity:1;
  pointer-events:auto;
}
#memberUnsavedPrompt .member-unsaved-dialog{
  background:var(--dropdown-bg, rgba(17,17,17,0.96));
  border:1px solid var(--border);
  border-radius:12px;
  padding:20px;
  max-width:360px;
  width:calc(100% - 40px);
  display:flex;
  flex-direction:column;
  gap:14px;
  box-shadow:0 18px 60px rgba(0,0,0,0.55);
}
#memberUnsavedPrompt .member-unsaved-actions{
  display:flex;
  justify-content:flex-end;
  gap:10px;
}
#adminStatusMessage{
  position:fixed;
  top:calc(var(--safe-top, 0px) + 20px);
  left:50%;
  transform:translate(-50%, -10px);
  background:rgba(0,0,0,0.85);
  color:#fff;
  padding:8px 18px;
  border-radius:999px;
  box-shadow:0 10px 25px rgba(0,0,0,0.4);
  opacity:0;
  pointer-events:none;
  transition:opacity 0.2s ease, transform 0.2s ease;
  z-index:13000;
  font-size:14px;
}
#adminStatusMessage.show{
  opacity:1;
  transform:translate(-50%, 0);
}
#memberStatusMessage{
  position:fixed;
  top:calc(var(--safe-top, 0px) + 20px);
  left:50%;
  transform:translate(-50%, -10px);
  background:rgba(0,0,0,0.85);
  color:#fff;
  padding:8px 18px;
  border-radius:999px;
  box-shadow:0 10px 25px rgba(0,0,0,0.4);
  opacity:0;
  pointer-events:none;
  transition:opacity 0.2s ease, transform 0.2s ease;
  z-index:13000;
  font-size:14px;
}
#memberStatusMessage.show{
  opacity:1;
  transform:translate(-50%, 0);
}
.panel-header h2{
  margin:0;
}

@media (max-width:440px){
  .panel-header .panel-actions .move-left,
  .panel-header .panel-actions .move-right{
    display:none;
  }
  #post-mode-background-row input[type="range"]{
    flex-basis:100%;
  }
  #post-mode-background-row span{
    text-align:left;
  }
}
#filterPanel .panel-header{
  padding:10px;
}
.palette{
  display:flex;
  gap:10px;
  margin-bottom:10px;
}
.field-item,
.field-instance{
  padding:6px 10px;
  border:1px solid #ccc;
  border-radius:8px;
  background:#f9f9f9;
  cursor:move;
}
.builder-zone{
  min-height:100px;
  border:2px dashed #ccc;
  padding:10px;
}
.field-instance{margin:4px 0;}

.left-tools{
  display: flex;
  gap: 8px;
  margin-bottom: 8px;
  padding-left: 2px;
}

.sq{
  width: 30px;
  height: 30px;
  border-radius: 8px;
  background: var(--btn);
  display: grid;
  place-items: center;
  border: 1px solid var(--btn);
}

.sq svg{
  width: 14px;
  height: 14px;
  opacity: .9;
}

.field{
  display:flex;
  align-items:center;
  gap:8px;
  padding:8px 0;
  margin:0;
}

.field .input{
  position: relative;
  display:flex;
  align-items:center;
  gap:6px;
  flex:1;
}

.field .options-dropdown{
  flex:1;
}

.field .options-dropdown > button{
  width:100%;
}

.input input,
.input select{
  flex: 1;
  width: 100%;
  height: 35px;
  line-height: 35px;
  border: none;
  padding: 0 12px;
  outline: 0;
  display: flex;
  align-items: center;
}
.input input{
  border-radius: 8px;
  background: var(--btn);
  color: var(--ink);
}
.input select{
  border-radius: var(--dropdown-radius);
}
#filterPanel #keyword-textbox{
  background: var(--keyword-bg);
}
#filterPanel #daterange-textbox{
  background: #333333;
  color: var(--date-range-text);
}

.input .down{
  position: static;
  width: 35px;
  height: 35px;
  border-radius: 8px;
  background: var(--btn);
  cursor: pointer;
  border: 1px solid var(--btn);
  line-height:35px;
  text-align:center;
}
.input .down svg{
  vertical-align:middle;
}
#filterPanel .keyword-clear-button,
#filterPanel .daterange-clear-button,
#filterPanel .price-clear-button{
  position: static;
  width: 35px;
  height: 35px;
  border-radius: 8px;
  background: var(--dropdown-bg);
  cursor: pointer;
  border: 0;
  margin-left: 6px;
  line-height: 35px;
  text-align: center;
  color: var(--dropdown-text);
  opacity:1;
}
#filterPanel .keyword-clear-button.active,
#filterPanel .daterange-clear-button.active,
#filterPanel .price-clear-button.active{
  background: var(--filter-active-color);
  color: var(--button-text);
  opacity:1;
}

#filterPanel .field label.t{
  grid-column: 1 / -1;
  display: flex;
  align-items: center;
  gap: 6px;
}

.expired-row{
  grid-template-columns:1fr auto;
  align-items:center;
  gap:8px;
}
.expired-text{
  color:#fff;
  font-size:14px;
}
.filter-summary{
  font-size:14px;
  width:100%;
  max-width:420px;
  margin:0 auto;
  text-align:center;
}
#filterPanel .panel-header{
  align-items:center;
}
#filterPanel .panel-header #filterSummary{
  margin:0;
}
#filterPanel .panel-body > .filter-panel-actions{
  display:flex;
  justify-content:flex-end;
  gap:10px;
}
#filterPanel .panel-body > .filter-panel-actions button{
  flex:0 0 auto;
}

#filterPanel .reset-box,
#filterPanel .sort-field{
  width:100%;
  max-width:420px;
  margin:0 auto;
  padding:0;
}
#filterPanel .reset-box{
  padding:0;
}
#filterPanel .reset-box + .reset-box{
  margin-top:0;
}
#filterPanel .panel-body > .reset-box{
  padding:0;
}
#filterPanel .reset-box #resetBtn{
  width:100%;
}
#filterPanel .sort-field{
  display:flex;
  justify-content:center;
}
#filterPanel .sort-field .options-menu{
  width:100%;
  max-width:420px;
}
.sort-options .sort-option[aria-pressed="true"]{
  background:#2e3a72;
  color:var(--button-active-text);
  border-color:#2e3a72;
}
#filterPanel .filter-basics-container,
#filterPanel .filter-category-container,
#tab-forms .formbuilder-container{
  width:100%;
  max-width:420px;
  margin:0 auto;
  background:#444444;
  border-radius:8px;
  padding:10px;
}
#filterPanel .filter-basics-container{
  position:relative;
}
#filterPanel .filter-category-container,
#tab-forms .formbuilder-container{
  margin-top:10px;
}
#filterPanel .keyword-row,
#filterPanel .price-range-row,
#filterPanel .daterange-row,
#filterPanel .expired-row{
  width:100%;
  max-width:420px;
  margin:0 auto;
}
#filterPanel .price-range-row .input{
  align-items:center;
}
#filterPanel .price-range-row input{
  background:#ffffff;
  color:var(--dropdown-text);
}
#filterPanel .price-range-row .price-separator{
  color:#ffffff;
  font-size:14px;
  font-weight:600;
}
#filterPanel .filter-category-container .cats,
#filterPanel .filter-category-container .filter-category-menu,
#tab-forms .formbuilder-container .cats,
#tab-forms .formbuilder-container .filter-category-menu{
  width:100%;
}

.formbuilder-confirm-overlay{
  position:fixed;
  inset:0;
  display:flex;
  align-items:center;
  justify-content:center;
  background:rgba(17, 24, 39, 0.45);
  opacity:0;
  pointer-events:none;
  transition:opacity 0.2s ease;
  z-index:4000;
}

.formbuilder-confirm-overlay.visible{
  opacity:1;
  pointer-events:auto;
}

.formbuilder-confirm-dialog{
  background:#fff;
  color:#111827;
  border-radius:16px;
  box-shadow:0 20px 45px rgba(15, 23, 42, 0.25);
  padding:24px;
  width:min(90vw, 360px);
  display:flex;
  flex-direction:column;
  gap:16px;
}

.formbuilder-confirm-dialog h2{
  margin:0;
  font-size:1.1rem;
  font-weight:600;
}

.formbuilder-confirm-dialog p{
  margin:0;
  line-height:1.5;
}

.formbuilder-confirm-actions{
  display:flex;
  justify-content:flex-end;
  gap:12px;
}

.formbuilder-confirm-actions button{
  border:none;
  border-radius:999px;
  padding:10px 18px;
  font:inherit;
  font-weight:600;
  cursor:pointer;
  transition:background-color 0.15s ease, color 0.15s ease, box-shadow 0.15s ease;
}

.formbuilder-confirm-cancel{
  background:#e5e7eb;
  color:#111827;
}

.formbuilder-confirm-cancel:focus-visible,
.formbuilder-confirm-cancel:hover{
  background:#d1d5db;
  outline:none;
}

.formbuilder-confirm-delete{
  background:#dc2626;
  color:#fff;
  box-shadow:0 10px 20px rgba(220, 38, 38, 0.35);
}

.formbuilder-confirm-delete:focus-visible,
.formbuilder-confirm-delete:hover{
  background:#b91c1c;
  outline:none;
}
.switch{
  position:relative;
  display:inline-block;
  width:48px;
  height:24px;
  flex:0 0 48px;
}
.switch input{
  opacity:0;
  width:0;
  height:0;
}
.switch .slider{
  position:absolute;
  cursor:pointer;
  top:0;
  left:0;
  right:0;
  bottom:0;
  background:var(--btn);
  border-radius:24px;
  transition:.2s;
}
.switch .slider:before{
  position:absolute;
  content:'';
  height:20px;
  width:20px;
  left:2px;
  top:2px;
  background:var(--button-text);
  border-radius:50%;
  transition:.2s;
}
.switch input:checked + .slider{
  background:var(--session-selected);
}
#expiredToggle:checked + .slider{
  background:var(--filter-active-color);
}
.switch input:checked + .slider:before{
  transform:translateX(24px);
}

.tiny{
  display: grid;
  place-items: center;
  width: 38px;
  height: 40px;
  border-radius: 8px;
  background: var(--btn);
  cursor: pointer;
  border: 1px solid var(--btn);
}

.tiny svg{
  width: 18px;
  height: 18px;
}

.cats{
  margin:8px 0;
  display:flex;
  flex-direction:column;
  gap:8px;
}

.filter-category-menu{
  display:flex;
  flex-direction:column;
  gap:6px;
}

.filter-category-menu .filter-category-header{
  display:flex;
  align-items:flex-start;
  gap:8px;
}

.filter-category-menu .filter-category-trigger-wrap{
  flex:1;
}

.filter-category-menu .filter-category-trigger{
  height:36px;
  border-radius:8px;
  padding:0 12px;
  display:flex;
  align-items:center;
  justify-content:flex-start;
  gap:10px;
  background: var(--btn);
  border: 1px solid var(--btn);
  cursor: pointer;
  width: 100%;
  text-align: left;
  color: var(--button-text);
  font: inherit;
  margin: 0;
}

.filter-category-menu .category-logo{
  flex:0 0 24px;
  width:24px;
  height:24px;
  display:flex;
  align-items:center;
  justify-content:center;
}

.filter-category-menu .category-logo img{
  width:24px;
  height:24px;
}

.filter-category-menu .filter-category-trigger .label{
  font-weight:700;
  letter-spacing:.2px;
  flex:1;
}

.filter-category-menu .cat-switch{
  position:relative;
  display:flex;
  align-items:center;
  justify-content:flex-end;
  width:38px;
  height:36px;
  flex:0 0 38px;
  cursor:pointer;
  align-self:flex-start;
}
.filter-category-menu .cat-switch input{
  opacity:0;
  width:0;
  height:0;
}
.filter-category-menu .cat-switch .slider{
  position:absolute;
  top:8px;
  left:0;
  right:0;
  margin:0 auto;
  width:38px;
  height:20px;
  border-radius:16px;
  background:var(--btn);
  border:1px solid var(--btn);
  transition:.2s;
}
.filter-category-menu .cat-switch .slider:before{
  content:'';
  position:absolute;
  width:16px;
  height:16px;
  left:1px;
  top:1px;
  border-radius:50%;
  background:var(--button-text);
  transition:.2s;
}
.filter-category-menu .cat-switch input:checked + .slider{
  background:var(--category-switch-active);
  border-color:var(--category-switch-active);
}
.filter-category-menu .cat-switch input:checked + .slider:before{
  transform:translateX(18px);
}

.filter-category-menu .options-dropdown{
  width:100%;
}

.filter-category-menu .options-menu{
  width:100%;
  box-sizing:border-box;
  position:static;
  margin-top:6px;
  background:transparent;
  border:none;
  padding:0;
  border-radius:0;
  z-index:auto;
}

.filter-category-menu .options-menu button{
  width:100%;
  display:flex;
  align-items:center;
  justify-content:flex-start;
  gap:var(--gap);
  border-radius:6px;
  border:1px solid transparent;
  box-sizing:border-box;
  padding:0 12px;
}

.filter-category-menu .options-menu button .subcategory-logo{
  flex:0 0 24px;
  width:24px;
  height:24px;
  display:flex;
  align-items:center;
  justify-content:center;
}

.filter-category-menu .options-menu button .subcategory-logo img{
  width:20px;
  height:20px;
}

.filter-category-menu .options-menu button .subcategory-label{
  flex:1;
  text-align:left;
}

.filter-category-menu .options-menu button .subcategory-switch{
  flex:0 0 auto;
  display:flex;
  align-items:center;
  justify-content:flex-end;
  width:34px;
  height:18px;
  position:relative;
  pointer-events:none;
}

.filter-category-menu .options-menu button .subcategory-switch .track{
  position:absolute;
  inset:0;
  border-radius:12px;
  background:var(--btn);
  border:1px solid var(--btn);
  transition:.2s;
}

.filter-category-menu .options-menu button .subcategory-switch .thumb{
  position:absolute;
  width:14px;
  height:14px;
  border-radius:50%;
  background:var(--button-text);
  left:2px;
  top:2px;
  transition:.2s;
}
.filter-category-menu .options-menu button[aria-pressed="false"]{
  color:var(--muted);
}
.filter-category-menu .options-menu button[aria-pressed="false"] .subcategory-logo{
  opacity:0.6;
}
.filter-category-menu .options-menu button[aria-pressed="false"] .subcategory-logo img{
  filter:grayscale(1);
}
.filter-category-menu .options-menu button[aria-pressed="false"] .subcategory-label{
  color:inherit;
}
.filter-category-menu .options-menu button[aria-pressed="false"] .subcategory-switch .track{
  background:var(--btn);
  border-color:var(--btn);
}
.filter-category-menu .options-menu button[aria-pressed="false"] .subcategory-switch .thumb{
  transform:translateX(0);
  opacity:0.7;
}

.filter-category-menu .options-menu button[aria-pressed="true"]{
  background: var(--dropdown-selected-bg);
  color: var(--dropdown-selected-text);
  border-color: var(--dropdown-selected-bg);
  --button-selected-bg: var(--dropdown-selected-bg);
  --button-selected-border: var(--dropdown-selected-bg);
  --button-selected-text: var(--dropdown-selected-text);
}
.filter-category-menu .options-menu button.on{
  --button-selected-bg: var(--dropdown-selected-bg);
  --button-selected-border: var(--dropdown-selected-bg);
  --button-selected-text: var(--dropdown-selected-text);
}

.filter-category-menu .options-menu button[aria-pressed="true"] .subcategory-switch .track,
.filter-category-menu .options-menu button.on .subcategory-switch .track{
  background:var(--category-switch-active);
  border-color:var(--category-switch-active);
}

.filter-category-menu .options-menu button[aria-pressed="true"] .subcategory-switch .thumb,
.filter-category-menu .options-menu button.on .subcategory-switch .thumb{
  transform:translateX(16px);
}

.filter-category-menu[aria-expanded="true"] .filter-category-trigger{
  border-color: var(--border-active);
}

.filter-category-menu.cat-off{
  opacity:0.6;
}

.filter-category-menu.cat-off .filter-category-trigger{
  cursor:default;
}

.reset-box{
  margin:0;
}

.reset-box .btn{
  width:100%;
  height: 36px;
  border-radius: 8px;
  background: var(--btn);
  border: 1px solid var(--btn);
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 0 14px;
  font-weight: 700;
  letter-spacing: .2px;
  color: var(--ink);
  cursor: pointer;
}
.reset-box .btn.active{
  background: var(--filter-active-color);
  border-color: var(--filter-active-color);
}

.reset-box .btn svg{
  width: 16px;
  height: 16px;
}

.reset-box .arr{
  display: grid;
  place-items: center;
  width: 38px;
  height: 36px;
  border-radius: 8px;
  background: var(--btn);
  border: 1px solid var(--btn);
}

.post-mode-background{
  position:fixed;
  top:calc(var(--header-h) + var(--safe-top));
  bottom:var(--footer-h);
  left:0;
  right:0;
  background: rgba(var(--post-mode-bg-color), var(--post-mode-bg-opacity));
  z-index:1;
  pointer-events:none;
  display:none;
}

.mode-posts .post-mode-background{
  display:block;
  pointer-events:none;
}

.post-mode-boards{
  position:fixed;
  top:calc(var(--header-h) + var(--safe-top));
  bottom:auto;
  left:0;
  right:0;
  height:var(--panel-area-height, calc((var(--vh, 1vh) * 100) - var(--header-h) - var(--safe-top) - var(--footer-h)));
  max-height:var(--panel-area-height, calc((var(--vh, 1vh) * 100) - var(--header-h) - var(--safe-top) - var(--footer-h)));
  min-height:var(--panel-area-height, calc((var(--vh, 1vh) * 100) - var(--header-h) - var(--safe-top) - var(--footer-h)));
  padding-left:var(--filter-panel-offset);
  padding-right:0;
  display:flex;
  justify-content:center;
  align-items:stretch;
  gap:var(--gap);
  z-index:2;
  pointer-events:none;
  transition:padding var(--panel-transition-duration, 0.3s) ease;
}

body.filter-anchored .post-mode-boards{
  justify-content:flex-start;
}

body.hide-ads .post-mode-boards{padding-right:0;}

.quick-list-board{
  position:fixed;
  top:calc(var(--header-h) + var(--safe-top));
  bottom:auto;
  left:0;
  width:440px;
  padding:10px;
  overflow:auto;
  overflow:overlay;
  background:rgba(0,0,0,0);
  pointer-events:auto;
  z-index:2;
  transform:translateX(0);
  height:var(--panel-area-height, calc((var(--vh, 1vh) * 100) - var(--header-h) - var(--safe-top) - var(--footer-h)));
  max-height:var(--panel-area-height, calc((var(--vh, 1vh) * 100) - var(--header-h) - var(--safe-top) - var(--footer-h)));
  min-height:var(--panel-area-height, calc((var(--vh, 1vh) * 100) - var(--header-h) - var(--safe-top) - var(--footer-h)));
  transition:transform var(--panel-transition-duration, 0.3s) ease;
  will-change:transform;
}

.recents-board{
  position:relative;
  top:auto;
  bottom:auto;
  left:auto;
  padding:0;
  margin:0;
  overflow:auto;
  overflow:overlay;
  overflow-x:hidden;
  background:rgba(0,0,0,0.7);
  transition:margin var(--panel-transition-duration, 0.3s) ease, transform var(--panel-transition-duration, 0.3s) ease;
  will-change:margin, transform;
  display:flex;
  flex-direction:column;
  gap:0;
  pointer-events:auto;
  height:var(--panel-area-height, calc((var(--vh, 1vh) * 100) - var(--header-h) - var(--safe-top) - var(--footer-h)));
  max-height:var(--panel-area-height, calc((var(--vh, 1vh) * 100) - var(--header-h) - var(--safe-top) - var(--footer-h)));
  min-height:var(--panel-area-height, calc((var(--vh, 1vh) * 100) - var(--header-h) - var(--safe-top) - var(--footer-h)));
  transform:translateX(0);
}

.post-board{
  width:var(--post-board-max-w);
  max-width:var(--post-board-max-w);
  flex-shrink:0;
  position:relative;
  left:0;
  display:flex;
  flex-direction:column;
  height:var(--panel-area-height, calc((var(--vh, 1vh) * 100) - var(--header-h) - var(--safe-top) - var(--footer-h)));
  min-height:var(--panel-area-height, calc((var(--vh, 1vh) * 100) - var(--header-h) - var(--safe-top) - var(--footer-h)));
  max-height:var(--panel-area-height, calc((var(--vh, 1vh) * 100) - var(--header-h) - var(--safe-top) - var(--footer-h)));
  transition:left var(--panel-transition-duration, 0.3s) ease,
             margin var(--panel-transition-duration, 0.3s) ease,
             transform var(--panel-transition-duration, 0.3s) ease;
  will-change:left, margin, transform;
  transform:translateX(0);
}

.recents-board{
  width:var(--post-board-max-w);
  max-width:var(--post-board-max-w);
  flex-shrink:0;
  height:var(--panel-area-height, calc((var(--vh, 1vh) * 100) - var(--header-h) - var(--safe-top) - var(--footer-h)));
  min-height:var(--panel-area-height, calc((var(--vh, 1vh) * 100) - var(--header-h) - var(--safe-top) - var(--footer-h)));
  max-height:var(--panel-area-height, calc((var(--vh, 1vh) * 100) - var(--header-h) - var(--safe-top) - var(--footer-h)));
}

.recents-board,
.post-board{
  transition:transform var(--panel-transition-duration, 0.3s) ease;
  will-change:transform;
}

.recents-board[data-side='left']:not(.panel-visible),
.post-board[data-side='left']:not(.panel-visible),
.ad-board[data-side='left']:not(.panel-visible){
  transform:translateX(-110%);
}

.recents-board[data-side='right']:not(.panel-visible),
.post-board[data-side='right']:not(.panel-visible),
.ad-board[data-side='right']:not(.panel-visible){
  transform:translateX(110%);
}

.recents-board.panel-visible,
.post-board.panel-visible,
.ad-board.panel-visible{
  transform:translateX(0);
}

.recents-board:not(.panel-visible),
.post-board:not(.panel-visible){
  pointer-events:none;
}

.ad-board{
  opacity:0;
}

.ad-board.panel-visible{
  opacity:1;
}

.ad-board:not(.panel-visible){
  pointer-events:none;
}
  @media (max-width:440px){
    .post-board,
    .recents-board,
    .post-mode-boards > .post-body.is-visible{
      width:100%;
      max-width:100%;
    }
    .post-mode-boards > .post-body{
      display:none;
    }
  }

.last-opened-label{
  font-size:12px;
  margin:0;
  background:#000;
  color:#fff;
  padding:2px 4px;
}

.post-board{
  padding:0;
  margin:0;
  overflow-y:auto;
  overflow-y:overlay;
  overflow-x:hidden;
  display:flex;
  flex-direction:column;
  gap:0;
  background:rgba(0,0,0,0.7);
  pointer-events:auto;
}
.post-board .post-card{
  width:100%;
  max-width:100%;
}

.post-board .open-post{
  width:100%;
  max-width:100%;
}

.recents-board .recents-card{
  width:100%;
  max-width:100%;
}
.recents-board .recents-card{
  margin:0;
  border-radius:0;
  background-color:transparent;
  border-bottom:1px solid rgba(255,255,255,0.12);
}
.recents-board .recents-card:last-child{border-bottom:none;}

.post-board .post-body,
.recents-board .post-body{
  display:flex;
  flex-direction:column;
  padding-bottom:10px;
  gap:0;
  position:relative;
}

.main-post-column{
  flex:0 0 100%;
  width:100%;
  max-width:var(--post-board-max-w);
  padding:0;
  display:flex;
  flex-direction:column;
}

.post-images{
  margin-top:var(--gap);
  padding-top:0;
  width:100%;
  display:flex;
  flex-direction:column;
}

@media (max-width:440px){
  .main-post-column{
    flex:0 0 auto;
    width:100%;
    max-width:none;
  }
  .post-images .thumbnail-row{
    width:100%;
  }
}

.post-board .post-header{
  position:sticky;
  top:0;
  z-index:1;
}

.post-images .thumbnail-row{
  display:flex;
  width:100%;
  max-width:var(--post-board-max-w);
  box-sizing:border-box;
  padding:0 15px 10px 0;
  margin:0;
  gap:5px;
  overflow-x:auto;
  overflow-y:hidden;
  justify-content:flex-start;
}

@supports (scrollbar-gutter: stable){
  .post-images .thumbnail-row{
    scrollbar-gutter:stable both-edges;
  }
}

.post-images .thumbnail-row img{
  width:40px;
  height:40px;
  object-fit:cover;
  border-radius:8px;
  cursor:pointer;
  flex:0 0 auto;
}

.post-images .selected-image{
  width:100%;
  max-width:var(--post-board-max-w);
  aspect-ratio:1/1;
  background:#000;
  display:flex;
  align-items:center;
  justify-content:center;
  overflow:hidden;
}

.post-images .selected-image img{
  width:100%;
  height:100%;
  object-fit:cover;
  display:block;
}

.post-mode-boards > .post-body,
.post-body{
  width:100%;
  max-width:100%;
  min-width:0;
  padding:0;
  display:flex;
  flex-direction:column;
  overflow:visible;
  height:auto;
  margin-top:0;
}

.post-venue-selection-container,
.post-session-selection-container{
  width:100%;
  height:auto;
  min-height:0;
  display:flex;
  flex-direction:column;
  gap:var(--gap);
}
.post-venue-selection-container:empty,
.post-session-selection-container:empty{
  display:none;
}

.post-details-title-container,
.post-details-member-container,
.post-details-info-container,
.post-details-description-container{
  width:100%;
  min-width:0;
}
.post-details-info-container{
  display:flex;
  flex-direction:column;
  gap:var(--gap);
}
.post-details-info-container > *{
  min-width:0;
}

.post-details-description-container{
  display:flex;
  flex-direction:column;
  gap:var(--gap);
}

.post-details-description-container .desc,
.post-details-description-container .desc-wrap{
  border:none;
  padding:0;
}

.post-details-description-container .desc{
  font-size:14px;
}

.ad-board{
  position:fixed;
  top:calc(var(--header-h) + var(--safe-top));
  bottom:auto;
  right:0;
  width:440px;
  padding:10px;
  background:rgba(0,0,0,0.7);
  pointer-events:auto;
  z-index:2;
  transform:translateX(0);
  transition:transform var(--panel-transition-duration, 0.3s) ease,
             opacity var(--panel-transition-duration, 0.3s) ease;
  will-change:transform, opacity;
  height:var(--panel-area-height, calc((var(--vh, 1vh) * 100) - var(--header-h) - var(--safe-top) - var(--footer-h)));
  max-height:var(--panel-area-height, calc((var(--vh, 1vh) * 100) - var(--header-h) - var(--safe-top) - var(--footer-h)));
  min-height:var(--panel-area-height, calc((var(--vh, 1vh) * 100) - var(--header-h) - var(--safe-top) - var(--footer-h)));
}

body.hide-ads .ad-board{
  pointer-events:none;
}

@media (min-width:1900px){
  .ad-board{
    display:block;
  }
  body.hide-ads .ad-board{
    display:block;
  }
}

.ad-panel{
  width:100%;
  height:100%;
  position:relative;
  overflow:hidden;
  border-radius:8px;
}

.ad-panel .ad-slide{
  position:absolute;
  inset:0;
  opacity:0;
  transition:opacity 1.5s ease-in-out;
  cursor:pointer;
}

.ad-panel .ad-slide.active{opacity:1;}

.ad-panel .ad-slide img{
  width:100%;
  height:100%;
  object-fit:cover;
  animation:adZoom 20s linear forwards;
}

.ad-panel .ad-slide .info{
  position:absolute;
  left:0;
  right:0;
  bottom:0;
  background:rgba(0,0,0,0.5);
  color:#fff;
  padding:10px;
  text-shadow:0 0 4px #000;
}

@keyframes adZoom{
  from{transform:scale(1);}
  to{transform:scale(1.1);}
}

#filterBtn,
#memberBtn,
#adminBtn{
  gap:4px;
}
.header .view-toggle #filterBtn{
  height:40px;
  width:auto;
  padding:0 16px;
  border-radius:20px;
}
.icon-search{
  display:inline-block;
  vertical-align:middle;
  color: currentColor;
  width:30px; height:30px;
}
.mode-toggle{
  display:grid;
  grid-template-columns:repeat(3,40px);
  flex:0 1 auto;
  min-width:0;
  height:40px;
  border:1px solid var(--btn);
  border-radius:8px;
  overflow:hidden;
}
.mode-toggle button{
  width:40px;
  border:none;
  background:var(--btn);
  color:var(--button-text);
  font-weight:600;
  cursor:pointer;
  transition:background .2s,border-color .2s,color .2s;
  height:100%;
  border-radius:0;
  min-width:0;
  display:flex;
  align-items:center;
  justify-content:center;
  gap:0;
  padding:0;
}
.mode-toggle .mode-icon{
  display:flex;
  align-items:center;
  justify-content:center;
  line-height:0;
  width:100%;
  height:100%;
}
.mode-toggle .mode-label{
  display:none;
  font-size:14px;
  line-height:1;
  white-space:nowrap;
}
.mode-toggle button svg{
  width:20px;
  height:20px;
}
.mode-toggle button + button{
  border-left:1px solid var(--btn);
}
.mode-toggle button[aria-pressed="true"]{
  background:var(--btn-selected);
  color:var(--button-active-text);
}
@media (min-width: 601px){
  .mode-toggle{
    grid-template-columns:repeat(3, auto);
  }
  .mode-toggle button{
    width:auto;
    padding:0 16px;
  }
  .mode-toggle .mode-icon{
    display:none;
  }
  .mode-toggle .mode-label{
    display:block;
  }
}
body.filters-active #filterBtn{
  background: var(--filter-active-color);
  border-color: var(--filter-active-color);
  }

.options-dropdown{ position:relative; }
.options-menu{ position:absolute; top:calc(100% + 4px); left:0; background:var(--dropdown-bg); color:var(--dropdown-text); border:1px solid var(--border); border-radius:var(--dropdown-radius); padding:10px; display:flex; flex-direction:column; gap:6px;  z-index:30; }
.options-menu[hidden]{ display:none; }
.options-menu label{ display:flex; align-items:center; gap:6px; white-space:nowrap; }

.card,
.recents-card,
.post-card{
  display: grid;
  grid-template-columns:90px 1fr 36px;
  gap:12px;
  align-items: flex-start;
  background-color: transparent;
  border: none;
  border-radius:8px;
  padding:12px;
  margin-bottom:12px;
  cursor:pointer;
}

.post-card:hover,
.recents-card:hover{
  background:#2e3a72 !important;
}

.post-card{
  border:none;
  border-radius:8px;
  padding-top:10px;
  margin-top:10px;
}

.thumb{
  width: 90px;
  height: 70px;
  border-radius: 8px;
  object-fit: cover;
  display: block;
  background: var(--panel-bg);
  transition: filter .22s ease;
}

.thumb.lqip{
  filter: none;
}

.meta{
  display: flex;
  flex-direction: column;
  gap: 6px;
  min-width: 0;
}

.title{
  margin: 0;
  font-weight: bold;
  font-size: 16px;
  line-height: 1.2;
  overflow: hidden;
  text-overflow: ellipsis;
  display: -webkit-box;
  -webkit-line-clamp: 2;
  line-clamp: 2;
  -webkit-box-orient: vertical;
}

.info{
  display: flex;
  gap: 16px;
  align-items: center;
  min-width: 0;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

.quick-list-board .info{
  flex-direction: column;
  align-items: flex-start;
  gap: 4px;
  font-size: 13px;
}

.post-board .info{
  flex-direction: column;
  align-items: flex-start;
  gap: 4px;
  font-size: 13px;
}

.quick-list-board .info > div{
  display: flex;
  align-items: center;
  gap: 0;
}

.post-board .info > div{
  display: flex;
  align-items: center;
  gap: 0;
}

.badge{
  display: inline-flex;
  align-items: center;
  justify-content: center;
  font-size: 14px;
  padding-right: 5px;
  border: 0;
  border-radius: 0;
  width: auto;
  height: auto;
  line-height: 1;
}

.info > div > :not(.badge) + *{
  margin-left: 5px;
}

.fav{
  width: 36px;
  height: 36px;
  border-radius: 8px;
  display: grid;
  place-items: center;
  background: var(--btn);
  border: 1px solid var(--btn);
}

.fav svg{
  width: 18px;
  height: 18px;
  fill: none;
  stroke: var(--gold);
  stroke-width: 1.5;
}

.fav[aria-pressed="true"] svg{
  fill: var(--gold);
  stroke: var(--gold);
}

.share{
  width: 36px;
  height: 36px;
  border-radius: 8px;
  display: grid;
  place-items: center;
  background: var(--btn);
  border: 1px solid var(--btn);
  margin-left: auto;
}

.share svg{
  width: 18px;
  height: 18px;
  fill: var(--button-text);
}

#favToggle{
  white-space:nowrap;
}
#favToggle svg{
  width:18px;
  height:18px;
  fill:none;
  stroke:var(--gold);
  stroke-width:1.5;
  vertical-align:middle;
  margin-left:6px;
}
#favToggle[aria-pressed="true"] svg{
  fill:var(--gold);
  stroke:var(--gold);
}

#map{
  position: absolute;
  inset: 0;
}

.map-overlay{
  position: absolute;
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;
  display: grid;
  place-items: center;
  color: #fff;
  font-weight: 700;
  letter-spacing: .5px;
  opacity: .15;
  pointer-events: none;
}

.map-zoom-indicator{
  position:absolute;
  bottom:calc(var(--safe-bottom, 0px) + 20px);
  left:50%;
  transform:translateX(-50%);
  display:inline-flex;
  align-items:center;
  justify-content:center;
  gap:8px;
  padding:6px 12px;
  border-radius:999px;
  background:rgba(0, 0, 0, 0.7);
  color:#fff;
  font-size:12px;
  font-weight:600;
  letter-spacing:.3px;
  line-height:1;
  white-space:nowrap;
  pointer-events:none;
  z-index:5;
  min-width:72px;
  text-align:center;
}

.map-control-row{
  display:flex;
  align-items:center;
  gap:var(--gap);
  flex-wrap:nowrap;
}
.map-control-row .geocoder{
  background-color:#ffffff;
  border-radius:8px;
  flex:1 1 240px;
  min-width:0;
  width:100%;
  max-width:100%;
  display:flex;
}
#filterPanel .map-control-row .geocoder,
#filterPanel .map-control-row .mapboxgl-ctrl-geocoder,
#filterPanel .map-control-row .mapboxgl-ctrl-geocoder .mapboxgl-ctrl-geocoder--input{
  background-color:#ffffff;
  color:#000000;
}
#memberPanel .map-control-row .mapboxgl-ctrl-geolocate button:not(.mapboxgl-ctrl-geolocate-active):not(.mapboxgl-ctrl-geolocate-loading),
#memberPanel .map-control-row .mapboxgl-ctrl-compass button{
  background-color:#ffffff;
  box-shadow:none;
}
#memberPanel .map-control-row .mapboxgl-ctrl-geolocate button svg,
#memberPanel .map-control-row .mapboxgl-ctrl-compass button svg{
  filter:none !important;
}
.map-control-row .mapboxgl-ctrl-geolocate button,
.map-control-row .mapboxgl-ctrl-compass button{
  width:35px;
  height:35px;
  border-radius:8px;
  border:1px solid rgba(0,0,0,0.15);
  box-shadow:none;
}

.map-control-row .mapboxgl-ctrl-geolocate button:not(.mapboxgl-ctrl-geolocate-active):not(.mapboxgl-ctrl-geolocate-loading),
.map-control-row .mapboxgl-ctrl-compass button{
  background-color:#ffffff;
}

.mapboxgl-ctrl-geolocate button,
.mapboxgl-ctrl-compass button{
  width:35px !important;
  height:35px !important;
  border-radius:8px !important;
  border:1px solid rgba(0,0,0,0.15) !important;
  box-shadow:none !important;
}

.mapboxgl-ctrl-geolocate button:not(.mapboxgl-ctrl-geolocate-active):not(.mapboxgl-ctrl-geolocate-loading){
  background-color:#ffffff;
}

.map-control-row .mapboxgl-ctrl-geolocate button:hover,
.map-control-row .mapboxgl-ctrl-compass button:hover{
  background-color:#f2f2f2;
}

.map-control-row .mapboxgl-ctrl-geolocate button svg,
.map-control-row .mapboxgl-ctrl-compass button svg{
  filter:none;
}

.map-control-row .mapboxgl-ctrl-geocoder{
  background:#ffffff;
  border-radius:8px;
  color:#000000;
  display:flex;
  align-items:center;
  gap:0;
  height:var(--geocoder-h);
  min-height:var(--geocoder-h);
  width:100%;
  max-width:100%;
  min-width:0;
}

.map-control-row .mapboxgl-ctrl-geocoder .mapboxgl-ctrl-geocoder--input{
  background:#ffffff;
  color:#000000;
  flex:1 1 auto;
  width:100%;
  height:100%;
  padding-top:0;
  padding-bottom:0;
  padding-left:12px;
  padding-right:12px;
  line-height:var(--geocoder-h);
}

.map-control-row .mapboxgl-ctrl-geocoder input.mapboxgl-ctrl-geocoder--input{
  height:100%;
}

.map-control-row .mapboxgl-ctrl-geocoder .mapboxgl-ctrl-geocoder--pin-right{
  display:none;
}

.map-control-row .mapboxgl-ctrl-geocoder .mapboxgl-ctrl-geocoder--button,
.map-control-row .mapboxgl-ctrl-geocoder .mapboxgl-ctrl-geocoder--icon,
.map-control-row .mapboxgl-ctrl-geocoder .mapboxgl-ctrl-geocoder--icon-loading,
.map-control-row .mapboxgl-ctrl-geocoder .mapboxgl-ctrl-geocoder--icon-search{
  display:none;
}

.panel-body .map-control-row:not(.map-controls-welcome){
  width:100%;
  max-width:100%;
  margin:0;
  justify-content:flex-start;
  background:none;
  border-radius:0;
  padding:0;
  box-sizing:border-box;
}
.panel-body .map-control-row:not(.map-controls-welcome) > *{
  flex:0 0 auto;
  width:auto;
  max-width:none;
  background:transparent;
  border-radius:8px;
  min-width:0;
}
.panel-body .map-control-row:not(.map-controls-welcome) > .geocoder{
  flex:1 1 auto;
}

#welcomeBody .map-control-row{
  justify-content:center;
  width:100%;
  max-width:100%;
  margin:0 auto;
  gap:10px;
  flex-wrap:nowrap;
}
#welcomeBody .map-controls-welcome{
  pointer-events:auto;
}
#welcomeBody .map-control-row > *{
  flex:0 0 auto;
}
#welcomeBody .map-control-row > .geocoder{
  flex:1 1 300px;
  min-width:0;
  width:100%;
  max-width:300px;
}
#welcomeBody .map-control-row .mapboxgl-ctrl-geocoder{
  width:100% !important;
  max-width:300px !important;
  min-width:0 !important;
}
#welcomeBody .map-controls-welcome .mapboxgl-ctrl-geocoder{
  display:flex;
  align-items:center;
  gap:0;
  height:var(--control-h);
}
#welcomeBody .map-controls-welcome .mapboxgl-ctrl-geocoder .mapboxgl-ctrl-geocoder--input{
  flex:1 1 auto;
  height:100%;
  padding-top:0;
  padding-bottom:0;
  padding-left:12px;
  padding-right:12px;
  line-height:var(--control-h);
}
#welcomeBody .map-controls-welcome .mapboxgl-ctrl-geocoder,
#welcomeBody .map-controls-welcome .mapboxgl-ctrl-geocoder *,
#welcomeBody .map-controls-welcome .mapboxgl-ctrl-geolocate,
#welcomeBody .map-controls-welcome .mapboxgl-ctrl-geolocate *{
  text-align:left;
}
#welcomeBody .map-controls-welcome .mapboxgl-ctrl-geocoder .mapboxgl-ctrl-geocoder--button{
  display:none;
}
#welcomeBody .map-controls-welcome .mapboxgl-ctrl-geocoder .mapboxgl-ctrl-geocoder--icon{
  display:none;
}
#welcomeBody .map-control-row .mapboxgl-ctrl-geocoder .mapboxgl-ctrl-geocoder--input{
  width:100%;
}

.map-controls-map{
  position:absolute;
  left:50%;
  top:calc(var(--header-h) + 10px);
  transform:translateX(-50%);
  width:auto;
  max-width:calc(100% - 20px);
  min-width:0;
  z-index:1;
  flex-wrap:nowrap;
  justify-content:center;
}

.map-controls-map.in-header{
  top:calc(var(--safe-top) + var(--header-h) / 2);
  transform:translate(-50%, -50%);
  width:auto;
  max-width:none;
}

.map-controls-map .geocoder{
  flex:1 1 300px;
  min-width:0;
  width:100%;
  max-width:300px;
}

.map-controls-map .mapboxgl-ctrl-geocoder{
  width:100% !important;
  max-width:300px !important;
  min-width:0 !important;
}

.map-control-row .geocoder{margin:0;}

@media (max-width:600px){
  .map-controls-map{
    flex-wrap:nowrap;
    justify-content:center;
    gap:8px;
  }
  .map-controls-map:not(.in-header){
    width:calc(100% - 20px);
    max-width:calc(100% - 20px);
  }
  .map-controls-map .geocoder,
  .map-controls-map .mapboxgl-ctrl-geocoder{
    flex:1 1 100%;
    width:100% !important;
    max-width:min(100%, 300px) !important;
  }
  #welcomeBody .map-control-row > .geocoder,
  #welcomeBody .map-control-row .mapboxgl-ctrl-geocoder{
    width:100% !important;
    max-width:min(100%, 300px) !important;
  }
}

.post-board .posts{
  flex:1 1 auto;
  min-height:0;
  overflow-y:auto;
  overflow-y:overlay;
  overflow-x:hidden;
  padding:0;
  margin:0;
}
@supports (scrollbar-width: thin){
  .post-board .posts,
  .recents-board{
    scrollbar-width:thin;
  }
}

@supports (scrollbar-color: #000 #fff){
  .post-board .posts,
  .recents-board{
    scrollbar-color:rgba(255,255,255,0.4) rgba(0,0,0,0);
  }
}
.post-board .posts::-webkit-scrollbar,
.recents-board::-webkit-scrollbar{
  width:8px;
  height:8px;
}
.post-board .posts::-webkit-scrollbar-track,
.recents-board::-webkit-scrollbar-track{
  background-color:rgba(0,0,0,0);
}
.post-board .posts::-webkit-scrollbar-thumb,
.recents-board::-webkit-scrollbar-thumb{
  background-color:rgba(255,255,255,0.4);
  border-radius:999px;
}
.post-board .posts::-webkit-scrollbar-corner,
.recents-board::-webkit-scrollbar-corner{
  background-color:rgba(0,0,0,0);
}
.post-board{color:#fff;}
.post-board .post-card,
.post-board .open-post{
  background-color:transparent;
  margin:0;
  border:none;
  border-radius:0;
  border-bottom:1px solid rgba(255,255,255,0.12);
}
.post-board .post-card.is-map-highlight{
  background-color:#2e3a72;
}
.post-board .post-card:last-child,
.post-board .open-post:last-child{border-bottom:none;}
.post-board > *:last-child{margin-bottom:0 !important;}
.post-board .post-card .thumb{border-radius:8px;}
.post-board button{background:var(--btn);border-color:var(--btn);color:var(--ink);}

.post-board-empty{
  padding:20px 16px;
  text-align:center;
  display:flex;
  flex-direction:column;
  align-items:center;
  gap:0;
}

.post-board-empty-summary{
  margin:0 0 10px;
  width:100%;
  max-width:var(--post-board-max-w);
}

.post-board-empty-image{
  margin-top:10px;
  width:auto;
  max-width:100%;
  height:auto;
  border-radius:8px;
}

.post-board-empty-message{
  margin:10px 0 0;
}

.recents-board-reminder{
  margin:10px 0 20px;
  padding:0 12px;
  text-align:center;
  display:flex;
  flex-direction:column;
  align-items:center;
  gap:10px;
}

.recents-board-reminder img{
  max-width:100%;
  height:auto;
  border-radius:8px;
}

.recents-board-reminder p{
  margin:0;
}

body.mode-posts .post-board,
body.mode-map .post-board{
  z-index:1;
}
.map-area{
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  z-index: 0;
}

.open-post{
  border:none;
  border-radius:0;
  margin:0;
  padding-top:0;
  overflow:visible;
  color:#fff;
  font-size:14px;
  display:flex;
  flex-direction:column;
  gap:0;
  position:relative;
}

.open-post .post-header{
  display:flex;
  justify-content:space-between;
  align-items:center;
  padding:10px;
  opacity:1;
  border-top-left-radius:inherit;
  border-top-right-radius:inherit;
  position:sticky;
  top:0;
  z-index:3;
  background:transparent;
  pointer-events:none;
}
.open-post .post-header button,
.open-post .post-header [role="button"],
.open-post .post-header a{
  pointer-events:auto;
}
.post-card .post-header{
  background-color:transparent;
}
.open-post .post-header .share{margin-left:auto;margin-right:var(--gap);}

.open-post .post-body{
  padding:0 0 10px;
  display:flex;
  flex-direction:row;
  flex-wrap:wrap;
  gap:var(--gap);
  align-items:flex-start;
  align-content:flex-start;
  flex:1 1 100%;
  max-width:100%;
  width:100%;
}
.open-post .post-body > .main-post-column{
  flex:0 0 var(--post-board-max-w);
  max-width:var(--post-board-max-w);
  width:var(--post-board-max-w);
}

.open-post .post-details{
  margin-top:0;
  width:calc(100% - 20px);
  max-width:calc(100% - 20px);
  min-width:0;
  display:flex;
  flex-direction:column;
  gap:var(--gap);
  padding:10px 0;
  flex:1 1 auto;
  box-sizing:border-box;
  margin-left:auto;
  margin-right:auto;
}

.open-post:not(.desc-expanded) .post-venue-selection-container,
.open-post:not(.desc-expanded) .post-session-selection-container,
.open-post:not(.desc-expanded) .location-section,
.open-post:not(.desc-expanded) .post-details-info-container,
.open-post:not(.desc-expanded) .member-avatar-row{
  display:none;
}

.open-post .post-details .info{
  color: inherit;
  font-size: inherit;
}

.open-post .post-images{
  display:flex;
  flex-direction:column;
  gap:5px;
  width:100%;
  max-width:var(--post-board-max-w);
  flex:0 0 100%;
  box-sizing:border-box;
  margin:0 auto;
  align-self:center;
}

.open-post.desc-expanded .post-images,
body.open-post-sticky-images .open-post.desc-expanded .post-images{
  position:static;
}

.open-post.desc-expanded .post-images{
  margin-top:var(--gap);
}

.open-post-sticky-images .open-post .post-images{
  position:sticky;
  top:var(--open-post-header-h,0px);
  align-self:start;
}

.open-post .image-box{
  width:100%;
  max-width:100%;
  aspect-ratio:1/1;
  height:auto;
  min-height:0;
  overflow:hidden;
  border:none;
  border-radius:0;
  flex-shrink:0;
  cursor:pointer;
  background: rgba(0,0,0,0);
  position:relative;
}

.open-post .image-box .image-track{
  display:flex;
  width:100%;
  height:100%;
  gap:0;
  align-items:stretch;
  transition:transform 0.35s ease;
  will-change:transform;
  touch-action: pan-y;
}

.open-post .image-box img{
  width:100%;
  height:100%;
  aspect-ratio:1/1;
  object-fit:cover;
  object-position:center;
  display:block;
  flex:0 0 100%;
}
.open-post .image-box img.ready{
  object-fit:cover;
}

.open-post .thumbnail-row{
  position:relative;
}

.open-post .thumbnail-row img{
  width:50px;
  height:50px;
  object-fit:cover;
  object-position:center;
  aspect-ratio:1/1;
  border:1px solid var(--border);
  border-radius:8px;
  cursor:pointer;
  position:relative;
  z-index:1;
}

@media (max-width: 440px){
  .post-board .posts{padding:0;}
  .post-board .post-card{
    grid-template-columns:80px 1fr 36px;
    gap:12px;
    padding:12px;
    margin:10px 0 12px;
    border-radius:0;
  }
  .post-board .post-card .thumb{
    width:80px;
    height:80px;
  }
  .post-board .post-card .meta{padding:0;}
  .open-post{
    margin:10px 0 12px;
  }
  .post-board .post-card:last-child,
  .post-board .open-post:last-child{
    margin-bottom:0;
  }
  .open-post .post-body{
    padding:0;
  }
  .open-post .post-header{
    padding:10px;
  }
  .open-post .post-images,
  .open-post .venue-dropdown,
  .open-post .session-dropdown,
  .open-post .post-details{
    margin-bottom:var(--gap);
  }
  .open-post .post-details{
    margin-bottom:0;
  }
  .open-post .post-images{
    flex:1 1 100%;
    width:100%;
  }
  .open-post .image-box{
    width:100%;
    max-width:100%;
    aspect-ratio:1/1;
    height:auto;
    margin:0;
    border-radius:0;
    position:relative;
    overflow:hidden;
  }
  .open-post .image-box .image-track{
    display:flex;
    width:100%;
    height:100%;
    gap:0;
    align-items:stretch;
    transition:transform 0.35s ease;
    will-change:transform;
    touch-action: pan-y;
  }
  .open-post .image-box img{
    width:100%;
    height:100%;
    aspect-ratio:1/1;
    object-fit:cover;
    object-position:center;
    flex:0 0 100%;
  }
  .open-post .thumbnail-row{
    width:100%;
    max-width:100%;
  }
  .open-post .venue-dropdown,
  .open-post .session-dropdown{
    width:100%;
    max-width:100%;
    padding:0;
  }
  .post-body .venue-dropdown,
  .post-body .session-dropdown{
    width:100%;
    max-width:100%;
    padding:0;
  }
  .open-post .venue-dropdown,
  .open-post .session-dropdown,
  .post-body .venue-dropdown,
  .post-body .session-dropdown{
    min-width:0;
    width:100%;
    max-width:100%;
  }
}

.open-post .post-header .title{
  margin:0;
  font-size:16px;
  font-weight:bold;
  line-height:1.2;
  color:#fff;
}

.open-post .post-header .title-block{
  display:flex;
  flex-direction:column;
}

.open-post .post-header .cat-line{
  font-size:14px;
  margin-top:4px;
  display:flex;
  align-items:center;
}

.open-post .meta{
  font-size:14px;
  display:flex;
  gap:12px;
  flex-wrap:wrap;
}

.open-post .member-avatar-row,
.post-body .member-avatar-row{
  display:none;
  align-items:center;
  height:50px;
  gap:10px;
  margin:var(--gap) 0 0;
}
.open-post.desc-expanded .member-avatar-row,
.open-post.desc-expanded .post-body .member-avatar-row{
  display:flex;
}
.open-post .member-avatar-row img,
.post-body .member-avatar-row img{
  width:50px;
  height:50px;
  object-fit:cover;
}

.open-post .member-avatar-row span,
.post-body .member-avatar-row span{
  padding-left:10px;
}

.post-body .desc-wrap{
  width:100%;
}

.post-body .desc{
  display:-webkit-box;
  -webkit-line-clamp:2;
  line-clamp:2;
  -webkit-box-orient:vertical;
  overflow:hidden;
  text-overflow:ellipsis;
  cursor:pointer;
  white-space:normal;
}

.post-body .desc:focus{
  outline:none;
}

.post-body .desc.expanded{
  display:block;
  -webkit-line-clamp:unset;
  line-clamp:unset;
  overflow:visible;
  text-overflow:unset;
}

.open-post .location-section,
.post-body .location-section{
  display:flex;
  flex-direction:column;
  gap:var(--gap);
  margin:0;
}

.open-post .venue-dropdown,
.open-post .session-dropdown,
.post-body .venue-dropdown,
.post-body .session-dropdown{
  position:relative;
  width:100%;
  max-width:100%;
  min-width:0;
}

.venue-options,
.session-options{
  display:flex;
  flex-direction:column;
  gap:var(--gap);
  width:100%;
  flex:1 1 auto;
  max-height:250px;
  overflow-y:auto;
}

.open-post .post-venue-menu .map-container,
.post-body .post-venue-menu .map-container{
  position:relative;
  width:100%;
  border-radius:8px;
  overflow:hidden;
  background:var(--dropdown-bg);
  min-height:200px;
  flex:0 0 auto;
}

.open-post .post-venue-menu .post-map,
.post-body .post-venue-menu .post-map{
  width:100%;
  height:200px;
  min-height:200px;
  border:none;
  border-radius:8px;
}

.post-map{
  border-radius:8px;
}

.open-post .venue-dropdown > button,
.post-body .venue-dropdown > button{
  height:50px;
  background:var(--btn);
  border:1px solid var(--btn);
  border-radius:var(--dropdown-radius);
  text-align:left;
  padding:2px 8px;
  color:var(--button-text);
  display:inline-flex;
  flex-direction:column;
  align-items:flex-start;
  justify-content:center;
  width:100%;
}

.open-post .session-dropdown > button,
.post-body .session-dropdown > button{
  height:50px;
  background:var(--btn);
  border:1px solid var(--btn);
  border-radius:var(--dropdown-radius);
  text-align:left;
  padding:2px 8px;
  color:var(--button-text);
  display:inline-flex;
  align-items:center;
  justify-content:flex-start;
  width:100%;
}

.open-post .venue-dropdown > button .venue-name,
.post-body .venue-dropdown > button .venue-name{
  font-weight:bold;
  display:block;
}

.open-post .venue-dropdown > button .venue-address,
.post-body .venue-dropdown > button .venue-address{
  display:block;
}

.open-post .post-venue-menu .venue-options button .venue-name,
.post-body .post-venue-menu .venue-options button .venue-name{
  font-weight:bold;
  display:block;
}

.open-post .post-venue-menu .venue-options button .venue-address,
.post-body .post-venue-menu .venue-options button .venue-address{
  display:block;
}

.open-post .venue-dropdown > button .venue-name,
.post-body .venue-dropdown > button .venue-name,
.open-post .venue-dropdown > button .venue-address,
.post-body .venue-dropdown > button .venue-address,
.open-post .post-venue-menu .venue-options button .venue-name,
.post-body .post-venue-menu .venue-options button .venue-name,
.open-post .post-venue-menu .venue-options button .venue-address,
.post-body .post-venue-menu .venue-options button .venue-address{
  line-height:1.2;
}

.open-post .post-venue-menu,
.open-post .session-menu,
.post-body .post-venue-menu,
.post-body .session-menu{
  position:absolute;
  top:calc(100% + 4px);
  left:0;
  width:100%;
  min-width:0;
  box-sizing:border-box;
  max-width:100%;
  max-height:min(80vh, calc(100vh - (var(--header-h) + var(--safe-top) + 20px)));
  overflow:auto;
  background:var(--dropdown-bg);
  border:1px solid var(--border);
  border-radius:var(--dropdown-radius);
  padding:10px;
  display:flex;
  flex-direction:column;
  gap:10px;
  z-index:30;
}
.open-post .post-venue-menu,
.open-post .session-menu{
  max-width:100%;
}
.post-body .post-venue-menu,
.post-body .session-menu{
  max-width:100%;
}

.open-post .post-venue-menu[hidden],
.open-post .session-menu[hidden],
.post-body .post-venue-menu[hidden],
.post-body .session-menu[hidden]{display:none;}

.open-post .post-venue-menu .venue-options button,
.post-body .post-venue-menu .venue-options button{
  height:50px;
  background:var(--btn);
  border:1px solid var(--btn);
  border-radius:var(--dropdown-radius);
  text-align:left;
  padding:4px 8px;
  color:var(--button-text);
  display:flex;
  flex-direction:column;
  align-items:flex-start;
  justify-content:center;
  width:100%;
}

.open-post .session-menu button,
.post-body .session-menu button{
  height:50px;
  background:var(--btn);
  border:1px solid var(--btn);
  border-radius:var(--dropdown-radius);
  text-align:left;
  padding:4px 8px;
  color:var(--button-text);
  display:flex;
  align-items:center;
  justify-content:flex-start;
}

.open-post .post-venue-menu,
.open-post .session-menu,
.post-body .post-venue-menu,
.post-body .session-menu,
.sort-options{
  --button-selected-bg: #2e3a72;
  --button-selected-border: #2e3a72;
  --button-selected-text: var(--button-active-text);
  --button-selected-hover: #2e3a72;
  --button-selected-hover-border: #2e3a72;
  --button-selected-hover-text: var(--button-active-text);
  --button-selected-active: #2e3a72;
  --button-selected-active-border: #2e3a72;
  --button-selected-active-text: var(--button-active-text);
}

.open-post .post-venue-menu .venue-options button.selected,
.open-post .session-menu button.selected,
.post-body .post-venue-menu .venue-options button.selected,
.post-body .session-menu button.selected{
  background:#2e3a72;
  color:var(--button-active-text);
  border-color:#2e3a72;
}

.open-post .session-menu button .session-time,
.post-body .session-menu button .session-time{
  margin-left:auto;
  padding-right:20px;
}
.open-post .session-dropdown > button .session-time,
.post-body .session-dropdown > button .session-time{
  margin-left:auto;
  padding-right:20px;
}

.open-post .location-section .post-venue-menu,
.post-body .location-section .post-venue-menu{
  width:100%;
  box-sizing:border-box;
}

.hide-map-calendar .open-post .map-container,
.hide-map-calendar .open-post .calendar-container,
.hide-map-calendar .post-body .map-container,
.hide-map-calendar .post-body .calendar-container{
  display:none;
}

.open-post .post-calendar,
.post-body .post-calendar,
.post-body .post-calendar{
  position:relative;
  font-size:var(--panel-label-size);
  min-width:var(--calendar-width);
  width:max-content;
}

.open-post .session-menu .calendar-container,
.post-body .session-menu .calendar-container{
  display:flex;
  flex-direction:column;
  gap:var(--gap);
  position:relative;
  width:100%;
  min-width:0;
  height:auto;
  border-radius:8px;
  overflow:hidden;
  background:var(--dropdown-bg);
  min-height:200px;
  flex:0 0 auto;
}

.open-post .calendar-container .calendar-scroll,
.post-body .calendar-container .calendar-scroll{
  width:100%;
  min-height:var(--calendar-height);
  height:auto;
  max-height:none;
  display:flex;
  align-items:stretch;
  overflow-x:auto;
  overflow-y:hidden;
  padding-bottom:var(--scrollbar-h);
  box-sizing:content-box;
  background:var(--dropdown-bg);
  border:none;
  border-radius:8px;
  display:flex;
  align-items:stretch;
  flex:1 1 auto;
  max-width:100%;
  margin-bottom:0;
}

@supports (scrollbar-gutter: stable){
  .open-post .calendar-container .calendar-scroll,
  .post-body .calendar-container .calendar-scroll{
    scrollbar-gutter: stable;
  }
}
.open-post .post-calendar .calendar,
.post-body .post-calendar .calendar,
.post-body .post-calendar .calendar{
  margin:0;
  box-sizing:border-box;
  display:flex;
  flex-direction:row;
  align-items:flex-start;
  width:max-content;
  height:var(--calendar-height);
  transform:scale(var(--calendar-scale));
  transform-origin:top left;
  background:var(--dropdown-bg);
  color:var(--dropdown-text);
  font-size:inherit;
}
.open-post .post-calendar .month,
.post-body .post-calendar .month,
.post-body .post-calendar .month{
  flex:0 0 auto;
  width:var(--calendar-width);
  min-width:var(--calendar-width);
  height:var(--calendar-height);
  display:flex;
  flex-direction:column;
}
.open-post .post-calendar .month:not(:first-child),
.post-body .post-calendar .month:not(:first-child),
.post-body .post-calendar .month:not(:first-child){
  border-left:1px solid var(--calendar-past-bg);
}
.open-post .post-calendar .grid,
.post-body .post-calendar .grid,
.post-body .post-calendar .grid{
  flex:1 1 auto;
  width:100%;
  height:calc(var(--calendar-height) - var(--calendar-header-h));
  display:grid;
  grid-template-columns:repeat(7,var(--calendar-cell-w));
  grid-template-rows:repeat(7,var(--calendar-cell-h));
}
.open-post .post-calendar .calendar-header,
.post-body .post-calendar .calendar-header,
.post-body .post-calendar .calendar-header{
  height:var(--calendar-header-h);
  display:flex;
  align-items:center;
  justify-content:center;
  text-align:center;
  font-weight:bold;
  line-height:var(--calendar-header-h);
  background:#2e3a72;
  color:#fff;
  font-size:inherit;
}
.open-post .post-calendar .weekday,
.open-post .post-calendar .day,
.post-body .post-calendar .weekday,
.post-body .post-calendar .day,
.post-body .post-calendar .weekday,
.post-body .post-calendar .day{
  width:var(--calendar-cell-w);
  height:var(--calendar-cell-h);
  line-height:var(--calendar-cell-h);
  text-align:center;
  font-size:inherit;
}
.open-post .post-calendar .weekday,
.post-body .post-calendar .weekday,
.post-body .post-calendar .weekday{
  font-weight:bold;
  color:var(--dropdown-text);
}
.open-post .post-calendar .day,
.post-body .post-calendar .day,
.post-body .post-calendar .day{
  cursor:pointer;
  background:var(--calendar-future-bg);
  color:var(--dropdown-text);
  transition:background .2s,color .2s;
}
.open-post .post-calendar .day.empty,
.post-body .post-calendar .day.empty,
.post-body .post-calendar .day.empty{
  cursor:default;
  background:var(--calendar-future-bg);
  color:var(--dropdown-text);
  opacity:0.6;
}
.open-post .post-calendar .day.available-day,
.post-body .post-calendar .day.available-day,
.post-body .post-calendar .day.available-day{
  background:var(--session-available);
  color:#fff;
}
.open-post .post-calendar .day.available-day:hover,
.post-body .post-calendar .day.available-day:hover,
.post-body .post-calendar .day.available-day:hover{
  background:var(--session-available);
  color:#fff;
}
.open-post .post-calendar .day.selected,
.post-body .post-calendar .day.selected,
.post-body .post-calendar .day.selected{
  background:var(--session-selected);
  color:#fff;
}
.open-post .post-calendar .day.selected:hover,
.post-body .post-calendar .day.selected:hover,
.post-body .post-calendar .day.selected:hover{
  background:var(--session-selected);
  color:#fff;
}
.open-post .post-calendar .day.today,
.post-body .post-calendar .day.today,
.post-body .post-calendar .day.today{color:var(--today) !important;}
.open-post .post-calendar .day.available-day.today,
.open-post .post-calendar .day.available-day.selected.today,
.open-post .post-calendar .day.selected.today,
.post-body .post-calendar .day.available-day.today,
.post-body .post-calendar .day.available-day.selected.today,
.post-body .post-calendar .day.selected.today,
.post-body .post-calendar .day.available-day.today,
.post-body .post-calendar .day.available-day.selected.today,
.post-body .post-calendar .day.selected.today{color:var(--today) !important;}

.open-post .post-calendar .selected-month-name,
.post-body .post-calendar .selected-month-name,
.post-body .post-calendar .selected-month-name{
  background:var(--accent);
  color:var(--button-hover-text);
  border-radius:8px;
  padding:0 4px;
}

.open-post .calendar-container .time-popup,
.post-body .calendar-container .time-popup{
  position:absolute;
  z-index:10;
}

.open-post .calendar-container .time-popup .time-list,
.post-body .calendar-container .time-popup .time-list{
  background:var(--dropdown-bg);
  color:var(--dropdown-text);
  padding:8px;
  border-radius:8px;
  display:flex;
  flex-direction:column;
  gap:4px;
   }

.open-post .calendar-container .time-popup .time-list button,
.post-body .calendar-container .time-popup .time-list button{
  background:var(--btn);
  border:1px solid var(--btn);
  color:var(--button-text);
  border-radius:8px;
  padding:6px 10px;
  cursor:pointer;
}

.open-post .venue-info,
.open-post .session-info,
.post-body .venue-info,
.post-body .session-info{
  color: inherit;
  font-size: inherit;
}
.open-post .venue-info,
.post-body .venue-info{margin-top:4px;}
.open-post .session-info,
.post-body .session-info{margin-top:8px;}

.pill{
  border: 1px solid var(--btn);
  background: var(--btn);
  border-radius: 999px;
  padding: 8px 12px;
  font-weight: 700;
  cursor: pointer;
}

.close{
  border: 0;
  background: #16283f;
  border-radius: 8px;
  padding: 8px 12px;
  cursor: pointer;
}

.dates{
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
  margin-top: 4px;
}

.date{
  background: var(--btn);
  border: 1px solid var(--btn);
  border-radius: 999px;
  padding: 6px 10px;
  font-size: 14px;
}

.desc{
  margin-top:8px;
  cursor:pointer;
  font-size:14px;
}

@media (max-width:440px){
  html{
    touch-action:pan-x pan-y;
  }
  .map-container{
    touch-action:auto;
  }
}

@media (max-width:440px){
  .post-mode-boards{
    top:calc(var(--header-h) + var(--safe-top));
    bottom:var(--footer-h);
    padding:0;
    gap:0;
    flex-direction:column;
    align-items:flex-start;
  }
  .quick-list-board,
  .post-board,
  .recents-board{
    width:100%;
    max-width:100%;
    left:0;
    right:0;
    padding:0;
    border-radius:0;
    flex:0 0 auto;
    min-height:0;
    height:auto;
    max-height:100%;
  }
  .post-board{
    min-height:var(--panel-area-height, calc((var(--vh, 1vh) * 100) - var(--header-h) - var(--safe-top) - var(--footer-h)));
    height:var(--panel-area-height, calc((var(--vh, 1vh) * 100) - var(--header-h) - var(--safe-top) - var(--footer-h)));
    max-height:var(--panel-area-height, calc((var(--vh, 1vh) * 100) - var(--header-h) - var(--safe-top) - var(--footer-h)));
  }
  .quick-list-board{
    position:relative;
    top:0;
    bottom:auto;
  }
  .panel-content{
    top:calc(var(--header-h) + var(--safe-top));
    bottom:var(--footer-h);
    height:calc(100vh - var(--header-h) - var(--safe-top) - var(--footer-h));
    min-height:0;
  }
  .card,
  .recents-card,
  .post-card{
    margin:0;
    border-radius:0;
    padding:12px;
  }
  .post-board .post-card,
  .recents-board .recents-card{
    margin:0;
    border-radius:0;
  }
  .thumb,
  .recents-card .thumb{
    border-radius:0;
  }
  .post-card .thumb{
    border-radius:8px;
  }
  .post-board .post-card,
  .recents-board .recents-card{
    border-bottom:1px solid rgba(255,255,255,0.12);
  }
  .post-board .post-card:last-child,
  .recents-board .recents-card:last-child{
    border-bottom:none;
  }
  .panel-content{
    left:0 !important;
    right:0 !important;
    top:calc(var(--header-h) + var(--safe-top));
    bottom:var(--footer-h);
    width:100% !important;
    max-width:100% !important;
    height:calc(100vh - var(--header-h) - var(--safe-top) - var(--footer-h));
    max-height:calc(100vh - var(--header-h) - var(--safe-top) - var(--footer-h));
    border-radius:0;
  }
  .panel-body{
    padding:10px;
    align-items:stretch;
  }
  .panel-body > *{
    max-width:100%;
  }
  #filterPanel .panel-body{
    padding:10px;
  }
  #filterPanel .panel-body > *{
    max-width:100%;
  }
  .post-details-description-container .desc-wrap{
    margin:10px 0 0;
  }
  .open-post:not(.desc-expanded) .post-details-description-container .desc-wrap{
    margin-top:0;
  }
  .post-details-description-container .desc{
    margin:0;
  }
  .post-details-description-container .desc[aria-expanded="false"]{
    display:-webkit-box;
    -webkit-line-clamp:2;
    line-clamp:2;
    -webkit-box-orient:vertical;
    overflow:hidden;
    text-overflow:ellipsis;
  }
  .post-details-description-container .desc[aria-expanded="true"],
  .post-details-description-container .desc.expanded{
    display:block;
  }
  .post-images{
    margin-top:10px;
  }
  .open-post .image-box{
    width:100%;
    max-width:100%;
    aspect-ratio:1/1;
    margin:0;
    border-radius:0;
    display:block;
    overflow:hidden;
    position:relative;
  }
  .open-post .image-box .image-track{
    display:flex;
    width:100%;
    height:100%;
    gap:0;
    align-items:stretch;
    transition:transform 0.35s ease;
    will-change:transform;
    touch-action: pan-y;
  }
  .open-post .image-box img{
    border-radius:0;
    width:100%;
    height:100%;
    aspect-ratio:1/1;
    object-fit:cover;
    display:block;
    flex:0 0 100%;
  }
  .open-post .thumbnail-row img{
    width:60px;
    height:60px;
    border-radius:8px;
  }
}

@media (max-width:440px){
  .open-post .post-body{
    flex-direction:column;
    gap:var(--gap);
  }
    .open-post .post-body > .main-post-column,
    .open-post .post-body{
      flex:1 1 100%;
      max-width:100%;
      width:100%;
    }
    .open-post .location-section,
    .post-body .location-section{
      flex-direction:column;
    }
    .open-post .post-details .location-section,
    .post-body .post-details .location-section{
      order:-1;
    }
  .open-post .image-box{
    max-width:100%;
    width:100%;
    aspect-ratio:1/1;
    height:auto;
    display:block;
    position:relative;
    overflow:hidden;
  }
    .open-post .image-box .image-track{
      display:flex;
      width:100%;
      height:100%;
      gap:0;
      align-items:stretch;
      transition:transform 0.35s ease;
      will-change:transform;
      touch-action: pan-y;
    }
    .open-post .image-box img{
      width:100%;
      height:100%;
      aspect-ratio:1/1;
      flex:0 0 100%;
    }
  .open-post .venue-dropdown,
  .open-post .session-dropdown,
  .post-body .venue-dropdown,
  .post-body .session-dropdown{
    display:block;
  }
}

  @media (max-width:440px){
    .post-board,
    .post-board .post-card,
    .open-post{
      width:100%;
      max-width:100%;
      border:none;
      border-radius:0;
    }
    .post-board,
    .open-post{
      min-width:0;
    }
    .open-post .image-box{
      width:100%;
      max-width:100%;
      aspect-ratio:1/1;
      height:auto;
      max-height:none;
      margin:0;
      padding:0;
      border:none;
      border-radius:0;
      display:block;
      overflow:hidden;
      position:relative;
    }
    .open-post .image-box .image-track{
      display:flex;
      width:100%;
      height:100%;
      gap:0;
      align-items:stretch;
      transition:transform 0.35s ease;
      will-change:transform;
      touch-action: pan-y;
    }
    .open-post .image-box img{
      width:100%;
      height:100%;
      object-fit:cover;
      margin:0;
      border-radius:0;
      aspect-ratio:1/1;
      flex:0 0 100%;
    }
    .open-post .post-body{
      padding:0;
      gap:0;
    }
    .open-post .post-details{
      padding:10px 0;
    }
  }

@media (max-width:440px){
  .open-post .venue-dropdown > button,
  .open-post .session-dropdown > button{
    height:50px;
  }
}

  .fullscreen-btn{
    width:35px;
    height:35px;
    padding:0;
    flex:0 0 auto;
  }

  .copy-msg{ 
    position:absolute;
    background:rgba(0,0,0,0.8);
    color:#fff;
    padding:4px 8px;
    border-radius:8px;
    opacity:0;
    transition:opacity .3s;
    pointer-events:none;
  }
  .copy-msg.show{opacity:1;}

  .image-modal-container{
    position:fixed;
    top:0;
    left:0;
    width:100%;
    height:100%;
    background:rgba(0,0,0,0.7);
    display:flex;
    align-items:center;
    justify-content:center;
    z-index:3000;
  }
  .image-modal-container.hidden{display:none;}
  .image-modal-container .image-modal img{
    max-width:90vw;
    max-height:90vh;
    display:block;
  }

  #post-modal-container{
    position:fixed;
    top:0;
    left:0;
    width:100%;
    height:100%;
    background:rgba(0,0,0,0.7);
    display:flex;
    align-items:center;
    justify-content:center;
    z-index:3000;
  }
  #post-modal-container.hidden{display:none;}
    #post-modal-container .post-modal{
      width:880px;
    max-width:100%;
    height:90%;
    overflow:auto;
    overflow:overlay;
    background:var(--list-background);
    border-radius:8px;
  }
    @media (max-width:440px){
      #post-modal-container .post-modal{width:440px;}
    }
    @media (max-width:440px){
      #post-modal-container .post-modal{width:100%;min-width:0;}
    }

  .chip-small{
  flex: 0 0 auto;
  max-width: 240px;
  display: flex;
  align-items: center;
  gap: 8px;
  background: var(--btn);
  border-radius: 8px;
  padding: 6px 10px;
  font-size: 14px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  cursor: pointer;
}

.chip-small img.mini{
  width: 26px;
  height: 20px;
  border-radius: 8px;
  object-fit: cover;
  flex: 0 0 auto;
  display: block;
  background: var(--btn);
}

.chip-small .t{
  overflow: hidden;
  text-overflow: ellipsis;
}

.card .thumb,
.recents-card .thumb,
.post-card .thumb{
  flex: 0 0 80px;
  width: 80px;
  height: 80px;
  display: block;
  object-fit: cover;
  border-radius: 8px;
}

.card .meta,
.recents-card .meta,
.post-card .meta{
  flex: 1 1 auto;
  min-width: 0;
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.post-card,
.post-card *,
.recents-card,
.recents-card *{
  cursor: pointer;
}

.card .fav,
.recents-card .fav,
.post-card .fav{
  flex: 0 0 auto;
}

.recents-card[aria-selected="true"]{
  position:relative;
  z-index:0;
  background:none;
}

.recents-card[aria-selected="true"]::before{
  content:"";
  position:absolute;
  inset:0;
  background-color:#2e3a72;
  border-radius:8px;
  z-index:-1;
}

.big-map-card--popup,
.big-map-card--list{
  pointer-events: auto;
  cursor: pointer;
}
.big-map-card--popup{
  display: block;
}

.map-card-list{
  max-height: 360px;
  overflow-y: auto;
  overflow-y: overlay;
  overflow-x: hidden;
  padding: 2px 6px 2px 2px;
  box-sizing: border-box;
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.map-card-list-item{
  padding: 5px;
  border-radius: 8px;
  cursor: pointer;
  min-width: 0;
  box-sizing: border-box;
}

.mapboxgl-popup,
.mapboxgl-popup-content{
  border-radius:8px !important;
}

.mapboxgl-popup-content{
  background: var(--popup-bg) !important;
  color: var(--popup-text) !important;
  overflow:hidden;
}

.mapboxgl-popup.big-map-card .mapboxgl-popup-content{
  overflow: visible;
}

.mapboxgl-popup-close-button{
  color: var(--popup-text) !important;
}

.nowrap{
  white-space: nowrap;
}

.hero img.lqip{
  filter: blur(10px);
  transform: scale(1.02);
  transition: filter .22s ease, transform .22s ease;
}

.hero img.ready{
  filter: none;
  transform: none;
}

img.thumb{
  width: 80px;
  height: 80px;
  object-fit: cover;
  border-radius: 8px;
}

#results .recents-card > img, #results .recents-card img.thumb{
  width: 80px;
  height: 80px;
  aspect-ratio: 1/1;
  object-fit: cover;
  display: block;
  border-radius: 8px;
}

.mode-posts #postsWide{
  border: none;
  background: transparent;
}

.mode-posts #postsWide.posts{
  background: transparent;
}

@media (max-width:440px){
  #filterPanel .panel-content{
    top:calc(var(--header-h) + var(--safe-top));
    left:0;
    right:0;
    bottom:var(--footer-h);
    width:100%;
    max-width:none;
    max-height:none;
    border-radius:0;
    padding-bottom:10px;
  }
  #filterPanel .panel-content .resizer{
    display:none;
  }
}

@media (max-width:440px){
  .post-board .posts{
    padding:0;
    margin:0;
  }
  .post-board .post-card{
    width:100%;
    margin:0;
    border-radius:0;
  }
  .post-board .open-post{
    margin:0;
  }
  .open-post{
    width:100%;
    border-radius:0;
    margin:0;
  }
  .open-post .post-images{
    flex:0 0 100%;
    width:100%;
  }
  .open-post .post-details{
    width:calc(100% - 20px);
    max-width:calc(100% - 20px);
    min-width:0;
    padding:10px 0;
    margin-left:auto;
    margin-right:auto;
  }
  .open-post .image-box{
    width:100%;
    max-width:100%;
    aspect-ratio:1/1;
    height:auto;
    flex:0 0 auto;
    border-radius:0;
    display:block;
    position:relative;
    overflow:hidden;
  }
  .open-post .image-box .image-track{
    display:flex;
    width:100%;
    height:100%;
    gap:0;
    align-items:stretch;
    transition:transform 0.35s ease;
    will-change:transform;
    touch-action: pan-y;
  }
  .open-post .image-box img{
    width:100%;
    height:100%;
    object-fit:cover;
    aspect-ratio:1/1;
    flex:0 0 100%;
  }
    .post-mode-boards > .post-body,
    .post-body{
      width:100%;
      max-width:520px;
      min-width:0;
      flex:0 0 100%;
    }
    .open-post .post-body{
      height:auto;
      max-height:none;
      overflow:visible;
    }
    .open-post .post-body .post-details{
      height:auto;
    }
}

@media (max-width:440px){
  :root{
    --footer-h:0;
  }
  body.mode-map{
    --footer-h:0;
  }
  #filterPanel .panel-content{
    top:calc(var(--header-h) + var(--safe-top));
    left:0;
    right:0;
  }
  .open-post .post-header{
    padding:10px;
  }
  .open-post .post-body{
    padding:0;
  }
}

</style>
  <style id="cursor-fixes">
    html, body { cursor: auto !important; }
    a, button, [role="button"], .clickable { cursor: pointer !important; }
    .mapboxgl-canvas { cursor: grab; }
    .mapboxgl-canvas:active { cursor: grabbing; }
    * { -webkit-tap-highlight-color: transparent; }
  </style>
  <script>
  // --- tiny scheduler helpers ---
  function rafThrottle(fn){
    let scheduled = false, lastArgs, lastThis;
    return function throttled(...args){
      lastArgs = args; lastThis = this;
      if (scheduled) return;
      scheduled = true;
      requestAnimationFrame(() => { scheduled = false; fn.apply(lastThis, lastArgs); });
    };
  }

  // Prefer idle time, but don't stall forever.
  function scheduleIdle(fn, timeout=200){
    if ('requestIdleCallback' in window) {
      requestIdleCallback(fn, { timeout });
    } else {
      setTimeout(fn, Math.min(timeout, 50));
    }
  }

  function withPassiveDefault(options){
    if(options === undefined){
      return { passive: true };
    }
    if(typeof options === 'boolean'){
      return { capture: options, passive: true };
    }
    if(typeof options === 'object' && options !== null && options.passive === undefined){
      return Object.assign({}, options, { passive: true });
    }
    return options;
  }

  function addPassiveScrollListener(target, listener, options){
    if(!target || typeof target.addEventListener !== 'function') return null;
    const opts = withPassiveDefault(options);
    target.addEventListener('scroll', listener, opts);
    return opts;
  }

  function removeScrollListener(target, listener, options){
    if(!target || typeof target.removeEventListener !== 'function') return;
    let capture = false;
    if(typeof options === 'boolean'){
      capture = options;
    } else if(typeof options === 'object' && options !== null){
      capture = !!options.capture;
    }
    target.removeEventListener('scroll', listener, capture);
  }
  </script>

<script>
(function(){
  const ASSET_VERSION = 'v=20240705';
  const assetPattern = /^(?:\.\/)?assets\//;

  function withVersion(url){
    if (!url || url.includes('?')) return url;
    if (!assetPattern.test(url)) return url;
    if (url.startsWith('./')) {
      return `./${url.slice(2)}?${ASSET_VERSION}`;
    }
    return `${url}?${ASSET_VERSION}`;
  }

  function toAbsoluteUrl(url){
    if (!url) return url;
    try {
      return new URL(url, window.location.href).href;
    } catch (err) {
      return url;
    }
  }

  function bustCacheAttributes(){
    const attrs = ['src', 'href'];
    attrs.forEach((attr) => {
      document.querySelectorAll(`[${attr}]`).forEach((node) => {
        const current = node.getAttribute(attr);
        const updated = withVersion(current);
        if (updated && updated !== current) {
          node.setAttribute(attr, updated);
        }
      });
    });

    document.querySelectorAll('[srcset]').forEach((node) => {
      const srcset = node.getAttribute('srcset');
      if (!srcset) return;
      const rewritten = srcset
        .split(',')
        .map((entry) => {
          const trimmed = entry.trim();
          if (!trimmed) return trimmed;
          const parts = trimmed.split(/\s+/, 2);
          const nextUrl = withVersion(parts[0]);
          if (!nextUrl || nextUrl === parts[0]) return trimmed;
          return parts[1] ? `${nextUrl} ${parts[1]}` : nextUrl;
        })
        .join(', ');
      if (rewritten !== srcset) {
        node.setAttribute('srcset', rewritten);
      }
    });
  }

  function updateManifest(){
    const link = document.querySelector('link[rel="manifest"]');
    if (!link) return;
    const manifest = {
      name: 'Events Platform',
      short_name: 'Events',
      icons: [
        {
          src: toAbsoluteUrl(withVersion('assets/favicons/android-chrome-192x192.png')),
          sizes: '192x192',
          type: 'image/png'
        },
        {
          src: toAbsoluteUrl(withVersion('assets/favicons/android-chrome-512x512.png')),
          sizes: '512x512',
          type: 'image/png'
        }
      ],
      theme_color: '#ffffff',
      background_color: '#ffffff',
      display: 'standalone'
    };
    const serialized = encodeURIComponent(JSON.stringify(manifest));
    link.setAttribute('href', `data:application/manifest+json;charset=utf-8,${serialized}`);
  }

  function hideGeocoderIconFromAT(){
    let applied = false;
    document.querySelectorAll('.mapboxgl-ctrl-geocoder--icon').forEach((icon) => {
      if (icon.getAttribute('aria-hidden') === 'true') return;
      icon.setAttribute('aria-hidden', 'true');
      icon.setAttribute('role', 'presentation');
      applied = true;
    });
    return applied;
  }

  function setupGeocoderObserver(){
    const observer = new MutationObserver(() => {
      if (hideGeocoderIconFromAT()) {
        /* noop */
      }
    });
    observer.observe(document.body, { childList: true, subtree: true });
    setTimeout(() => observer.disconnect(), 5000);
  }

  document.addEventListener('DOMContentLoaded', () => {
    bustCacheAttributes();
    updateManifest();
    hideGeocoderIconFromAT();
    setupGeocoderObserver();
  });
})();
</script>

<script>
if (typeof slugify !== 'function') {
  function slugify(text) {
    return String(text)
      .normalize('NFD')
      .replace(/[\u0300-\u036f]/g, '')
      .toLowerCase()
      .trim()
      .replace(/[^a-z0-9]+/g, '-')
      .replace(/^-+|-+$/g, '');
  }
}
</script>

<script>
// === 150x40 pill provider (sprite id: marker-label-bg) ===
(function(){
  const PILL_ID = 'marker-label-bg';
  const ACCENT_ID = `${PILL_ID}--accent`;
  const PILL_BASE_IMAGE_URL = 'assets/icons-30/150x40-pill-70.webp';
  const PILL_ACCENT_IMAGE_URL = 'assets/icons-30/150x40-pill-2f3b73.webp';
  let cachedImages = null;
  let loadingTask = null;
  const pendingMaps = new Set();

  function applyImageToMap(map){
    if(!map || typeof map.hasImage !== 'function' || !cachedImages){
      return;
    }
    try{
      if(map.hasImage(PILL_ID)){
        try{ map.removeImage(PILL_ID); }catch(e){}
      }
      if(map.hasImage(ACCENT_ID)){
        try{ map.removeImage(ACCENT_ID); }catch(e){}
      }
      const baseImage = cachedImages.base || cachedImages.accent;
      if(baseImage){
        map.addImage(PILL_ID, baseImage, { pixelRatio: 1 });
      }
      const accentImage = cachedImages.accent || cachedImages.base;
      if(accentImage){
        map.addImage(ACCENT_ID, accentImage, { pixelRatio: 1 });
      }
    }catch(e){ /* silent */ }
  }

  function tintImage(sourceImage, color, alpha = 1){
    if(!sourceImage){
      return null;
    }
    try{
      const width = sourceImage.naturalWidth || sourceImage.width || 150;
      const height = sourceImage.naturalHeight || sourceImage.height || 40;
      const canvas = document.createElement('canvas');
      canvas.width = Math.max(1, Math.round(width));
      canvas.height = Math.max(1, Math.round(height));
      const ctx = canvas.getContext('2d');
      if(!ctx){
        return null;
      }
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(sourceImage, 0, 0, canvas.width, canvas.height);
      if(color){
        ctx.globalCompositeOperation = 'source-atop';
        ctx.globalAlpha = alpha;
        ctx.fillStyle = color;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.globalAlpha = 1;
        ctx.globalCompositeOperation = 'source-over';
      }
      return canvas;
    }catch(err){
      return null;
    }
  }

  function prepareCachedImages(baseImage, accentImage){
    if(!baseImage){
      cachedImages = null;
      return;
    }
    const tintedBase = tintImage(baseImage, 'rgba(0,0,0,1)', 0.9) || baseImage;
    let highlight = null;
    if(accentImage){
      highlight = tintImage(accentImage, null, 1) || accentImage;
    }
    if(!highlight){
      highlight = tintImage(baseImage, '#2f3b73', 1) || tintedBase;
    }
    cachedImages = { base: tintedBase, accent: highlight };
  }

  function loadImage(url){
    if(!url){
      return Promise.resolve(null);
    }
    return new Promise((resolve) => {
      const img = new Image();
      try{ img.crossOrigin = 'anonymous'; }catch(e){}
      try{ img.decoding = 'async'; }catch(e){}
      img.onload = () => {
        if(img.naturalWidth > 0 && img.naturalHeight > 0){
          resolve(img);
        }else{
          resolve(null);
        }
      };
      img.onerror = () => resolve(null);
      img.src = url;
      if(img.complete && img.naturalWidth > 0 && img.naturalHeight > 0){
        resolve(img);
      }
    });
  }

  function ensureImage(){
    if(cachedImages || loadingTask){
      return;
    }
    loadingTask = Promise.all([
      loadImage(PILL_BASE_IMAGE_URL),
      loadImage(PILL_ACCENT_IMAGE_URL)
    ]).then(([baseImage, accentImage]) => {
      if(baseImage){
        prepareCachedImages(baseImage, accentImage);
        if(cachedImages){
          pendingMaps.forEach((map) => applyImageToMap(map));
        }
      }
    }).catch(() => {
      cachedImages = null;
    }).finally(() => {
      pendingMaps.clear();
      loadingTask = null;
    });
  }

  function addOrReplacePill(map){
    try{
      if(!map || typeof map.hasImage !== 'function'){
        return;
      }
      if(cachedImages){
        applyImageToMap(map);
        return;
      }
      pendingMaps.add(map);
      ensureImage();
    }catch(e){ /* silent */ }
  }

  window.__addOrReplacePill150x40 = addOrReplacePill;
  ensureImage();
})();
</script>
</head>
<body class="mode-map" style="padding-bottom:var(--footer-h);">
  <header class="header" role="banner">
    <div class="logo" aria-label="Site logo">
      <img src="assets/funmap-logo-small.png" alt="FunMap.com logo" />
    </div>
    <nav class="view-toggle" aria-label="Primary">
      <!-- <button id="quickBtn" aria-pressed="false" aria-label="Toggle results list">Quick List</button> -->
      <button id="filterBtn" aria-pressed="false" aria-label="Open filters panel">
        <svg class="icon-search" width="30" height="30" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
          <circle cx="11" cy="11" r="8"></circle>
          <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
        </svg>
        <span id="resultCount" aria-live="polite" style="display:none"></span>
      </button>
      <div class="mode-toggle">
        <button id="recents-button" aria-pressed="false" aria-label="Recents">
          <span class="mode-icon" aria-hidden="true">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <circle cx="12" cy="12" r="10"></circle>
              <polyline points="12 6 12 12 16 14"></polyline>
            </svg>
          </span>
          <span class="mode-label">Recents</span>
        </button>
        <button id="posts-button" aria-pressed="false" aria-label="Posts">
          <span class="mode-icon" aria-hidden="true">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <line x1="5" y1="6" x2="19" y2="6"></line>
              <line x1="5" y1="12" x2="19" y2="12"></line>
              <line x1="5" y1="18" x2="13" y2="18"></line>
            </svg>
          </span>
          <span class="mode-label">Posts</span>
        </button>
        <button id="map-button" aria-pressed="true" aria-label="Map">
          <span class="mode-icon" aria-hidden="true">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M12 21s-6-4.5-6-10a6 6 0 1112 0c0 5.5-6 10-6 10z"></path>
              <circle cx="12" cy="11" r="2.5"></circle>
            </svg>
          </span>
          <span class="mode-label">Map</span>
        </button>
      </div>
    </nav>
    <div class="header-buttons">
      <button id="memberBtn" type="button" aria-pressed="false" aria-label="Open members area">
        <svg viewBox="0 0 24 24" width="24" height="24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
          <path stroke-linecap="round" stroke-linejoin="round" d="M15.75 18.75a6 6 0 00-7.5 0"/>
          <path stroke-linecap="round" stroke-linejoin="round" d="M12 15a3 3 0 100-6 3 3 0 000 6z"/>
          <path stroke-linecap="round" stroke-linejoin="round" d="M12 3.75a8.25 8.25 0 100 16.5 8.25 8.25 0 000-16.5z"/>
        </svg>
      </button>
      <button id="adminBtn" type="button" aria-pressed="false" aria-label="Open admin area">
        <svg viewBox="0 0 24 24" width="24" height="24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
          <circle cx="12" cy="12" r="3"/>
          <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82 2 2 0 1 1-2.83 2.83 1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51 2 2 0 1 1-4 0 1.65 1.65 0 0 0-1-1.51 1.65 1.65 0 0 0-1.82.33 2 2 0 1 1-2.83-2.83 1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1A2 2 0 1 1 4 9a1.65 1.65 0 0 0 1.51-1 1.65 1.65 0 0 0-.33-1.82A2 2 0 1 1 8.01 3.35a1.65 1.65 0 0 0 1.82-.33 1.65 1.65 0 0 0 1-1.51A2 2 0 1 1 14 3a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33A2 2 0 1 1 19.65 8a1.65 1.65 0 0 0-.33 1.82 1.65 1.65 0 0 0 1.51 1A2 2 0 1 1 21 15a1.65 1.65 0 0 0-1.51 1z"/>
        </svg>
      </button>
      <button id="fullscreenBtn" type="button" class="fullscreen-btn" aria-label="Toggle fullscreen">⛶</button>
    </div>
  </header>
  

  <section class="map-area" aria-label="Map">
    <div class="map-control-row map-controls-map">
      <div id="geocoder-map" class="geocoder"></div>
      <div id="geolocate-map" class="geolocate-btn"></div>
      <div id="compass-map" class="compass-btn"></div>
    </div>
    <div class="map-zoom-indicator" id="mapZoomIndicator" aria-live="polite">Zoom -- • Pitch --</div>
    <div id="map"></div>
  </section>

  <div class="post-mode-background"></div>
  <div class="post-mode-boards">
    <!-- <section class="quick-list-board" id="results" aria-label="Quick List Board"></section> -->
    <section class="recents-board quick-list-board" id="recentsBoard" aria-label="Recents Board" data-side="left" aria-hidden="true" style="display:none;">
    </section>
    <section class="post-board" aria-label="Post Board" data-side="left" aria-hidden="true" style="display:none;">
    </section>
    <section class="ad-board" aria-label="Ad Board" data-side="right" aria-hidden="true" style="display:none;">
      <div class="ad-panel">
      </div>
    </section>
  </div>

  <div id="filterPanel" class="panel" role="dialog" aria-panel="true" aria-hidden="true">
    <div class="panel-content" style="top:calc(var(--header-h) + var(--safe-top));left:0;">
      <div class="panel-header">
        <div id="filterSummary" class="filter-summary"></div>
      </div>
      <div class="panel-body">
        <div class="map-control-row map-controls-filter">
          <div id="geocoder-filter" class="geocoder"></div>
          <div id="geolocate-filter" class="geolocate-btn"></div>
          <div id="compass-filter" class="compass-btn"></div>
        </div>
        <div class="reset-box">
          <div id="resetBtn" class="btn" role="button" aria-label="Reset all filters">
            Reset All Filters
          </div>
        </div>
        <div class="reset-box">
          <div id="resetCategoriesBtn" class="btn" role="button" aria-label="Reset all categories">
            Reset All Categories
          </div>
        </div>
        <div class="field sort-field">
          <div class="options-dropdown">
            <button id="optionsBtn" aria-haspopup="true" aria-expanded="false">Sort by Title A-Z</button>
            <div id="optionsMenu" class="options-menu" hidden>
              <button id="favToggle" aria-pressed="false">Favourites on top<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M12 17.3 6.2 21l1.6-6.7L2 9.3l6.9-.6L12 2l3.1 6.7 6.9.6-5.8 4.9L17.8 21 12 17.3z"/></svg></button>
              <div class="sort-options" role="group" aria-label="Sort order" style="display:flex; flex-direction:column; gap:6px;">
                <button class="sort-option" data-sort="az" aria-pressed="true">Sort by Title A-Z</button>
                <button class="sort-option" data-sort="nearest" aria-pressed="false">Sort by Closest</button>
                <button class="sort-option" data-sort="soon" aria-pressed="false">Sort by Soonest</button>
              </div>
            </div>
          </div>
        </div>
        <section aria-label="Filters">
          <div class="filter-basics-container">
            <div class="field keyword-row">
              <div class="input"><input id="keyword-textbox" type="text" placeholder="Keywords" aria-label="Keywords" />
                <div class="keyword-clear-button" role="button" aria-label="Clear keywords">X</div>
              </div>
            </div>
            <div class="field price-range-row">
              <div class="input">
                <input id="min-price-input" type="text" inputmode="numeric" pattern="[0-9]*" placeholder="Min price" aria-label="Minimum price" />
                <span class="price-separator" aria-hidden="true">-</span>
                <input id="max-price-input" type="text" inputmode="numeric" pattern="[0-9]*" placeholder="Max price" aria-label="Maximum price" />
                <div class="price-clear-button" role="button" aria-label="Clear price range">X</div>
              </div>
            </div>
            <div class="field daterange-row">
              <div class="input"><input id="daterange-textbox" type="text" aria-label="Date range" placeholder="Date Range" readonly aria-haspopup="dialog" aria-expanded="false" aria-controls="datePickerContainer" />
                <div class="daterange-clear-button" role="button" aria-label="Clear date">X</div>
              </div>
            </div>
            <div class="field expired-row">
              <span class="expired-text">Show Expired Events</span>
              <label class="switch">
                <input id="expiredToggle" type="checkbox" />
                <span class="slider"></span>
              </label>
            </div>
            <div id="datePickerContainer" class="calendar-container" aria-hidden="true">
              <div id="datePicker"></div>
            </div>
          </div>
          <div class="filter-category-container">
            <div class="cats" id="cats" aria-label="Categories"></div>
          </div>
        </section>
      </div>
    </div>
  </div>

  <div id="memberPanel" class="panel" role="dialog" aria-panel="true" aria-hidden="true">
    <div class="panel-content" style="right:0;">
      <div class="panel-header">
        <div class="header-top">
          <h2>Create Post</h2>
          <div class="panel-actions">
            <button type="button" class="save-changes primary-action">Save</button>
            <button type="button" class="discard-changes" disabled>Discard Changes</button>
            <button type="button" class="close-panel">Close</button>
          </div>
        </div>
      </div>
      <form id="memberForm" class="panel-body">
        <div class="map-control-row map-controls-member">
          <div id="geocoder-member" class="geocoder"></div>
          <div id="geolocate-member" class="geolocate-btn"></div>
          <div id="compass-member" class="compass-btn"></div>
        </div>
        <div class="panel-field">
          <label for="mTitle">Title</label>
          <input type="text" id="mTitle" required />
        </div>
        <div class="panel-field">
          <label for="mImage">Image</label>
          <input type="file" id="mImage" accept="image/*" />
        </div>
        <div class="panel-field">
          <label for="mDate">Date</label>
          <input type="date" id="mDate" />
        </div>
        <div class="panel-field">
          <label for="mColor">Color</label>
          <input type="color" id="mColor" data-mode="hex" value="#000000" />
        </div>
      </form>
    </div>
  </div>

  <div id="adminPanel" class="panel" role="dialog" aria-panel="true" aria-hidden="true">
    <div class="panel-content" style="top:calc(var(--header-h) + var(--safe-top));right:0;">
      <div class="panel-header">
        <div class="header-top">
          <h2 class="title">Admin</h2>
          <div class="panel-actions">
            <button type="button" class="save-changes primary-action">Save</button>
            <button type="button" class="discard-changes" disabled>Discard Changes</button>
            <button type="button" class="close-panel">Close</button>
          </div>
        </div>
        <div class="tab-bar">
          <button type="button" class="tab-btn" data-tab="map" aria-selected="true">Map</button>
          <button type="button" class="tab-btn" data-tab="settings">Settings</button>
          <button type="button" class="tab-btn" data-tab="forms">Forms</button>
        </div>
      </div>
      <form id="adminForm" class="panel-body">
        <div id="tab-map" class="tab-panel active">
          <div class="map-spin-container">
            <div class="panel-field">
              <div class="option-label">
                <span>Spin on Load</span>
                <label class="switch">
                  <input type="checkbox" id="spinLoadStart" />
                  <span class="slider"></span>
                </label>
              </div>
              <div id="spinType" class="option-group">
                <label class="option-label"><span>Everyone</span><input type="radio" name="spinType" value="all" /></label>
                <label class="option-label"><span>New Users</span><input type="radio" name="spinType" value="new" /></label>
              </div>
            </div>
            <div class="panel-field">
              <div class="option-label">
                <span>Spin on Logo</span>
                <label class="switch">
                  <input type="checkbox" id="spinLogoClick" checked />
                  <span class="slider"></span>
                </label>
              </div>
          </div>
        </div>
        <div id="map-balloon-container" class="map-balloon-container">
          <style>
              #map-balloon-container .t{font-size:16px;font-weight:bold;}
              #map-balloon-container .shape-dropdown{position:relative;width:100%;max-width:100%;height:35px;margin-bottom:8px;}
              #map-balloon-container .shape-dropdown > button{width:100%;height:35px;background:var(--btn);border:1px solid var(--btn);border-radius:var(--dropdown-radius);text-align:left;padding:0;}
              #map-balloon-container .shape-menu{position:absolute;top:calc(100% + 4px);left:0;width:100%;max-height:400px;overflow-y:auto;overflow-y:overlay;background:var(--dropdown-bg);border:1px solid var(--border);border-radius:var(--dropdown-radius);padding:10px;display:flex;flex-direction:column;gap:6px;z-index:30;}
              #map-balloon-container .shape-menu[hidden]{display:none;}
              #map-balloon-container .shape-button{width:100%;height:35px;background:var(--btn);border:1px solid var(--btn);border-radius:var(--dropdown-radius);text-align:left;display:flex;align-items:center;gap:4px;padding:4px;cursor:pointer;}
              #map-balloon-container .shape-button svg{width:24px;height:24px;vertical-align:middle;}
              #map-balloon-container .shape-button.active{outline:2px solid var(--border);}
              #map-balloon-container .panel-field{width:100%;max-width:100%;}
              #map-balloon-container #copySvgCode{width:100%;height:35px;padding:0;margin-bottom:8px;}
              #map-balloon-container #shapeMenuBtn{padding:0;}
              #map-balloon-container #balloonGrid{display:grid;grid-template-columns: repeat(auto-fill, minmax(32px, 1fr)); gap:4px;overflow-x:auto;margin-bottom:8px;}
              #map-balloon-container #balloonGrid svg{cursor:pointer;}
              #map-balloon-container #balloonSvgCode{width:100%;max-width:100%;min-height:200px;}
            </style>
            <div class="t">Balloon Icon Generator</div>
            <div class="shape-dropdown">
              <button type="button" id="shapeMenuBtn" aria-expanded="false">Select Shape</button>
              <div class="shape-menu" id="balloonShapeButtons" hidden></div>
            </div>
            <div class="panel-field size-control">
              <label for="balloonSize">Balloon size</label>
              <div class="range-wrap">
                <input type="range" id="balloonSize" min="40" max="120" value="40" />
                <span id="balloonSizeValue">40</span>px
              </div>
            </div>
            <button type="button" id="copySvgCode">Copy SVG</button>
            <div id="balloonGrid"></div>
            <textarea id="balloonSvgCode"></textarea>
          </div>
        </div>
        <div id="tab-settings" class="tab-panel">
        <div id="post-mode-background-field" class="panel-field">
          <label for="postModeBgColor">Post Mode Background</label>
          <div class="settings-style-container">
            <div id="post-mode-background-row">
              <input type="color" id="postModeBgColor">
              <input type="range" id="postModeBgOpacity" min="0" max="1" step="0.01">
              <span id="postModeBgOpacityVal">0.00</span>
            </div>
          </div>
        </div>
        <div class="settings-welcome-container">
          <div id="welcome-message-panel" class="panel-field">
            <label for="welcomeMessageEditor">Welcome Message</label>
            <div class="wysiwyg-toolbar">
              <button type="button" data-command="bold"><b>B</b></button>
              <button type="button" data-command="italic"><i>I</i></button>
              <button type="button" data-command="underline"><u>U</u></button>
            </div>
            <div id="welcomeMessageEditor" class="wysiwyg" contenteditable="true" data-placeholder='<p>Welcome to Funmap! Choose an area on the map to search for events and listings. Click the <svg class="icon-search" width="30" height="30" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" role="img" aria-label="Filters"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg> button to refine your search.</p>'></div>
            <textarea id="welcomeMessage" hidden></textarea>
          </div>
        </div>
        </div>
        <div id="tab-forms" class="tab-panel">
          <div class="formbuilder-container">
            <div class="formbuilder-actions">
              <button type="button" id="formbuilderAddCategory" class="formbuilder-add-category-btn">Add Category</button>
            </div>
            <div class="cats" id="formbuilderCats" aria-label="Categories"></div>
          </div>
          <style>
            #tab-forms .category-form-menu{
              margin-bottom:12px;
              border:1px solid var(--border);
              border-radius:12px;
              background:rgba(0,0,0,0.35);
              overflow:hidden;
              transition:border-color .2s,background .2s,opacity .2s;
              will-change:transform;
            }
            #tab-forms .category-form-menu:last-child{
              margin-bottom:0;
            }
            #tab-forms .category-form-menu .filter-category-header{
              display:flex;
              align-items:center;
              justify-content:space-between;
              gap:12px;
              padding:12px;
            }
            #tab-forms .category-form-menu .filter-category-trigger{
              min-width:0;
            }
            #tab-forms .category-form-menu .filter-category-trigger-wrap{
              flex:1;
            }
            #tab-forms .category-form-menu.cat-off{
              opacity:0.5;
            }
            #tab-forms .category-drag-handle,
            #tab-forms .subcategory-drag-handle{
              border:none;
              background:rgba(255,255,255,0.1);
              color:var(--button-text);
              width:34px;
              height:34px;
              border-radius:8px;
              display:flex;
              align-items:center;
              justify-content:center;
              cursor:grab;
              flex:0 0 auto;
              transition:background .2s, color .2s;
            }
            #tab-forms .category-drag-handle:hover,
            #tab-forms .subcategory-drag-handle:hover{
              background:rgba(255,255,255,0.18);
            }
            #tab-forms .category-drag-handle:active,
            #tab-forms .subcategory-drag-handle:active{
              cursor:grabbing;
            }
            #tab-forms .category-drag-handle:focus-visible,
            #tab-forms .subcategory-drag-handle:focus-visible{
              outline:2px solid var(--btn-hover, #2e3a72);
              outline-offset:2px;
            }
            #tab-forms .drag-handle-icon{
              pointer-events:none;
              font-size:18px;
              line-height:1;
            }
            #tab-forms .category-form-menu.is-dragging,
            #tab-forms .subcategory-form-menu.is-dragging{
              opacity:0.65;
            }
            #tab-forms .category-form-menu.drag-target-before{
              box-shadow:0 -2px 0 var(--btn-hover, #2e3a72);
            }
            #tab-forms .category-form-menu.drag-target-after{
              box-shadow:0 2px 0 var(--btn-hover, #2e3a72);
            }
            #tab-forms .subcategory-form-menu.drag-target-before{
              box-shadow:0 -2px 0 var(--btn-hover, #2e3a72);
            }
            #tab-forms .subcategory-form-menu.drag-target-after{
              box-shadow:0 2px 0 var(--btn-hover, #2e3a72);
            }
            #tab-forms .category-form-content{
              border-top:1px solid var(--border);
              padding:16px;
              display:flex;
              flex-direction:column;
              gap:16px;
              background:rgba(0,0,0,0.25);
            }
            #tab-forms .category-form-content[hidden]{
              display:none;
            }
            #tab-forms .formbuilder-actions{
              margin-bottom:12px;
            }
            #tab-forms .category-edit-menu{
              display:flex;
              flex-direction:column;
              gap:12px;
            }
            #tab-forms .category-edit-trigger-wrap{
              width:100%;
            }
            #tab-forms .formbuilder-add-category-btn,
            #tab-forms .category-edit-trigger,
            #tab-forms .add-subcategory-btn{
              width:100%;
              height:40px;
              border-radius:8px;
              border:1px solid var(--btn);
              background:var(--btn);
              color:var(--button-text);
              font-weight:600;
              display:flex;
              align-items:center;
              justify-content:center;
              gap:8px;
              cursor:pointer;
              transition:background .2s,border-color .2s,color .2s;
            }
            #tab-forms .formbuilder-add-category-btn:hover,
            #tab-forms .category-edit-trigger:hover,
            #tab-forms .add-subcategory-btn:hover{
              background:var(--btn-hover, #2e3a72);
              border-color:var(--btn-hover, #2e3a72);
            }
            #tab-forms .category-edit-panel{
              border:1px solid var(--border);
              border-radius:12px;
              padding:16px;
              background:rgba(0,0,0,0.25);
              display:flex;
              flex-direction:column;
              gap:12px;
              max-width:100%;
            }
            #tab-forms .category-edit-panel[hidden]{
              display:none;
            }
            #tab-forms .category-name-input{
              width:300px;
              max-width:100%;
              height:36px;
              border-radius:8px;
              border:1px solid var(--border);
              background:rgba(0,0,0,0.35);
              color:var(--button-text);
              padding:0 12px;
            }
            #tab-forms .iconpicker-container{
              display:flex;
              align-items:center;
              gap:16px;
              flex-wrap:wrap;
            }
            #tab-forms .iconpicker-upload{
              position:relative;
              display:inline-flex;
              align-items:center;
              justify-content:center;
              gap:8px;
              padding:8px 16px;
              border-radius:8px;
              background:var(--btn);
              border:1px solid var(--btn);
              color:var(--button-text);
              font-weight:600;
              cursor:pointer;
              transition:background .2s,border-color .2s,color .2s;
            }
            #tab-forms .iconpicker-upload:hover{
              background:var(--btn-hover, #2e3a72);
              border-color:var(--btn-hover, #2e3a72);
            }
            #tab-forms .iconpicker-upload input[type="file"]{
              position:absolute;
              inset:0;
              opacity:0;
              cursor:pointer;
            }
            #tab-forms .iconpicker-preview{
              width:64px;
              height:64px;
              border:1px dashed var(--border);
              border-radius:8px;
              display:flex;
              align-items:center;
              justify-content:center;
              background:rgba(0,0,0,0.35);
              color:var(--muted);
              font-size:12px;
              text-align:center;
              padding:6px;
              box-sizing:border-box;
            }
            #tab-forms .iconpicker-preview img{
              max-width:100%;
              max-height:100%;
              display:none;
            }
            #tab-forms .iconpicker-preview.has-image{
              color:transparent;
            }
            #tab-forms .iconpicker-preview.has-image img{
              display:block;
            }
            #tab-forms .subcategory-form-menus{
              display:flex;
              flex-direction:column;
              gap:10px;
            }
            #tab-forms .subcategory-form-menu{
              border:1px solid var(--border);
              border-radius:10px;
              background:rgba(0,0,0,0.2);
              overflow:hidden;
              transition:border-color .2s,background .2s,opacity .2s;
              will-change:transform;
            }
            #tab-forms .subcategory-form-menu.subcategory-off{
              opacity:0.5;
            }
            #tab-forms .delete-category-btn,
            #tab-forms .delete-subcategory-btn{
              display:flex;
              align-items:center;
              justify-content:center;
              padding:10px 16px;
              border-radius:8px;
              border:1px solid #a42828;
              background:#b83030;
              color:#fff;
              font-weight:600;
              cursor:pointer;
              transition:background .2s,border-color .2s,color .2s;
              width:100%;
            }
            #tab-forms .delete-category-btn:hover,
            #tab-forms .delete-subcategory-btn:hover{
              background:#d13c3c;
              border-color:#d13c3c;
            }
            #tab-forms .category-edit-panel .delete-category-btn,
            #tab-forms .subcategory-form-content .delete-subcategory-btn{
              margin-top:12px;
            }
            #tab-forms .subcategory-form-header{
              display:flex;
              align-items:center;
              justify-content:space-between;
              gap:12px;
              padding:10px 12px;
            }
            #tab-forms .subcategory-trigger-wrap{
              flex:1;
            }
            #tab-forms .subcategory-form-trigger{
              width:100%;
              border:none;
              background:none;
              color:inherit;
              font:inherit;
              display:flex;
              align-items:center;
              justify-content:space-between;
              gap:10px;
              cursor:pointer;
            }
            #tab-forms .subcategory-label-wrap{
              display:flex;
              align-items:center;
              gap:8px;
            }
            #tab-forms .subcategory-logo{
              width:28px;
              height:28px;
              border-radius:50%;
              background:rgba(255,255,255,0.08);
              display:flex;
              align-items:center;
              justify-content:center;
              font-weight:700;
              text-transform:uppercase;
              font-size:12px;
            }
            #tab-forms .subcategory-logo svg{
              width:20px;
              height:20px;
            }
            #tab-forms .subcategory-logo.has-icon{
              background:transparent;
            }
            #tab-forms .subcategory-logo.has-icon svg{
              width:24px;
              height:24px;
            }
            #tab-forms .subcategory-form-toggle{
              position:relative;
              display:flex;
              align-items:center;
              justify-content:flex-end;
              width:38px;
              height:36px;
              flex:0 0 38px;
              cursor:pointer;
              align-self:flex-start;
            }
            #tab-forms .subcategory-form-toggle input{
              opacity:0;
              width:0;
              height:0;
            }
            #tab-forms .subcategory-form-toggle .slider{
              position:absolute;
              top:8px;
              left:0;
              right:0;
              margin:0 auto;
              width:38px;
              height:20px;
              border-radius:16px;
              background:var(--btn);
              border:1px solid var(--btn);
              transition:.2s;
            }
            #tab-forms .subcategory-form-toggle .slider:before{
              content:'';
              position:absolute;
              width:16px;
              height:16px;
              left:1px;
              top:1px;
              border-radius:50%;
              background:var(--button-text);
              transition:.2s;
            }
            #tab-forms .subcategory-form-toggle input:checked + .slider{
              background:var(--category-switch-active);
              border-color:var(--category-switch-active);
            }
            #tab-forms .subcategory-form-toggle input:checked + .slider:before{
              transform:translateX(18px);
            }
            #tab-forms .subcategory-form-content{
              border-top:1px solid var(--border);
              padding:12px 16px;
              background:rgba(0,0,0,0.25);
              display:flex;
              flex-direction:column;
              gap:12px;
            }
            #tab-forms .subcategory-form-content[hidden]{
              display:none;
            }
            #tab-forms .subcategory-name-input{
              width:260px;
              max-width:100%;
              height:36px;
              border-radius:8px;
              border:1px solid var(--border);
              background:rgba(0,0,0,0.35);
              color:var(--button-text);
              padding:0 12px;
            }
            #tab-forms .subcategory-form-placeholder{
              margin:0;
              font-size:14px;
              color:var(--muted);
            }
            #tab-forms .add-subcategory-btn{
              padding:0 16px;
            }
            #tab-forms .subcategory-drop-anchor{
              width:100%;
              height:0;
              margin:0;
              padding:0;
              pointer-events:none;
              visibility:hidden;
              display:none;
            }
          </style>
          <div id="formsControls">
            <div id="formsCategories"></div>
          </div>
        </div>
      </form>
  </div>
  </div>

  <div id="adminUnsavedPrompt" class="admin-unsaved-prompt" aria-hidden="true">
    <div class="admin-unsaved-dialog" role="dialog" aria-modal="true" aria-labelledby="adminUnsavedTitle">
      <h3 id="adminUnsavedTitle">Unsaved Changes</h3>
      <p>You have unsaved changes. Save before closing the admin panel?</p>
      <div class="admin-unsaved-actions">
        <button type="button" class="confirm-save primary-action">Save</button>
        <button type="button" class="confirm-discard" disabled>Discard Changes</button>
      </div>
    </div>
  </div>

  <div id="adminStatusMessage" role="status" aria-live="polite" aria-hidden="true"></div>

  <div id="memberUnsavedPrompt" class="member-unsaved-prompt" aria-hidden="true">
    <div class="member-unsaved-dialog" role="dialog" aria-modal="true" aria-labelledby="memberUnsavedTitle">
      <h3 id="memberUnsavedTitle">Unsaved Changes</h3>
      <p>You have unsaved changes. Save before closing the member panel?</p>
      <div class="member-unsaved-actions">
        <button type="button" class="confirm-save primary-action">Save</button>
        <button type="button" class="confirm-discard" disabled>Discard Changes</button>
      </div>
    </div>
  </div>

  <div id="memberStatusMessage" role="status" aria-live="polite" aria-hidden="true"></div>

  <script>
    // Remember where the user actually clicked/tapped
    document.addEventListener('pointerdown', (e) => {
      window.__lastPointerDown = e;
    }, { capture: true });
  </script>

  <div id="welcome-modal" class="modal" role="dialog" aria-modal="true" aria-hidden="true">
    <!-- Welcome modal content (not a panel) -->
    <div class="modal-content">
      <div class="panel-body" id="welcomeBody">
        <img class="welcome-logo" src="https://raw.githubusercontent.com/Zxen1/Events-Platform/refs/heads/main/assets/funmap-logo-big.png" alt="FunMap logo" />
        <div class="map-control-row map-controls-welcome">
          <div id="geocoder-welcome" class="geocoder"></div>
          <div id="geolocate-welcome" class="geolocate-btn"></div>
          <div id="compass-welcome" class="compass-btn"></div>
        </div>
        <div id="welcomeMessageBox"></div>
        <img class="welcome-illustration" src="assets/monkeys/Firefly_cute-little-monkey-in-red-cape-with-arms-outstretched-in-welcome-609041-600.png" alt="Friendly monkey mascot welcoming visitors" />
      </div>
    </div>
  </div>

  <script>
  async function ensureMapboxCssFor(container) {
    const ver = (window.MAPBOX_VERSION || "v3.15.0").replace(/^v/,'v');
    const cssHref = `https://api.mapbox.com/mapbox-gl-js/${ver}/mapbox-gl.css`;

    const doc = (container && container.ownerDocument) || document;
    const root = container && container.getRootNode && container.getRootNode();

    // For Shadow DOM maps, inject right into the shadow root
    if (root && root.host && typeof ShadowRoot !== "undefined" && root instanceof ShadowRoot) {
      if (!root.querySelector('style[data-mapbox-gl]')) {
        const s = document.createElement('style');
        s.setAttribute('data-mapbox-gl','');
        s.textContent = `@import url('${cssHref}');`;
        root.prepend(s);
      }
      return;
    }

    // Normal document (or iframe document)
    let link = doc.getElementById('mapbox-gl-css');
    if (!link) {
      link = doc.createElement('link');
      link.id = 'mapbox-gl-css';
      link.rel = 'stylesheet';
      link.href = cssHref;
      doc.head.appendChild(link);
    }
    if (link.sheet) return;
    await new Promise(res => link.addEventListener('load', res, { once: true }));
  }

  (async () => {
    try {
      await ensureMapboxCssFor(document.body);
    } catch(e){}
  })();

  (function(){
    const q = [];
    let scheduled = false;
    function flush(){
      scheduled = false;
      const budget = 6;
      let start = performance.now();
      while(q.length){
        const fn = q.shift();
        try{ fn && fn(); }catch(err){ console.error(err); }
        if(performance.now() - start > budget){
          if(typeof requestAnimationFrame === 'function'){
            requestAnimationFrame(flush);
          } else {
            setTimeout(flush, 16);
          }
          return;
        }
      }
    }
    window.deferToAnimationFrame = function(cb){
      q.push(cb);
      if(!scheduled){
        scheduled = true;
        if(typeof requestAnimationFrame === 'function'){
          requestAnimationFrame(flush);
        } else {
          setTimeout(flush, 16);
        }
      }
    };
  })();

  // Helper: do nothing until style is truly loaded
  function whenStyleReady(map, fn){
    if (map.isStyleLoaded && map.isStyleLoaded()) { fn(); return; }
    const onLoad = () => { map.off('load', onLoad); fn(); };
    map.on('load', onLoad);
  }

  function applyNightSky(mapInstance){
    if(!mapInstance) return;
    if(typeof mapInstance.setFog === 'function'){
      try {
        mapInstance.setFog({
          color: 'rgba(11,13,23,0.6)',
          'high-color': 'rgba(27,32,53,0.7)',
          'horizon-blend': 0.15,
          'space-color': '#010409',
          'star-intensity': 0.6
        });
      } catch(err){}
    }
    if(typeof mapInstance.getLayer !== 'function'){
      return;
    }
    let skyLayerId = null;
    const skyPaint = {
      'sky-type': 'gradient',
      'sky-gradient-center': [0, 0],
      'sky-gradient-radius': 80,
      'sky-gradient': [
        'interpolate',
        ['linear'],
        ['sky-radial-progress'],
        0.0, 'rgba(6,10,20,1)',
        0.6, '#0b1d51',
        1.0, '#1a2a6c'
      ],
      'sky-opacity': 1
    };
    try {
      if(mapInstance.getLayer('sky')){
        skyLayerId = 'sky';
      } else if(mapInstance.getLayer('night-sky')){
        skyLayerId = 'night-sky';
      } else if(typeof mapInstance.addLayer === 'function'){
        mapInstance.addLayer({
          id:'night-sky',
          type:'sky',
          paint: skyPaint
        });
        skyLayerId = 'night-sky';
      }
    } catch(err){
      if(!skyLayerId && typeof mapInstance.getLayer === 'function' && mapInstance.getLayer('sky')){
        skyLayerId = 'sky';
      }
    }
    if(!skyLayerId || typeof mapInstance.setPaintProperty !== 'function'){
      return;
    }
    Object.entries(skyPaint).forEach(([prop, value]) => {
      try { mapInstance.setPaintProperty(skyLayerId, prop, value); } catch(err){}
    });
  }

  function createTransparentPlaceholder(width, height){
    const canvas = document.createElement('canvas');
    const w = Math.max(1, Number.isFinite(width) ? width : (width || 2));
    const h = Math.max(1, Number.isFinite(height) ? height : (Number.isFinite(width) ? width : (width || 2)));
    canvas.width = w;
    canvas.height = h;
    const ctx = canvas.getContext('2d');
    if(ctx){
      ctx.clearRect(0, 0, w, h);
    }
    return canvas;
  }

  function ensurePlaceholderSprites(mapInstance){
    if(!mapInstance || typeof mapInstance.addImage !== 'function') return;
    const required = ['mx-federal-5','background','background-stroke','icon','icon-stroke'];
    const install = () => {
      required.forEach(name => {
        try{
          if(mapInstance.hasImage?.(name)) return;
          const size = name === 'mx-federal-5' ? 2 : 4;
          const options = { pixelRatio: 1 };
          if(name !== 'mx-federal-5'){
            options.sdf = true;
          }
          mapInstance.addImage(name, createTransparentPlaceholder(size), options);
        }catch(err){}
      });
    };
    if(typeof mapInstance.isStyleLoaded === 'function' && !mapInstance.isStyleLoaded()){
      if(!mapInstance.__placeholderSpriteReady){
        const onStyleLoad = () => {
          try{ install(); }catch(err){}
          try{ mapInstance.off?.('style.load', onStyleLoad); }catch(err){}
          mapInstance.__placeholderSpriteReady = null;
        };
        mapInstance.__placeholderSpriteReady = onStyleLoad;
        try{ mapInstance.on('style.load', onStyleLoad); }catch(err){}
      }
      return;
    }
    install();
  }

  const isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0) || (window.matchMedia && window.matchMedia('(pointer: coarse)').matches);
  const markerIconSize = 1;
  const markerIconBaseSizePx = 30;
  const markerLabelBackgroundWidthPx = 150;
  const markerLabelBackgroundHeightPx = 40;
  const markerLabelTextGapPx = 5;
  const markerLabelMarkerInsetPx = 5;
  const markerLabelTextRightPaddingPx = 5;
  const markerLabelTextPaddingPx = markerIconBaseSizePx * markerIconSize + markerLabelMarkerInsetPx + markerLabelTextGapPx;
  const markerLabelTextAreaWidthPx = Math.max(0, markerLabelBackgroundWidthPx - markerLabelTextPaddingPx - markerLabelTextRightPaddingPx);
  const markerLabelTextSize = 12;
  const markerLabelTextLineHeight = 1.2;
  const markerLabelBgTranslatePx = 0;
  const markerLabelEllipsisChar = '\u2026';
  const mapCardTitleWidthPx = 165;
  let markerLabelMeasureContext = null;
  const markerLabelCompositePlaceholderIds = new Set();

  function ensureMarkerLabelMeasureContext(){
    if(markerLabelMeasureContext){
      return markerLabelMeasureContext;
    }
    const canvas = document.createElement('canvas');
    markerLabelMeasureContext = canvas.getContext('2d');
    return markerLabelMeasureContext;
  }

  function markerLabelMeasureFont(){
    return `${markerLabelTextSize}px "Open Sans", "Arial Unicode MS Regular", sans-serif`;
  }

  function shortenMarkerLabelText(text, widthPx = markerLabelTextAreaWidthPx){
    const raw = (text ?? '').toString().trim();
    if(!raw){
      return '';
    }
    const ctx = ensureMarkerLabelMeasureContext();
    if(!ctx){
      return raw;
    }
    ctx.font = markerLabelMeasureFont();
    const maxWidth = widthPx;
    if(maxWidth <= 0){
      return raw;
    }
    if(ctx.measureText(raw).width <= maxWidth){
      return raw;
    }
    const ellipsis = markerLabelEllipsisChar;
    let low = 0;
    let high = raw.length;
    let best = ellipsis;
    while(low <= high){
      const mid = Math.floor((low + high) / 2);
      if(mid <= 0){
        high = mid - 1;
        continue;
      }
      const candidate = raw.slice(0, mid).trimEnd() + ellipsis;
      if(ctx.measureText(candidate).width <= maxWidth){
        best = candidate;
        low = mid + 1;
      } else {
        high = mid - 1;
      }
    }
    return best;
  }

  function splitTextAcrossLines(text, widthPx, maxLines){
    const normalized = (text ?? '').toString().replace(/\s+/g, ' ').trim();
    if(!normalized){
      return [];
    }
    if(!Number.isFinite(widthPx) || widthPx <= 0 || maxLines <= 0){
      return [normalized];
    }
    const ctx = ensureMarkerLabelMeasureContext();
    if(!ctx){
      return [normalized];
    }
    ctx.font = markerLabelMeasureFont();
    if(ctx.measureText(normalized).width <= widthPx){
      return [normalized];
    }
    const lines = [];
    let remaining = normalized;
    while(remaining && lines.length < maxLines){
      if(lines.length === maxLines - 1){
        lines.push(shortenMarkerLabelText(remaining, widthPx));
        break;
      }
      let low = 1;
      let high = remaining.length;
      let bestIndex = 0;
      while(low <= high){
        const mid = Math.floor((low + high) / 2);
        const candidate = remaining.slice(0, mid).trimEnd();
        if(!candidate){
          low = mid + 1;
          continue;
        }
        if(ctx.measureText(candidate).width <= widthPx){
          bestIndex = mid;
          low = mid + 1;
        } else {
          high = mid - 1;
        }
      }
      let line = remaining.slice(0, bestIndex).trimEnd();
      const leftoverRaw = remaining.slice(bestIndex);
      const leftoverHadLeadingWhitespace = /^\s/.test(leftoverRaw);
      let leftover = leftoverRaw.trimStart();
      if(leftover){
        const lastSpace = line.lastIndexOf(' ');
        if(lastSpace > 0){
          const candidate = line.slice(0, lastSpace).trimEnd();
          const movedBase = line.slice(lastSpace + 1);
          const moved = (leftoverHadLeadingWhitespace ? `${movedBase} ${leftover}` : `${movedBase}${leftover}`).trim();
          if(candidate && ctx.measureText(candidate).width <= widthPx){
            line = candidate;
            leftover = moved;
          }
        }
      }
      if(!line){
        lines.push(shortenMarkerLabelText(remaining, widthPx));
        break;
      }
      lines.push(line);
      remaining = leftover;
      if(remaining && ctx.measureText(remaining).width <= widthPx && lines.length < maxLines){
        lines.push(remaining);
        break;
      }
    }
    return lines;
  }

  function getPrimaryVenueName(p){
    if(!p) return '';
    const activeKey = typeof selectedVenueKey === 'string' && selectedVenueKey ? selectedVenueKey : null;
    if(activeKey && Array.isArray(p.locations) && p.locations.length){
      const match = p.locations.find(loc => loc && toVenueCoordKey(loc.lng, loc.lat) === activeKey && loc.venue);
      if(match && match.venue){
        return match.venue;
      }
    }
    const loc = Array.isArray(p.locations) && p.locations.length ? p.locations[0] : null;
    if(loc && loc.venue){
      return loc.venue;
    }
    if(p.venue){
      return p.venue;
    }
    return p.city || '';
  }

  function getMarkerLabelLines(p){
    const title = p && p.title ? p.title : '';
    const markerTitleLines = splitTextAcrossLines(title, markerLabelTextAreaWidthPx, 2);
    while(markerTitleLines.length < 2){ markerTitleLines.push(''); }
    const cardTitleLines = splitTextAcrossLines(title, mapCardTitleWidthPx, 2);
    while(cardTitleLines.length < 2){ cardTitleLines.push(''); }
    const venueRaw = getPrimaryVenueName(p);
    return {
      line1: markerTitleLines[0] || '',
      line2: markerTitleLines[1] || '',
      cardTitleLines,
      venueLine: venueRaw ? shortenMarkerLabelText(venueRaw, mapCardTitleWidthPx) : ''
    };
  }

  function buildMarkerLabelText(p, overrideLines){
    const lines = overrideLines || getMarkerLabelLines(p);
    if(lines.line2){
      return `${lines.line1}\n${lines.line2}`;
    }
    return lines.line1;
  }

  const MARKER_LABEL_BG_ID = 'marker-label-bg';
  const MARKER_LABEL_BG_ACCENT_ID = `${MARKER_LABEL_BG_ID}--accent`;
  const MARKER_LABEL_COMPOSITE_PREFIX = 'marker-label-composite-';
  const MARKER_LABEL_COMPOSITE_ACCENT_SUFFIX = '--accent';
  const VISIBLE_MARKER_LABEL_LAYERS = ['marker-label', 'marker-label-highlight'];
  const markerLabelCompositeStore = new Map();
  const markerLabelCompositePending = new Map();
  let lastInViewMarkerLabelSpriteIds = new Set();
  // Mapbox GL JS enforces a hard limit on the number of images that can be
  // registered with a style (currently ~1000). Generating a composite sprite
  // for every single marker label without a cap quickly exhausts that budget,
  // which in turn causes Mapbox to render the fallback pill without any icon
  // or text. Each composite registers both a base pill and its accent variant,
  // so cap the composites to keep the total image count comfortably below the
  // platform ceiling.
  const MARKER_LABEL_COMPOSITE_LIMIT = 900;
  const MARKER_SPRITE_RETAIN_ZOOM = 12;
  let markerLabelPillImagePromise = null;

  function nowTimestamp(){
    try{
      if(typeof performance !== 'undefined' && typeof performance.now === 'function'){
        return performance.now();
      }
    }catch(err){}
    return Date.now();
  }

  function collectActiveCompositeEntries(mapInstance){
    const entries = [];
    if(!mapInstance) return entries;
    markerLabelCompositeStore.forEach((meta, spriteId) => {
      if(!meta || !meta.image) return;
      const compositeId = markerLabelCompositeId(spriteId);
      let present = false;
      if(typeof mapInstance.hasImage === 'function'){
        try{ present = !!mapInstance.hasImage(compositeId); }
        catch(err){ present = false; }
      }
      if(!present) return;
      entries.push({
        spriteId,
        compositeId,
        priority: Boolean(meta.priority),
        inView: Boolean(meta.inView),
        lastUsed: Number.isFinite(meta.lastUsed) ? meta.lastUsed : 0
      });
    });
    return entries;
  }

  function touchMarkerLabelCompositeMeta(spriteId, options = {}){
    if(!spriteId) return null;
    const opts = options || {};
    const meta = markerLabelCompositeStore.get(spriteId) || {};
    const shouldUpdateTime = opts.updateTimestamp !== false;
    if(shouldUpdateTime){
      const ts = Number.isFinite(opts.timestamp) ? opts.timestamp : nowTimestamp();
      meta.lastUsed = ts;
    } else if(!Number.isFinite(meta.lastUsed)){
      meta.lastUsed = 0;
    }
    if(opts.inView !== undefined){
      meta.inView = Boolean(opts.inView);
    }
    if(opts.priority !== undefined){
      meta.priority = Boolean(opts.priority);
    }
    markerLabelCompositeStore.set(spriteId, meta);
    return meta;
  }

  function refreshInViewMarkerLabelComposites(mapInstance){
    if(!mapInstance || typeof mapInstance.queryRenderedFeatures !== 'function'){
      return;
    }
    let features = [];
    const layersToQuery = Array.isArray(VISIBLE_MARKER_LABEL_LAYERS)
      ? VISIBLE_MARKER_LABEL_LAYERS.filter(layerId => {
          if(!layerId){
            return false;
          }
          if(typeof mapInstance.getLayer !== 'function'){
            return true;
          }
          try{
            return Boolean(mapInstance.getLayer(layerId));
          }catch(err){
            return false;
          }
        })
      : [];
    try{
      if(layersToQuery.length){
        features = mapInstance.queryRenderedFeatures({ layers: layersToQuery });
      }
    }catch(err){
      features = [];
    }
    const nextIds = new Set();
    const timestamp = nowTimestamp();
    features.forEach(feature => {
      if(!feature || !feature.properties) return;
      const rawSpriteId = feature.properties.labelSpriteId ?? feature.properties.spriteId;
      if(rawSpriteId === undefined || rawSpriteId === null) return;
      const spriteId = String(rawSpriteId);
      if(!spriteId) return;
      if(nextIds.has(spriteId)){
        touchMarkerLabelCompositeMeta(spriteId, { inView: true, updateTimestamp: false });
        return;
      }
      nextIds.add(spriteId);
      touchMarkerLabelCompositeMeta(spriteId, { inView: true, timestamp });
    });
    lastInViewMarkerLabelSpriteIds.forEach(spriteId => {
      if(nextIds.has(spriteId)) return;
      const meta = markerLabelCompositeStore.get(spriteId);
      if(!meta) return;
      meta.inView = false;
      markerLabelCompositeStore.set(spriteId, meta);
    });
    lastInViewMarkerLabelSpriteIds = nextIds;
  }

  function enforceMarkerLabelCompositeBudget(mapInstance, options = {}){
    if(!mapInstance || !MARKER_LABEL_COMPOSITE_LIMIT || MARKER_LABEL_COMPOSITE_LIMIT <= 0){
      return;
    }
    let zoomForBudget = NaN;
    if(typeof mapInstance.getZoom === 'function'){
      try{ zoomForBudget = mapInstance.getZoom(); }
      catch(err){ zoomForBudget = NaN; }
    }
    if(Number.isFinite(zoomForBudget) && zoomForBudget >= MARKER_SPRITE_RETAIN_ZOOM){
      mapInstance.__retainAllMarkerSprites = true;
    }
    if(mapInstance.__retainAllMarkerSprites){
      return;
    }
    if(typeof mapInstance.removeImage !== 'function'){
      return;
    }
    const { keep = [], reserve = 0 } = options || {};
    const keepList = Array.isArray(keep) ? keep : [keep];
    const keepSet = new Set(keepList.filter(Boolean));
    const entries = collectActiveCompositeEntries(mapInstance);
    if(!entries.length){
      return;
    }
    const effectiveLimit = Math.max(0, MARKER_LABEL_COMPOSITE_LIMIT - Math.max(0, reserve));
    if(entries.length <= effectiveLimit){
      return;
    }
    entries.forEach(entry => {
      entry.keep = keepSet.has(entry.spriteId);
    });
    entries.sort((a, b) => {
      if(a.keep !== b.keep){
        return a.keep ? -1 : 1;
      }
      if(a.inView !== b.inView){
        return a.inView ? -1 : 1;
      }
      if(a.priority !== b.priority){
        return a.priority ? -1 : 1;
      }
      return (b.lastUsed || 0) - (a.lastUsed || 0);
    });
    entries.slice(effectiveLimit).forEach(entry => {
      if(keepSet.has(entry.spriteId)) return;
      const meta = markerLabelCompositeStore.get(entry.spriteId);
      if(meta){
        if(meta.image){
          try{ delete meta.image; }catch(err){ meta.image = null; }
        }
        if(meta.options){
          try{ delete meta.options; }catch(err){ meta.options = undefined; }
        }
        if(meta.highlightImage){
          try{ delete meta.highlightImage; }catch(err){ meta.highlightImage = null; }
        }
        if(meta.highlightOptions){
          try{ delete meta.highlightOptions; }catch(err){ meta.highlightOptions = undefined; }
        }
        meta.inView = false;
        markerLabelCompositeStore.set(entry.spriteId, meta);
      }
      markerLabelCompositePending.delete(entry.spriteId);
      try{
        if(typeof mapInstance.hasImage === 'function'){
          if(mapInstance.hasImage(entry.compositeId)){
            mapInstance.removeImage(entry.compositeId);
          }
          const highlightId = `${entry.compositeId}${MARKER_LABEL_COMPOSITE_ACCENT_SUFFIX}`;
          if(mapInstance.hasImage(highlightId)){
            mapInstance.removeImage(highlightId);
          }
        }
      }catch(err){}
    });
  }

  function loadMarkerLabelImage(url){
    return new Promise((resolve, reject) => {
      if(!url){
        reject(new Error('Missing URL'));
        return;
      }
      const img = new Image();
      try{ img.crossOrigin = 'anonymous'; }catch(err){}
      img.decoding = 'async';
      img.onload = () => resolve(img);
      img.onerror = () => reject(new Error(`Failed to load ${url}`));
      img.src = url;
      if(img.complete){
        setTimeout(() => {
          if(img.naturalWidth > 0 && img.naturalHeight > 0){
            resolve(img);
          }
        }, 0);
      }
    });
  }

  async function ensureMarkerLabelPillImage(){
    if(markerLabelPillImagePromise){
      return markerLabelPillImagePromise;
    }
    const baseUrl = 'assets/icons-30/150x40-pill-70.webp';
    const accentUrl = 'assets/icons-30/150x40-pill-2f3b73.webp';
    const promise = Promise.all([
      loadMarkerLabelImage(baseUrl),
      loadMarkerLabelImage(accentUrl).catch(() => null)
    ]).then(([baseImg, accentImg]) => {
      if(!baseImg){
        return null;
      }
      return { base: baseImg, highlight: accentImg };
    }).catch(err => {
      console.error(err);
      return null;
    });
    markerLabelPillImagePromise = promise;
    promise.then(result => {
      if(!result){
        markerLabelPillImagePromise = null;
      }
    }).catch(() => {
      markerLabelPillImagePromise = null;
    });
    return markerLabelPillImagePromise;
  }

  function markerLabelCompositeId(spriteId){
    return `${MARKER_LABEL_COMPOSITE_PREFIX}${spriteId}`;
  }

  async function ensureMarkerLabelComposite(mapInstance, labelSpriteId, iconId, labelLine1, labelLine2, isMulti, options = {}){
    if(!mapInstance || !labelSpriteId){
      return null;
    }
    const { priority = false } = options || {};
    const compositeId = markerLabelCompositeId(labelSpriteId);
    const highlightId = `${compositeId}${MARKER_LABEL_COMPOSITE_ACCENT_SUFFIX}`;
    const meta = markerLabelCompositeStore.get(labelSpriteId) || {};
    meta.iconId = iconId || meta.iconId || '';
    meta.labelLine1 = labelLine1 ?? meta.labelLine1 ?? '';
    meta.labelLine2 = labelLine2 ?? meta.labelLine2 ?? '';
    meta.isMulti = Boolean(isMulti ?? meta.isMulti);
    meta.priority = Boolean(priority);
    meta.lastUsed = nowTimestamp();
    markerLabelCompositeStore.set(labelSpriteId, meta);
    if(mapInstance.hasImage?.(compositeId)){
      if(markerLabelCompositePlaceholderIds.has(compositeId)){
        try{ mapInstance.removeImage(compositeId); }catch(err){}
        markerLabelCompositePlaceholderIds.delete(compositeId);
      } else {
        return compositeId;
      }
    }
    if(markerLabelCompositePlaceholderIds.has(highlightId) && mapInstance.hasImage?.(highlightId)){
      try{ mapInstance.removeImage(highlightId); }catch(err){}
      markerLabelCompositePlaceholderIds.delete(highlightId);
    }
    if(meta.image && meta.highlightImage){
      try{
        enforceMarkerLabelCompositeBudget(mapInstance, { keep: [labelSpriteId], reserve: 1 });
        try{ if(mapInstance.hasImage?.(compositeId)) mapInstance.removeImage(compositeId); }catch(err){}
        mapInstance.addImage(compositeId, meta.image, meta.options || {});
        markerLabelCompositePlaceholderIds.delete(compositeId);
        if(meta.highlightImage){
          try{ if(mapInstance.hasImage?.(highlightId)) mapInstance.removeImage(highlightId); }catch(err){}
          try{ mapInstance.addImage(highlightId, meta.highlightImage, meta.highlightOptions || meta.options || {}); }
          catch(err){ console.error(err); }
          markerLabelCompositePlaceholderIds.delete(highlightId);
        }
        enforceMarkerLabelCompositeBudget(mapInstance, { keep: [labelSpriteId] });
        return compositeId;
      }catch(err){
        console.error(err);
      }
    }
    if(markerLabelCompositePending.has(labelSpriteId)){
      return markerLabelCompositePending.get(labelSpriteId);
    }
    const task = (async () => {
      const pillAssets = await ensureMarkerLabelPillImage();
      if(!pillAssets || !pillAssets.base){
        return null;
      }
      const pillImg = pillAssets.base;
      const pillAccentImg = pillAssets.highlight;
      const markerSources = window.subcategoryMarkers || {};
      const iconUrl = meta.iconId ? markerSources[meta.iconId] : null;
      let iconImg = null;
      if(iconUrl){
        try{
          iconImg = await loadMarkerLabelImage(iconUrl);
        }catch(err){
          console.error(err);
        }
      }
      const rawWidth = pillImg.naturalWidth || pillImg.width || markerLabelBackgroundWidthPx;
      const rawHeight = pillImg.naturalHeight || pillImg.height || markerLabelBackgroundHeightPx;
      const canvasWidth = Math.max(1, Math.round(Number.isFinite(rawWidth) && rawWidth > 0 ? rawWidth : markerLabelBackgroundWidthPx));
      const canvasHeight = Math.max(1, Math.round(Number.isFinite(rawHeight) && rawHeight > 0 ? rawHeight : markerLabelBackgroundHeightPx));
      const pixelRatio = canvasWidth / markerLabelBackgroundWidthPx;
      const labelLines = [];
      const line1 = (meta.labelLine1 || '').trim();
      const line2 = (meta.labelLine2 || '').trim();
      if(line1){
        labelLines.push({ text: line1, color: '#ffffff' });
      }
      if(line2){
        labelLines.push({ text: line2, color: meta.isMulti ? '#d0d0d0' : '#ffffff' });
      }
      const drawForeground = (ctx)=>{
        if(!ctx){
          return;
        }
        try{
          ctx.imageSmoothingEnabled = true;
          if('imageSmoothingQuality' in ctx){
            ctx.imageSmoothingQuality = 'high';
          }
        }catch(err){}
        if(iconImg){
          const iconSizePx = markerIconBaseSizePx * markerIconSize * pixelRatio;
          const destX = Math.round(markerLabelMarkerInsetPx * pixelRatio);
          const destY = Math.round((canvasHeight - iconSizePx) / 2);
          try{
            ctx.drawImage(iconImg, destX, destY, iconSizePx, iconSizePx);
          }catch(err){
            console.error(err);
          }
        }
        if(labelLines.length){
          const fontSizePx = markerLabelTextSize * pixelRatio;
          const lineGapPx = Math.max(0, (markerLabelTextLineHeight - 1) * markerLabelTextSize * pixelRatio);
          const totalHeight = labelLines.length * fontSizePx + Math.max(0, labelLines.length - 1) * lineGapPx;
          let textY = Math.round((canvasHeight - totalHeight) / 2);
          if(!Number.isFinite(textY) || textY < 0){
            textY = 0;
          }
          const textX = Math.round(markerLabelTextPaddingPx * pixelRatio);
          ctx.font = `${fontSizePx}px "Open Sans", "Arial Unicode MS Regular", sans-serif`;
          ctx.textBaseline = 'top';
          ctx.textAlign = 'left';
          ctx.shadowColor = 'rgba(0,0,0,0.4)';
          ctx.shadowBlur = 2 * pixelRatio;
          ctx.shadowOffsetX = 0;
          ctx.shadowOffsetY = 1 * pixelRatio;
          labelLines.forEach(line => {
            ctx.fillStyle = line.color;
            try{
              ctx.fillText(line.text, textX, textY);
            }catch(err){
              console.error(err);
            }
            textY += fontSizePx + lineGapPx;
          });
          ctx.shadowColor = 'transparent';
        }
      };
      const buildComposite = (backgroundImage, tintColor, tintAlpha = 1)=>{
        if(!backgroundImage){
          return null;
        }
        const canvas = document.createElement('canvas');
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;
        const ctx = canvas.getContext('2d');
        if(!ctx){
          return null;
        }
        ctx.clearRect(0, 0, canvasWidth, canvasHeight);
        try{
          ctx.drawImage(backgroundImage, 0, 0, canvasWidth, canvasHeight);
        }catch(err){
          console.error(err);
        }
        if(tintColor){
          ctx.globalCompositeOperation = 'source-atop';
          ctx.globalAlpha = tintAlpha;
          ctx.fillStyle = tintColor;
          ctx.fillRect(0, 0, canvasWidth, canvasHeight);
          ctx.globalAlpha = 1;
          ctx.globalCompositeOperation = 'source-over';
        }
        drawForeground(ctx);
        let imageData = null;
        try{
          imageData = ctx.getImageData(0, 0, canvasWidth, canvasHeight);
        }catch(err){
          console.error(err);
          imageData = null;
        }
        if(!imageData){
          return null;
        }
        const options = { pixelRatio: Number.isFinite(pixelRatio) && pixelRatio > 0 ? pixelRatio : 1 };
        return { image: imageData, options };
      };
      const baseComposite = buildComposite(pillImg, 'rgba(0,0,0,1)', 0.9);
      let accentComposite = null;
      if(pillAccentImg){
        accentComposite = buildComposite(pillAccentImg, null, 1);
      }
      if(!accentComposite){
        accentComposite = buildComposite(pillImg, '#2f3b73', 1);
      }
      if(!baseComposite){
        return null;
      }
      const highlightComposite = accentComposite || baseComposite;
      try{
        if(mapInstance.hasImage?.(compositeId)){
          mapInstance.removeImage(compositeId);
        }
        markerLabelCompositePlaceholderIds.delete(compositeId);
        const highlightId = `${compositeId}${MARKER_LABEL_COMPOSITE_ACCENT_SUFFIX}`;
        if(mapInstance.hasImage?.(highlightId)){
          mapInstance.removeImage(highlightId);
        }
        markerLabelCompositePlaceholderIds.delete(highlightId);
      }catch(err){
        console.error(err);
      }
      try{
        enforceMarkerLabelCompositeBudget(mapInstance, { keep: [labelSpriteId], reserve: 1 });
        mapInstance.addImage(compositeId, baseComposite.image, baseComposite.options || {});
        markerLabelCompositePlaceholderIds.delete(compositeId);
        if(highlightComposite && highlightComposite.image){
          const highlightId = `${compositeId}${MARKER_LABEL_COMPOSITE_ACCENT_SUFFIX}`;
          mapInstance.addImage(highlightId, highlightComposite.image, highlightComposite.options || baseComposite.options || {});
          markerLabelCompositePlaceholderIds.delete(highlightId);
        }
        markerLabelCompositeStore.set(labelSpriteId, Object.assign(meta, {
          image: baseComposite.image,
          options: baseComposite.options,
          highlightImage: highlightComposite.image,
          highlightOptions: highlightComposite.options || baseComposite.options
        }));
        enforceMarkerLabelCompositeBudget(mapInstance, { keep: [labelSpriteId] });
        return compositeId;
      }catch(err){
        console.error(err);
        return null;
      }
    })().finally(() => {
      markerLabelCompositePending.delete(labelSpriteId);
    });
    markerLabelCompositePending.set(labelSpriteId, task);
    return task;
  }

  function reapplyMarkerLabelComposites(mapInstance){
    if(!mapInstance){
      return;
    }
    const entries = [];
    markerLabelCompositeStore.forEach((entry, spriteId) => {
      if(!entry || !entry.image){
        return;
      }
      entries.push({
        spriteId,
        compositeId: markerLabelCompositeId(spriteId),
        image: entry.image,
        options: entry.options || {},
        highlightImage: entry.highlightImage,
        highlightOptions: entry.highlightOptions || entry.options || {},
        priority: Boolean(entry.priority),
        lastUsed: Number.isFinite(entry.lastUsed) ? entry.lastUsed : 0
      });
    });
    entries.sort((a, b) => {
      if(a.priority !== b.priority){
        return a.priority ? -1 : 1;
      }
      if(a.lastUsed !== b.lastUsed){
        return (b.lastUsed || 0) - (a.lastUsed || 0);
      }
      return a.spriteId.localeCompare(b.spriteId);
    });
    entries.forEach(entry => {
      let already = false;
      if(typeof mapInstance.hasImage === 'function'){
        try{ already = !!mapInstance.hasImage(entry.compositeId); }
        catch(err){ already = false; }
      }
      if(already){
        if(markerLabelCompositePlaceholderIds.has(entry.compositeId)){
          try{ mapInstance.removeImage(entry.compositeId); }catch(err){}
          markerLabelCompositePlaceholderIds.delete(entry.compositeId);
          already = false;
        } else {
          return;
        }
      }
      try{
        enforceMarkerLabelCompositeBudget(mapInstance, { keep: [entry.spriteId], reserve: 1 });
        mapInstance.addImage(entry.compositeId, entry.image, entry.options || {});
        markerLabelCompositePlaceholderIds.delete(entry.compositeId);
        if(entry.highlightImage){
          const highlightId = `${entry.compositeId}${MARKER_LABEL_COMPOSITE_ACCENT_SUFFIX}`;
          try{ if(mapInstance.hasImage?.(highlightId)) mapInstance.removeImage(highlightId); }catch(err){}
          try{ mapInstance.addImage(highlightId, entry.highlightImage, entry.highlightOptions || entry.options || {}); }
          catch(err){ console.error(err); }
          markerLabelCompositePlaceholderIds.delete(highlightId);
        }
        enforceMarkerLabelCompositeBudget(mapInstance, { keep: [entry.spriteId] });
      }catch(err){
        console.error(err);
      }
    });
  }

  function scheduleMarkerLabelBackgroundRetry(mapInstance){
    if(!mapInstance || typeof mapInstance === 'undefined') return;
    const mark = '__markerLabelBgRetryScheduled';
    if(mapInstance[mark]) return;
    mapInstance[mark] = true;
    const retry = () => {
      mapInstance[mark] = false;
      try{ ensureMarkerLabelBackground(mapInstance); }catch(err){}
    };
    if(typeof mapInstance.once === 'function'){
      mapInstance.once('style.load', retry);
    } else if(typeof mapInstance.on === 'function'){
      const handler = () => {
        try{ mapInstance.off?.('style.load', handler); }catch(err){}
        retry();
      };
      mapInstance.on('style.load', handler);
    } else {
      setTimeout(retry, 0);
    }
  }

  function ensureMarkerLabelBackground(mapInstance){
    if(!mapInstance || typeof mapInstance.addImage !== 'function') return;
    try{
      if(mapInstance.hasImage && mapInstance.hasImage(MARKER_LABEL_BG_ID)){
        mapInstance.__markerLabelBgRetryScheduled = false;
        return;
      }
    }catch(err){
      scheduleMarkerLabelBackgroundRetry(mapInstance);
      return;
    }
    if(typeof mapInstance.isStyleLoaded === 'function' && !mapInstance.isStyleLoaded()){
      scheduleMarkerLabelBackgroundRetry(mapInstance);
      return;
    }
    const placeholder = document.createElement('canvas');
    try{
      placeholder.width = Math.max(1, Math.round(markerLabelBackgroundWidthPx));
      placeholder.height = Math.max(1, Math.round(markerLabelBackgroundHeightPx));
      const phCtx = placeholder.getContext('2d');
      if(phCtx){
        phCtx.clearRect(0, 0, placeholder.width, placeholder.height);
      }
    }catch(err){
      placeholder.width = 1;
      placeholder.height = 1;
    }
    try{
      mapInstance.addImage(MARKER_LABEL_BG_ID, placeholder, { pixelRatio: 1 });
      mapInstance.__markerLabelBgRetryScheduled = false;
    }catch(err){
      scheduleMarkerLabelBackgroundRetry(mapInstance);
      return;
    }
    try{ window.__addOrReplacePill150x40?.(mapInstance); }catch(err){}
  }

  function patchLayerFiltersForMissingLayer(mapInstance, style){
    if(!mapInstance || typeof mapInstance.setFilter !== 'function') return;
    const layers = style && Array.isArray(style.layers) ? style.layers : [];
    if(!layers.length) return;

    const shouldSkipLayer = (layer) => {
      if(!layer) return true;
      const meta = layer.metadata || {};
      const featureComponent = layer['mapbox:featureComponent'] || meta['mapbox:featureComponent'];
      const featureSet = layer['mapbox:featureset'] || meta['mapbox:featureset'];
      if(featureSet) return true;
      if(typeof featureComponent === 'string' && featureComponent.includes('place-label')) return true;
      if(typeof layer.id === 'string' && layer.id.includes('place-label')) return true;
      if(typeof layer.source === 'string' && layer.source.includes('place-label')) return true;
      return false;
    };

    function patchExpression(expr){
      if(!Array.isArray(expr)){
        return { expr, changed:false };
      }
      const op = expr[0];
      let changed = false;
      const result = expr.map((item, idx) => {
        if(idx === 0) return item;
        const patched = patchExpression(item);
        if(patched.changed) changed = true;
        return patched.expr;
      });

      if((op === 'number' || op === 'to-number') && result.length > 1){
        const target = result[1];
        if(Array.isArray(target)){
          const already = target[0] === 'coalesce'
            && Array.isArray(target[1])
            && target[1][0] === 'get'
            && target[1][1] === 'layer';
          if(!already && target[0] === 'get' && target[1] === 'layer'){
            result[1] = ['coalesce', target, 0];
            changed = true;
          }
        }
      }

      return { expr: result, changed };
    }

    layers.forEach(layer => {
      if(!layer || !layer.id || !layer.filter) return;
      if(shouldSkipLayer(layer)) return;
      try{
        const patched = patchExpression(layer.filter);
        if(!patched.changed) return;
        mapInstance.setFilter(layer.id, patched.expr);
      }catch(err){}
    });
  }

  function patchTerrainSource(mapInstance, style){
    if(!mapInstance || typeof mapInstance.setTerrain !== 'function') return;
    const terrain = style && style.terrain;
    if(!terrain || !terrain.source) return;
    const sources = style.sources || {};
    const originalSource = sources[terrain.source];
    if(!originalSource) return;

    const dedicatedId = 'terrain-dem-dedicated';
    const ensureDedicatedSource = () => {
      if(mapInstance.getSource?.(dedicatedId)) return true;
      try {
        const clone = JSON.parse(JSON.stringify(originalSource));
        mapInstance.addSource(dedicatedId, clone);
        return !!mapInstance.getSource?.(dedicatedId);
      } catch(err){}
      return false;
    };

    const currentTerrain = typeof mapInstance.getTerrain === 'function' ? mapInstance.getTerrain() : null;
    if(currentTerrain && currentTerrain.source === dedicatedId && typeof currentTerrain.cutoff === 'number' && currentTerrain.cutoff > 0){
      return;
    }

    const hasDedicated = ensureDedicatedSource();
    const targetSource = hasDedicated ? dedicatedId : terrain.source;
    const nextTerrain = Object.assign({}, terrain, { source: targetSource });
    if(typeof nextTerrain.cutoff !== 'number' || nextTerrain.cutoff <= 0){
      nextTerrain.cutoff = 0.01;
    }
    try { mapInstance.setTerrain(nextTerrain); } catch(err){}
  }

  function patchMapboxStyleArtifacts(mapInstance){
    if(!mapInstance || typeof mapInstance.getStyle !== 'function') return;
    if(mapInstance.isStyleLoaded && !mapInstance.isStyleLoaded()) return;
    let style;
    try{
      style = mapInstance.getStyle();
    }catch(err){
      return;
    }
    if(!style) return;
    try{ ensurePlaceholderSprites(mapInstance); }catch(err){}
    try{ patchLayerFiltersForMissingLayer(mapInstance, style); }catch(err){}
    try{ patchTerrainSource(mapInstance, style); }catch(err){}
  }

  // Attach pointer cursor only after style is ready, and re-attach if style changes later.
  function armPointerOnSymbolLayers(map){
    const POINTER_READY_IDS = new Set([
      'marker-label',
      'marker-label-highlight',
      'post-balloons'
    ]);

    function shouldAttachPointer(layer){
      if (!layer || layer.type !== 'symbol') return false;
      if (POINTER_READY_IDS.has(layer.id)) return true;
      if (typeof layer.source === 'string' && layer.source === 'posts') return true;
      if (layer.metadata && layer.metadata.cursor === 'pointer') return true;
      return false;
    }

    function attach(){
      if (!map.getStyle || !map.isStyleLoaded || !map.isStyleLoaded()) return;
      const st = map.getStyle();
      if (!st || !st.layers) return;

      map.__cursorArmed = map.__cursorArmed || new Set();
      st.layers.forEach(l => {
        if (!shouldAttachPointer(l) || map.__cursorArmed.has(l.id)) return;
        map.on('mouseenter', l.id, () => map.getCanvas().style.cursor = 'pointer');
        map.on('mouseleave', l.id, () => map.getCanvas().style.cursor = 'grab');
        map.__cursorArmed.add(l.id);
      });
    }

    // First time once the style is fully loaded
    whenStyleReady(map, attach);

    // If the style changes later, reattach *after* the new style finishes
    map.on('styledata', () => {
      if (map.isStyleLoaded && map.isStyleLoaded()) attach();
    });
  }
  const callWhenDefined = window.callWhenDefined || function(name, invoke, timeoutMs){
    const start = performance.now(), max = timeoutMs ?? 5000;
    (function wait(){
      const fn = window[name];
      if (typeof fn === 'function') {
        try { invoke(fn); } catch(e){}
        return;
      }
      if (performance.now() - start < max) requestAnimationFrame(wait);
    })();
  };
  window.callWhenDefined = window.callWhenDefined || callWhenDefined;

  let startPitch, startBearing, logoEls = [], geocoder;
  const LEGACY_DEFAULT_PITCH = 0;
  const geocoders = [];
  let lastGeocoderProximity = null;

  function setAllGeocoderProximity(lng, lat){
    if(!Number.isFinite(lng) || !Number.isFinite(lat)) return;
    const prox = { longitude: lng, latitude: lat };
    const key = `${lng.toFixed(6)},${lat.toFixed(6)}`;
    if(lastGeocoderProximity === key) return;
    lastGeocoderProximity = key;
    geocoders.forEach(gc => {
      if(gc && typeof gc.setProximity === 'function'){
        try{ gc.setProximity(prox); }catch(err){}
      }
    });
  }

  function syncGeocoderProximityToMap(){
    if(!map || typeof map.getCenter !== 'function') return;
    try{
      const center = map.getCenter();
      if(center && Number.isFinite(center.lng) && Number.isFinite(center.lat)){
        setAllGeocoderProximity(center.lng, center.lat);
      }
    }catch(err){}
  }
  const CARD_SURFACE = 'linear-gradient(rgba(0,0,0,0.8),rgba(0,0,0,0.6))';
  const CARD_HIGHLIGHT = '#2e3a72';
  const MapRegistry = {
    list: [],
    limit: 4,
    register(map){
      if(!map) return;
      if(this.list.includes(map)) return;
      this.list.push(map);
      if(typeof map.once === 'function'){
        map.once('remove', () => {
          this.list = this.list.filter(m => m !== map);
        });
      }
      if(this.list.length > this.limit){
        const victim = this.list.shift();
        try{ victim && typeof victim.remove === 'function' && victim.remove(); }catch(err){}
      }
    }
  };

  function getGeocoderInput(gc){
    if(!gc) return null;
    if(gc._inputReference) return gc._inputReference;
    if(gc._inputEl) return gc._inputEl;
    if(gc._container) return gc._container.querySelector('input[type="text"]');
    return null;
  }

  function blurAllGeocoderInputs(){
    geocoders.forEach(gc => {
      const input = getGeocoderInput(gc);
      if(input && typeof input.blur === 'function'){
        input.blur();
      }
    });
  }

  function clearMapGeocoder(){
    if(!geocoder || typeof geocoder.clear !== 'function') return;
    const before = document.activeElement;
    geocoder.clear();
    const after = document.activeElement;
    requestAnimationFrame(() => {
      [after, before, getGeocoderInput(geocoder)].forEach(el => {
        if(el && el.classList && el.classList.contains('mapboxgl-ctrl-geocoder--input') && typeof el.blur === 'function'){
          el.blur();
        }
      });
      blurAllGeocoderInputs();
    });
  }

  (function(){
    const MAPBOX_TOKEN = "pk.eyJ1IjoienhlbiIsImEiOiJjbWViaDRibXEwM2NrMm1wcDhjODg4em5iIn0.2A9teACgwpiCy33uO4WZJQ";

    let mode = localStorage.getItem('mode') || 'map';
    const DEFAULT_SPIN_SPEED = 0.3;
    const DEFAULT_WELCOME = '<p>Welcome to Funmap! Choose an area on the map to search for events and listings. Click the <svg class="icon-search" width="30" height="30" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" role="img" aria-label="Filters"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg> button to refine your search.</p>';

    const firstVisit = !localStorage.getItem('hasVisited');
    localStorage.setItem('hasVisited','1');
    if(firstVisit){
      mode = 'map';
      localStorage.setItem('mode','map');
      localStorage.setItem('historyActive','false');
      ['filterPanel','memberPanel','adminPanel'].forEach(id => {
        localStorage.setItem(`panel-open-${id}`,'false');
      });
    }
    const savedView = JSON.parse(localStorage.getItem('mapView') || 'null');
    if(savedView && typeof savedView === 'object'){
      savedView.bearing = 0;
      try{ localStorage.setItem('mapView', JSON.stringify(savedView)); }catch(err){}
    }
    const defaultCenter = [(Math.random()*360)-180,(Math.random()*140)-70];
    const startCenter = savedView?.center || defaultCenter;
    const startZoom = savedView?.zoom || 1.5;
    let lastKnownZoom = startZoom;
    const hasSavedPitch = typeof savedView?.pitch === 'number';
    const initialPitch = hasSavedPitch ? savedView.pitch : LEGACY_DEFAULT_PITCH;
    startPitch = window.startPitch = initialPitch;
    startBearing = window.startBearing = 0;

      let map, spinning = false, historyWasActive = localStorage.getItem('historyActive') === 'true', expiredWasOn = false, dateStart = null, dateEnd = null,
          spinLoadStart = JSON.parse(localStorage.getItem('spinLoadStart') ?? 'true'),
          spinLoadType = localStorage.getItem('spinLoadType') || 'all',
          spinLogoClick = localStorage.getItem('spinLogoClick') === 'false' ? false : true,
          spinSpeed = DEFAULT_SPIN_SPEED,
          spinEnabled = spinLoadStart && (spinLoadType === 'all' || (spinLoadType === 'new' && firstVisit)),
          mapStyle = window.mapStyle = 'mapbox://styles/mapbox/standard';
      let markersLoaded = false;
      window.__markersLoaded = false;
      const MARKER_ZOOM_THRESHOLD = 8;
      const MARKER_SPRITE_ZOOM = MARKER_SPRITE_RETAIN_ZOOM;
      const ZOOM_VISIBILITY_PRECISION = 1000;
      const MARKER_VISIBILITY_BUCKET = Math.round(MARKER_ZOOM_THRESHOLD * ZOOM_VISIBILITY_PRECISION);
      const MARKER_PRELOAD_OFFSET = 0.2;
      const MARKER_PRELOAD_ZOOM = Math.max(MARKER_ZOOM_THRESHOLD - MARKER_PRELOAD_OFFSET, 0);
      const MARKER_LAYER_IDS = [
        'hover-fill',
        'marker-label',
        'marker-label-highlight'
      ];
      const ALL_MARKER_LAYER_IDS = [...MARKER_LAYER_IDS];
      const MID_ZOOM_MARKER_CLASS = 'map--midzoom-markers';
      const SPRITE_MARKER_CLASS = 'map--sprite-markers';
        const BALLOON_SOURCE_ID = 'post-balloon-source';
        const BALLOON_LAYER_ID = 'post-balloons';
        const BALLOON_LAYER_IDS = [BALLOON_LAYER_ID];
        const BALLOON_IMAGE_ID = 'seed-balloon-icon';
        const BALLOON_IMAGE_URL = 'assets/balloons/balloons-icon-16181-80.png';
        const BALLOON_MIN_ZOOM = 0;
        const BALLOON_MAX_ZOOM = MARKER_ZOOM_THRESHOLD;
        let balloonLayersVisible = true;

        function ensureBalloonIconImage(mapInstance){
          return new Promise(resolve => {
            if(!mapInstance || typeof mapInstance.hasImage !== 'function'){
              resolve();
              return;
            }
            if(mapInstance.hasImage(BALLOON_IMAGE_ID)){
              resolve();
              return;
            }
            const handleImage = (image)=>{
              if(!image){
                resolve();
                return;
              }
              try{
                if(!mapInstance.hasImage(BALLOON_IMAGE_ID) && image.width > 0 && image.height > 0){
                  const pixelRatio = image.width >= 256 ? 2 : 1;
                  mapInstance.addImage(BALLOON_IMAGE_ID, image, { pixelRatio });
                }
              }catch(err){ console.error(err); }
              resolve();
            };
            try{
              if(typeof mapInstance.loadImage === 'function'){
                mapInstance.loadImage(BALLOON_IMAGE_URL, (err, image)=>{
                  if(err){ console.error(err); resolve(); return; }
                  handleImage(image);
                });
                return;
              }
            }catch(err){ console.error(err); resolve(); return; }
            if(typeof Image !== 'undefined'){
              const img = new Image();
              img.crossOrigin = 'anonymous';
              img.onload = ()=>handleImage(img);
              img.onerror = ()=>resolve();
              img.src = BALLOON_IMAGE_URL;
              return;
            }
            resolve();
          });
        }

        function formatBalloonCount(count){
          if(!Number.isFinite(count) || count <= 0){
            return '0';
          }
          if(count >= 1000000){
            const value = count / 1000000;
            const formatted = value >= 10 ? Math.round(value) : Math.round(value * 10) / 10;
            return `${formatted}m`;
          }
          if(count >= 1000){
            const value = count / 1000;
            const formatted = value >= 10 ? Math.round(value) : Math.round(value * 10) / 10;
            return `${formatted}k`;
          }
          return String(count);
        }

        function getBalloonGridSize(zoom){
          const z = Number.isFinite(zoom) ? zoom : 0;
          if(z >= 7.5) return 0.5;
          if(z >= 6) return 1;
          if(z >= 4) return 2.5;
          if(z >= 2) return 5;
          return 10;
        }

        const clampBalloonLat = (lat)=> Math.max(-85, Math.min(85, lat));

        function groupPostsForBalloonZoom(postsSource, zoom){
          const gridSizeRaw = getBalloonGridSize(zoom);
          const gridSize = gridSizeRaw > 0 ? gridSizeRaw : 5;
          const groups = new Map();
          postsSource.forEach(post => {
            if(!post || !Number.isFinite(post.lng) || !Number.isFinite(post.lat)) return;
            const lng = Number(post.lng);
            const lat = clampBalloonLat(Number(post.lat));
            const col = Math.floor((lng + 180) / gridSize);
            const row = Math.floor((lat + 90) / gridSize);
            const key = `${col}|${row}`;
            let bucket = groups.get(key);
            if(!bucket){
              bucket = { count:0, sumLng:0, sumLat:0, posts: [] };
              groups.set(key, bucket);
            }
            bucket.count += 1;
            bucket.sumLng += lng;
            bucket.sumLat += lat;
            bucket.posts.push(post);
          });
          return { groups };
        }

        let lastBalloonGroupingDetails = { key: null, zoom: null, groups: new Map() };

        function buildBalloonFeatureCollection(zoom){
          const allowInitialize = true; // ensure balloons have data even before marker zoom threshold
          const postsSource = getAllPostsCache({ allowInitialize });
          if(!Array.isArray(postsSource) || postsSource.length === 0){
            const emptyGroups = new Map();
            const groupingKey = getBalloonBucketKey(zoom);
            lastBalloonGroupingDetails = { key: groupingKey, zoom, groups: emptyGroups };
            return { type:'FeatureCollection', features: [] };
          }
          const { groups } = groupPostsForBalloonZoom(postsSource, zoom);
          const features = [];
          groups.forEach((bucket, key) => {
            if(!bucket || bucket.count <= 0) return;
            const avgLng = bucket.sumLng / bucket.count;
            const avgLat = bucket.sumLat / bucket.count;
            features.push({
              type:'Feature',
              properties:{
                count: bucket.count,
                label: formatBalloonCount(bucket.count),
                bucket: key
              },
              geometry:{ type:'Point', coordinates:[avgLng, avgLat] }
            });
          });
          const groupingKey = getBalloonBucketKey(zoom);
          lastBalloonGroupingDetails = { key: groupingKey, zoom, groups };
          return { type:'FeatureCollection', features };
        }

        function computeChildBalloonTarget(bucket, currentZoom, maxAllowedZoom){
          if(!bucket || !Array.isArray(bucket.posts) || bucket.posts.length <= 1){
            return null;
          }
          const safeCurrent = Number.isFinite(currentZoom) ? currentZoom : 0;
          const safeMax = Number.isFinite(maxAllowedZoom) ? maxAllowedZoom : safeCurrent;
          if(!(safeMax > safeCurrent)){
            return null;
          }
          const step = 0.25;
          const maxIterations = Math.max(1, Math.ceil((safeMax - safeCurrent) / step) + 1);
          for(let i=0;i<maxIterations;i++){
            const candidateZoom = Math.min(safeMax, safeCurrent + (i + 1) * step);
            if(!(candidateZoom > safeCurrent)){
              continue;
            }
            const { groups } = groupPostsForBalloonZoom(bucket.posts, candidateZoom);
            const childBuckets = Array.from(groups.values()).filter(child => child && child.count > 0);
            if(childBuckets.length <= 1){
              continue;
            }
            let totalCount = 0;
            let sumLng = 0;
            let sumLat = 0;
            childBuckets.forEach(child => {
              const childCenterLng = child.sumLng / child.count;
              const childCenterLat = child.sumLat / child.count;
              totalCount += child.count;
              sumLng += childCenterLng * child.count;
              sumLat += childCenterLat * child.count;
            });
            if(totalCount <= 0){
              continue;
            }
            return {
              center: [sumLng / totalCount, sumLat / totalCount],
              zoom: candidateZoom
            };
          }
          return null;
        }

        let lastBalloonBucketKey = null;

        function getBalloonBucketKey(zoom){
          const size = getBalloonGridSize(zoom);
          return Number.isFinite(size) ? size.toFixed(2) : 'default';
        }

        function updateBalloonSourceForZoom(zoom){
          if(!map) return;
          const source = map.getSource && map.getSource(BALLOON_SOURCE_ID);
          if(!source || typeof source.setData !== 'function') return;
          const zoomValue = Number.isFinite(zoom) ? zoom : (typeof map.getZoom === 'function' ? map.getZoom() : 0);
          const bucketKey = getBalloonBucketKey(zoomValue);
          if(lastBalloonBucketKey === bucketKey) return;
          try{
            const data = buildBalloonFeatureCollection(zoomValue);
            source.setData(data);
            lastBalloonBucketKey = bucketKey;
          }catch(err){ console.error(err); }
        }

        function resetBalloonSourceState(){
          lastBalloonBucketKey = null;
          lastBalloonGroupingDetails = { key: null, zoom: null, groups: new Map() };
        }

        function setupSeedLayers(mapInstance){
          if(!mapInstance) return;
          // Ensure balloon layers are ready even at low zoom on initial load
          const currentZoom = typeof mapInstance.getZoom === 'function' ? mapInstance.getZoom() : 0;
          if(!Number.isFinite(currentZoom)){
            if(!mapInstance.__seedLayerZoomGate){
              const handleZoomGate = ()=>{
                const readyZoom = typeof mapInstance.getZoom === 'function' ? mapInstance.getZoom() : 0;
                if(Number.isFinite(readyZoom)){
                  mapInstance.off('zoomend', handleZoomGate);
                  mapInstance.__seedLayerZoomGate = null;
                  setupSeedLayers(mapInstance);
                }
              };
              mapInstance.__seedLayerZoomGate = handleZoomGate;
              mapInstance.on('zoomend', handleZoomGate);
            }
            return;
          }
          if(mapInstance.__seedLayerZoomGate){
            mapInstance.off('zoomend', mapInstance.__seedLayerZoomGate);
            mapInstance.__seedLayerZoomGate = null;
          }
          ensureBalloonIconImage(mapInstance).then(()=>{
            try{
              if(mapInstance.getLayer(BALLOON_LAYER_ID)) mapInstance.removeLayer(BALLOON_LAYER_ID);
            }catch(err){ console.error(err); }

            let balloonSource = null;
            try{
              balloonSource = mapInstance.getSource && mapInstance.getSource(BALLOON_SOURCE_ID);
            }catch(err){ balloonSource = null; }
            const emptyData = (typeof EMPTY_FEATURE_COLLECTION !== 'undefined') ? EMPTY_FEATURE_COLLECTION : { type:'FeatureCollection', features: [] };
            try{
              if(balloonSource && typeof balloonSource.setData === 'function'){
                balloonSource.setData(emptyData);
              } else {
                if(balloonSource){
                  try{ mapInstance.removeSource(BALLOON_SOURCE_ID); }catch(removeErr){ console.error(removeErr); }
                }
                mapInstance.addSource(BALLOON_SOURCE_ID, { type:'geojson', data: emptyData });
              }
            }catch(err){ console.error(err); }

            try{
              mapInstance.addLayer({
                id: BALLOON_LAYER_ID,
                type: 'symbol',
                source: BALLOON_SOURCE_ID,
                minzoom: BALLOON_MIN_ZOOM,
                maxzoom: BALLOON_MAX_ZOOM,
                layout: {
                  'icon-image': BALLOON_IMAGE_ID,
                  'icon-size': ['interpolate', ['linear'], ['zoom'], 0, 0.4, 7.5, 1],
                  'icon-allow-overlap': true,
                  'icon-ignore-placement': true,
                  'icon-anchor': 'bottom',
                  'text-field': ['to-string', ['coalesce', ['get','label'], ['get','count']]],
                  'text-size': 12,
                  'text-offset': [0, -1.35],
                  'text-font': ['Open Sans Bold','Arial Unicode MS Bold'],
                  'text-allow-overlap': true,
                  'text-ignore-placement': true,
                  'symbol-z-order': 'viewport-y',
                  'symbol-sort-key': 900
                },
                paint: {
                  'text-color': '#ffffff',
                  'text-halo-color': 'rgba(0,0,0,0.45)',
                  'text-halo-width': 1.2,
                  'icon-opacity': 0.95
                },
                metadata:{ cursor:'pointer' }
              });
            }catch(err){ console.error(err); }

            resetBalloonSourceState();
            const currentZoomValue = mapInstance.getZoom ? mapInstance.getZoom() : BALLOON_MIN_ZOOM;
            updateBalloonSourceForZoom(currentZoomValue);
            const shouldShow = Number.isFinite(currentZoomValue) ? currentZoomValue < BALLOON_MAX_ZOOM : true;
            try{
              mapInstance.setLayoutProperty(BALLOON_LAYER_ID, 'visibility', shouldShow ? 'visible' : 'none');
            }catch(err){}
            balloonLayersVisible = shouldShow;
          });

          if(!mapInstance.__seedBalloonEventsBound){
            const handleBalloonClick = (e)=>{
              if(e && typeof e.preventDefault === 'function') e.preventDefault();
              const feature = e && e.features && e.features[0];
              if(!feature) return;
              const coords = feature.geometry && feature.geometry.coordinates;
              if(!Array.isArray(coords) || coords.length < 2) return;
              const currentZoom = typeof mapInstance.getZoom === 'function' ? mapInstance.getZoom() : 0;
              const maxZoom = typeof mapInstance.getMaxZoom === 'function' ? mapInstance.getMaxZoom() : 22;
              const maxAllowedZoom = Number.isFinite(maxZoom)
                ? Math.min(maxZoom, BALLOON_MAX_ZOOM)
                : BALLOON_MAX_ZOOM;
              const safeCurrentZoom = Number.isFinite(currentZoom) ? currentZoom : 0;
              const bucketKey = feature.properties && feature.properties.bucket;
              const grouping = lastBalloonGroupingDetails && lastBalloonGroupingDetails.groups instanceof Map
                ? lastBalloonGroupingDetails.groups
                : null;
              const bucketData = grouping && bucketKey ? grouping.get(bucketKey) : null;
              const childZoomLimit = Number.isFinite(maxZoom)
                ? Math.min(maxZoom, Math.max(maxAllowedZoom, 12))
                : 12;
              const childTarget = computeChildBalloonTarget(bucketData, safeCurrentZoom, childZoomLimit);
              const hasChildTarget = childTarget && Array.isArray(childTarget.center) && childTarget.center.length >= 2;
              const targetCenter = hasChildTarget
                ? [childTarget.center[0], childTarget.center[1]]
                : [coords[0], coords[1]];
              const desiredLeafZoom = Number.isFinite(maxZoom) ? Math.min(12, maxZoom) : 12;
              let finalZoom;
              if(hasChildTarget){
                const childZoom = childTarget && Number.isFinite(childTarget.zoom)
                  ? Math.min(childTarget.zoom, childZoomLimit)
                  : NaN;
                finalZoom = Number.isFinite(childZoom) ? childZoom : safeCurrentZoom;
                if(finalZoom < safeCurrentZoom){
                  finalZoom = safeCurrentZoom;
                }
              } else {
                finalZoom = Number.isFinite(desiredLeafZoom) ? desiredLeafZoom : safeCurrentZoom;
                if(finalZoom < safeCurrentZoom){
                  finalZoom = safeCurrentZoom;
                }
              }
              if(!Number.isFinite(finalZoom)){
                finalZoom = safeCurrentZoom;
              }
              let currentPitch = null;
              try{
                currentPitch = typeof mapInstance.getPitch === 'function' ? mapInstance.getPitch() : null;
              }catch(err){
                currentPitch = null;
              }
              try{
                const flight = { center: targetCenter, zoom: finalZoom, essential: true };
                if(Number.isFinite(currentPitch)){
                  flight.pitch = currentPitch;
                }
                if(typeof mapInstance.flyTo === 'function'){
                  mapInstance.flyTo(Object.assign({}, flight, {
                    speed: 1.35,
                    curve: 1.5,
                    easing: t => 1 - Math.pow(1 - t, 3)
                  }));
                } else {
                  mapInstance.easeTo(Object.assign({}, flight, { duration: 650, easing: t => 1 - Math.pow(1 - t, 3) }));
                }
              }catch(err){ console.error(err); }
            };
            mapInstance.on('click', BALLOON_LAYER_ID, handleBalloonClick);
            mapInstance.on('mouseenter', BALLOON_LAYER_ID, ()=>{ mapInstance.getCanvas().style.cursor = 'pointer'; });
            mapInstance.on('mouseleave', BALLOON_LAYER_ID, ()=>{ mapInstance.getCanvas().style.cursor = 'grab'; });
            mapInstance.__seedBalloonEventsBound = true;
          }
          if(mapInstance === map){
            updateLayerVisibility(lastKnownZoom);
          }
        }
        localStorage.setItem('spinGlobe', JSON.stringify(spinEnabled));
        logoEls = [document.querySelector('.logo')].filter(Boolean);
        let ensureMapIcon = null;
      function updateLogoClickState(){
        logoEls.forEach(el=>{
          el.style.cursor = 'pointer';
          el.style.pointerEvents = 'auto';
        });
      }
      updateLogoClickState();

      function openWelcome(){
        const popup = document.getElementById('welcome-modal');
        const msgEl = document.getElementById('welcomeMessageBox');
        const saved = JSON.parse(localStorage.getItem('admin-settings-current') || '{}');
        msgEl.innerHTML = saved.welcomeMessage || DEFAULT_WELCOME;
        openPanel(popup);
        const body = document.getElementById('welcomeBody');
        body.style.padding = '20px';
      }
      window.openWelcome = openWelcome;

      function toggleWelcome(){
        const popup = document.getElementById('welcome-modal');
        if(popup.classList.contains('show')){
          closePanel(popup);
        } else {
          openWelcome();
        }
      }

      logoEls.forEach(el=>{
        el.addEventListener('click', (e) => {
          e.stopPropagation();
          if(spinning){
            toggleWelcome();
            return;
          }
          if(spinLogoClick && map && map.getZoom() <= 4){
            spinEnabled = true;
            localStorage.setItem('spinGlobe', 'true');
            startSpin(true);
          }
          toggleWelcome();
        });
      });
    // 'Post Panel' is defined as the current map bounds
    let postPanel = null;
    let posts = [], filtered = [], adPosts = [], adIndex = -1, adTimer = null, adPanel = null, adIdsKey = '', pendingPostLoad = false;
    let filtersInitialized = false;
    let favToTop = false, favSortDirty = true, currentSort = 'az';
    let selection = { cats: new Set(), subs: new Set() };
    let viewHistory = loadHistory();
    let hoverPopup = null;
    let postSourceEventsBound = false;
    let touchMarker = null;
    let activePostId = null;
    let markerFeatureIndex = new Map();
    let lastHighlightedPostIds = [];
    let highlightedFeatureKeys = [];
    function updateMapFeatureHighlights(targets){
      const input = Array.isArray(targets) ? targets : [targets];
      const seen = new Set();
      const normalized = [];
      const highlightSpriteIds = new Set();
      input.forEach(entry => {
        if(entry === undefined || entry === null) return;
        let idValue;
        let venueKeyValue = null;
        if(typeof entry === 'object' && !Array.isArray(entry)){
          const rawId = entry.id ?? entry.postId ?? entry.postID ?? entry.postid;
          if(rawId === undefined || rawId === null) return;
          idValue = String(rawId);
          const rawVenue = entry.venueKey ?? entry.venue_key ?? entry.venue;
          if(rawVenue !== undefined && rawVenue !== null){
            const venueString = String(rawVenue).trim();
            if(venueString){
              venueKeyValue = venueString;
            }
          }
        } else {
          idValue = String(entry);
        }
        if(!idValue) return;
        const dedupeKey = venueKeyValue ? `${idValue}::${venueKeyValue}` : idValue;
        if(seen.has(dedupeKey)) return;
        seen.add(dedupeKey);
        normalized.push({ id: idValue, venueKey: venueKeyValue });
      });
      lastHighlightedPostIds = normalized.map(item => ({ id: item.id, venueKey: item.venueKey }));
      if(!map || typeof map.setFeatureState !== 'function'){
        if(!normalized.length){
          highlightedFeatureKeys = [];
        }
        return;
      }
      if(!normalized.length){
        highlightedFeatureKeys.forEach(entry => {
          try{ map.setFeatureState({ source: entry.source, id: entry.id }, { isHighlighted: false }); }
          catch(err){}
        });
        highlightedFeatureKeys = [];
        return;
      }
      const nextEntries = [];
      const nextKeys = new Set();
      const extractVenueFromId = (featureId)=>{
        if(typeof featureId !== 'string') return '';
        const parts = featureId.split('::');
        return parts.length >= 3 ? String(parts[1] || '') : '';
      };
      normalized.forEach(target => {
        if(!target || !target.id) return;
        const entries = markerFeatureIndex instanceof Map ? markerFeatureIndex.get(target.id) : null;
        if(!entries || !entries.length) return;
        entries.forEach(entry => {
          if(!entry) return;
          const source = entry.source || 'posts';
          const featureId = entry.id;
          if(featureId === undefined || featureId === null) return;
          if(target.venueKey){
            const entryVenueKey = entry.venueKey ? String(entry.venueKey) : extractVenueFromId(featureId);
            if(!entryVenueKey || entryVenueKey !== target.venueKey){
              return;
            }
          }
          const compositeKey = `${source}::${featureId}`;
          if(nextKeys.has(compositeKey)) return;
          nextKeys.add(compositeKey);
          nextEntries.push({ source, id: featureId });
          if(entry.spriteId){
            const spriteValue = String(entry.spriteId);
            if(spriteValue){
              highlightSpriteIds.add(spriteValue);
            }
          }
        });
      });
      highlightedFeatureKeys.forEach(entry => {
        const compositeKey = `${entry.source}::${entry.id}`;
        if(nextKeys.has(compositeKey)) return;
        try{ map.setFeatureState({ source: entry.source, id: entry.id }, { isHighlighted: false }); }
        catch(err){}
      });
      nextEntries.forEach(entry => {
        try{ map.setFeatureState({ source: entry.source, id: entry.id }, { isHighlighted: true }); }
        catch(err){}
      });
      highlightedFeatureKeys = nextEntries;
      if(highlightSpriteIds.size){
        highlightSpriteIds.forEach(spriteId => {
          touchMarkerLabelCompositeMeta(spriteId, { updateTimestamp: true });
        });
      }
    }
    let selectedVenueKey = null;
    const BASE_URL = (()=>{ let b = location.origin + location.pathname.split('/post/')[0]; if(!b.endsWith('/')) b+='/'; return b; })();

    const $ = (sel, root=document) => root.querySelector(sel);
    const $$ = (sel, root=document) => Array.from(root.querySelectorAll(sel));
    const clamp = (n, a, b)=> Math.max(a, Math.min(b, n));
    const toRad = d => d * Math.PI / 180;
    function distKm(a,b){ const dLat = toRad(b.lat - a.lat), dLng = toRad(b.lng - a.lng); const s = Math.sin(dLat/2)**2 + Math.cos(toRad(a.lat))*Math.cos(toRad(b.lat))*Math.sin(Math.PI*(b.lng - a.lng)/360)**2; return 2 * 6371 * Math.asin(Math.sqrt(s)); }
    const sleep = ms => new Promise(r=>setTimeout(r,ms));
    const nextFrame = ()=> new Promise(r=> requestAnimationFrame(()=>r()));

    // Ensure result lists occupy available space between the header and footer
    function adjustListHeight(){
      const rootStyles = getComputedStyle(document.documentElement);
      const headerH = parseFloat(rootStyles.getPropertyValue('--header-h')) || 0;
      const subH = parseFloat(rootStyles.getPropertyValue('--subheader-h')) || 0;
      const footerH = parseFloat(rootStyles.getPropertyValue('--footer-h')) || 0;
      const safeTop = parseFloat(rootStyles.getPropertyValue('--safe-top')) || 0;
      let viewportHeight = getViewportHeight();
      if(!Number.isFinite(viewportHeight) || viewportHeight <= 0){
        viewportHeight = headerH + subH + footerH + safeTop;
      }
      let availableHeight = Math.max(0, viewportHeight - headerH - subH - footerH - safeTop);
      const boardsContainer = document.querySelector('.post-mode-boards');
      if(boardsContainer){
        const boardsRect = boardsContainer.getBoundingClientRect();
        if(boardsRect && Number.isFinite(boardsRect.height) && boardsRect.height > 0){
          const measured = Math.max(0, boardsRect.height);
          availableHeight = availableHeight > 0 ? Math.min(availableHeight, measured) : measured;
        }
      }
      if(!Number.isFinite(availableHeight) || availableHeight < 0){
        availableHeight = 0;
      }
      const root = document.documentElement;
      if(root){
        const fullHeight = (Number.isFinite(viewportHeight) && viewportHeight > 0)
          ? viewportHeight
          : (availableHeight + headerH + subH + footerH + safeTop);
        if(Number.isFinite(fullHeight) && fullHeight > 0){
          root.style.setProperty('--vh', `${(fullHeight / 100)}px`);
        }
        if(availableHeight > 0){
          root.style.setProperty('--panel-area-height', `${availableHeight}px`);
          root.style.setProperty('--boards-area-height', `${availableHeight}px`);
        } else {
          root.style.removeProperty('--panel-area-height');
          root.style.removeProperty('--boards-area-height');
        }
      }
      document.querySelectorAll('.recents-board, .quick-list-board, .post-board, .ad-board').forEach(list=>{
        if(availableHeight > 0){
          const value = `${availableHeight}px`;
          list.style.height = value;
          list.style.maxHeight = value;
          list.style.minHeight = value;
        } else {
          list.style.removeProperty('height');
          list.style.removeProperty('max-height');
          list.style.removeProperty('min-height');
        }
      });
    }
    window.adjustListHeight = adjustListHeight;
    if(window.visualViewport){
      window.visualViewport.addEventListener('resize', adjustListHeight);
      addPassiveScrollListener(window.visualViewport, adjustListHeight);
    }
    window.addEventListener('resize', adjustListHeight);
    window.addEventListener('orientationchange', adjustListHeight);

    let stickyScrollHandler = null;
      function updateStickyImages(){
        const root = document.documentElement;
        const openPost = document.querySelector('.post-board .open-post');
        const body = openPost ? openPost.querySelector('.post-body') : null;
        const imgArea = body ? body.querySelector('.post-images') : null;
        const header = openPost ? openPost.querySelector('.post-header') : null;
        document.body.classList.remove('hide-map-calendar');
        if(!openPost || !body || !imgArea || !header){
          document.body.classList.remove('open-post-sticky-images');
          root.style.removeProperty('--open-post-header-h');
          return;
        }
        root.style.setProperty('--open-post-header-h', header.offsetHeight + 'px');
        document.body.classList.add('open-post-sticky-images');
      }

    window.updateStickyImages = updateStickyImages;

    function updateLayoutVars(){
      const root = document.documentElement;
      const header = document.querySelector('.header');
      if(header){
        const headerStyles = getComputedStyle(header);
        const safeTop = parseFloat(headerStyles.paddingTop) || 0;
        const rect = header.getBoundingClientRect();
        let measured = Number.isFinite(rect.height) ? rect.height : 0;
        if(!measured || measured <= safeTop){
          const fallbackOffset = Number.isFinite(header.offsetHeight) ? header.offsetHeight : 0;
          measured = fallbackOffset;
        }
        if(!measured || measured <= safeTop){
          const fallbackScroll = Number.isFinite(header.scrollHeight) ? header.scrollHeight : 0;
          measured = fallbackScroll;
        }
        measured = Math.max(0, measured - safeTop);
        if(!measured){
          const rootStyles = getComputedStyle(root);
          const current = parseFloat(rootStyles.getPropertyValue('--header-h')) || 0;
          if(current > 0){
            measured = current;
          }
        }
        if(measured > 0){
          root.style.setProperty('--header-h', `${measured}px`);
        }
      }
      if(typeof window.adjustListHeight === 'function'){
        window.adjustListHeight();
      }
    }
    window.updateLayoutVars = updateLayoutVars;

    function updatePostPanel(){ if(map) postPanel = map.getBounds(); }

    // === 0528 helpers: cluster contextmenu list (robust positioning + locking) ===
    let listLocked = false;
    function lockMap(lock){
      listLocked = lock;
      const fn = lock ? 'disable' : 'enable';
      try{ map.dragPan[fn](); }catch(e){}
      try{ map.scrollZoom[fn](); }catch(e){}
      try{ map.boxZoom[fn](); }catch(e){}
      try{ map.keyboard[fn](); }catch(e){}
      try{ map.doubleClickZoom[fn](); }catch(e){}
      try{ map.touchZoomRotate[fn](); }catch(e){}
    }
    const MARKER_INTERACTIVE_LAYERS = VISIBLE_MARKER_LABEL_LAYERS.slice();
    window.__overCard = window.__overCard || false;

    function getPopupElement(popup){
      return popup && typeof popup.getElement === 'function' ? popup.getElement() : null;
    }

    function popupIsHovered(popup){
      if(window.__overCard){
        return true;
      }
      const el = getPopupElement(popup);
      if(!el) return false;
      if(el.matches(':hover')) return true;
      try {
        const hovered = el.querySelector(':hover');
        if(hovered) return true;
      } catch(err){}
      try {
        const hoveredList = document.querySelectorAll(':hover');
        for(let i = hoveredList.length - 1; i >= 0; i--){
          const node = hoveredList[i];
          if(node && (node === el || el.contains(node))){
            return true;
          }
        }
      } catch(err){}
      return false;
    }

    function schedulePopupRemoval(popup, delay=180){
      const target = popup || hoverPopup;
      if(!target) return;
      setTimeout(()=>{
        if(hoverPopup !== target) return;
        if(popupIsHovered(target)){
          window.__overCard = true;
          return;
        }
        window.__overCard = false;
        runOverlayCleanup(target);
        try{ target.remove(); }catch(e){}
        if(hoverPopup === target){
          hoverPopup = null;
          updateSelectedMarkerRing();
        }
      }, delay);
    }

    const SMALL_MAP_CARD_PILL_DEFAULT_SRC = 'assets/icons-30/150x40-pill-70.webp';
    const SMALL_MAP_CARD_PILL_HOVER_SRC = 'assets/icons-30/150x40-pill-2f3b73.webp';
    const MULTI_POST_MARKER_ICON_ID = 'multi-post-icon';
    const MULTI_POST_MARKER_ICON_SRC = 'assets/icons-30/multi-post-icon-30.webp';
    const SMALL_MULTI_MAP_CARD_ICON_SRC = 'assets/icons-30/multi-post-icon-30.webp';

    function registerOverlayCleanup(overlayEl, fn){
      if(!overlayEl || typeof fn !== 'function') return;
      const list = Array.isArray(overlayEl.__cleanupFns)
        ? overlayEl.__cleanupFns
        : (overlayEl.__cleanupFns = []);
      list.push(fn);
    }

    function runOverlayCleanup(target){
      if(!target) return;
      const el = typeof target.getElement === 'function' ? target.getElement() : target;
      if(!el) return;
      const fns = Array.isArray(el.__cleanupFns) ? el.__cleanupFns.slice() : [];
      if(!fns.length) return;
      el.__cleanupFns = [];
      fns.forEach(fn => {
        try{ fn(); }catch(err){}
      });
    }

    function setSmallMapCardPillImage(cardEl, highlighted){
      if(!cardEl) return;
      const pillImg = cardEl.querySelector('.mapmarker-pill, .map-card-pill')
        || cardEl.querySelector('img[src*="150x40-pill" i]');
      if(!pillImg) return;
      if(!pillImg.dataset.defaultSrc){
        const currentSrc = pillImg.getAttribute('src') || '';
        pillImg.dataset.defaultSrc = currentSrc || SMALL_MAP_CARD_PILL_DEFAULT_SRC;
      }
      if(!pillImg.dataset.highlightSrc){
        pillImg.dataset.highlightSrc = SMALL_MAP_CARD_PILL_HOVER_SRC;
      }
      const targetSrc = highlighted
        ? (pillImg.dataset.highlightSrc || SMALL_MAP_CARD_PILL_HOVER_SRC)
        : (pillImg.dataset.defaultSrc || SMALL_MAP_CARD_PILL_DEFAULT_SRC);
      if((pillImg.getAttribute('src') || '') !== targetSrc){
        pillImg.setAttribute('src', targetSrc);
      }
      if(pillImg.getAttribute('srcset')){
        pillImg.removeAttribute('srcset');
      }
    }

    function enforceSmallMultiMapCardIcon(img, overlayEl){
      if(!img) return;
      const targetSrc = SMALL_MULTI_MAP_CARD_ICON_SRC;
      const apply = ()=>{
        const currentSrc = img.getAttribute('src') || '';
        if(currentSrc !== targetSrc){
          img.setAttribute('src', targetSrc);
        }
      };
      apply();
      const onLoad = ()=> apply();
      const onError = ()=> apply();
      img.addEventListener('load', onLoad);
      img.addEventListener('error', onError);
      if(overlayEl){
        registerOverlayCleanup(overlayEl, ()=>{
          img.removeEventListener('load', onLoad);
          img.removeEventListener('error', onError);
        });
      }
      if(typeof MutationObserver === 'function'){
        const observer = new MutationObserver(()=>{
          if(!img.isConnected){
            observer.disconnect();
            return;
          }
          apply();
        });
        try{
          observer.observe(img, { attributes: true, attributeFilter: ['src'] });
        }catch(err){
          try{ observer.disconnect(); }catch(e){}
          return;
        }
        if(overlayEl){
          registerOverlayCleanup(overlayEl, ()=>{
            try{ observer.disconnect(); }catch(e){}
          });
        }
      }
    }

    function escapeAttrValue(value){
      const raw = String(value);
      if(typeof window !== 'undefined' && window.CSS && typeof window.CSS.escape === 'function'){
        try{ return window.CSS.escape(raw); }catch(err){ /* fall through */ }
      }
      return raw.replace(/"/g, '\\"').replace(/\\/g, '\\\\');
    }

    function getOverlayMultiIds(overlay){
      if(!overlay || !overlay.dataset) return [];
      const raw = overlay.dataset.multiIds || '';
      if(!raw) return [];
      return raw.split(',').map(id => id.trim()).filter(Boolean);
    }

    function findMarkerOverlaysById(id){
      if(id === undefined || id === null) return [];
      const strId = String(id);
      const matches = new Set();
      const escaped = escapeAttrValue(strId);
      if(typeof document !== 'undefined' && document.querySelectorAll){
        try{
          document.querySelectorAll(`.mapmarker-overlay[data-id="${escaped}"]`).forEach(el => matches.add(el));
        }catch(err){ /* ignore selector issues */ }
        document.querySelectorAll('.mapmarker-overlay[data-multi-ids]').forEach(el => {
          if(matches.has(el)) return;
          const multiIds = getOverlayMultiIds(el);
          if(multiIds.includes(strId)){
            matches.add(el);
          }
        });
      }
      return Array.from(matches);
    }

    function toggleSmallMapCardHoverHighlight(postId, shouldHighlight){
      if(postId === undefined || postId === null) return;
      const highlightClass = 'is-pill-highlight';
      const mapHighlightClass = 'is-map-highlight';
      const overlays = findMarkerOverlaysById(postId);
      overlays.forEach(overlay => {
        overlay.querySelectorAll('.small-map-card').forEach(cardEl => {
          if(shouldHighlight){
            if(!Object.prototype.hasOwnProperty.call(cardEl.dataset, 'hoverPrevHighlight')){
              cardEl.dataset.hoverPrevHighlight = cardEl.classList.contains(highlightClass) ? '1' : '0';
            }
            if(!cardEl.classList.contains(highlightClass)){
              cardEl.classList.add(highlightClass);
            }
            setSmallMapCardPillImage(cardEl, true);
          } else if(Object.prototype.hasOwnProperty.call(cardEl.dataset, 'hoverPrevHighlight')){
            const prev = cardEl.dataset.hoverPrevHighlight === '1';
            delete cardEl.dataset.hoverPrevHighlight;
            if(!prev){
              cardEl.classList.remove(highlightClass);
              setSmallMapCardPillImage(cardEl, false);
            } else {
              setSmallMapCardPillImage(cardEl, true);
            }
          }
        });
        overlay.querySelectorAll('.big-map-card').forEach(cardEl => {
          if(shouldHighlight){
            if(!Object.prototype.hasOwnProperty.call(cardEl.dataset, 'hoverPrevMapHighlight')){
              cardEl.dataset.hoverPrevMapHighlight = cardEl.classList.contains(mapHighlightClass) ? '1' : '0';
            }
            if(!cardEl.classList.contains(mapHighlightClass)){
              cardEl.classList.add(mapHighlightClass);
            }
          } else if(Object.prototype.hasOwnProperty.call(cardEl.dataset, 'hoverPrevMapHighlight')){
            const prev = cardEl.dataset.hoverPrevMapHighlight === '1';
            delete cardEl.dataset.hoverPrevMapHighlight;
            if(!prev){
              cardEl.classList.remove(mapHighlightClass);
            }
          }
        });
      });
    }

    function updateSelectedMarkerRing(){
      const highlightClass = 'is-map-highlight';
      const markerHighlightClass = 'is-pill-highlight';
      const isSurfaceHighlightTarget = (el)=> !!(el && el.classList && (el.classList.contains('post-card') || el.classList.contains('post-header')));
      const restoreHighlightBackground = (el)=>{
        if(!isSurfaceHighlightTarget(el) || !el.dataset) return;
        if(Object.prototype.hasOwnProperty.call(el.dataset, 'prevHighlightBackground')){
          const prev = el.dataset.prevHighlightBackground;
          delete el.dataset.prevHighlightBackground;
          if(prev){
            el.style.background = prev;
            return;
          }
        }
        if(Object.prototype.hasOwnProperty.call(el.dataset, 'surfaceBg')){
          el.style.background = el.dataset.surfaceBg;
        } else {
          el.style.removeProperty('background');
        }
      };
      const applyHighlightBackground = (el)=>{
        if(!isSurfaceHighlightTarget(el) || !el.dataset) return;
        if(!Object.prototype.hasOwnProperty.call(el.dataset, 'prevHighlightBackground')){
          el.dataset.prevHighlightBackground = el.style.background || '';
        }
        el.style.background = CARD_HIGHLIGHT;
      };
      const restoreAttr = (el)=>{
        if(!el || !el.dataset) return;
        if(Object.prototype.hasOwnProperty.call(el.dataset, 'prevAriaSelected')){
          const prev = el.dataset.prevAriaSelected;
          if(prev){
            el.setAttribute('aria-selected', prev);
          } else {
            el.removeAttribute('aria-selected');
          }
          delete el.dataset.prevAriaSelected;
        }
      };
      document.querySelectorAll(`.post-card.${highlightClass}, .open-post .post-header.${highlightClass}, .big-map-card.${highlightClass}`).forEach(el => {
        el.classList.remove(highlightClass);
        restoreAttr(el);
        restoreHighlightBackground(el);
      });
      document.querySelectorAll(`.small-map-card.${markerHighlightClass}`).forEach(el => {
        setSmallMapCardPillImage(el, false);
        el.classList.remove(markerHighlightClass);
      });

      const overlayEl = hoverPopup && typeof hoverPopup.getElement === 'function'
        ? hoverPopup.getElement()
        : null;
      const overlayId = overlayEl && overlayEl.dataset ? String(overlayEl.dataset.id || '') : '';
      const overlayMultiIds = overlayEl ? getOverlayMultiIds(overlayEl) : [];
      let fallbackId = '';
      if(!overlayId){
        if(activePostId !== undefined && activePostId !== null){
          fallbackId = String(activePostId);
        } else {
          const openEl = document.querySelector('.post-board .open-post[data-id]');
          fallbackId = openEl && openEl.dataset ? String(openEl.dataset.id || '') : '';
        }
      }
      const idsToHighlight = Array.from(new Set([overlayId, fallbackId, ...(overlayMultiIds || [])].filter(Boolean)));
      if(!idsToHighlight.length){
        updateMapFeatureHighlights([]);
        return;
      }
      const applyHighlight = (el)=>{
        if(!el) return;
        if(el.dataset && !Object.prototype.hasOwnProperty.call(el.dataset, 'prevAriaSelected')){
          el.dataset.prevAriaSelected = el.hasAttribute('aria-selected') ? el.getAttribute('aria-selected') : '';
        }
        el.classList.add(highlightClass);
        el.setAttribute('aria-selected', 'true');
        applyHighlightBackground(el);
      };
      const overlayVenueKey = overlayEl && overlayEl.dataset ? String(overlayEl.dataset.venueKey || '').trim() : '';
      const globalVenueKey = typeof selectedVenueKey === 'string' && selectedVenueKey ? String(selectedVenueKey).trim() : '';
      const highlightTargets = [];
      const targetSeen = new Set();
      idsToHighlight.forEach(id => {
        const strId = String(id);
        const selectorId = escapeAttrValue(strId);
        const listCard = postsWideEl ? postsWideEl.querySelector(`.post-card[data-id="${selectorId}"]`) : null;
        applyHighlight(listCard);
        const openHeader = document.querySelector(`.open-post[data-id="${selectorId}"] .post-header`);
        applyHighlight(openHeader);
        const preferredVenue = (overlayId && strId === overlayId && overlayVenueKey)
          ? overlayVenueKey
          : globalVenueKey;
        const normalizedVenue = preferredVenue ? String(preferredVenue).trim() : '';
        const overlays = findMarkerOverlaysById(strId);
        overlays.forEach(overlay => {
          const overlayKey = overlay && overlay.dataset ? String(overlay.dataset.venueKey || '').trim() : '';
          if(normalizedVenue && overlayKey && overlayKey !== normalizedVenue){
            return;
          }
          overlay.querySelectorAll('.small-map-card').forEach(el => {
            setSmallMapCardPillImage(el, true);
            el.classList.add(markerHighlightClass);
          });
          overlay.querySelectorAll('.big-map-card').forEach(el => {
            el.classList.add(highlightClass);
          });
        });
        const dedupeKey = normalizedVenue ? `${strId}::${normalizedVenue}` : strId;
        if(!targetSeen.has(dedupeKey)){
          targetSeen.add(dedupeKey);
          highlightTargets.push({ id: strId, venueKey: normalizedVenue || null });
        }
      });
      updateMapFeatureHighlights(highlightTargets);
    }

    function hashString(str){
      let hash = 0;
      for(let i=0;i<str.length;i++){
        hash = ((hash << 5) - hash) + str.charCodeAt(i);
        hash |= 0;
      }
      return hash.toString(36);
    }

function countMarkersForVenue(postsAtVenue, venueKey, bounds){
  if(!Array.isArray(postsAtVenue) || !postsAtVenue.length){
    return 0;
  }
  const key = typeof venueKey === 'string' && venueKey ? venueKey : null;
  const normalizedBounds = bounds ? normalizeBounds(bounds) : null;
  const markerInBounds = (lng, lat)=>{
    const lon = Number(lng);
    const la = Number(lat);
    if(!Number.isFinite(lon) || !Number.isFinite(la)) return false;
    if(!normalizedBounds) return true;
    return pointWithinBounds(lon, la, normalizedBounds);
  };
  if(key){
    return postsAtVenue.reduce((total, post) => {
      if(!post) return total;
      let count = 0;
      if(Array.isArray(post.locations) && post.locations.length){
        count = post.locations.reduce((sum, loc) => {
          if(!loc) return sum;
          const lng = Number(loc.lng);
          const lat = Number(loc.lat);
          if(!Number.isFinite(lng) || !Number.isFinite(lat)) return sum;
          if(toVenueCoordKey(lng, lat) !== key) return sum;
          return markerInBounds(lng, lat) ? sum + 1 : sum;
        }, 0);
      }
      if(!count && Number.isFinite(post.lng) && Number.isFinite(post.lat) && toVenueCoordKey(post.lng, post.lat) === key && markerInBounds(post.lng, post.lat)){
        count = 1;
      }
      return total + (count || 0);
    }, 0);
  }
  return postsAtVenue.reduce((total, post) => {
    if(!post) return total;
    let count = 0;
    if(Array.isArray(post.locations) && post.locations.length){
      count += post.locations.reduce((sum, loc) => {
        if(!loc) return sum;
        const lng = Number(loc.lng);
        const lat = Number(loc.lat);
        if(!Number.isFinite(lng) || !Number.isFinite(lat)) return sum;
        return markerInBounds(lng, lat) ? sum + 1 : sum;
      }, 0);
    }
    if((!Array.isArray(post.locations) || !post.locations.length) && Number.isFinite(post.lng) && Number.isFinite(post.lat) && markerInBounds(post.lng, post.lat)){
      count += 1;
    }
    return total + count;
  }, 0);
}


function mulberry32(a){ return function(){var t=a+=0x6D2B79F5; t=Math.imul(t^t>>>15, t|1); t^=t+Math.imul(t^t>>>7, t|61); return ((t^t>>>14)>>>0)/4294967296; }; }
    const rnd = mulberry32(42);

    const cities = [
      {n:"Melbourne, Australia", c:[144.9631,-37.8136]},
      {n:"Sydney, Australia", c:[151.2093,-33.8688]},
      {n:"London, UK", c:[-0.1276,51.5072]},
      {n:"New York, USA", c:[-74.0060,40.7128]},
      {n:"Tokyo, Japan", c:[139.6917,35.6895]},
      {n:"Paris, France", c:[2.3522,48.8566]},
      {n:"Rio de Janeiro, Brazil", c:[-43.1729,-22.9068]},
      {n:"Cape Town, South Africa", c:[18.4241,-33.9249]},
      {n:"Reykjavík, Iceland", c:[-21.8174,64.1265]},
      {n:"Mumbai, India", c:[72.8777,19.0760]}
    ];
    const categories = window.categories = [
      { name:"What's On", subs:["Live Gigs","Live Theatre","Screenings","Artwork","Live Sport","Other Events"] },
      { name:"Opportunities", subs:["Stage Auditions","Screen Auditions","Clubs","Jobs","Volunteers","Competitions","Other Opportunities"] },
      { name:"Learning", subs:["Tutors","Education Centres","Courses","Other Learning"] },
      { name:"Buy and Sell", subs:["Wanted","For Sale","Freebies"] },
      { name:"For Hire", subs:["Performers","Staff","Goods and Services"] }
    ];
      const ICON_BASE = window.ICON_BASE = {
        "What's On": "whats-on-category-icon",
        "Opportunities": "opportunities-category-icon",
        "Learning": "learning-category-icon",
        "Buy and Sell": "Buy-and-sell-category-icon",
        "For Hire": "For-hire-category-icon"
      };
    const COLOR_NAMES = window.COLOR_NAMES = ['blue','dark-yellow','green','indigo','orange','red','violet'];
    const subcategoryColorMap = window.subcategoryColorMap = {};
    let subcategoryColorCursor = 0;
    categories.forEach(cat => {
      (cat.subs || []).forEach(sub => {
        const color = COLOR_NAMES[subcategoryColorCursor % COLOR_NAMES.length];
        subcategoryColorMap[`${cat.name}::${sub}`] = color;
        subcategoryColorCursor++;
      });
    });
    subcategoryColorMap["What's On::Other Events"] = 'red';
    subcategoryColorMap['Opportunities::Other Opportunities'] = 'red';
    subcategoryColorMap['Learning::Other Learning'] = 'red';
    const subcategoryIcons = window.subcategoryIcons = {};
    const subcategoryMarkers = window.subcategoryMarkers = {};
    subcategoryMarkers[MULTI_POST_MARKER_ICON_ID] = MULTI_POST_MARKER_ICON_SRC;
    const subcategoryMarkerIds = window.subcategoryMarkerIds = {};
    const categoryShapes = window.categoryShapes = {};

    // --- Icon loader: ensures Mapbox images are available and quiets missing-image logs ---
    function attachIconLoader(mapInstance){
      if(!mapInstance) return () => Promise.resolve(false);
      const KNOWN = [
        'freebies','live-sport','volunteers','goods-and-services','clubs','artwork',
        'live-gigs','for-sale','education-centres','tutors'
      ];
      const BASES = [
        'assets/icons/subcategories/',
        'assets/icons/',
        'assets/images/icons/'
      ];
      const pending = new Map();

      const urlsFor = (name) => {
        const urls = [];
        const markers = window.subcategoryMarkers || {};
        const manual = markers[name] || null;
        const shouldLookupLocal = manual || KNOWN.includes(name);
        if(manual) urls.push(manual);
        if(shouldLookupLocal){
          const ratio = (window.devicePixelRatio || 1) >= 2 ? '@2x' : '';
          BASES.forEach(base => urls.push(`${base}${name}${ratio}.png`));
          BASES.forEach(base => urls.push(`${base}${name}.png`));
        }
        return { urls, shouldLookupLocal };
      };

      function loadImageCompat(url){
        return new Promise((resolve, reject) => {
          if(typeof mapInstance.loadImage === 'function'){
            mapInstance.loadImage(url, (err, img) => err ? reject(err) : resolve(img));
          } else {
            fetch(url)
              .then(r => r.ok ? r.blob() : Promise.reject(url))
              .then(blob => createImageBitmap(blob))
              .then(resolve)
              .catch(reject);
          }
        });
      }

      function pickPixelRatio(url, img){
        if(typeof url === 'string' && /@2x\.[^./]+$/i.test(url)){
          return 2;
        }
        return 1;
      }

      function placeholder(name){
        const canvas = document.createElement('canvas');
        canvas.width = 48;
        canvas.height = 48;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#222';
        ctx.beginPath();
        ctx.arc(24, 24, 24, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 20px system-ui, sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText((name && name[0] ? name[0] : '?').toUpperCase(), 24, 24);
        return canvas;
      }

      async function addIcon(name){
        if(!name) return false;
        if(mapInstance.hasImage?.(name)) return true;
        if(pending.has(name)) return pending.get(name);
        const task = (async () => {
          const { urls, shouldLookupLocal } = urlsFor(name);
          if(!urls.length && !shouldLookupLocal){
            try{ mapInstance.addImage(name, placeholder(name)); }catch(err){}
            return false;
          }
          for(const url of urls){
            try{
              const img = await loadImageCompat(url);
              if(mapInstance.hasImage?.(name)) return true;
              const pixelRatio = pickPixelRatio(url, img);
              mapInstance.addImage(name, img, { sdf:false, pixelRatio });
              return true;
            }catch(err){}
          }
          try{ mapInstance.addImage(name, placeholder(name)); }catch(err){}
          return false;
        })().finally(() => pending.delete(name));
        pending.set(name, task);
        return task;
      }

      mapInstance.on('style.load', async () => {
        try{ ensureMarkerLabelBackground(mapInstance); }catch(err){}
        try{ reapplyMarkerLabelComposites(mapInstance); }catch(err){}
        const markers = window.subcategoryMarkers || {};
        const preload = new Set([...KNOWN, ...Object.keys(markers)]);
        for(const iconName of preload){
          try{ await addIcon(iconName); }catch(err){}
        }
      });

      mapInstance.on('styleimagemissing', e => {
        if(!e || !e.id) return;
        if(e.id === MARKER_LABEL_BG_ID){
          try{ ensureMarkerLabelBackground(mapInstance); }catch(err){}
          return;
        }
        if(e.id.startsWith(MARKER_LABEL_COMPOSITE_PREFIX)){
          const spriteId = e.id.slice(MARKER_LABEL_COMPOSITE_PREFIX.length);
          const meta = markerLabelCompositeStore.get(spriteId) || {};
          const hasLabelText = Boolean((meta.labelLine1 && meta.labelLine1.trim()) || (meta.labelLine2 && meta.labelLine2.trim()));
          if(!hasLabelText){
            return;
          }
          ensureMarkerLabelComposite(mapInstance, spriteId, meta.iconId, meta.labelLine1, meta.labelLine2, meta.isMulti, { priority: meta.priority });
          return;
        }
        addIcon(e.id);
      });

      return addIcon;
    }

    const venueKey = (lng, lat) => toVenueCoordKey(lng, lat);

    function setSelectedVenueHighlight(lng, lat){
      if(Number.isFinite(lng) && Number.isFinite(lat)){
        const key = venueKey(lng, lat);
        if(selectedVenueKey !== key){
          selectedVenueKey = key;
          updateSelectedMarkerRing();
        }
      } else if(selectedVenueKey !== null){
        selectedVenueKey = null;
        updateSelectedMarkerRing();
      }
    }

    function ensureSvgDimensions(svg){
      try{
        const doc = new DOMParser().parseFromString(svg, 'image/svg+xml');
        const el = doc.documentElement;
        let w = parseFloat(el.getAttribute('width'));
        let h = parseFloat(el.getAttribute('height'));
        const viewBox = el.getAttribute('viewBox');
        if((!w || !h) && viewBox){
          const parts = viewBox.split(/[ ,]/).map(Number);
          if(parts.length === 4){
            w = w || parts[2];
            h = h || parts[3];
          }
        }
        if(!w) w = 40;
        if(!h) h = 40;
        el.setAttribute('width', w);
        el.setAttribute('height', h);
        return {svg: new XMLSerializer().serializeToString(el), width: w, height: h};
      }catch(e){
        return {svg, width:40, height:40};
      }
    }
// 0585: unique title generator (with location; no category prefix)
const __ADJ = ["Radiant","Indigo","Velvet","Silver","Crimson","Neon","Amber","Sapphire","Emerald","Electric","Roaring","Midnight","Sunlit","Ethereal","Urban","Astral","Analog","Digital","Windswept","Golden","Hidden","Avant","Cosmic","Garden","Quiet","Vivid","Obsidian","Scarlet","Cerulean","Lunar","Solar","Autumn","Verdant","Azure"];
const __NOUN = ["Symphony","Market","Carnival","Showcase","Assembly","Parade","Salon","Summit","Expo","Soirée","Revue","Collective","Fair","Gathering","Series","Retrospective","Circuit","Sessions","Weekender","Festival","Bazaar","Program","Tableau","Odyssey","Forum","Mosaic","Canvas","Relay","Drift","Workshop","Lab"];
const __HOOK = ["at Dusk","of Ideas","in Motion","for Everyone","Remix","Live","Reborn","MKII","Redux","Infinite","Prime","Pulse","Wave","Future","Now","Unlocked","Extended","Panorama","Unbound","Edition","Run","Sequence"];
function __rng(seed){ let s = seed|0; return ()=> (s = (s*1664525 + 1013904223)>>>0); }
const __USED_BIGRAMS = new Set();
function uniqueTitle(seed, cityName, idx){
  // Deterministic RNG with attempt salt for conflict resolution
  const base = (seed||0) ^ ((idx||0)*99991);

  const normalize = (s)=> s
    .replace(/[^\p{L}\p{N}]+/gu,' ')
    .trim()
    .split(/\s+/)
    .filter(Boolean);

  const lower = (ws)=> ws.map(w=> w.toLowerCase());

  const bigrams = (words)=> {
    const out = [];
    for(let i=0;i<words.length-1;i++) out.push(words[i]+" "+words[i+1]);
    return out;
  };

  const violates = (title)=> {
    const ws = normalize(title);
    const lc = lower(ws);
    if(!ws.length) return true;

    // no duplicate adjacent words inside one title
    for(let i=0;i<lc.length-1;i++){
      if(lc[i]===lc[i+1]) return true;
    }
    // any bigram seen before globally?
    const b = bigrams(lc);
    for(const bg of b){ if(__USED_BIGRAMS.has(bg)) return true; }

    return false;
  };

  const pickFrom = (r, arr)=> arr[r()%arr.length];

  // Word banks
  const A = __ADJ, N = __NOUN, H = __HOOK;
  const ARTISTS = [
    "The Silver Comets","Neon Parade","Paper Lanterns","Velvet Echoes","Indigo Quartet",
    "The Jet Set","Crimson Tide","Midnight Radio","Electric Hearts","Golden Hour",
    "The Amber Rooms","Violet Skyline","Satellite City","The Night Owls","Ivory Street Band",
    "Bluebird Company","Marble Garden","Velvet Undergrounders","Echo Park Players","Lantern Light",
    "Harbor & Co.","The Carousel Club","Kite & Canvas","Saffron Society","The Prairie Dogs"
  ];
  const PLAY_FORMS = [
    "Picture Show","Live on Stage","In Concert","Experience","Cabaret","Showcase",
    "Festival","Gala","Residency","Matinee","After Dark","Revue","Workshop"
  ];
  const STORY_OPENERS = [
    "Once Upon a Time","Into the Unknown","A Night to Remember","Between Two Worlds",
    "The Last Carousel","Dreams of Summer","Echoes in the Hall","Velvet Midnight",
    "The Paper Moon","Lanterns at Dusk","The Long Goodbye","Morning After Dark","Before the Storm"
  ];
  const TOUR_TAGS = ["Greatest Hits","Unplugged","Anniversary Tour","Acoustic Sessions","Late Night Set"];
  const PROMOS = ["One Night Only!","Two Nights Only!","One Weekend Only!","2 weeks only!!","Limited Season","Encore Performance"];

  const makeTitle = (r)=>{
    const templates = [
      ()=> `${pickFrom(r, ARTISTS)} Live on Stage`,
      ()=> `${pickFrom(r, ARTISTS)} — ${pickFrom(r, TOUR_TAGS)}`,
      ()=> `An Evening with ${pickFrom(r, ARTISTS)}`,
      ()=> `The ${pickFrom(r, N)} ${pickFrom(r, PLAY_FORMS)}`,
      ()=> `The ${pickFrom(r, A)} ${pickFrom(r, N)}`,
      ()=> `${pickFrom(r, A)} ${pickFrom(r, N)} ${pickFrom(r, H)}`,
      ()=> `${pickFrom(r, STORY_OPENERS)}`,
      ()=> `${pickFrom(r, A)} ${pickFrom(r, N)}: ${pickFrom(r, H)}`,
      ()=> `${pickFrom(r, A)} ${pickFrom(r, N)} ${pickFrom(r, PLAY_FORMS)}`,
      ()=> `${pickFrom(r, N)} ${pickFrom(r, PLAY_FORMS)}`
    ];
    let t = templates[r()%templates.length]();
    if ((r()%4)===0) t += ` — ${pickFrom(r, PROMOS)}`;
    return t.replace(/\s+/g,' ').trim();
  };

  // Try multiple deterministic attempts with salted RNG until constraints satisfied
  let attempt = 0, title = "";
  for(; attempt < 96; attempt++){
    const r = __rng(base ^ (attempt * 1315423911));
    const candidate = makeTitle(r);
    if(!violates(candidate)){
      title = candidate;
      break;
    }
  }
  if(!title){ title = makeTitle(__rng(base ^ 0x9e3779b9)); } // fallback

  // Commit global constraints
  const ws = lower(normalize(title));
  for(let i=0;i<ws.length-1;i++){ __USED_BIGRAMS.add(ws[i]+" "+ws[i+1]); }

  return title;
}function pick(arr){ return arr[Math.floor(rnd()*arr.length)]; }
    function jitter([lng,lat]){ return [lng + (rnd()-0.5)*8, clamp(lat + (rnd()-0.5)*8,-80,80)]; }

  function toISODate(d){
    const y = d.getFullYear();
    const m = String(d.getMonth()+1).padStart(2,'0');
    const day = String(d.getDate()).padStart(2,'0');
    return `${y}-${m}-${day}`;
  }

  function parseISODate(s){
    const [yy, mm, dd] = s.split('-').map(Number);
    return new Date(yy, mm - 1, dd);
  }

  function randomDates(){
    const count = 1 + Math.floor(rnd()*30);
    const now = new Date();
    return Array.from({length:count}, ()=>{
      const d = new Date(+now + Math.floor(rnd()*365)*86400000);
      return toISODate(d);
    }).sort();
  }

  function randomSchedule(){
    const count = 1 + Math.floor(rnd()*20);
    const now = new Date();
    return Array.from({length:count}, ()=>{
      const offset = Math.floor(rnd()*730) - 365; // past and future
      const d = new Date(+now + offset*86400000);
      const date = d.toLocaleDateString('en-GB',{weekday:'short', day:'numeric', month:'short'}).replace(/,/g,'');
      const time = `${String(Math.floor(rnd()*24)).padStart(2,'0')}:${String(Math.floor(rnd()*4)*15).padStart(2,'0')}`;
      const full = `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`;
      return {date, time, full};
    });
  }

  function normalizeLongitude(value){
    if(!Number.isFinite(value)) value = 0;
    const normalized = ((value + 180) % 360 + 360) % 360 - 180;
    return Number.isFinite(normalized) ? normalized : 0;
  }

  function clampLatitude(value){
    if(!Number.isFinite(value)) return 0;
    return Math.max(-85, Math.min(85, value));
  }

  function safeCoordinate(city, baseLng=0, baseLat=0, radius=0){
    const centerLng = Number.isFinite(baseLng) ? baseLng : 0;
    const centerLat = Number.isFinite(baseLat) ? baseLat : 0;
    const spread = Math.max(Number.isFinite(radius) ? radius : 0, 0);

    let lng = centerLng;
    let lat = centerLat;

    if(spread > 0){
      const distance = Math.sqrt(rnd()) * spread;
      const angle = rnd() * Math.PI * 2;
      lng += Math.cos(angle) * distance;
      lat += Math.sin(angle) * distance;
    }

    return {
      lng: normalizeLongitude(lng),
      lat: clampLatitude(lat)
    };
  }

  function createRandomLocation(city, baseLng=0, baseLat=0, options={}){
    const defaultRadius = 0.05;
    const radius = Number.isFinite(options.radius) ? Math.max(options.radius, 0) : defaultRadius;
    const coord = safeCoordinate(city, baseLng, baseLat, radius);
    const venueName = options.name || city || 'Event Venue';
    const address = options.address || city || '';
    return {
      venue: venueName,
      address,
      lng: coord.lng,
      lat: coord.lat,
      dates: randomSchedule(),
      price: randomPriceRange()
    };
  }

  const LOCAL_GEOCODER_MAX_RESULTS = 10;
  const localVenueIndex = [];
  const localVenueKeySet = new Set();
  const MULTI_VENUE_COORD_PRECISION = 6;
  window.postsAtVenue = window.postsAtVenue && typeof window.postsAtVenue === 'object'
    ? window.postsAtVenue
    : Object.create(null);

  function getPostsAtVenueStore(){
    if(!window.postsAtVenue || typeof window.postsAtVenue !== 'object'){
      window.postsAtVenue = Object.create(null);
    }
    return window.postsAtVenue;
  }

  function toVenueCoordKey(lng, lat){
    if(!Number.isFinite(lng) || !Number.isFinite(lat)) return '';
    const normalizedLng = Number(lng).toFixed(MULTI_VENUE_COORD_PRECISION);
    const normalizedLat = Number(lat).toFixed(MULTI_VENUE_COORD_PRECISION);
    return `${normalizedLng},${normalizedLat}`;
  }

  function clearPostsAtVenueIndex(){
    const store = getPostsAtVenueStore();
    Object.keys(store).forEach(key => { delete store[key]; });
  }

  function registerPostAtVenue(post, key){
    if(!key) return;
    const store = getPostsAtVenueStore();
    const bucket = store[key] || (store[key] = []);
    if(!bucket.some(item => item && item.id === post.id)){
      bucket.push(post);
    }
  }

  function getPostsAtVenueByCoords(lng, lat){
    const key = toVenueCoordKey(lng, lat);
    if(!key) return [];
    const store = getPostsAtVenueStore();
    const bucket = store[key];
    return Array.isArray(bucket) ? bucket.slice() : [];
  }

  window.getPostsAtVenueByCoords = getPostsAtVenueByCoords;

  function localVenueKey(name='', address='', lng, lat){
    const normName = (name || '').toLowerCase();
    const normAddr = (address || '').toLowerCase();
    const normLng = Number.isFinite(lng) ? lng.toFixed(6) : '';
    const normLat = Number.isFinite(lat) ? lat.toFixed(6) : '';
    return `${normName}|${normAddr}|${normLng}|${normLat}`;
  }

  function cloneGeocoderFeature(feature){
    return {
      ...feature,
      geometry: {
        ...feature.geometry,
        coordinates: Array.isArray(feature.geometry?.coordinates)
          ? feature.geometry.coordinates.slice()
          : []
      },
      center: Array.isArray(feature.center) ? feature.center.slice() : [],
      properties: {
        ...(feature.properties || {})
      }
    };
  }

  function addVenueToLocalIndex({ name, address, lng, lat, city }){
    if(!name || !Number.isFinite(lng) || !Number.isFinite(lat)) return;
    const key = localVenueKey(name, address, lng, lat);
    if(localVenueKeySet.has(key)) return;
    localVenueKeySet.add(key);
    const contextParts = [address, city].filter(Boolean);
    const placeName = contextParts.length ? `${name} — ${contextParts.join(', ')}` : name;
    const searchText = [name, address, city].filter(Boolean).join(' ').toLowerCase();
    localVenueIndex.push({
      search: searchText,
      feature: {
        type:'Feature',
        geometry:{ type:'Point', coordinates:[lng, lat] },
        center:[lng, lat],
        place_name: placeName,
        text: name,
        place_type:['venue'],
        properties:{
          name,
          address: address || '',
          city: city || '',
          source:'local-venue'
        }
      }
    });
  }

  function rebuildVenueIndex(){
    localVenueIndex.length = 0;
    localVenueKeySet.clear();
    clearPostsAtVenueIndex();
    const postList = Array.isArray(posts) ? posts : [];
    const addFromPost = (post) => {
      if(!post) return;
      const city = post.city || '';
      const fallbackName = getPrimaryVenueName(post) || city;
      const fallbackAddress = city || post.city || '';
      const seenVenueKeys = new Set();
      const addVenue = (lng, lat, locName, locAddress) => {
        if(!Number.isFinite(lng) || !Number.isFinite(lat)) return;
        const nameValue = locName || fallbackName;
        const addressValue = locAddress || fallbackAddress;
        addVenueToLocalIndex({ name: nameValue, address: addressValue, lng, lat, city });
        const key = toVenueCoordKey(lng, lat);
        if(!key || seenVenueKeys.has(key)) return;
        seenVenueKeys.add(key);
        registerPostAtVenue(post, key);
      };
      if(Array.isArray(post.locations) && post.locations.length){
        post.locations.forEach(loc => {
          if(!loc) return;
          addVenue(loc.lng, loc.lat, loc.venue, loc.address);
        });
        return;
      }
      addVenue(post.lng, post.lat, fallbackName, fallbackAddress);
    };
    postList.forEach(addFromPost);
  }

  function searchLocalVenues(query){
    const normalized = (query || '').toLowerCase().trim();
    if(!normalized) return [];
    const terms = normalized.split(/\s+/).filter(Boolean);
    if(!terms.length) return [];
    const matches = [];
    for(const entry of localVenueIndex){
      const haystack = entry.search;
      let score = 0;
      let valid = true;
      for(const term of terms){
        const idx = haystack.indexOf(term);
        if(idx === -1){
          valid = false;
          break;
        }
        score += 1 / (1 + idx);
      }
      if(valid){
        matches.push({ entry, score });
      }
    }
    matches.sort((a,b)=> b.score - a.score);
    return matches.slice(0, LOCAL_GEOCODER_MAX_RESULTS).map(item => {
      const feature = cloneGeocoderFeature(item.entry.feature);
      feature.relevance = Math.min(1, item.score);
      return feature;
    });
  }

  const localVenueGeocoder = (query) => searchLocalVenues(query);

  rebuildVenueIndex();


  function randomImages(id){
    const hero = heroUrl(id);
    const others = Array.from({length:9},(_,i)=>{
      const port = i % 2 === 0;
      return `https://picsum.photos/seed/${encodeURIComponent(id)}-${i}/${port?'800/1200':'1200/800'}`;
    });
    return [hero, ...others];
  }

  function randomText(min=50,max=200){
    const lorem = "lorem ipsum dolor sit amet consectetur adipiscing elit sed do eiusmod tempor incididunt ut labore et dolore magna aliqua".split(' ');
    const count = min + Math.floor(rnd()*(max-min+1));
    const words = [];
    for(let i=0;i<count;i++){ words.push(lorem[i%lorem.length]); }
    words[0] = words[0][0].toUpperCase() + words[0].slice(1);
    return words.join(' ') + '.';
  }

  function randomPriceRange(){
    const low = 10 + Math.floor(rnd()*90);
    const high = low + 10 + Math.floor(rnd()*90);
    return `$${low} - $${high}`;
  }

  function randomUsername(seed){
    const names = ['Aria','Blake','Casey','Drew','Evan','Finn','Gray','Harper','Indie','Jules'];
    let h = 0; for(let i=0;i<seed.length;i++){ h = (h<<5)-h+seed.charCodeAt(i); }
    const name = names[Math.abs(h)%names.length];
    const num = Math.abs(Math.floor(h/7))%1000;
    return name + num;
  }

  function randomAvatar(seed){
    return `https://picsum.photos/seed/${encodeURIComponent(seed)}-a/100/100`;
  }

  function slugify(str){
    return str.toLowerCase().replace(/[^a-z0-9]+/g,'-').replace(/^-|-$/g,'');
  }
  window.slugify = slugify;

  function postUrl(p){
    return `${BASE_URL}#/post/${p.slug}-${p.created}`;
  }

  function showCopyMsg(btn){
    const header = btn && btn.closest('.post-header');
    if(!header) return;
    const msg = document.createElement('div');
    msg.className='copy-msg';
    msg.textContent='Link Copied';
    header.appendChild(msg);
    const btnRect = btn.getBoundingClientRect();
    const headerRect = header.getBoundingClientRect();
    const msgRect = msg.getBoundingClientRect();
    msg.style.top = (btnRect.top - headerRect.top + (btnRect.height - msgRect.height)/2) + 'px';
    msg.style.left = (btnRect.left - headerRect.left - msgRect.width - 10) + 'px';
    requestAnimationFrame(()=>msg.classList.add('show'));
    setTimeout(()=>msg.remove(),1500);
  }

function makePosts(){
  const out = [];
  const cityCounts = Object.create(null);
  const MAX_POSTS_PER_CITY = 200;
  const neighborhoodCache = new Map();

  function pushPost(post){
    if(post && post.city){
      const key = String(post.city);
      cityCounts[key] = (cityCounts[key] || 0) + 1;
    }
    out.push(post);
  }

  function canAddCity(city){
    if(!city) return true;
    const key = String(city);
    return (cityCounts[key] || 0) < MAX_POSTS_PER_CITY;
  }

  function inlandShiftFor(lng){
    if(!Number.isFinite(lng)) return 0;
    if(lng < -90) return 0.012;
    if(lng < -30) return -0.012;
    if(lng >= 120) return -0.012;
    if(lng >= 60) return -0.009;
    if(lng >= 20) return -0.008;
    if(lng >= -10) return -0.006;
    return -0.01;
  }

  function buildNeighborhoods(city, baseLng, baseLat){
    const key = city || `${baseLng},${baseLat}`;
    if(neighborhoodCache.has(key)){
      return neighborhoodCache.get(key);
    }
    const latSign = Number.isFinite(baseLat) && baseLat < 0 ? -1 : 1;
    const lngShift = inlandShiftFor(baseLng);
    const neighborhoods = [
      { lng: normalizeLongitude(baseLng), lat: clampLatitude(baseLat) },
      { lng: normalizeLongitude(baseLng + lngShift), lat: clampLatitude(baseLat + 0.008 * latSign) },
      { lng: normalizeLongitude(baseLng + lngShift * 0.6), lat: clampLatitude(baseLat - 0.007 * latSign) },
      { lng: normalizeLongitude(baseLng + lngShift * -0.4), lat: clampLatitude(baseLat + 0.004 * latSign) }
    ];
    neighborhoodCache.set(key, neighborhoods);
    return neighborhoods;
  }

  function jitterNeighborhoodPoint(point){
    if(!point) return { lng: 0, lat: 0 };
    const jitterRange = 0.004;
    const lng = normalizeLongitude(point.lng + (rnd() - 0.5) * jitterRange * 2);
    const lat = clampLatitude(point.lat + (rnd() - 0.5) * jitterRange * 2);
    return { lng, lat };
  }
  // ---- 100 posts at Federation Square (as before) ----
  const fsLng = 144.9695, fsLat = -37.8178;
  const fsCity = "Federation Square, Melbourne";
  for(let i=0;i<100;i++){
    const cat = pick(categories);
    const sub = pick(cat.subs);
    const id = 'FS'+i;
    const title = `${id} ${uniqueTitle(i*7777+13, fsCity, i)}`;
    const created = new Date().toISOString().replace(/[:.]/g,'-');
    const location = createRandomLocation(fsCity, fsLng, fsLat, {
      name: 'Federation Square',
      address: 'Swanston St & Flinders St, Melbourne VIC 3000, Australia',
      radius: 0.05
    });
    pushPost({
      id,
      title,
      slug: slugify(title),
      created,
      city: fsCity,
      lng: location.lng, lat: location.lat,
      category: cat.name,
      subcategory: sub,
      dates: randomDates(),
      sponsored: true, // All posts are sponsored for development
      fav:false,
      desc: randomText(),
      images: randomImages(id),
      locations: [location],
      member: { username: randomUsername(id), avatar: randomAvatar(id) },
    });
  }

  // ---- 100 posts in Tasmania ----
  const tasLng = 147.3272, tasLat = -42.8821;
  const tasCity = "Hobart, Tasmania";
  const todayTas = new Date(); todayTas.setHours(0,0,0,0);
  for(let i=0;i<100;i++){
    const cat = pick(categories);
    const sub = pick(cat.subs);
    const id = 'TAS'+i;
    const title = `${id} ${uniqueTitle(i*5311+23, tasCity, i)}`;
    const created = new Date().toISOString().replace(/[:.]/g,'-');
    const offset = 1 + i%30;
    const date = new Date(todayTas);
    date.setDate(date.getDate() + (i<50 ? -offset : offset));
    const location = createRandomLocation(tasCity, tasLng, tasLat, { radius: 0.05 });
    pushPost({
      id,
      title,
      slug: slugify(title),
      created,
      city: tasCity,
      lng: location.lng,
      lat: location.lat,
      category: cat.name,
      subcategory: sub,
      dates: [toISODate(date)],
      sponsored: true, // All posts are sponsored for development
      fav:false,
      desc: randomText(),
      images: randomImages(id),
      locations: [location],
      member: { username: randomUsername(id), avatar: randomAvatar(id) },
    });
  }

  // ---- Restore world-wide posts ----
  // A light list of hub cities for better realism
  const hubs = [
    {c:"New York, USA",      lng:-73.9857, lat:40.7484},
    {c:"Los Angeles, USA",   lng:-118.2437, lat:34.0522},
    {c:"London, UK",         lng:-0.1276, lat:51.5074},
    {c:"Paris, France",      lng:2.3522, lat:48.8566},
    {c:"Berlin, Germany",    lng:13.4050, lat:52.5200},
    {c:"Madrid, Spain",      lng:-3.7038, lat:40.4168},
    {c:"Rome, Italy",        lng:12.4964, lat:41.9028},
    {c:"Amsterdam, NL",      lng:4.9041, lat:52.3676},
    {c:"Dublin, Ireland",    lng:-6.2603, lat:53.3498},
    {c:"Stockholm, Sweden",  lng:18.0686, lat:59.3293},
    {c:"Copenhagen, Denmark",lng:12.5683, lat:55.6761},
    {c:"Helsinki, Finland",  lng:24.9384, lat:60.1699},
    {c:"Oslo, Norway",       lng:10.7522, lat:59.9139},
    {c:"Reykjavík, Iceland", lng:-21.8277, lat:64.1265},
    {c:"Moscow, Russia",     lng:37.6173, lat:55.7558},
    {c:"Istanbul, Türkiye",  lng:28.9784, lat:41.0082},
    {c:"Athens, Greece",     lng:23.7275, lat:37.9838},
    {c:"Cairo, Egypt",       lng:31.2357, lat:30.0444},
    {c:"Nairobi, Kenya",     lng:36.8219, lat:-1.2921},
    {c:"Lagos, Nigeria",     lng:3.3792, lat:6.5244},
    {c:"Johannesburg, SA",   lng:28.0473, lat:-26.2041},
    {c:"Cape Town, SA",      lng:18.4241, lat:-33.9249},
    {c:"Dubai, UAE",         lng:55.2708, lat:25.2048},
    {c:"Mumbai, India",      lng:72.8777, lat:19.0760},
    {c:"Delhi, India",       lng:77.1025, lat:28.7041},
    {c:"Bangkok, Thailand",  lng:100.5018, lat:13.7563},
    {c:"Singapore",          lng:103.8198, lat:1.3521},
    {c:"Hong Kong, China",   lng:114.1694, lat:22.3193},
    {c:"Tokyo, Japan",       lng:139.6917, lat:35.6895},
    {c:"Seoul, South Korea", lng:126.9780, lat:37.5665},
    {c:"Sydney, Australia",  lng:151.2093, lat:-33.8688},
    {c:"Brisbane, Australia",lng:153.0251, lat:-27.4698},
    {c:"Auckland, New Zealand", lng:174.7633, lat:-36.8485},
    {c:"Toronto, Canada",    lng:-79.3832, lat:43.6532},
    {c:"Vancouver, Canada",  lng:-123.1207, lat:49.2827},
    {c:"Mexico City, Mexico",lng:-99.1332, lat:19.4326},
    {c:"São Paulo, Brazil",  lng:-46.6333, lat:-23.5505},
    {c:"Rio de Janeiro, Brazil", lng:-43.1729, lat:-22.9068},
    {c:"Buenos Aires, Argentina", lng:-58.3816, lat:-34.6037},
    {c:"Santiago, Chile",    lng:-70.6693, lat:-33.4489}
  ];

  // Generate ~900 posts across hubs with curated neighbourhood jitter
  const TOTAL_WORLD = 900;
  const worldCitySpecs = hubs.map(hub => ({
    city: hub.c,
    baseLng: hub.lng,
    baseLat: hub.lat,
    neighborhoods: buildNeighborhoods(hub.c, hub.lng, hub.lat),
    generated: 0
  }));
  const shufflePool = (pool)=>{
    if(!pool.length) return pool;
    const order = shuffledIndices(pool.length);
    return order.map(idx => pool[idx]);
  };
  let worldPool = shufflePool(worldCitySpecs.map((_, idx) => idx));
  let worldPoolIndex = 0;
  let worldProduced = 0;
  const WORLD_ATTEMPT_MAX = TOTAL_WORLD * 6;
  let worldAttempts = 0;
  while(worldProduced < TOTAL_WORLD && worldPool.length && worldAttempts < WORLD_ATTEMPT_MAX){
    if(worldPoolIndex >= worldPool.length){
      const available = worldPool.filter(idx => canAddCity(worldCitySpecs[idx].city));
      worldPool = shufflePool(available);
      worldPoolIndex = 0;
      if(!worldPool.length){
        break;
      }
    }
    const specIndex = worldPool[worldPoolIndex++];
    const spec = worldCitySpecs[specIndex];
    worldAttempts++;
    if(!spec || !canAddCity(spec.city)){
      continue;
    }
    const neighborhoods = spec.neighborhoods && spec.neighborhoods.length
      ? spec.neighborhoods
      : buildNeighborhoods(spec.city, spec.baseLng, spec.baseLat);
    const generation = spec.generated || 0;
    const basePoint = neighborhoods[generation % neighborhoods.length] || neighborhoods[0];
    spec.generated = generation + 1;
    const coords = jitterNeighborhoodPoint(basePoint);
    const cityLabel = typeof spec.city === 'string' ? spec.city.split(',')[0].trim() || spec.city : spec.city;
    const location = createRandomLocation(spec.city, coords.lng, coords.lat, {
      name: `${cityLabel} District ${((generation % neighborhoods.length) + 1)}`,
      address: spec.city,
      radius: 0
    });
    const cat = pick(categories);
    const sub = pick(cat.subs);
    const id = `WW${worldProduced}`;
    const title = `${id} ${uniqueTitle(worldProduced*9343+19, spec.city, worldProduced)}`;
    const created = new Date().toISOString().replace(/[:.]/g,'-');
    pushPost({
      id,
      title,
      slug: slugify(title),
      created,
      city: spec.city,
      lng: location.lng,
      lat: location.lat,
      category: cat.name,
      subcategory: sub,
      dates: randomDates(),
      sponsored: true, // All posts are sponsored for development
      fav:false,
      desc: randomText(),
      images: randomImages(id),
      locations: [location],
      member: { username: randomUsername(id), avatar: randomAvatar(id) },
    });
    worldProduced++;
  }

  // ---- Fixed Sydney Opera House posts to show multi-marker clustering ----
  const operaCity = 'Sydney, Australia';
  const operaVenueName = 'Sydney Opera House';
  const operaAddress = 'Bennelong Point, Sydney NSW 2000, Australia';
  const operaLng = 151.2153;
  const operaLat = -33.8568;
  for(let i=0;i<10;i++){
    const cat = pick(categories);
    const sub = pick(cat.subs);
    const id = 'SOH'+i;
    const title = `${id} ${uniqueTitle(i*12007+7, operaCity, i)}`;
    const created = new Date().toISOString().replace(/[:.]/g,'-');
    const location = {
      venue: operaVenueName,
      address: operaAddress,
      lng: operaLng,
      lat: operaLat,
      dates: randomSchedule(),
      price: randomPriceRange()
    };
    pushPost({
      id,
      title,
      slug: slugify(title),
      created,
      city: operaCity,
      lng: operaLng,
      lat: operaLat,
      category: cat.name,
      subcategory: sub,
      dates: randomDates(),
      sponsored: true, // All posts are sponsored for development
      fav:false,
      desc: randomText(),
      images: randomImages(id),
      locations: [location],
      member: { username: randomUsername(id), avatar: randomAvatar(id) },
    });
  }

  // ---- 400 single-venue posts across unique locations ----
  const coordKey = (lng, lat)=>{
    if(!Number.isFinite(lng) || !Number.isFinite(lat)) return '';
    return `${lng.toFixed(6)},${lat.toFixed(6)}`;
  };
  const existingCoordKeys = new Set(out.map(p => coordKey(p.lng, p.lat)).filter(Boolean));
  const singleVenueBases = [
    { city: "Anchorage, USA", lng: -149.9003, lat: 61.2181 },
    { city: "Honolulu, USA", lng: -157.8583, lat: 21.3069 },
    { city: "San Francisco, USA", lng: -122.4194, lat: 37.7749 },
    { city: "Seattle, USA", lng: -122.3321, lat: 47.6062 },
    { city: "Vancouver, Canada", lng: -123.1207, lat: 49.2827 },
    { city: "Calgary, Canada", lng: -114.0719, lat: 51.0447 },
    { city: "Toronto, Canada", lng: -79.3832, lat: 43.6532 },
    { city: "Montreal, Canada", lng: -73.5673, lat: 45.5017 },
    { city: "Boston, USA", lng: -71.0589, lat: 42.3601 },
    { city: "New Orleans, USA", lng: -90.0715, lat: 29.9511 },
    { city: "Chicago, USA", lng: -87.6298, lat: 41.8781 },
    { city: "Miami, USA", lng: -80.1918, lat: 25.7617 },
    { city: "Dallas, USA", lng: -96.7969, lat: 32.7767 },
    { city: "Denver, USA", lng: -104.9903, lat: 39.7392 },
    { city: "Phoenix, USA", lng: -112.0740, lat: 33.4484 },
    { city: "Los Angeles, USA", lng: -118.2437, lat: 34.0522 },
    { city: "Mexico City, Mexico", lng: -99.1332, lat: 19.4326 },
    { city: "Guadalajara, Mexico", lng: -103.3496, lat: 20.6597 },
    { city: "Bogotá, Colombia", lng: -74.0721, lat: 4.7110 },
    { city: "Lima, Peru", lng: -77.0428, lat: -12.0464 },
    { city: "Quito, Ecuador", lng: -78.4678, lat: -0.1807 },
    { city: "Santiago, Chile", lng: -70.6693, lat: -33.4489 },
    { city: "Buenos Aires, Argentina", lng: -58.3816, lat: -34.6037 },
    { city: "Montevideo, Uruguay", lng: -56.1645, lat: -34.9011 },
    { city: "São Paulo, Brazil", lng: -46.6333, lat: -23.5505 },
    { city: "Rio de Janeiro, Brazil", lng: -43.1729, lat: -22.9068 },
    { city: "Brasília, Brazil", lng: -47.8825, lat: -15.7942 },
    { city: "Recife, Brazil", lng: -34.8770, lat: -8.0476 },
    { city: "Fortaleza, Brazil", lng: -38.5434, lat: -3.7319 },
    { city: "Caracas, Venezuela", lng: -66.9036, lat: 10.4806 },
    { city: "San Juan, Puerto Rico", lng: -66.1057, lat: 18.4655 },
    { city: "Reykjavík, Iceland", lng: -21.8277, lat: 64.1265 },
    { city: "Oslo, Norway", lng: 10.7522, lat: 59.9139 },
    { city: "Stockholm, Sweden", lng: 18.0686, lat: 59.3293 },
    { city: "Helsinki, Finland", lng: 24.9384, lat: 60.1699 },
    { city: "Copenhagen, Denmark", lng: 12.5683, lat: 55.6761 },
    { city: "Edinburgh, UK", lng: -3.1883, lat: 55.9533 },
    { city: "Dublin, Ireland", lng: -6.2603, lat: 53.3498 },
    { city: "Glasgow, UK", lng: -4.2518, lat: 55.8642 },
    { city: "London, UK", lng: -0.1276, lat: 51.5074 },
    { city: "Manchester, UK", lng: -2.2426, lat: 53.4808 },
    { city: "Paris, France", lng: 2.3522, lat: 48.8566 },
    { city: "Lyon, France", lng: 4.8357, lat: 45.7640 },
    { city: "Marseille, France", lng: 5.3698, lat: 43.2965 },
    { city: "Madrid, Spain", lng: -3.7038, lat: 40.4168 },
    { city: "Barcelona, Spain", lng: 2.1734, lat: 41.3851 },
    { city: "Valencia, Spain", lng: -0.3763, lat: 39.4699 },
    { city: "Lisbon, Portugal", lng: -9.1393, lat: 38.7223 },
    { city: "Porto, Portugal", lng: -8.6291, lat: 41.1579 },
    { city: "Brussels, Belgium", lng: 4.3517, lat: 50.8503 },
    { city: "Amsterdam, Netherlands", lng: 4.9041, lat: 52.3676 },
    { city: "Rotterdam, Netherlands", lng: 4.4792, lat: 51.9244 },
    { city: "Berlin, Germany", lng: 13.4050, lat: 52.5200 },
    { city: "Hamburg, Germany", lng: 9.9937, lat: 53.5511 },
    { city: "Munich, Germany", lng: 11.5820, lat: 48.1351 },
    { city: "Frankfurt, Germany", lng: 8.6821, lat: 50.1109 },
    { city: "Prague, Czechia", lng: 14.4378, lat: 50.0755 },
    { city: "Vienna, Austria", lng: 16.3738, lat: 48.2082 },
    { city: "Zurich, Switzerland", lng: 8.5417, lat: 47.3769 },
    { city: "Warsaw, Poland", lng: 21.0122, lat: 52.2297 },
    { city: "Kraków, Poland", lng: 19.9440, lat: 50.0647 },
    { city: "Budapest, Hungary", lng: 19.0402, lat: 47.4979 },
    { city: "Bucharest, Romania", lng: 26.1025, lat: 44.4268 },
    { city: "Athens, Greece", lng: 23.7275, lat: 37.9838 },
    { city: "Istanbul, Türkiye", lng: 28.9784, lat: 41.0082 },
    { city: "Ankara, Türkiye", lng: 32.8597, lat: 39.9334 },
    { city: "Cairo, Egypt", lng: 31.2357, lat: 30.0444 },
    { city: "Casablanca, Morocco", lng: -7.5898, lat: 33.5731 },
    { city: "Marrakesh, Morocco", lng: -7.9811, lat: 31.6295 },
    { city: "Algiers, Algeria", lng: 3.0588, lat: 36.7538 },
    { city: "Tunis, Tunisia", lng: 10.1815, lat: 36.8065 },
    { city: "Tripoli, Libya", lng: 13.1913, lat: 32.8872 },
    { city: "Khartoum, Sudan", lng: 32.5599, lat: 15.5007 },
    { city: "Addis Ababa, Ethiopia", lng: 38.7578, lat: 8.9806 },
    { city: "Nairobi, Kenya", lng: 36.8219, lat: -1.2921 },
    { city: "Kampala, Uganda", lng: 32.5825, lat: 0.3476 },
    { city: "Dar es Salaam, Tanzania", lng: 39.2083, lat: -6.7924 },
    { city: "Kigali, Rwanda", lng: 30.0588, lat: -1.9499 },
    { city: "Lagos, Nigeria", lng: 3.3792, lat: 6.5244 },
    { city: "Accra, Ghana", lng: -0.1869, lat: 5.6037 },
    { city: "Abidjan, Côte d'Ivoire", lng: -4.0083, lat: 5.3599 },
    { city: "Dakar, Senegal", lng: -17.4731, lat: 14.7167 },
    { city: "Kinshasa, DR Congo", lng: 15.2663, lat: -4.4419 },
    { city: "Luanda, Angola", lng: 13.2344, lat: -8.8383 },
    { city: "Johannesburg, South Africa", lng: 28.0473, lat: -26.2041 },
    { city: "Cape Town, South Africa", lng: 18.4241, lat: -33.9249 },
    { city: "Windhoek, Namibia", lng: 17.0832, lat: -22.5609 },
    { city: "Gaborone, Botswana", lng: 25.9089, lat: -24.6282 },
    { city: "Harare, Zimbabwe", lng: 31.0530, lat: -17.8249 },
    { city: "Maputo, Mozambique", lng: 32.5732, lat: -25.9692 },
    { city: "Riyadh, Saudi Arabia", lng: 46.6753, lat: 24.7136 },
    { city: "Jeddah, Saudi Arabia", lng: 39.1979, lat: 21.4858 },
    { city: "Doha, Qatar", lng: 51.5310, lat: 25.2854 },
    { city: "Dubai, UAE", lng: 55.2708, lat: 25.2048 },
    { city: "Muscat, Oman", lng: 58.4059, lat: 23.5859 },
    { city: "Kuwait City, Kuwait", lng: 47.9783, lat: 29.3759 },
    { city: "Manama, Bahrain", lng: 50.5861, lat: 26.2285 },
    { city: "Tehran, Iran", lng: 51.3890, lat: 35.6892 },
    { city: "Baghdad, Iraq", lng: 44.3661, lat: 33.3152 },
    { city: "Amman, Jordan", lng: 35.9239, lat: 31.9522 },
    { city: "Beirut, Lebanon", lng: 35.5018, lat: 33.8938 },
    { city: "Jerusalem", lng: 35.2137, lat: 31.7683 },
    { city: "Mumbai, India", lng: 72.8777, lat: 19.0760 },
    { city: "Delhi, India", lng: 77.1025, lat: 28.7041 },
    { city: "Bengaluru, India", lng: 77.5946, lat: 12.9716 },
    { city: "Hyderabad, India", lng: 78.4867, lat: 17.3850 },
    { city: "Chennai, India", lng: 80.2707, lat: 13.0827 },
    { city: "Kolkata, India", lng: 88.3639, lat: 22.5726 },
    { city: "Kathmandu, Nepal", lng: 85.3240, lat: 27.7172 },
    { city: "Dhaka, Bangladesh", lng: 90.4125, lat: 23.8103 },
    { city: "Colombo, Sri Lanka", lng: 79.8612, lat: 6.9271 },
    { city: "Bangkok, Thailand", lng: 100.5018, lat: 13.7563 },
    { city: "Chiang Mai, Thailand", lng: 98.9931, lat: 18.7883 },
    { city: "Vientiane, Laos", lng: 102.6341, lat: 17.9757 },
    { city: "Phnom Penh, Cambodia", lng: 104.9282, lat: 11.5564 },
    { city: "Ho Chi Minh City, Vietnam", lng: 106.6297, lat: 10.8231 },
    { city: "Hanoi, Vietnam", lng: 105.8342, lat: 21.0278 },
    { city: "Yangon, Myanmar", lng: 96.1951, lat: 16.8409 },
    { city: "Singapore", lng: 103.8198, lat: 1.3521 },
    { city: "Kuala Lumpur, Malaysia", lng: 101.6869, lat: 3.1390 },
    { city: "Jakarta, Indonesia", lng: 106.8456, lat: -6.2088 },
    { city: "Surabaya, Indonesia", lng: 112.7521, lat: -7.2575 },
    { city: "Manila, Philippines", lng: 120.9842, lat: 14.5995 },
    { city: "Cebu, Philippines", lng: 123.8854, lat: 10.3157 },
    { city: "Hong Kong", lng: 114.1694, lat: 22.3193 },
    { city: "Macau", lng: 113.5439, lat: 22.1987 },
    { city: "Taipei, Taiwan", lng: 121.5654, lat: 25.0330 },
    { city: "Seoul, South Korea", lng: 126.9780, lat: 37.5665 },
    { city: "Busan, South Korea", lng: 129.0756, lat: 35.1796 },
    { city: "Tokyo, Japan", lng: 139.6917, lat: 35.6895 },
    { city: "Osaka, Japan", lng: 135.5023, lat: 34.6937 },
    { city: "Nagoya, Japan", lng: 136.9066, lat: 35.1815 },
    { city: "Sapporo, Japan", lng: 141.3544, lat: 43.0618 },
    { city: "Beijing, China", lng: 116.4074, lat: 39.9042 },
    { city: "Shanghai, China", lng: 121.4737, lat: 31.2304 },
    { city: "Guangzhou, China", lng: 113.2644, lat: 23.1291 },
    { city: "Shenzhen, China", lng: 114.0579, lat: 22.5431 },
    { city: "Chengdu, China", lng: 104.0665, lat: 30.5728 },
    { city: "Xi'an, China", lng: 108.9398, lat: 34.3416 },
    { city: "Ulaanbaatar, Mongolia", lng: 106.9057, lat: 47.8864 },
    { city: "Almaty, Kazakhstan", lng: 76.8860, lat: 43.2389 },
    { city: "Bishkek, Kyrgyzstan", lng: 74.5698, lat: 42.8746 },
    { city: "Tashkent, Uzbekistan", lng: 69.2401, lat: 41.2995 },
    { city: "Astana, Kazakhstan", lng: 71.4704, lat: 51.1605 },
    { city: "Moscow, Russia", lng: 37.6173, lat: 55.7558 },
    { city: "Saint Petersburg, Russia", lng: 30.3351, lat: 59.9343 },
    { city: "Novosibirsk, Russia", lng: 82.9346, lat: 55.0084 },
    { city: "Yekaterinburg, Russia", lng: 60.5975, lat: 56.8389 },
    { city: "Perth, Australia", lng: 115.8575, lat: -31.9505 },
    { city: "Adelaide, Australia", lng: 138.6007, lat: -34.9285 },
    { city: "Melbourne, Australia", lng: 144.9631, lat: -37.8136 },
    { city: "Sydney, Australia", lng: 151.2093, lat: -33.8688 },
    { city: "Brisbane, Australia", lng: 153.0251, lat: -27.4698 },
    { city: "Hobart, Australia", lng: 147.3272, lat: -42.8821 },
    { city: "Auckland, New Zealand", lng: 174.7633, lat: -36.8485 },
    { city: "Wellington, New Zealand", lng: 174.7762, lat: -41.2865 },
    { city: "Christchurch, New Zealand", lng: 172.6362, lat: -43.5321 },
    { city: "Suva, Fiji", lng: 178.4419, lat: -18.1248 }
  ];
  const SINGLE_VENUE_POSTS = 400;
  const singleVenueSpecs = singleVenueBases.map(base => ({
    city: base.city,
    baseLng: base.lng,
    baseLat: base.lat,
    neighborhoods: buildNeighborhoods(base.city, base.lng, base.lat),
    generated: 0
  }));
  let singlePool = shufflePool(singleVenueSpecs.map((_, idx) => idx));
  let singlePoolIndex = 0;
  let singleProduced = 0;
  const SINGLE_ATTEMPT_MAX = SINGLE_VENUE_POSTS * 8;
  let singleAttempts = 0;
  while(singleProduced < SINGLE_VENUE_POSTS && singlePool.length && singleAttempts < SINGLE_ATTEMPT_MAX){
    if(singlePoolIndex >= singlePool.length){
      const available = singlePool.filter(idx => canAddCity(singleVenueSpecs[idx].city));
      singlePool = shufflePool(available);
      singlePoolIndex = 0;
      if(!singlePool.length){
        break;
      }
    }
    const specIndex = singlePool[singlePoolIndex++];
    const spec = singleVenueSpecs[specIndex];
    singleAttempts++;
    if(!spec || !canAddCity(spec.city)){
      continue;
    }
    const neighborhoods = spec.neighborhoods && spec.neighborhoods.length
      ? spec.neighborhoods
      : buildNeighborhoods(spec.city, spec.baseLng, spec.baseLat);
    const generation = spec.generated || 0;
    const venueIndex = generation % neighborhoods.length;
    const cycle = Math.floor(generation / neighborhoods.length) + 1;
    spec.generated = generation + 1;
    const basePoint = neighborhoods[venueIndex] || neighborhoods[0];
    let coords = jitterNeighborhoodPoint(basePoint);
    let key = coordKey(coords.lng, coords.lat);
    let coordAttempts = 0;
    while((!key || existingCoordKeys.has(key)) && coordAttempts < 20){
      coords = jitterNeighborhoodPoint(basePoint);
      key = coordKey(coords.lng, coords.lat);
      coordAttempts++;
    }
    if(!key || existingCoordKeys.has(key)){
      continue;
    }
    const venueName = `${spec.city} Solo Venue ${cycle}-${venueIndex + 1}`;
    const locationDetail = createRandomLocation(spec.city, coords.lng, coords.lat, {
      name: venueName,
      address: spec.city,
      radius: 0
    });
    const finalKey = coordKey(locationDetail.lng, locationDetail.lat);
    if(finalKey){
      existingCoordKeys.add(finalKey);
    }
    const cat = pick(categories);
    const sub = pick(cat.subs);
    const id = `SV${singleProduced}`;
    const title = `${id} ${uniqueTitle(singleProduced*48271+131, spec.city, singleProduced)}`;
    const created = new Date().toISOString().replace(/[:.]/g,'-');
    pushPost({
      id,
      title,
      slug: slugify(title),
      created,
      city: spec.city,
      lng: locationDetail.lng,
      lat: locationDetail.lat,
      category: cat.name,
      subcategory: sub,
      dates: randomDates(),
      sponsored: true, // All posts are sponsored for development
      fav:false,
      desc: randomText(),
      images: randomImages(id),
      locations: [locationDetail],
      member: { username: randomUsername(id), avatar: randomAvatar(id) },
    });
    singleProduced++;
  }

  const MIN_MULTI_VENUE_DISTANCE_KM = 50;
  const MAX_MULTI_VENUE_DISTANCE_KM = 4000;
  const EARTH_RADIUS_KM = 6371;

  function toRadians(degrees){
    return (Number.isFinite(degrees) ? degrees : 0) * Math.PI / 180;
  }

  function haversineDistanceKm(a, b){
    if(!a || !b) return Infinity;
    const lat1 = toRadians(a.lat);
    const lat2 = toRadians(b.lat);
    const dLat = toRadians(b.lat - a.lat);
    const dLng = toRadians(b.lng - a.lng);
    const sinDLat = Math.sin(dLat / 2);
    const sinDLng = Math.sin(dLng / 2);
    const chord = sinDLat * sinDLat + Math.cos(lat1) * Math.cos(lat2) * sinDLng * sinDLng;
    const clampChord = Math.min(1, Math.max(0, chord));
    return 2 * EARTH_RADIUS_KM * Math.atan2(Math.sqrt(clampChord), Math.sqrt(1 - clampChord));
  }

  function buildMultiVenuePool(){
    const cityLookup = singleVenueBases.reduce((acc, base)=>{
      if(!base || !base.city) return acc;
      if(Number.isFinite(base.lng) && Number.isFinite(base.lat)){
        acc[base.city] = { lng: base.lng, lat: base.lat };
      }
      return acc;
    }, Object.create(null));

    const MULTI_REGION_CITY_LISTS = [
      {
        region: 'North America',
        cityNames: [
          'Anchorage, USA',
          'Honolulu, USA',
          'San Francisco, USA',
          'Seattle, USA',
          'Vancouver, Canada',
          'Calgary, Canada',
          'Toronto, Canada',
          'Montreal, Canada',
          'Boston, USA',
          'New Orleans, USA',
          'Chicago, USA',
          'Miami, USA',
          'Dallas, USA',
          'Denver, USA',
          'Phoenix, USA',
          'Los Angeles, USA'
        ]
      },
      {
        region: 'Central & South America',
        cityNames: [
          'Mexico City, Mexico',
          'Guadalajara, Mexico',
          'Bogotá, Colombia',
          'Lima, Peru',
          'Quito, Ecuador',
          'Santiago, Chile',
          'Buenos Aires, Argentina',
          'Montevideo, Uruguay',
          'São Paulo, Brazil',
          'Rio de Janeiro, Brazil',
          'Brasília, Brazil',
          'Recife, Brazil',
          'Fortaleza, Brazil',
          'Caracas, Venezuela',
          'San Juan, Puerto Rico'
        ]
      },
      {
        region: 'Europe',
        cityNames: [
          'Reykjavík, Iceland',
          'Oslo, Norway',
          'Stockholm, Sweden',
          'Helsinki, Finland',
          'Copenhagen, Denmark',
          'Edinburgh, UK',
          'Dublin, Ireland',
          'Glasgow, UK',
          'London, UK',
          'Manchester, UK',
          'Paris, France',
          'Lyon, France',
          'Marseille, France',
          'Madrid, Spain',
          'Barcelona, Spain',
          'Valencia, Spain',
          'Lisbon, Portugal',
          'Berlin, Germany',
          'Hamburg, Germany',
          'Munich, Germany',
          'Frankfurt, Germany',
          'Prague, Czechia',
          'Vienna, Austria',
          'Zurich, Switzerland',
          'Warsaw, Poland',
          'Kraków, Poland',
          'Budapest, Hungary',
          'Bucharest, Romania',
          'Athens, Greece'
        ]
      },
      {
        region: 'Africa',
        cityNames: [
          'Cairo, Egypt',
          'Casablanca, Morocco',
          'Marrakesh, Morocco',
          'Algiers, Algeria',
          'Tunis, Tunisia',
          'Tripoli, Libya',
          'Khartoum, Sudan',
          'Addis Ababa, Ethiopia',
          'Nairobi, Kenya',
          'Kampala, Uganda',
          'Dar es Salaam, Tanzania',
          'Kigali, Rwanda',
          'Lagos, Nigeria',
          'Accra, Ghana',
          "Abidjan, Côte d'Ivoire",
          'Dakar, Senegal',
          'Kinshasa, DR Congo',
          'Luanda, Angola',
          'Johannesburg, South Africa',
          'Cape Town, South Africa',
          'Windhoek, Namibia',
          'Gaborone, Botswana',
          'Harare, Zimbabwe',
          'Maputo, Mozambique'
        ]
      },
      {
        region: 'Middle East',
        cityNames: [
          'Riyadh, Saudi Arabia',
          'Jeddah, Saudi Arabia',
          'Doha, Qatar',
          'Dubai, UAE',
          'Muscat, Oman',
          'Kuwait City, Kuwait',
          'Manama, Bahrain',
          'Tehran, Iran',
          'Baghdad, Iraq',
          'Amman, Jordan',
          'Beirut, Lebanon',
          'Jerusalem'
        ]
      },
      {
        region: 'Asia',
        cityNames: [
          'Mumbai, India',
          'Delhi, India',
          'Bengaluru, India',
          'Hyderabad, India',
          'Chennai, India',
          'Kolkata, India',
          'Kathmandu, Nepal',
          'Dhaka, Bangladesh',
          'Colombo, Sri Lanka',
          'Bangkok, Thailand',
          'Chiang Mai, Thailand',
          'Vientiane, Laos',
          'Phnom Penh, Cambodia',
          'Ho Chi Minh City, Vietnam',
          'Hanoi, Vietnam',
          'Yangon, Myanmar',
          'Singapore',
          'Kuala Lumpur, Malaysia',
          'Jakarta, Indonesia',
          'Surabaya, Indonesia',
          'Manila, Philippines',
          'Cebu, Philippines',
          'Hong Kong',
          'Macau',
          'Taipei, Taiwan',
          'Seoul, South Korea',
          'Busan, South Korea',
          'Tokyo, Japan',
          'Osaka, Japan',
          'Nagoya, Japan',
          'Sapporo, Japan',
          'Beijing, China',
          'Shanghai, China',
          'Guangzhou, China',
          'Shenzhen, China',
          'Chengdu, China',
          "Xi'an, China",
          'Ulaanbaatar, Mongolia',
          'Almaty, Kazakhstan',
          'Bishkek, Kyrgyzstan',
          'Tashkent, Uzbekistan',
          'Astana, Kazakhstan',
          'Moscow, Russia',
          'Saint Petersburg, Russia',
          'Novosibirsk, Russia',
          'Yekaterinburg, Russia'
        ]
      },
      {
        region: 'Oceania',
        cityNames: [
          'Perth, Australia',
          'Adelaide, Australia',
          'Melbourne, Australia',
          'Sydney, Australia',
          'Brisbane, Australia',
          'Hobart, Australia',
          'Auckland, New Zealand',
          'Wellington, New Zealand',
          'Christchurch, New Zealand',
          'Suva, Fiji'
        ]
      }
    ];

    const deterministicOffset = (label, axis)=>{
      let hash = 0;
      for(let i = 0; i < label.length; i++){
        const charCode = label.charCodeAt(i);
        hash = (hash * 33 + charCode + (axis + 1) * 131) & 0xffffffff;
      }
      const normalized = ((hash % 2001) / 2000) - 0.5;
      return normalized * 0.002;
    };

    const pool = [];
    const seen = new Set();

    MULTI_REGION_CITY_LISTS.forEach(spec => {
      if(!spec || !spec.region || !Array.isArray(spec.cityNames)) return;
      spec.cityNames.forEach(cityName => {
        if(!cityName) return;
        const base = cityLookup[cityName];
        if(!base) return;
        const label = `${spec.region}:${cityName}`;
        let lng = normalizeLongitude(base.lng + deterministicOffset(label, 0));
        let lat = clampLatitude(base.lat + deterministicOffset(label, 1));
        let key = toVenueCoordKey(lng, lat);
        if(!key || seen.has(key)){
          let attempts = 0;
          let adjustment = 0.0003;
          while(attempts < 5 && key && seen.has(key)){
            const delta = adjustment * (attempts % 2 === 0 ? 1 : -1);
            lng = normalizeLongitude(base.lng + delta);
            lat = clampLatitude(base.lat + delta);
            key = toVenueCoordKey(lng, lat);
            attempts++;
            adjustment += 0.0001;
          }
          if((!key || seen.has(key)) && toVenueCoordKey(base.lng, base.lat) && !seen.has(toVenueCoordKey(base.lng, base.lat))){
            lng = normalizeLongitude(base.lng);
            lat = clampLatitude(base.lat);
            key = toVenueCoordKey(lng, lat);
          }
        }
        if(!key || seen.has(key)){
          return;
        }
        seen.add(key);
        pool.push({
          city: cityName,
          region: spec.region,
          lng,
          lat
        });
      });
    });
    return pool;
  }

  function shuffledIndices(length){
    const indices = Array.from({ length }, (_, idx) => idx);
    for(let i = indices.length - 1; i > 0; i--){
      const j = Math.floor(rnd() * (i + 1));
      const tmp = indices[i];
      indices[i] = indices[j];
      indices[j] = tmp;
    }
    return indices;
  }

  function assignMultiVenues(postList, targetCount){
    if(!Array.isArray(postList) || !postList.length || targetCount <= 0){
      return 0;
    }
    const pool = buildMultiVenuePool();
    if(pool.length < 2){
      return 0;
    }
    const venuesByRegion = pool.reduce((acc, venue) => {
      if(!venue) return acc;
      const key = venue.region || 'Global';
      if(!acc[key]) acc[key] = [];
      acc[key].push(venue);
      return acc;
    }, Object.create(null));
    const regionKeys = Object.keys(venuesByRegion).filter(key => Array.isArray(venuesByRegion[key]) && venuesByRegion[key].length >= 2);
    if(!regionKeys.length){
      return 0;
    }
    const sampleVenueSet = (regionKey, desiredCount)=>{
      const candidates = venuesByRegion[regionKey];
      if(!Array.isArray(candidates) || candidates.length < desiredCount){
        return null;
      }
      const maxAttempts = Math.max(20, candidates.length);
      for(let attempt = 0; attempt < maxAttempts; attempt++){
        const order = shuffledIndices(candidates.length);
        const selection = [];
        const used = new Set();
        for(let i = 0; i < order.length && selection.length < desiredCount; i++){
          const candidate = candidates[order[i]];
          if(!candidate) continue;
          const key = toVenueCoordKey(candidate.lng, candidate.lat);
          if(!key || used.has(key)) continue;
          let ok = true;
          for(let s = 0; s < selection.length; s++){
            const existing = selection[s];
            const distance = haversineDistanceKm(existing, candidate);
            if(distance < MIN_MULTI_VENUE_DISTANCE_KM || distance > MAX_MULTI_VENUE_DISTANCE_KM){
              ok = false;
              break;
            }
          }
          if(ok){
            selection.push(candidate);
            used.add(key);
          }
        }
        if(selection.length === desiredCount){
          return selection;
        }
      }
      return null;
    };
    const indices = shuffledIndices(postList.length);
    let assigned = 0;
    for(let idx = 0; idx < indices.length && assigned < targetCount; idx++){
      const post = postList[indices[idx]];
      if(!post){
        continue;
      }
      const desiredBase = 2 + Math.floor(rnd() * 3);
      let desired = desiredBase;
      let venues = null;
      let attempts = 0;
      while(attempts < 60 && !venues){
        const regionKey = regionKeys[Math.floor(rnd() * regionKeys.length)];
        venues = sampleVenueSet(regionKey, desired);
        if(!venues){
          attempts++;
          if(attempts % 10 === 0 && desired > 2){
            desired--;
          }
        }
      }
      if(!venues || venues.length < 2){
        for(let r = 0; r < regionKeys.length && (!venues || venues.length < 2); r++){
          venues = sampleVenueSet(regionKeys[r], 2);
        }
      }
      if(!venues || venues.length < 2){
        continue;
      }
      const nextLocations = venues.map((venue, venueIdx) => {
        const cityLabel = venue.city;
        const venueLabel = `${cityLabel} · Spot ${venueIdx + 1}`;
        return {
          venue: venueLabel,
          address: cityLabel,
          lng: venue.lng,
          lat: venue.lat,
          dates: randomSchedule(),
          price: randomPriceRange()
        };
      });
      post.locations = nextLocations;
      const primary = nextLocations[0];
      if(primary){
        post.lng = primary.lng;
        post.lat = primary.lat;
        post.city = primary.address || primary.venue || post.city;
      }
      assigned++;
    }
    return assigned;
  }

  assignMultiVenues(out, 1000);
  return out;
}

    let ALL_POSTS_CACHE = null;
    let ALL_POSTS_BY_ID = null;
    function rebuildAllPostsIndex(cache){
      if(!Array.isArray(cache)){
        ALL_POSTS_BY_ID = null;
        return;
      }
      const map = new Map();
      cache.forEach(item => {
        if(!item || item.id === undefined || item.id === null) return;
        map.set(String(item.id), item);
      });
      ALL_POSTS_BY_ID = map;
    }
    function getAllPostsCache(options = {}){
      const { allowInitialize = true } = options;
      if(Array.isArray(ALL_POSTS_CACHE)){
        return ALL_POSTS_CACHE;
      }
      if(!allowInitialize){
        return null;
      }
      ALL_POSTS_CACHE = makePosts();
      rebuildAllPostsIndex(ALL_POSTS_CACHE);
      return ALL_POSTS_CACHE;
    }
    function getPostByIdAnywhere(id){
      if(id === undefined || id === null) return null;
      const normalizedId = String(id);
      const checkList = (list) => {
        if(!Array.isArray(list)) return null;
        return list.find(entry => entry && String(entry.id) === normalizedId) || null;
      };
      const loaded = checkList(posts);
      if(loaded) return loaded;
      if(!ALL_POSTS_BY_ID || !(ALL_POSTS_BY_ID instanceof Map)){
        const cache = getAllPostsCache({ allowInitialize: true });
        if(Array.isArray(cache)){
          rebuildAllPostsIndex(cache);
        }
      }
      return ALL_POSTS_BY_ID instanceof Map ? (ALL_POSTS_BY_ID.get(normalizedId) || null) : null;
    }
    const EMPTY_FEATURE_COLLECTION = { type:'FeatureCollection', features: [] };

    const markerDataCache = {
      signature: null,
      postsData: EMPTY_FEATURE_COLLECTION,
      featureIndex: new Map()
    };

    function invalidateMarkerDataCache(){
      markerDataCache.signature = null;
      markerDataCache.postsData = EMPTY_FEATURE_COLLECTION;
      markerDataCache.featureIndex = new Map();
    }

    function markerSignatureForList(list){
      if(!Array.isArray(list) || !list.length){
        return 'empty';
      }
      const parts = [];
      list.forEach(post => {
        if(!post) return;
        const baseId = post.id || '';
        let added = false;
        if(Array.isArray(post.locations) && post.locations.length){
          post.locations.forEach((loc, idx) => {
            if(!loc) return;
            const key = toVenueCoordKey(loc.lng, loc.lat);
            if(!key) return;
            parts.push(`${baseId}#${idx}:${key}`);
            added = true;
          });
        }
        if(!added){
          const key = toVenueCoordKey(post.lng, post.lat);
          if(key){
            parts.push(`${baseId}:${key}`);
          } else {
            parts.push(String(baseId));
          }
        }
      });
      parts.sort();
      return parts.join('|');
    }

    function buildMarkerFeatureIndex(postsData){
      const index = new Map();
      const features = Array.isArray(postsData?.features) ? postsData.features : [];
      features.forEach(feature => {
        if(!feature || !feature.properties) return;
        const props = feature.properties;
        const baseId = props.id;
        if(baseId === undefined || baseId === null) return;
        const fid = feature.id ?? props.featureId;
        if(fid === undefined || fid === null) return;
        let venueKey = '';
        if(props.venueKey !== undefined && props.venueKey !== null){
          const venueString = String(props.venueKey).trim();
          venueKey = venueString;
        } else if(typeof fid === 'string'){
          const parts = fid.split('::');
          if(parts.length >= 3){
            venueKey = String(parts[1] || '');
          }
        }
        const rawSpriteId = props.labelSpriteId ?? props.spriteId ?? '';
        const spriteId = rawSpriteId !== undefined && rawSpriteId !== null ? String(rawSpriteId) : '';
        const ids = new Set();
        ids.add(String(baseId));
        if(Array.isArray(props.multiPostIds)){
          props.multiPostIds.forEach(postId => {
            if(postId === undefined || postId === null) return;
            const strId = String(postId);
            if(strId) ids.add(strId);
          });
        }
        ids.forEach(idValue => {
          if(!index.has(idValue)){
            index.set(idValue, []);
          }
          index.get(idValue).push({ source: 'posts', id: fid, venueKey, spriteId });
        });
      });
      return index;
    }

    function getMarkerCollections(list){
      const signature = markerSignatureForList(list);
      if(markerDataCache.signature === signature && markerDataCache.postsData){
        return {
          postsData: markerDataCache.postsData,
          signature,
          changed: false,
          featureIndex: markerDataCache.featureIndex
        };
      }
      if(!Array.isArray(list) || !list.length){
        markerDataCache.signature = signature;
        markerDataCache.postsData = EMPTY_FEATURE_COLLECTION;
        markerDataCache.featureIndex = new Map();
        return {
          postsData: EMPTY_FEATURE_COLLECTION,
          signature,
          changed: true,
          featureIndex: markerDataCache.featureIndex
        };
      }
      const postsData = postsToGeoJSON(list);
      markerDataCache.signature = signature;
      markerDataCache.postsData = postsData;
      markerDataCache.featureIndex = buildMarkerFeatureIndex(postsData);
      return { postsData, signature, changed: true, featureIndex: markerDataCache.featureIndex };
    }

    function syncMarkerSources(list, options = {}){
      const { force = false } = options;
      const collections = getMarkerCollections(list);
      const { postsData, signature, featureIndex } = collections;
      markerFeatureIndex = featureIndex instanceof Map ? featureIndex : new Map();
      let updated = false;
      if(map && typeof map.getSource === 'function'){
        const postsSource = map.getSource('posts');
        if(postsSource && (force || postsSource.__markerSignature !== signature)){
          try{ postsSource.setData(postsData); }catch(err){ console.error(err); }
          postsSource.__markerSignature = signature;
          updated = true;
        }
      }
      if(updated || force){
        updateMapFeatureHighlights(lastHighlightedPostIds);
      }
      return { updated, signature };
    }

    let postsLoaded = false;
    window.postsLoaded = postsLoaded;
    let waitForInitialZoom = window.waitForInitialZoom ?? (firstVisit ? true : false);
    let initialZoomStarted = false;
    let postLoadRequested = false;
    let lastLoadedBoundsKey = null;
    window.waitForInitialZoom = waitForInitialZoom;
    let updatePostsButtonState = () => {};

    function boundsToKey(bounds, precision = 2){
      if(!bounds) return '';
      const west = typeof bounds.getWest === 'function' ? bounds.getWest() : bounds.west;
      const east = typeof bounds.getEast === 'function' ? bounds.getEast() : bounds.east;
      const south = typeof bounds.getSouth === 'function' ? bounds.getSouth() : bounds.south;
      const north = typeof bounds.getNorth === 'function' ? bounds.getNorth() : bounds.north;
      const fmt = (val) => Number.isFinite(val) ? val.toFixed(precision) : 'nan';
      return [west, south, east, north].map(fmt).join('|');
    }

    function normalizeBounds(bounds){
      if(!bounds) return null;
      if(typeof bounds.getWest === 'function'){
        return {
          west: bounds.getWest(),
          east: bounds.getEast(),
          south: bounds.getSouth(),
          north: bounds.getNorth()
        };
      }
      const { west, east, south, north } = bounds;
      if(!Number.isFinite(west) || !Number.isFinite(east) || !Number.isFinite(south) || !Number.isFinite(north)){
        return null;
      }
      return { west, east, south, north };
    }

    function expandBounds(bounds, padding = {}){
      const normalized = normalizeBounds(bounds);
      if(!normalized) return null;
      let latPad;
      let lngPad;
      if(typeof padding === 'number'){
        latPad = lngPad = padding;
      } else {
        const latCandidate = padding.lat ?? padding.latitude ?? padding.y ?? padding.vertical;
        const lngCandidate = padding.lng ?? padding.longitude ?? padding.x ?? padding.horizontal;
        latPad = Number.isFinite(latCandidate) ? latCandidate : 0.25;
        lngPad = Number.isFinite(lngCandidate) ? lngCandidate : 0.25;
      }
      latPad = Math.max(0, latPad);
      lngPad = Math.max(0, lngPad);
      let { west, east, south, north } = normalized;
      west = Math.max(-180, west - lngPad);
      east = Math.min(180, east + lngPad);
      const clampLat = (value) => Math.max(-85, Math.min(85, value));
      south = clampLat(south - latPad);
      north = clampLat(north + latPad);
      return { west, east, south, north };
    }

    function pointWithinBounds(lng, lat, bounds){
      if(!Number.isFinite(lng) || !Number.isFinite(lat) || !bounds){
        return false;
      }
      const { west, east, south, north } = bounds;
      if(!Number.isFinite(west) || !Number.isFinite(east) || !Number.isFinite(south) || !Number.isFinite(north)){
        return false;
      }
      const withinLat = lat >= Math.min(south, north) && lat <= Math.max(south, north);
      if(!withinLat) return false;
      if(west <= east){
        return lng >= west && lng <= east;
      }
      return lng >= west || lng <= east;
    }

    function clearLoadedPosts(){
      invalidateMarkerDataCache();
      if(postsLoaded){
        postsLoaded = false;
        window.postsLoaded = postsLoaded;
      }
      lastLoadedBoundsKey = null;
      posts = [];
      filtered = [];
      if(typeof sortedPostList !== 'undefined'){ sortedPostList = []; }
      if(typeof renderedPostCount !== 'undefined'){ renderedPostCount = 0; }
      if(typeof postBatchObserver !== 'undefined' && postBatchObserver){
        try{ postBatchObserver.disconnect(); }catch(err){}
        postBatchObserver = null;
      }
      if(typeof postSentinel !== 'undefined' && postSentinel && postSentinel.remove){
        postSentinel.remove();
        postSentinel = null;
      }
      if(typeof adTimer !== 'undefined' && adTimer){
        clearInterval(adTimer);
        adTimer = null;
      }
      if(typeof adPosts !== 'undefined'){ adPosts = []; }
      if(typeof adIdsKey !== 'undefined'){ adIdsKey = ''; }
      const adPanelEl = typeof document !== 'undefined' ? document.querySelector('.ad-panel') : null;
      if(adPanelEl){ adPanelEl.innerHTML = ''; }
      const resultsElLocal = $('#results');
      if(resultsElLocal){ resultsElLocal.innerHTML = ''; }
      const postsBoardEl = $('.post-board');
      if(postsBoardEl){ postsBoardEl.innerHTML = ''; }
      hideResultIndicators();
      if(typeof updateResetBtn === 'function'){ updateResetBtn(); }
      if(map){
        const postsSource = map.getSource && map.getSource('posts');
        if(postsSource && typeof postsSource.setData === 'function'){
          postsSource.setData(EMPTY_FEATURE_COLLECTION);
          postsSource.__markerSignature = null;
        }
      }
      updateLayerVisibility(lastKnownZoom);
    }

    function loadPosts(bounds){
      if(spinning){
        pendingPostLoad = true;
        return;
      }
      const normalized = normalizeBounds(bounds);
      if(!normalized){
        postLoadRequested = true;
        hideResultIndicators();
        return;
      }
      const key = boundsToKey(normalized);
      if(postsLoaded && lastLoadedBoundsKey === key){
        applyFilters();
        return;
      }
      const cache = getAllPostsCache();
      const nextPosts = Array.isArray(cache)
        ? cache.filter(p => pointWithinBounds(p.lng, p.lat, normalized))
        : [];
      posts = nextPosts;
      postsLoaded = true;
      window.postsLoaded = postsLoaded;
      lastLoadedBoundsKey = key;
      rebuildVenueIndex();
      invalidateMarkerDataCache();
      resetBalloonSourceState();
      if(markersLoaded && map && Object.keys(subcategoryMarkers).length){ addPostSource(); }
      initAdBoard();
      applyFilters();
      updateLayerVisibility(lastKnownZoom);
    }

    let markerLayersVisible = false;
    let pendingZoomCheckToken = null;
    let pendingZoomEvent = null;

    function getZoomFromEvent(event){
      if(event){
        if(typeof event.zoom === 'number'){ return event.zoom; }
        const target = event.target && typeof event.target.getZoom === 'function' ? event.target : null;
        if(target){
          try{ return target.getZoom(); }catch(err){ return NaN; }
        }
      }
      if(map && typeof map.getZoom === 'function'){
        try{ return map.getZoom(); }catch(err){ return NaN; }
      }
      return NaN;
    }

    function setLayerVisibility(id, visible){
      if(!map || typeof map.getLayer !== 'function') return;
      let layer = null;
      try{ layer = map.getLayer(id); }catch(err){ layer = null; }
      if(!layer) return;
      const desired = visible ? 'visible' : 'none';
      try{
        const current = map.getLayoutProperty(id, 'visibility');
        if(current !== desired){
          map.setLayoutProperty(id, 'visibility', desired);
        }
      }catch(err){
        try{ map.setLayoutProperty(id, 'visibility', desired); }catch(e){}
      }
    }

    function updateMarkerZoomClasses(zoom){
      if(!map || typeof map.getContainer !== 'function') return;
      const container = map.getContainer();
      if(!container || !container.classList) return;
      const zoomValue = Number.isFinite(zoom) ? zoom : getZoomFromEvent();
      const isMidZoom = Number.isFinite(zoomValue) && zoomValue >= MARKER_ZOOM_THRESHOLD && zoomValue < MARKER_SPRITE_ZOOM;
      const isSpriteZoom = Number.isFinite(zoomValue) && zoomValue >= MARKER_SPRITE_ZOOM;
      container.classList.toggle(MID_ZOOM_MARKER_CLASS, isMidZoom);
      container.classList.toggle(SPRITE_MARKER_CLASS, isSpriteZoom);
    }

    function updateLayerVisibility(zoom){
      const zoomValue = Number.isFinite(zoom) ? zoom : getZoomFromEvent();
      const zoomBucket = Number.isFinite(zoomValue)
        ? Math.floor((zoomValue + 1e-6) * ZOOM_VISIBILITY_PRECISION)
        : NaN;
      const hasBucket = Number.isFinite(zoomBucket);
      const shouldShowMarkers = hasBucket ? zoomBucket >= MARKER_VISIBILITY_BUCKET : markerLayersVisible;
      const shouldShowBalloons = hasBucket ? zoomBucket < MARKER_VISIBILITY_BUCKET : balloonLayersVisible;
      if(markerLayersVisible !== shouldShowMarkers){
        MARKER_LAYER_IDS.forEach(id => setLayerVisibility(id, shouldShowMarkers));
        markerLayersVisible = shouldShowMarkers;
      }
      if(balloonLayersVisible !== shouldShowBalloons){
        BALLOON_LAYER_IDS.forEach(id => setLayerVisibility(id, shouldShowBalloons));
        balloonLayersVisible = shouldShowBalloons;
      }
      if(shouldShowBalloons && Number.isFinite(zoomValue)){
        updateBalloonSourceForZoom(zoomValue);
      }
    }

    function updateZoomState(zoom){
      if(Number.isFinite(zoom)){
        lastKnownZoom = zoom;
      } else {
        const current = getZoomFromEvent();
        if(Number.isFinite(current)){
          lastKnownZoom = current;
        }
      }
      updatePostsButtonState(lastKnownZoom);
      updateLayerVisibility(lastKnownZoom);
      updateMarkerZoomClasses(lastKnownZoom);
      updateBalloonSourceForZoom(lastKnownZoom);
      if(map && Number.isFinite(lastKnownZoom) && lastKnownZoom >= MARKER_SPRITE_ZOOM){
        map.__retainAllMarkerSprites = true;
      }
      if(!markersLoaded){
        const preloadCandidate = Number.isFinite(lastKnownZoom) ? lastKnownZoom : getZoomFromEvent();
        if(Number.isFinite(preloadCandidate) && preloadCandidate >= MARKER_PRELOAD_ZOOM){
          try{ loadPostMarkers(); }catch(err){ console.error(err); }
          markersLoaded = true;
          window.__markersLoaded = true;
        }
      }
    }

    function scheduleCheckLoadPosts(event){
      pendingZoomEvent = event || { zoom: lastKnownZoom, target: map };
      if(pendingZoomCheckToken !== null) return;
      const scheduler = typeof requestAnimationFrame === 'function' ? requestAnimationFrame : (cb)=> setTimeout(cb, 0);
      pendingZoomCheckToken = scheduler(()=>{
        pendingZoomCheckToken = null;
        const evt = pendingZoomEvent;
        pendingZoomEvent = null;
        checkLoadPosts(evt);
      });
    }

    function checkLoadPosts(event){
      if(!map) return;
      const zoomCandidate = getZoomFromEvent(event);
      updateZoomState(zoomCandidate);
      let zoomLevel = Number.isFinite(zoomCandidate) ? zoomCandidate : lastKnownZoom;
      if(!Number.isFinite(zoomLevel)){
        zoomLevel = getZoomFromEvent();
      }
      if(waitForInitialZoom){
        if(Number.isFinite(zoomLevel) && zoomLevel >= MARKER_PRELOAD_ZOOM){
          waitForInitialZoom = false;
          window.waitForInitialZoom = waitForInitialZoom;
          initialZoomStarted = false;
        } else {
          postLoadRequested = true;
          hideResultIndicators();
          return;
        }
      }
      if(!Number.isFinite(zoomLevel)){
        postLoadRequested = true;
        hideResultIndicators();
        return;
      }
      updatePostsButtonState(zoomLevel);
      if(Number.isFinite(zoomLevel) && zoomLevel < MARKER_PRELOAD_ZOOM){
        postLoadRequested = true;
        if(postsLoaded || (Array.isArray(posts) && posts.length)){ clearLoadedPosts(); }
        hideResultIndicators();
        return;
      }
      if(spinning){
        pendingPostLoad = true;
        hideResultIndicators();
        return;
      }
      postLoadRequested = false;
      const bounds = typeof map.getBounds === 'function' ? map.getBounds() : null;
      if(!bounds){
        postLoadRequested = true;
        hideResultIndicators();
        return;
      }
      loadPosts(bounds);
    }

    const resultsEl = $('#results');
    const postsWideEl = $('.post-board');
    const postsModeEl = $('.post-board');

    let sortedPostList = [];
    let renderedPostCount = 0;
    let postBatchObserver = null;
    let postSentinel = null;
    let postBoardScrollOptions = null;
    const INITIAL_RENDER_COUNT = 50;
    const POST_BATCH_SIZE = 25;

    function appendPostBatch(count = POST_BATCH_SIZE){
      const slice = sortedPostList.slice(renderedPostCount, renderedPostCount + count);
      slice.forEach(p => {
        if(resultsEl){
          const rCard = card(p);
          if(activePostId && p.id === activePostId) rCard.setAttribute('aria-selected','true');
          resultsEl.appendChild(rCard);
        }
        const wCard = card(p, true);
        postsWideEl.insertBefore(wCard, postSentinel);
      });
      renderedPostCount += slice.length;
      if(renderedPostCount >= sortedPostList.length){
        if(postBatchObserver) postBatchObserver.disconnect();
        removeScrollListener(postsWideEl, onPostBoardScroll, postBoardScrollOptions);
        postBoardScrollOptions = null;
      }
      prioritizeVisibleImages();
    }

    function onPostBoardScroll(){
      if(postsWideEl.scrollTop + postsWideEl.clientHeight >= postsWideEl.scrollHeight - 200){
        appendPostBatch();
      }
    }

    // Image helpers (reuse shared utilities)

    function memberAvatarUrl(p){
      if(p.member && p.member.avatar){
        return p.member.avatar;
      }
      return 'assets/balloons/birthday-party-png-45917-100.png';
    }

    function mapCardHTML(p, opts={}){
      const overrideKey = typeof opts.venueKey === 'string' && opts.venueKey ? opts.venueKey : null;
      const prevKey = selectedVenueKey;
      if(overrideKey){
        selectedVenueKey = overrideKey;
      }
      try{
        const venueName = getPrimaryVenueName(p) || p.city;
        const labelLines = getMarkerLabelLines(p);
        const cardTitleLines = Array.isArray(labelLines.cardTitleLines) && labelLines.cardTitleLines.length
          ? labelLines.cardTitleLines.slice(0, 2)
          : [labelLines.line1, labelLines.line2].filter(Boolean).slice(0, 2);
        const normalizedTitleLines = cardTitleLines.slice(0, 2);
        const firstTitleLine = normalizedTitleLines[0] || '';
        const hasSecondTitleLine = Boolean((normalizedTitleLines[1] || '').trim());
        const displayTitleLines = hasSecondTitleLine ? normalizedTitleLines : [firstTitleLine];
        const titleHtml = displayTitleLines
          .map(line => `<div class="map-card-title-line">${line}</div>`)
          .join('');
        const venueLine = labelLines.venueLine || shortenMarkerLabelText(venueName, mapCardTitleWidthPx);
        const venueHtml = venueLine ? `<div class="map-card-venue">${venueLine}</div>` : '';
        const labelClasses = ['map-card-label'];
        if(!hasSecondTitleLine){
          labelClasses.push('map-card-label--single-line');
        }
        const labelHtml = `<div class="${labelClasses.join(' ')}"><div class="map-card-title">${titleHtml}</div>${venueHtml}</div>`;
        const classes = ['big-map-card'];
        const extraClasses = Array.isArray(opts.extraClasses) ? opts.extraClasses : (opts.extraClass ? [opts.extraClass] : []);
        const variant = opts.variant || 'popup';
        if(variant === 'popup') classes.push('big-map-card--popup');
        if(variant === 'list') classes.push('big-map-card--list');
        extraClasses.filter(Boolean).forEach(cls => classes.push(cls));
        if(variant === 'list'){
          return `<div class="${classes.join(' ')}" data-id="${p.id}"><img class="map-card-thumb" src="${thumbUrl(p)}" alt="" referrerpolicy="no-referrer" />${labelHtml}</div>`;
        }
        return `<div class="${classes.join(' ')}" data-id="${p.id}"><img class="map-card-pill" src="assets/icons-30/225x60-pill-99.webp" alt="" /><img class="map-card-thumb" src="${thumbUrl(p)}" alt="" referrerpolicy="no-referrer" />${labelHtml}</div>`;
      } finally {
        if(overrideKey){
          selectedVenueKey = prevKey;
        }
      }
    }

    function hoverHTML(p){
      return mapCardHTML(p);
    }

    // Categories UI
    const categoryControllers = {};
    const allSubcategoryKeys = [];
    const resetCategoriesBtn = $('#resetCategoriesBtn');
    const catsEl = $('#cats');
    const formbuilderCats = document.getElementById('formbuilderCats');
    const formbuilderAddCategoryBtn = document.getElementById('formbuilderAddCategory');
    let formbuilderConfirmOverlay = null;
    let categoryDragContainerInitialized = false;
    let draggedCategoryMenu = null;
    let categoryDropIndicatorTarget = null;
    let categoryDropIndicatorClass = '';
    let categoryDropCommitted = false;
    let draggedSubcategoryMenu = null;
    let draggedSubcategoryContainer = null;
    const subcategoryContainerState = new WeakMap();

    function clearCategoryDropIndicator(){
      if(categoryDropIndicatorTarget){
        categoryDropIndicatorTarget.classList.remove('drag-target-before','drag-target-after');
        categoryDropIndicatorTarget = null;
        categoryDropIndicatorClass = '';
      }
    }

    function updateCategoryDropIndicator(target, before){
      if(!target) return;
      const cls = before ? 'drag-target-before' : 'drag-target-after';
      if(categoryDropIndicatorTarget && categoryDropIndicatorTarget !== target){
        categoryDropIndicatorTarget.classList.remove('drag-target-before','drag-target-after');
      }
      if(categoryDropIndicatorTarget !== target || categoryDropIndicatorClass !== cls){
        target.classList.remove('drag-target-before','drag-target-after');
        target.classList.add(cls);
        categoryDropIndicatorTarget = target;
        categoryDropIndicatorClass = cls;
      }
    }

    function captureChildPositions(container, selector){
      const map = new Map();
      if(!container) return map;
      container.querySelectorAll(selector).forEach(el=>{
        map.set(el, el.getBoundingClientRect());
      });
      return map;
    }

    function animateListReorder(container, selector, previousRects, exclude){
      if(!container || !previousRects || previousRects.size === 0) return;
      requestAnimationFrame(()=>{
        container.querySelectorAll(selector).forEach(el=>{
          if(el === exclude) return;
          const prevRect = previousRects.get(el);
          if(!prevRect) return;
          const nextRect = el.getBoundingClientRect();
          const dx = prevRect.left - nextRect.left;
          const dy = prevRect.top - nextRect.top;
          if(Math.abs(dx) < 0.5 && Math.abs(dy) < 0.5) return;
          el.style.transition = 'none';
          el.style.transform = `translate(${dx}px, ${dy}px)`;
          void el.offsetWidth;
          el.style.transition = 'transform 150ms ease';
          el.style.transform = '';
          const cleanup = ()=>{
            el.style.transition = '';
            el.style.transform = '';
            el.removeEventListener('transitionend', cleanup);
          };
          el.addEventListener('transitionend', cleanup);
        });
      });
    }

    function notifyFormbuilderChange(){
      if(!formbuilderCats) return;
      try{
        formbuilderCats.dispatchEvent(new Event('change', { bubbles: true }));
      }catch(err){
        const evt = document.createEvent('Event');
        evt.initEvent('change', true, true);
        formbuilderCats.dispatchEvent(evt);
      }
    }

    function syncCategoriesFromDom(){
      if(!formbuilderCats) return;
      const menuEls = Array.from(formbuilderCats.querySelectorAll('.category-form-menu'));
      if(menuEls.length !== categories.length) return;
      const used = new Set();
      const newOrder = [];
      menuEls.forEach(menu=>{
        const idx = Number.parseInt(menu.dataset.categoryIndex, 10);
        if(Number.isInteger(idx) && idx >= 0 && idx < categories.length && !used.has(idx)){
          newOrder.push(categories[idx]);
          used.add(idx);
          return;
        }
        const name = menu.dataset.category || '';
        const fallback = categories.findIndex((cat, index)=> cat && !used.has(index) && cat.name === name);
        if(fallback !== -1){
          newOrder.push(categories[fallback]);
          used.add(fallback);
        }
      });
      let changed = false;
      if(newOrder.length === categories.length){
        for(let i = 0; i < newOrder.length; i++){
          if(newOrder[i] !== categories[i]){
            changed = true;
            break;
          }
        }
        if(changed){
          categories.splice(0, categories.length, ...newOrder);
        }
      }
      menuEls.forEach((menu, index)=>{
        menu.dataset.categoryIndex = String(index);
      });
      if(changed){
        notifyFormbuilderChange();
      }
    }

    function ensureCategoryDragContainer(){
      if(categoryDragContainerInitialized || !formbuilderCats) return;
      categoryDragContainerInitialized = true;
      formbuilderCats.addEventListener('dragover', event=>{
        if(!draggedCategoryMenu || draggedSubcategoryMenu){
          return;
        }
        event.preventDefault();
        if(event.dataTransfer){
          event.dataTransfer.dropEffect = 'move';
        }
        const target = event.target.closest('.category-form-menu');
        if(!target){
          clearCategoryDropIndicator();
          if(draggedCategoryMenu && draggedCategoryMenu !== formbuilderCats.lastElementChild){
            const beforeRects = captureChildPositions(formbuilderCats, '.category-form-menu');
            formbuilderCats.appendChild(draggedCategoryMenu);
            animateListReorder(formbuilderCats, '.category-form-menu', beforeRects, draggedCategoryMenu);
          }
          return;
        }
        if(target === draggedCategoryMenu){
          clearCategoryDropIndicator();
          return;
        }
        const rect = target.getBoundingClientRect();
        const before = event.clientY < rect.top + rect.height / 2;
        updateCategoryDropIndicator(target, before);
        const reference = before ? target : target.nextSibling;
        if((before && draggedCategoryMenu.nextElementSibling === target) || (!before && target.nextElementSibling === draggedCategoryMenu)){
          return;
        }
        if(reference !== draggedCategoryMenu){
          if(reference || formbuilderCats.lastElementChild !== draggedCategoryMenu){
            const beforeRects = captureChildPositions(formbuilderCats, '.category-form-menu');
            formbuilderCats.insertBefore(draggedCategoryMenu, reference);
            animateListReorder(formbuilderCats, '.category-form-menu', beforeRects, draggedCategoryMenu);
          }
        }
      });
      formbuilderCats.addEventListener('drop', event=>{
        if(!draggedCategoryMenu){
          return;
        }
        event.preventDefault();
        categoryDropCommitted = true;
        clearCategoryDropIndicator();
        syncCategoriesFromDom();
      });
      formbuilderCats.addEventListener('dragleave', event=>{
        if(!draggedCategoryMenu || draggedSubcategoryMenu) return;
        if(event.target === formbuilderCats){
          clearCategoryDropIndicator();
        }
      });
    }

    function clearSubDropIndicator(state){
      if(!state) return;
      if(state.dropIndicatorTarget){
        state.dropIndicatorTarget.classList.remove('drag-target-before','drag-target-after');
        state.dropIndicatorTarget = null;
        state.dropIndicatorClass = '';
      }
    }

    function updateSubDropIndicator(state, target, before){
      if(!state || !target) return;
      const cls = before ? 'drag-target-before' : 'drag-target-after';
      if(state.dropIndicatorTarget && state.dropIndicatorTarget !== target){
        state.dropIndicatorTarget.classList.remove('drag-target-before','drag-target-after');
      }
      if(state.dropIndicatorTarget !== target || state.dropIndicatorClass !== cls){
        target.classList.remove('drag-target-before','drag-target-after');
        target.classList.add(cls);
        state.dropIndicatorTarget = target;
        state.dropIndicatorClass = cls;
      }
    }

    function syncSubcategoryOrderFromDom(container, categoryObj){
      if(!container || !categoryObj) return;
      const subEls = Array.from(container.querySelectorAll('.subcategory-form-menu'));
      const original = Array.isArray(categoryObj.subs) ? categoryObj.subs.slice() : [];
      const used = new Set();
      const reordered = [];
      subEls.forEach(subMenu=>{
        const idx = Number.parseInt(subMenu.dataset.subIndex, 10);
        if(Number.isInteger(idx) && idx >= 0 && idx < original.length && !used.has(idx)){
          reordered.push(original[idx]);
          used.add(idx);
          return;
        }
        const name = subMenu.dataset.subcategory || '';
        const fallback = original.findIndex((subName, index)=> subName === name && !used.has(index));
        if(fallback !== -1){
          reordered.push(original[fallback]);
          used.add(fallback);
        }
      });
      let changed = false;
      if(reordered.length === original.length){
        for(let i = 0; i < reordered.length; i++){
          if(reordered[i] !== original[i]){
            changed = true;
            break;
          }
        }
        if(changed){
          categoryObj.subs = reordered;
        }
      }
      subEls.forEach((subMenu, index)=>{
        subMenu.dataset.subIndex = String(index);
      });
      if(changed){
        notifyFormbuilderChange();
      }
    }

    function setupSubcategoryContainer(container, categoryObj, addButton){
      if(!container) return null;
      let state = subcategoryContainerState.get(container);
      if(!state){
        state = {
          dropIndicatorTarget: null,
          dropIndicatorClass: '',
          dropCommitted: false,
          addButton: addButton,
          category: categoryObj
        };
        subcategoryContainerState.set(container, state);
        container.addEventListener('dragover', event=>{
          if(!draggedSubcategoryMenu || draggedSubcategoryContainer !== container) return;
          event.preventDefault();
          event.stopPropagation();
          if(event.dataTransfer){
            event.dataTransfer.dropEffect = 'move';
          }
          const target = event.target.closest('.subcategory-form-menu');
          if(!target || target === draggedSubcategoryMenu){
            clearSubDropIndicator(state);
            const anchor = state.addButton || null;
            if(anchor && draggedSubcategoryMenu !== anchor && draggedSubcategoryMenu.nextSibling !== anchor){
              const beforeRects = captureChildPositions(container, '.subcategory-form-menu');
              container.insertBefore(draggedSubcategoryMenu, anchor);
              animateListReorder(container, '.subcategory-form-menu', beforeRects, draggedSubcategoryMenu);
            }
            return;
          }
          const rect = target.getBoundingClientRect();
          const before = event.clientY < rect.top + rect.height / 2;
          updateSubDropIndicator(state, target, before);
          if((before && draggedSubcategoryMenu.nextElementSibling === target) || (!before && target.nextElementSibling === draggedSubcategoryMenu)){
            return;
          }
          let reference = before ? target : target.nextSibling;
          if(!reference || reference === state.addButton){
            reference = state.addButton;
          }
          if(reference !== draggedSubcategoryMenu){
            const beforeRects = captureChildPositions(container, '.subcategory-form-menu');
            container.insertBefore(draggedSubcategoryMenu, reference);
            animateListReorder(container, '.subcategory-form-menu', beforeRects, draggedSubcategoryMenu);
          }
        });
        container.addEventListener('drop', event=>{
          if(!draggedSubcategoryMenu || draggedSubcategoryContainer !== container) return;
          event.preventDefault();
          event.stopPropagation();
          state.dropCommitted = true;
          clearSubDropIndicator(state);
          syncSubcategoryOrderFromDom(container, state.category);
        });
        container.addEventListener('dragleave', event=>{
          if(!draggedSubcategoryMenu || draggedSubcategoryContainer !== container) return;
          if(event.target === container){
            clearSubDropIndicator(state);
          }
        });
      }
      state.addButton = addButton;
      state.category = categoryObj;
      return state;
    }

    function attachCategoryDragHandle(menu, handle){
      if(!menu || !handle) return;
      ensureCategoryDragContainer();
      handle.draggable = true;
      handle.addEventListener('click', event=> event.preventDefault());
      handle.addEventListener('keydown', event=>{
        if(event.key === ' ' || event.key === 'Enter'){
          event.preventDefault();
        }
      });
      handle.addEventListener('dragstart', event=>{
        event.stopPropagation();
        draggedCategoryMenu = menu;
        categoryDropCommitted = false;
        menu.classList.add('is-dragging');
        if(event.dataTransfer){
          event.dataTransfer.effectAllowed = 'move';
          try{ event.dataTransfer.setData('text/plain', menu.dataset.category || ''); }catch(err){}
          try{
            const rect = menu.getBoundingClientRect();
            event.dataTransfer.setDragImage(menu, rect.width / 2, rect.height / 2);
          }catch(err){}
        }
      });
      handle.addEventListener('dragend', event=>{
        event.stopPropagation();
        if(draggedCategoryMenu === menu){
          menu.classList.remove('is-dragging');
          draggedCategoryMenu = null;
        }
        clearCategoryDropIndicator();
        if(!categoryDropCommitted){
          syncCategoriesFromDom();
        }
        categoryDropCommitted = false;
      });
    }

    function attachSubcategoryDragHandle(subMenu, container, categoryObj, handle, addButton){
      if(!subMenu || !container || !handle) return;
      const state = setupSubcategoryContainer(container, categoryObj, addButton);
      handle.draggable = true;
      handle.addEventListener('click', event=> event.preventDefault());
      handle.addEventListener('keydown', event=>{
        if(event.key === ' ' || event.key === 'Enter'){
          event.preventDefault();
        }
      });
      handle.addEventListener('dragstart', event=>{
        event.stopPropagation();
        draggedSubcategoryMenu = subMenu;
        draggedSubcategoryContainer = container;
        if(state) state.dropCommitted = false;
        subMenu.classList.add('is-dragging');
        if(event.dataTransfer){
          event.dataTransfer.effectAllowed = 'move';
          try{ event.dataTransfer.setData('text/plain', subMenu.dataset.subcategory || ''); }catch(err){}
          try{
            const rect = subMenu.getBoundingClientRect();
            event.dataTransfer.setDragImage(subMenu, rect.width / 2, rect.height / 2);
          }catch(err){}
        }
      });
      handle.addEventListener('dragend', event=>{
        event.stopPropagation();
        if(draggedSubcategoryMenu === subMenu){
          subMenu.classList.remove('is-dragging');
          draggedSubcategoryMenu = null;
          draggedSubcategoryContainer = null;
        }
        if(state){
          clearSubDropIndicator(state);
          if(!state.dropCommitted){
            syncSubcategoryOrderFromDom(container, state.category);
          }
          state.dropCommitted = false;
        }
      });
    }

    function ensureFormbuilderConfirmOverlay(){
      if(formbuilderConfirmOverlay) return formbuilderConfirmOverlay;
      const overlay = document.createElement('div');
      overlay.id = 'formbuilderConfirmOverlay';
      overlay.className = 'formbuilder-confirm-overlay';
      overlay.setAttribute('aria-hidden', 'true');
      overlay.setAttribute('tabindex', '-1');

      const dialog = document.createElement('div');
      dialog.className = 'formbuilder-confirm-dialog';
      dialog.setAttribute('role', 'alertdialog');
      dialog.setAttribute('aria-modal', 'true');
      dialog.setAttribute('aria-labelledby', 'formbuilderConfirmTitle');
      dialog.setAttribute('aria-describedby', 'formbuilderConfirmMessage');

      const title = document.createElement('h2');
      title.id = 'formbuilderConfirmTitle';
      title.textContent = 'Delete item?';

      const message = document.createElement('p');
      message.id = 'formbuilderConfirmMessage';
      message.textContent = 'Are you sure you want to delete this item?';

      const actions = document.createElement('div');
      actions.className = 'formbuilder-confirm-actions';

      const cancelBtn = document.createElement('button');
      cancelBtn.type = 'button';
      cancelBtn.className = 'formbuilder-confirm-cancel';
      cancelBtn.textContent = 'Cancel';

      const deleteBtn = document.createElement('button');
      deleteBtn.type = 'button';
      deleteBtn.className = 'formbuilder-confirm-delete';
      deleteBtn.textContent = 'Delete';

      actions.append(cancelBtn, deleteBtn);
      dialog.append(title, message, actions);
      overlay.append(dialog);
      document.body.appendChild(overlay);
      formbuilderConfirmOverlay = overlay;
      return overlay;
    }

    function confirmFormbuilderDeletion(messageText, titleText){
      const overlay = ensureFormbuilderConfirmOverlay();
      const dialog = overlay.querySelector('.formbuilder-confirm-dialog');
      const title = dialog.querySelector('#formbuilderConfirmTitle');
      const message = dialog.querySelector('#formbuilderConfirmMessage');
      const cancelBtn = overlay.querySelector('.formbuilder-confirm-cancel');
      const deleteBtn = overlay.querySelector('.formbuilder-confirm-delete');
      title.textContent = titleText || 'Delete item?';
      message.textContent = messageText || 'Are you sure you want to delete this item?';
      overlay.setAttribute('aria-hidden', 'false');
      overlay.classList.add('visible');
      const previouslyFocused = document.activeElement;

      return new Promise(resolve=>{
        const cleanup = (result)=>{
          overlay.classList.remove('visible');
          overlay.setAttribute('aria-hidden', 'true');
          cancelBtn.removeEventListener('click', onCancel);
          deleteBtn.removeEventListener('click', onConfirm);
          window.removeEventListener('keydown', onKeyDown, true);
          overlay.removeEventListener('click', onOverlayClick);
          if(previouslyFocused && typeof previouslyFocused.focus === 'function'){
            try{
              previouslyFocused.focus({ preventScroll: true });
            }catch(err){
              try{ previouslyFocused.focus(); }catch(e){}
            }
          }
          resolve(result);
        };
        const onCancel = ()=> cleanup(false);
        const onConfirm = ()=> cleanup(true);
        const onOverlayClick = (event)=>{
          if(event.target === overlay){
            cleanup(false);
          }
        };
        const onKeyDown = (event)=>{
          if(event.key === 'Escape'){
            event.preventDefault();
            cleanup(false);
          }
        };

        cancelBtn.addEventListener('click', onCancel, { once: true });
        deleteBtn.addEventListener('click', onConfirm, { once: true });
        overlay.addEventListener('click', onOverlayClick);
        window.addEventListener('keydown', onKeyDown, true);

        requestAnimationFrame(()=>{
          try{
            cancelBtn.focus({ preventScroll: true });
          }catch(err){
            cancelBtn.focus();
          }
        });
      });
    }
    const refreshFormbuilderSubcategoryLogos = ()=>{
      if(!formbuilderCats) return;
      formbuilderCats.querySelectorAll('.subcategory-form-menu').forEach(menu=>{
        const logoSpan = menu.querySelector('.subcategory-logo');
        if(!logoSpan) return;
        const subName = menu.dataset.subcategory || '';
        const iconHtml = subcategoryIcons[subName] || '';
        logoSpan.innerHTML = '';
        if(iconHtml){
          logoSpan.innerHTML = iconHtml;
          logoSpan.classList.add('has-icon');
        } else {
          logoSpan.textContent = subName ? subName.charAt(0) : '';
          logoSpan.classList.remove('has-icon');
        }
      });
    };
    const renderFormbuilderCats = ()=>{
      if(!formbuilderCats) return;
      const normalizeIconPath = (path)=> {
        if(typeof path !== 'string') return path;
        let next = path.replace(/-30(\.[^./]+)$/i, '-20$1');
        if(/icons-30\//i.test(next)){
          next = next.replace(/icons-30\//i, 'icons-20/');
        }
        return next;
      };
      const frag = document.createDocumentFragment();
      categories.forEach((c, index)=>{
        const baseId = slugify(c.name) || `category-${index + 1}`;
        const contentId = `category-form-content-${baseId}-${index}`;
        const editPanelId = `category-edit-panel-${baseId}-${index}`;

        const menu = document.createElement('div');
        menu.className = 'category-form-menu filter-category-menu';
        menu.dataset.category = c.name;
        menu.dataset.categoryIndex = String(index);
        menu.setAttribute('role','group');
        menu.setAttribute('aria-expanded','false');

        const header = document.createElement('div');
        header.className = 'filter-category-header';

        const dragHandle = document.createElement('button');
        dragHandle.type = 'button';
        dragHandle.className = 'category-drag-handle';
        dragHandle.setAttribute('aria-label', `Reorder ${c.name} category`);
        const dragHandleIcon = document.createElement('span');
        dragHandleIcon.className = 'drag-handle-icon';
        dragHandleIcon.setAttribute('aria-hidden','true');
        dragHandleIcon.textContent = '⋮⋮';
        dragHandle.appendChild(dragHandleIcon);

        const triggerWrap = document.createElement('div');
        triggerWrap.className = 'options-dropdown filter-category-trigger-wrap';

        const menuBtn = document.createElement('button');
        menuBtn.type = 'button';
        menuBtn.className = 'filter-category-trigger';
        menuBtn.setAttribute('aria-haspopup','true');
        menuBtn.setAttribute('aria-expanded','false');
        menuBtn.setAttribute('aria-controls', contentId);

        const categoryLogo = document.createElement('span');
        categoryLogo.className = 'category-logo';
        const iconPrefix = (window.ICON_BASE || {})[c.name];
        if(iconPrefix){
          const img = document.createElement('img');
          img.src = `assets/icons-20/${iconPrefix}-20.webp`;
          img.width = 20;
          img.height = 20;
          img.alt = '';
          categoryLogo.appendChild(img);
          categoryLogo.classList.add('has-icon');
        } else {
          categoryLogo.textContent = c.name.charAt(0) || '';
        }

        const label = document.createElement('span');
        label.className = 'label';
        label.textContent = c.name;

        const arrow = document.createElement('span');
        arrow.className = 'dropdown-arrow';
        arrow.setAttribute('aria-hidden','true');

        menuBtn.append(categoryLogo, label, arrow);
        triggerWrap.append(menuBtn);

        const toggle = document.createElement('label');
        toggle.className = 'switch cat-switch';
        const toggleInput = document.createElement('input');
        toggleInput.type = 'checkbox';
        toggleInput.checked = true;
        toggleInput.setAttribute('aria-label', `Toggle ${c.name} category`);
        const toggleSlider = document.createElement('span');
        toggleSlider.className = 'slider';
        toggle.append(toggleInput, toggleSlider);

        header.append(dragHandle, triggerWrap, toggle);
        menu.append(header);

        const content = document.createElement('div');
        content.className = 'category-form-content';
        content.id = contentId;
        content.hidden = true;

        const editMenu = document.createElement('div');
        editMenu.className = 'category-edit-menu';

        const editWrap = document.createElement('div');
        editWrap.className = 'options-dropdown category-edit-trigger-wrap';

        const editBtn = document.createElement('button');
        editBtn.type = 'button';
        editBtn.className = 'category-edit-trigger';
        editBtn.textContent = 'Edit Category';
        const editArrow = document.createElement('span');
        editArrow.className = 'dropdown-arrow';
        editArrow.setAttribute('aria-hidden','true');
        editBtn.append(editArrow);
        editBtn.setAttribute('aria-expanded','false');
        editBtn.setAttribute('aria-controls', editPanelId);

        editWrap.append(editBtn);

        const editPanel = document.createElement('div');
        editPanel.className = 'category-edit-panel';
        editPanel.id = editPanelId;
        editPanel.hidden = true;

        const nameInput = document.createElement('input');
        nameInput.type = 'text';
        nameInput.className = 'category-name-input';
        nameInput.placeholder = 'Category Name';
        nameInput.value = c.name || '';

        const iconPicker = document.createElement('div');
        iconPicker.className = 'iconpicker-container';

        const uploadLabel = document.createElement('label');
        uploadLabel.className = 'iconpicker-upload';
        const uploadLabelText = document.createElement('span');
        uploadLabelText.textContent = 'Upload Icon';
        const uploadInput = document.createElement('input');
        uploadInput.type = 'file';
        uploadInput.accept = 'image/*';
        uploadInput.setAttribute('aria-label', `Upload icon for ${c.name}`);
        uploadLabel.append(uploadLabelText, uploadInput);

        const preview = document.createElement('div');
        preview.className = 'iconpicker-preview';
        const previewLabel = document.createElement('span');
        previewLabel.textContent = 'No Icon';
        const previewImg = document.createElement('img');
        previewImg.alt = `${c.name} icon preview`;
        preview.append(previewLabel, previewImg);
        const baseIconPath20 = iconPrefix ? `assets/icons-20/${iconPrefix}-20.webp` : '';
        const baseIconPath = iconPrefix ? `assets/icons-30/${iconPrefix}-30.webp` : '';
        if(baseIconPath){
          previewImg.src = baseIconPath;
          preview.classList.add('has-image');
          previewLabel.textContent = '';
          uploadLabelText.textContent = 'Change Icon';
        }
        iconPicker.append(uploadLabel, preview);

        const deleteCategoryBtn = document.createElement('button');
        deleteCategoryBtn.type = 'button';
        deleteCategoryBtn.className = 'delete-category-btn';
        deleteCategoryBtn.textContent = 'Delete Category';
        deleteCategoryBtn.setAttribute('aria-label', `Delete ${c.name} category`);

        const addSubBtn = document.createElement('button');
        addSubBtn.type = 'button';
        addSubBtn.className = 'add-subcategory-btn';
        addSubBtn.textContent = 'Add Subcategory';
        addSubBtn.setAttribute('aria-label', `Add subcategory to ${c.name}`);

        editPanel.append(nameInput, iconPicker, deleteCategoryBtn);
        editMenu.append(editWrap, addSubBtn, editPanel);

        const subMenusContainer = document.createElement('div');
        subMenusContainer.className = 'subcategory-form-menus';
        const addSubAnchor = document.createElement('div');
        addSubAnchor.className = 'subcategory-drop-anchor';
        subMenusContainer.append(addSubAnchor);

        const subNameUpdaters = [];
        const getCategoryNameValue = ()=> nameInput.value.trim();
        let lastCategoryName = c.name || 'Category';
        const getCategoryDisplayName = ()=> getCategoryNameValue() || lastCategoryName || 'Category';
        const updateCategoryIconDisplay = (src)=>{
          categoryLogo.innerHTML = '';
          if(src){
            const img = document.createElement('img');
            img.src = src;
            img.width = 20;
            img.height = 20;
            img.alt = '';
            categoryLogo.appendChild(img);
            categoryLogo.classList.add('has-icon');
          } else {
            categoryLogo.textContent = getCategoryDisplayName().charAt(0) || '';
            categoryLogo.classList.remove('has-icon');
          }
        };
        const applyCategoryNameChange = ()=>{
          const nameValue = getCategoryNameValue();
          if(nameValue){
            lastCategoryName = nameValue;
          }
          const displayName = getCategoryDisplayName();
          const datasetValue = displayName;
          menu.dataset.category = datasetValue;
          label.textContent = displayName;
          dragHandle.setAttribute('aria-label', `Reorder ${displayName} category`);
          toggleInput.setAttribute('aria-label', `Toggle ${displayName} category`);
          uploadInput.setAttribute('aria-label', `Upload icon for ${displayName}`);
          previewImg.alt = `${displayName} icon preview`;
          deleteCategoryBtn.setAttribute('aria-label', `Delete ${displayName} category`);
          addSubBtn.setAttribute('aria-label', `Add subcategory to ${displayName}`);
          subMenusContainer.querySelectorAll('.subcategory-form-menu').forEach(subEl=>{
            subEl.dataset.category = datasetValue;
          });
          if(categoryLogo.querySelector('img')){
            categoryLogo.classList.add('has-icon');
          } else {
            updateCategoryIconDisplay('');
          }
          subNameUpdaters.forEach(fn=>{
            try{ fn(); }catch(err){}
          });
        };
        nameInput.addEventListener('input', applyCategoryNameChange);
        deleteCategoryBtn.addEventListener('click', async ()=>{
          const displayName = getCategoryDisplayName();
          const confirmed = await confirmFormbuilderDeletion(`Delete the "${displayName}" category?`, 'Delete Category');
          if(!confirmed) return;
          menu.remove();
          notifyFormbuilderChange();
        });

        c.subs.forEach((sub, subIndex)=>{
          const subMenu = document.createElement('div');
          subMenu.className = 'subcategory-form-menu';
          subMenu.dataset.category = c.name;
          subMenu.dataset.subcategory = sub;
          subMenu.dataset.subIndex = String(subIndex);
          subMenu.setAttribute('aria-expanded','false');

          const subHeader = document.createElement('div');
          subHeader.className = 'subcategory-form-header';

          const subDragHandle = document.createElement('button');
          subDragHandle.type = 'button';
          subDragHandle.className = 'subcategory-drag-handle';
          subDragHandle.setAttribute('aria-label', `Reorder ${sub} subcategory`);
          const subDragIcon = document.createElement('span');
          subDragIcon.className = 'drag-handle-icon';
          subDragIcon.setAttribute('aria-hidden','true');
          subDragIcon.textContent = '⋮⋮';
          subDragHandle.appendChild(subDragIcon);

          const subTriggerWrap = document.createElement('div');
          subTriggerWrap.className = 'options-dropdown subcategory-trigger-wrap';

          const subContentId = `subcategory-form-content-${baseId}-${subIndex}`;
          const subBtn = document.createElement('button');
          subBtn.type = 'button';
          subBtn.className = 'subcategory-form-trigger';
          subBtn.setAttribute('aria-expanded','false');
          subBtn.setAttribute('aria-controls', subContentId);

          const subLabelWrap = document.createElement('span');
          subLabelWrap.className = 'subcategory-label-wrap';

          const subLogo = document.createElement('span');
          subLogo.className = 'subcategory-logo';
          subLogo.textContent = sub.charAt(0) || '';

          const subLabel = document.createElement('span');
          subLabel.className = 'subcategory-label';
          subLabel.textContent = sub;

          subLabelWrap.append(subLogo, subLabel);

          const subArrow = document.createElement('span');
          subArrow.className = 'dropdown-arrow';
          subArrow.setAttribute('aria-hidden','true');

          subBtn.append(subLabelWrap, subArrow);
          subTriggerWrap.append(subBtn);

          const subToggle = document.createElement('label');
          subToggle.className = 'subcategory-form-toggle';
          const subInput = document.createElement('input');
          subInput.type = 'checkbox';
          subInput.checked = true;
          subInput.setAttribute('aria-label', `Toggle ${sub} subcategory`);
          const subSlider = document.createElement('span');
          subSlider.className = 'slider';
          subToggle.append(subInput, subSlider);

          subHeader.append(subDragHandle, subTriggerWrap, subToggle);
          subMenu.append(subHeader);

          const subContent = document.createElement('div');
          subContent.className = 'subcategory-form-content';
          subContent.id = subContentId;
          subContent.hidden = true;

          const subNameInput = document.createElement('input');
          subNameInput.type = 'text';
          subNameInput.className = 'subcategory-name-input';
          subNameInput.placeholder = 'Subcategory Name';
          subNameInput.value = sub || '';

          const subIconPicker = document.createElement('div');
          subIconPicker.className = 'iconpicker-container';

          const subUploadLabel = document.createElement('label');
          subUploadLabel.className = 'iconpicker-upload';
          const subUploadLabelText = document.createElement('span');
          subUploadLabelText.textContent = 'Upload Icon';
          const subUploadInput = document.createElement('input');
          subUploadInput.type = 'file';
          subUploadInput.accept = 'image/*';
          subUploadInput.setAttribute('aria-label', `Upload icon for ${sub}`);
          subUploadLabel.append(subUploadLabelText, subUploadInput);

          const subPreview = document.createElement('div');
          subPreview.className = 'iconpicker-preview';
          const subPreviewLabel = document.createElement('span');
          subPreviewLabel.textContent = 'No Icon';
          const subPreviewImg = document.createElement('img');
          subPreviewImg.alt = `${sub} icon preview`;
          subPreview.append(subPreviewLabel, subPreviewImg);
          const subColorKey = (window.subcategoryColorMap || {})[`${c.name}::${sub}`] || '';
          const subIconPrefix = iconPrefix || '';
          const subIconPath = subIconPrefix
            ? (subColorKey ? `assets/icons-30/${subIconPrefix}-${subColorKey}-30.webp` : `assets/icons-30/${subIconPrefix}-30.webp`)
            : '';
          if(subIconPath){
            subPreviewImg.src = subIconPath;
            subPreview.classList.add('has-image');
            subPreviewLabel.textContent = '';
            subUploadLabelText.textContent = 'Change Icon';
          }

          subIconPicker.append(subUploadLabel, subPreview);

          const deleteSubBtn = document.createElement('button');
          deleteSubBtn.type = 'button';
          deleteSubBtn.className = 'delete-subcategory-btn';
          deleteSubBtn.textContent = 'Delete Subcategory';
          deleteSubBtn.setAttribute('aria-label', `Delete ${sub} subcategory from ${c.name}`);

          const subPlaceholder = document.createElement('p');
          subPlaceholder.className = 'subcategory-form-placeholder';
          subPlaceholder.innerHTML = `Customize the <strong>${sub}</strong> subcategory.`;

          const defaultSubName = sub || 'Subcategory';
          let currentSubName = defaultSubName;
          let lastSubName = defaultSubName;
          const getSubNameValue = ()=> subNameInput.value.trim();
          const getSubDisplayName = ()=> getSubNameValue() || lastSubName || defaultSubName;
          const updateSubIconDisplay = (src)=>{
            const displayName = getSubDisplayName();
            subLogo.innerHTML = '';
            if(src){
              const img = document.createElement('img');
              img.src = src;
              img.width = 20;
              img.height = 20;
              img.alt = '';
              subLogo.appendChild(img);
              subLogo.classList.add('has-icon');
              subcategoryIcons[currentSubName] = `<img src="${src}" width="20" height="20" alt="">`;
            } else {
              subLogo.textContent = displayName.charAt(0) || '';
              subLogo.classList.remove('has-icon');
              delete subcategoryIcons[currentSubName];
            }
          };
          const applySubNameChange = ()=>{
            const rawValue = getSubNameValue();
            if(rawValue){
              lastSubName = rawValue;
            }
            const displayName = getSubDisplayName();
            const datasetValue = displayName;
            subLabel.textContent = displayName;
            subMenu.dataset.subcategory = datasetValue;
            subBtn.dataset.subcategory = datasetValue;
            subDragHandle.setAttribute('aria-label', `Reorder ${displayName} subcategory`);
            subInput.setAttribute('aria-label', `Toggle ${displayName} subcategory`);
            subUploadInput.setAttribute('aria-label', `Upload icon for ${displayName}`);
            subPreviewImg.alt = `${displayName} icon preview`;
            subPlaceholder.innerHTML = `Customize the <strong>${displayName}</strong> subcategory.`;
            const categoryDisplayName = getCategoryDisplayName();
            deleteSubBtn.setAttribute('aria-label', `Delete ${displayName} subcategory from ${categoryDisplayName}`);
            if(!subLogo.querySelector('img')){
              subLogo.textContent = displayName.charAt(0) || '';
              subLogo.classList.remove('has-icon');
            } else {
              subLogo.classList.add('has-icon');
            }
            if(currentSubName !== datasetValue){
              if(subcategoryIcons[currentSubName] !== undefined && subcategoryIcons[datasetValue] === undefined){
                subcategoryIcons[datasetValue] = subcategoryIcons[currentSubName];
              }
              if(currentSubName !== datasetValue){
                delete subcategoryIcons[currentSubName];
              }
              currentSubName = datasetValue;
            }
          };
          subNameUpdaters.push(applySubNameChange);
          subNameInput.addEventListener('input', ()=> applySubNameChange());

          deleteSubBtn.addEventListener('click', async ()=>{
            const categoryDisplayName = getCategoryDisplayName();
            const subDisplayName = getSubDisplayName();
            const confirmed = await confirmFormbuilderDeletion(`Delete the "${subDisplayName}" subcategory from ${categoryDisplayName}?`, 'Delete Subcategory');
            if(!confirmed) return;
            subMenu.remove();
            notifyFormbuilderChange();
          });

          const normalizedSubIconPath = normalizeIconPath(subIconPath) || subIconPath || '';

          subContent.append(subNameInput, subIconPicker, subPlaceholder, deleteSubBtn);

          subMenu.append(subContent);

          subUploadInput.addEventListener('change', ()=>{
            applySubNameChange();
            const file = subUploadInput.files && subUploadInput.files[0];
            if(file){
              const reader = new FileReader();
              reader.onload = ()=>{
                const result = typeof reader.result === 'string' ? reader.result : '';
                if(result){
                  subPreviewImg.src = result;
                  subPreview.classList.add('has-image');
                  subPreviewLabel.textContent = '';
                  subUploadLabelText.textContent = 'Change Icon';
                  updateSubIconDisplay(result);
                } else {
                  subPreviewImg.removeAttribute('src');
                  subPreview.classList.remove('has-image');
                  subPreviewLabel.textContent = 'No Icon';
                  subUploadLabelText.textContent = subIconPath ? 'Change Icon' : 'Upload Icon';
                  if(normalizedSubIconPath){
                    updateSubIconDisplay(normalizedSubIconPath);
                  } else {
                    updateSubIconDisplay('');
                  }
                }
              };
              reader.onerror = ()=>{
                subPreviewImg.removeAttribute('src');
                subPreview.classList.remove('has-image');
                subPreviewLabel.textContent = 'No Icon';
                subUploadLabelText.textContent = subIconPath ? 'Change Icon' : 'Upload Icon';
                if(normalizedSubIconPath){
                  updateSubIconDisplay(normalizedSubIconPath);
                } else {
                  updateSubIconDisplay('');
                }
              };
              reader.readAsDataURL(file);
            } else if(subIconPath){
              subPreviewImg.src = subIconPath;
              subPreview.classList.add('has-image');
              subPreviewLabel.textContent = '';
              subUploadLabelText.textContent = 'Change Icon';
              updateSubIconDisplay(normalizedSubIconPath);
            } else {
              subPreviewImg.removeAttribute('src');
              subPreview.classList.remove('has-image');
              subPreviewLabel.textContent = 'No Icon';
              subUploadLabelText.textContent = 'Upload Icon';
              updateSubIconDisplay('');
            }
          });

          applySubNameChange();
          if(subIconPath){
            updateSubIconDisplay(normalizedSubIconPath);
          }

          subBtn.addEventListener('click', ()=>{
            const isExpanded = subMenu.getAttribute('aria-expanded') === 'true';
            const next = !isExpanded;
            subMenu.setAttribute('aria-expanded', next ? 'true' : 'false');
            subBtn.setAttribute('aria-expanded', next ? 'true' : 'false');
            subContent.hidden = !next;
          });

          subInput.addEventListener('change', ()=>{
            const isOn = subInput.checked;
            subMenu.classList.toggle('subcategory-off', !isOn);
            if(!isOn){
              if(subMenu.getAttribute('aria-expanded') === 'true'){
                subMenu.setAttribute('aria-expanded','false');
                subBtn.setAttribute('aria-expanded','false');
                subContent.hidden = true;
              }
            }
          });

          subMenusContainer.insertBefore(subMenu, addSubAnchor);

          attachSubcategoryDragHandle(subMenu, subMenusContainer, c, subDragHandle, addSubAnchor);
        });

        setupSubcategoryContainer(subMenusContainer, c, addSubAnchor);

        addSubBtn.addEventListener('click', ()=>{
          if(!Array.isArray(c.subs)){
            c.subs = [];
          }
          const baseName = 'New Subcategory';
          const existing = new Set(c.subs.map(sub => (sub && typeof sub === 'string') ? sub : ''));
          let candidate = baseName;
          let counter = 2;
          while(existing.has(candidate)){
            candidate = `${baseName} ${counter++}`;
          }
          c.subs.unshift(candidate);
          const categoryIndex = categories.indexOf(c);
          renderFormbuilderCats();
          notifyFormbuilderChange();
          if(!formbuilderCats) return;
          const categorySelector = categoryIndex >= 0 ? `.category-form-menu[data-category-index="${categoryIndex}"]` : null;
          const categoryMenu = categorySelector ? formbuilderCats.querySelector(categorySelector) : null;
          if(!categoryMenu) return;
          categoryMenu.setAttribute('aria-expanded','true');
          const menuTrigger = categoryMenu.querySelector('.filter-category-trigger');
          const content = categoryMenu.querySelector('.category-form-content');
          if(menuTrigger) menuTrigger.setAttribute('aria-expanded','true');
          if(content) content.hidden = false;
          const newSubMenu = categoryMenu.querySelector('.subcategory-form-menu');
          if(!newSubMenu) return;
          newSubMenu.setAttribute('aria-expanded','true');
          const subTrigger = newSubMenu.querySelector('.subcategory-form-trigger');
          const subContent = newSubMenu.querySelector('.subcategory-form-content');
          if(subTrigger) subTrigger.setAttribute('aria-expanded','true');
          if(subContent) subContent.hidden = false;
          const subNameField = newSubMenu.querySelector('.subcategory-name-input');
          if(subNameField){
            requestAnimationFrame(()=>{
              try{ subNameField.focus({ preventScroll: true }); }
              catch(err){
                try{ subNameField.focus(); }catch(e){}
              }
            });
          }
        });

        applyCategoryNameChange();

        content.append(editMenu, subMenusContainer);
        menu.append(content);

        menuBtn.addEventListener('click', ()=>{
          const isExpanded = menu.getAttribute('aria-expanded') === 'true';
          const next = !isExpanded;
          menu.setAttribute('aria-expanded', next ? 'true' : 'false');
          menuBtn.setAttribute('aria-expanded', next ? 'true' : 'false');
          content.hidden = !next;
        });

        toggleInput.addEventListener('change', ()=>{
          const isOn = toggleInput.checked;
          menu.classList.toggle('cat-off', !isOn);
          if(!isOn){
            if(menu.getAttribute('aria-expanded') === 'true'){
              menu.setAttribute('aria-expanded','false');
              menuBtn.setAttribute('aria-expanded','false');
              content.hidden = true;
            }
            if(editBtn.getAttribute('aria-expanded') === 'true'){
              editBtn.setAttribute('aria-expanded','false');
              editPanel.hidden = true;
            }
          }
        });

        editBtn.addEventListener('click', ()=>{
          const isExpanded = editBtn.getAttribute('aria-expanded') === 'true';
          const next = !isExpanded;
          editBtn.setAttribute('aria-expanded', next ? 'true' : 'false');
          editPanel.hidden = !next;
          if(next){
            try{
              nameInput.focus({ preventScroll: true });
            }catch(err){
              try{ nameInput.focus(); }catch(e){}
            }
          }
        });

        uploadInput.addEventListener('change', ()=>{
          const file = uploadInput.files && uploadInput.files[0];
          if(file){
            const reader = new FileReader();
            reader.onload = ()=>{
              const result = typeof reader.result === 'string' ? reader.result : '';
              if(result){
                previewImg.src = result;
                preview.classList.add('has-image');
                previewLabel.textContent = '';
                uploadLabelText.textContent = 'Change Icon';
                updateCategoryIconDisplay(result);
              } else {
                previewImg.removeAttribute('src');
                preview.classList.remove('has-image');
                previewLabel.textContent = 'No Icon';
                uploadLabelText.textContent = baseIconPath ? 'Change Icon' : 'Upload Icon';
                if(baseIconPath20){
                  updateCategoryIconDisplay(baseIconPath20);
                } else if(baseIconPath){
                  updateCategoryIconDisplay(baseIconPath);
                } else {
                  updateCategoryIconDisplay('');
                }
              }
            };
            reader.onerror = ()=>{
              previewImg.removeAttribute('src');
              preview.classList.remove('has-image');
              previewLabel.textContent = 'No Icon';
              uploadLabelText.textContent = baseIconPath ? 'Change Icon' : 'Upload Icon';
              if(baseIconPath20){
                updateCategoryIconDisplay(baseIconPath20);
              } else if(baseIconPath){
                updateCategoryIconDisplay(baseIconPath);
              } else {
                updateCategoryIconDisplay('');
              }
            };
            reader.readAsDataURL(file);
          } else if(baseIconPath){
            previewImg.src = baseIconPath;
            preview.classList.add('has-image');
            previewLabel.textContent = '';
            uploadLabelText.textContent = 'Change Icon';
            updateCategoryIconDisplay(baseIconPath20 || baseIconPath);
          } else {
            previewImg.removeAttribute('src');
            preview.classList.remove('has-image');
            previewLabel.textContent = 'No Icon';
            uploadLabelText.textContent = 'Upload Icon';
            updateCategoryIconDisplay('');
          }
        });

        frag.appendChild(menu);
        attachCategoryDragHandle(menu, dragHandle);
      });
      formbuilderCats.innerHTML = '';
      formbuilderCats.appendChild(frag);
      refreshFormbuilderSubcategoryLogos();
    };
    if(formbuilderAddCategoryBtn){
      formbuilderAddCategoryBtn.addEventListener('click', ()=>{
        if(!Array.isArray(categories)) return;
        const baseName = 'New Category';
        const existing = new Set(categories.map(cat => (cat && typeof cat.name === 'string') ? cat.name : ''));
        let candidate = baseName;
        let counter = 2;
        while(existing.has(candidate)){
          candidate = `${baseName} ${counter++}`;
        }
        categories.unshift({ name: candidate, subs: [] });
        renderFormbuilderCats();
        notifyFormbuilderChange();
        const newMenu = formbuilderCats ? formbuilderCats.querySelector('.category-form-menu:first-of-type') : null;
        if(!newMenu) return;
        const menuTrigger = newMenu.querySelector('.filter-category-trigger');
        const content = newMenu.querySelector('.category-form-content');
        const editTrigger = newMenu.querySelector('.category-edit-trigger');
        const editPanel = newMenu.querySelector('.category-edit-panel');
        const nameField = newMenu.querySelector('.category-name-input');
        newMenu.setAttribute('aria-expanded','true');
        if(menuTrigger) menuTrigger.setAttribute('aria-expanded','true');
        if(content) content.hidden = false;
        if(editTrigger) editTrigger.setAttribute('aria-expanded','true');
        if(editPanel) editPanel.hidden = false;
        if(nameField){
          requestAnimationFrame(()=>{
            try{ nameField.focus({ preventScroll: true }); }
            catch(err){
              try{ nameField.focus(); }catch(e){}
            }
          });
        }
      });
    }
    function cloneCategoryList(list){
      return Array.isArray(list) ? list.map(item => ({
        name: item && typeof item.name === 'string' ? item.name : '',
        subs: Array.isArray(item && item.subs) ? item.subs.slice() : []
      })) : [];
    }
    function cloneMapLike(source){
      const out = {};
      if(source && typeof source === 'object'){
        Object.keys(source).forEach(key => {
          out[key] = source[key];
        });
      }
      return out;
    }
    function assignMapLike(target, source){
      if(!target || typeof target !== 'object') return;
      Object.keys(target).forEach(key => { delete target[key]; });
      if(source && typeof source === 'object'){
        Object.keys(source).forEach(key => {
          target[key] = source[key];
        });
      }
    }
    function captureFormbuilderSnapshot(){
      return {
        categories: cloneCategoryList(categories),
        subcategoryIcons: cloneMapLike(subcategoryIcons),
        subcategoryMarkers: cloneMapLike(subcategoryMarkers),
        subcategoryMarkerIds: cloneMapLike(subcategoryMarkerIds),
        categoryShapes: cloneMapLike(categoryShapes)
      };
    }
    let savedFormbuilderSnapshot = captureFormbuilderSnapshot();
    function restoreFormbuilderSnapshot(snapshot){
      if(!snapshot) return;
      const nextCategories = cloneCategoryList(snapshot.categories);
      if(Array.isArray(nextCategories)){
        categories.splice(0, categories.length, ...nextCategories);
      }
      assignMapLike(subcategoryIcons, snapshot.subcategoryIcons);
      assignMapLike(subcategoryMarkers, snapshot.subcategoryMarkers);
      assignMapLike(subcategoryMarkerIds, snapshot.subcategoryMarkerIds);
      assignMapLike(categoryShapes, snapshot.categoryShapes);
      renderFormbuilderCats();
      refreshSubcategoryLogos();
      refreshFormbuilderSubcategoryLogos();
    }
    function updateFormbuilderSnapshot(){
      savedFormbuilderSnapshot = captureFormbuilderSnapshot();
    }
    window.formbuilderStateManager = {
      capture: captureFormbuilderSnapshot,
      restoreSaved(){ restoreFormbuilderSnapshot(savedFormbuilderSnapshot); },
      save(){ updateFormbuilderSnapshot(); },
      getSaved(){ return savedFormbuilderSnapshot ? JSON.parse(JSON.stringify(savedFormbuilderSnapshot)) : null; },
      restore(snapshot){ restoreFormbuilderSnapshot(snapshot); }
    };
    function updateCategoryResetBtn(){
      if(!resetCategoriesBtn) return;
      const anyCategoryOff = Object.values(categoryControllers).some(ctrl=>ctrl && typeof ctrl.isActive === 'function' && !ctrl.isActive());
      const totalSubs = allSubcategoryKeys.length;
      const activeSubs = selection.subs instanceof Set ? selection.subs.size : 0;
      const anySubOff = totalSubs > 0 && activeSubs < totalSubs;
      resetCategoriesBtn.classList.toggle('active', anyCategoryOff || anySubOff);
    }
    function refreshSubcategoryLogos(){
      Object.values(categoryControllers).forEach(ctrl=>{
        if(ctrl && typeof ctrl.refreshLogos === 'function'){
          ctrl.refreshLogos();
        }
      });
    }
    if(catsEl){
      const seedSubs = selection.subs.size === 0;
      categories.forEach(c=>{
        const el = document.createElement('div');
        el.className='filter-category-menu';
        el.dataset.category = c.name;
        el.setAttribute('role','group');
        el.setAttribute('aria-expanded','false');

        const header = document.createElement('div');
        header.className='filter-category-header';

        const triggerWrap = document.createElement('div');
        triggerWrap.className='options-dropdown filter-category-trigger-wrap';

        const menuBtn = document.createElement('button');
        menuBtn.type='button';
        menuBtn.className='filter-category-trigger';
        menuBtn.setAttribute('aria-haspopup','true');
        menuBtn.setAttribute('aria-expanded','false');
        const menuId = `filter-category-menu-${slugify(c.name)}`;
        menuBtn.setAttribute('aria-controls', menuId);

        const categoryLogo = document.createElement('span');
        categoryLogo.className='category-logo';
        const iconPrefix = (window.ICON_BASE || {})[c.name];
        if(iconPrefix){
          const img = document.createElement('img');
          img.src = `assets/icons-20/${iconPrefix}-20.webp`;
          img.width = 20;
          img.height = 20;
          img.alt = '';
          categoryLogo.appendChild(img);
        } else {
          categoryLogo.textContent = c.name.charAt(0) || '';
        }

        const label = document.createElement('span');
        label.className='label';
        label.textContent=c.name;

        const arrow = document.createElement('span');
        arrow.className='dropdown-arrow';
        arrow.setAttribute('aria-hidden','true');

        menuBtn.append(categoryLogo, label, arrow);

        const optionsMenu = document.createElement('div');
        optionsMenu.className='options-menu';
        optionsMenu.id = menuId;
        optionsMenu.hidden = true;

        triggerWrap.append(menuBtn, optionsMenu);

        const toggle = document.createElement('label');
        toggle.className='cat-switch';
        const input = document.createElement('input');
        input.type='checkbox';
        input.setAttribute('aria-label',`Toggle ${c.name} category`);
        const slider = document.createElement('span');
        slider.className='slider';
        toggle.append(input, slider);

        const subButtons = [];
        c.subs.forEach(s=>{
          const subBtn=document.createElement('button');
          subBtn.type='button';
          subBtn.className='subcategory-option';
          subBtn.dataset.category = c.name;
          subBtn.dataset.subcategory = s;
          const key = c.name+'::'+s;
          if(!allSubcategoryKeys.includes(key)){
            allSubcategoryKeys.push(key);
          }
          if(seedSubs){
            selection.subs.add(key);
          }
          const isSelected = selection.subs.has(key);
          subBtn.setAttribute('aria-pressed', isSelected ? 'true' : 'false');
          if(isSelected){
            subBtn.classList.add('on');
          }
          subBtn.innerHTML='<span class="subcategory-logo"></span><span class="subcategory-label"></span><span class="subcategory-switch" aria-hidden="true"><span class="track"></span><span class="thumb"></span></span>';
          const subLabel = subBtn.querySelector('.subcategory-label');
          if(subLabel){
            subLabel.textContent = s;
          }
          subBtn.addEventListener('click',()=>{
            if(!input.checked) return;
            const isActive = subBtn.getAttribute('aria-pressed') === 'true';
            if(isActive){
              subBtn.setAttribute('aria-pressed','false');
              subBtn.classList.remove('on');
              selection.subs.delete(key);
            } else {
              subBtn.setAttribute('aria-pressed','true');
              subBtn.classList.add('on');
              selection.subs.add(key);
            }
            applyFilters();
            updateCategoryResetBtn();
          });
          optionsMenu.appendChild(subBtn);
          subButtons.push(subBtn);
        });

        header.append(triggerWrap, toggle);
        el.appendChild(header);
        catsEl.appendChild(el);

        let openState = false;
        function syncExpanded(){
          const expanded = input.checked && openState;
          el.setAttribute('aria-expanded', expanded ? 'true' : 'false');
          menuBtn.setAttribute('aria-expanded', expanded ? 'true' : 'false');
          optionsMenu.hidden = !expanded;
        }
        function setOpenState(next){
          openState = !!next;
          syncExpanded();
        }
        function setCategoryActive(active, opts={}){
          const enabled = !!active;
          input.checked = enabled;
          el.classList.toggle('cat-off', !enabled);
          menuBtn.disabled = !enabled;
          menuBtn.setAttribute('aria-disabled', enabled ? 'false' : 'true');
          subButtons.forEach(btn=>{
            btn.disabled = !enabled;
            btn.setAttribute('aria-disabled', enabled ? 'false' : 'true');
          });
          if(enabled){
            selection.cats.add(c.name);
          } else {
            selection.cats.delete(c.name);
            setOpenState(false);
          }
          syncExpanded();
          if(!opts.silent){
            applyFilters();
            updateResetBtn();
          }
          updateCategoryResetBtn();
        }
        menuBtn.addEventListener('click', ()=>{
          if(menuBtn.disabled) return;
          setOpenState(!openState);
        });
        input.addEventListener('change', ()=>{
          setCategoryActive(input.checked);
        });

        const controller = {
          name: c.name,
          element: el,
          setActive: (active, opts={})=> setCategoryActive(active, opts),
          setOpen: (open)=> setOpenState(open),
          getOpenState: ()=> openState,
          isActive: ()=> input.checked,
          syncSubs: ()=>{
            subButtons.forEach(btn=>{
              const subName = btn.dataset.subcategory;
              const key = c.name+'::'+subName;
              const selected = selection.subs.has(key);
              btn.setAttribute('aria-pressed', selected ? 'true' : 'false');
              btn.classList.toggle('on', selected);
            });
          },
          refreshLogos: ()=>{
            subButtons.forEach(btn=>{
              const logoSpan = btn.querySelector('.subcategory-logo');
              if(!logoSpan) return;
              const iconHtml = subcategoryIcons[btn.dataset.subcategory] || '';
              logoSpan.innerHTML = iconHtml;
            });
          }
        };
        categoryControllers[c.name] = controller;
        setCategoryActive(true, {silent:true});
        controller.syncSubs();
        syncExpanded();
      });
      refreshSubcategoryLogos();
      renderFormbuilderCats();
      updateFormbuilderSnapshot();
      const handleIconsReady = ()=>{
        refreshSubcategoryLogos();
        refreshFormbuilderSubcategoryLogos();
      };
      document.addEventListener('subcategory-icons-ready', handleIconsReady);
      updateCategoryResetBtn();
      updateResetBtn();
    }

    if(resetCategoriesBtn){
      resetCategoriesBtn.addEventListener('click', ()=>{
        selection.subs = new Set(allSubcategoryKeys);
        Object.values(categoryControllers).forEach(ctrl=>{
          ctrl.setActive(true, {silent:true});
          ctrl.setOpen(false);
          ctrl.syncSubs();
        });
        applyFilters();
        updateResetBtn();
        updateCategoryResetBtn();
      });
    }

    // Reset
    $('#resetBtn').addEventListener('click',()=>{
      $('#keyword-textbox').value='';
      $('#daterange-textbox').value='';
      const minPriceInput = $('#min-price-input');
      const maxPriceInput = $('#max-price-input');
      if(minPriceInput) minPriceInput.value='';
      if(maxPriceInput) maxPriceInput.value='';
      const expired = $('#expiredToggle');
      if(expired){
        expired.checked = false;
        expiredWasOn = false;
      }
      dateStart = null;
      dateEnd = null;
      buildFilterCalendar(today, maxPickerDate);
      updateRangeClasses();
      updateInput();
      closeCalendarPopup();
      if(geocoder) geocoder.clear();
      applyFilters();
      updateClearButtons();
    });

    function updateClearButtons(){
      const kw = $('#keyword-textbox');
      const kwX = kw.parentElement.querySelector('.keyword-clear-button');
      kwX && kwX.classList.toggle('active', kw.value.trim() !== '');
      const minPriceInput = $('#min-price-input');
      const maxPriceInput = $('#max-price-input');
      const priceClear = $('#filterPanel .price-clear-button');
      const hasPrice = (minPriceInput && minPriceInput.value.trim() !== '') || (maxPriceInput && maxPriceInput.value.trim() !== '');
      priceClear && priceClear.classList.toggle('active', hasPrice);
      const date = $('#daterange-textbox');
      const dateX = date.parentElement.querySelector('.daterange-clear-button');
      const hasDate = (dateStart || dateEnd) || $('#expiredToggle').checked;
      dateX && dateX.classList.toggle('active', !!hasDate);
      updateResetBtn();
    }

    function nonLocationFiltersActive(){
      const kw = $('#keyword-textbox').value.trim() !== '';
      const raw = $('#daterange-textbox').value.trim();
      const hasDate = !!(dateStart || dateEnd || raw);
      const expired = $('#expiredToggle').checked;
      const {min, max} = getPriceFilterValues();
      const priceActive = min !== null || max !== null;
      return kw || hasDate || expired || priceActive;
    }

    function updateResetBtn(){
      const active = nonLocationFiltersActive();
      document.body.classList.toggle('filters-active', active);
      const reset = $('#resetBtn');
      reset && reset.classList.toggle('active', active);
    }

    function fmtShort(iso){
      return parseISODate(iso).toLocaleDateString('en-GB', {weekday:'short', day:'numeric', month:'short'}).replace(/,/g,'');
    }

    const dateRangeInput = $('#daterange-textbox');
    $('#keyword-textbox').addEventListener('input', ()=>{ applyFilters(); updateClearButtons(); });
    const minPriceInput = $('#min-price-input');
    const maxPriceInput = $('#max-price-input');
    [minPriceInput, maxPriceInput].forEach(input=>{
      if(!input) return;
      input.addEventListener('input', ()=>{
        const sanitized = input.value.replace(/\D+/g,'');
        if(sanitized !== input.value){ input.value = sanitized; }
        applyFilters();
        updateClearButtons();
      });
    });
    dateRangeInput?.addEventListener('input', ()=>{ applyFilters(); updateClearButtons(); });
    if(dateRangeInput){
      dateRangeInput.addEventListener('focus', ()=> openCalendarPopup());
      dateRangeInput.addEventListener('click', ()=> openCalendarPopup());
    }
    $('#daterange-textbox').addEventListener('keydown', e=>{
      if(e.key === 'Tab'){
        closeCalendarPopup();
        return;
      }
      if(e.key === 'Escape'){
        e.preventDefault();
        closeCalendarPopup();
        return;
      }
      if(e.key === 'Enter' || e.key === ' ' || e.key === 'ArrowDown'){
        e.preventDefault();
        openCalendarPopup(true);
        return;
      }
      if(e.key==='ArrowLeft' || e.key==='ArrowRight'){
        e.preventDefault();
        openCalendarPopup();
        const month = calendarScroll ? calendarScroll.querySelector('.month') : null;
        const w = month ? month.offsetWidth : 0;
        if(calendarScroll && w){
          calendarScroll.scrollBy({left:e.key==='ArrowLeft'?-w:w, behavior:'smooth'});
        }
        return;
      }
      e.preventDefault();
    });
    const today = new Date();
    today.setHours(0,0,0,0);
    const minPickerDate = new Date(today);
    minPickerDate.setMonth(minPickerDate.getMonth() - 12);
    const maxPickerDate = new Date(today);
    maxPickerDate.setFullYear(maxPickerDate.getFullYear() + 2);
    const expiredToggle = $('#expiredToggle');
    const calendarScroll = $('#datePickerContainer');
    const filterBasics = $('#filterPanel .filter-basics-container');
    const filterPanelBody = $('#filterPanel .panel-body');
    let calendarPopupOpen = false;

    function positionCalendarPopup(){
      if(!calendarScroll || !dateRangeInput || !filterBasics) return;
      const inputRect = dateRangeInput.getBoundingClientRect();
      const containerRect = filterBasics.getBoundingClientRect();
      const left = inputRect.left - containerRect.left;
      const top = inputRect.bottom - containerRect.top + 8;
      const popupWidth = calendarScroll.offsetWidth || 0;
      const maxLeft = Math.max(0, containerRect.width - popupWidth);
      const clampedLeft = Math.min(Math.max(left, 0), maxLeft);
      calendarScroll.style.left = `${Math.round(clampedLeft)}px`;
      calendarScroll.style.top = `${Math.round(top)}px`;
    }

    function handleCalendarOutsideClick(e){
      if(!calendarScroll) return;
      if(calendarScroll.contains(e.target)) return;
      if(dateRangeInput && dateRangeInput.contains(e.target)) return;
      closeCalendarPopup();
    }

    function openCalendarPopup(focusCalendar = false){
      if(!calendarScroll) return;
      if(!calendarPopupOpen){
        calendarPopupOpen = true;
        calendarScroll.classList.add('is-visible');
        calendarScroll.setAttribute('tabindex','0');
        calendarScroll.setAttribute('aria-hidden','false');
        if(dateRangeInput) dateRangeInput.setAttribute('aria-expanded','true');
        document.addEventListener('click', handleCalendarOutsideClick, true);
        window.addEventListener('resize', positionCalendarPopup);
        filterPanelBody?.addEventListener('scroll', positionCalendarPopup, { passive:true });
      }
      positionCalendarPopup();
      if(focusCalendar){
        calendarScroll.focus({ preventScroll:true });
      }
    }

    function closeCalendarPopup(){
      if(!calendarScroll || !calendarPopupOpen) return;
      calendarPopupOpen = false;
      if(calendarScroll.contains(document.activeElement)){
        const activeEl = document.activeElement;
        if(activeEl && typeof activeEl.blur === 'function'){
          activeEl.blur();
        }
      }
      calendarScroll.setAttribute('tabindex','-1');
      calendarScroll.classList.remove('is-visible');
      calendarScroll.setAttribute('aria-hidden','true');
      if(dateRangeInput) dateRangeInput.setAttribute('aria-expanded','false');
      document.removeEventListener('click', handleCalendarOutsideClick, true);
      window.removeEventListener('resize', positionCalendarPopup);
      filterPanelBody?.removeEventListener('scroll', positionCalendarPopup);
    }

    function verticalCanScroll(el, delta){
      if(!el) return false;
      if(delta < 0) return el.scrollTop > 0;
      if(delta > 0) return el.scrollTop < el.scrollHeight - el.clientHeight;
      return false;
    }

    function setupHorizontalWheel(scroller){
      if(!scroller) return;
      scroller.addEventListener('wheel', e=>{
        const delta = Math.abs(e.deltaX) > Math.abs(e.deltaY) ? e.deltaX : e.deltaY;
        if(delta !== 0){
          scroller.scrollLeft += delta;
          e.preventDefault();
        }
      }, {passive:false});
    }

    function smoothScroll(el, to, duration=600){
      const start = el.scrollLeft;
      const change = to - start;
      const startTime = performance.now();
      function animate(time){
        const elapsed = time - startTime;
        const progress = Math.min(elapsed / duration, 1);
        el.scrollLeft = start + change * progress;
        if(progress < 1) requestAnimationFrame(animate);
      }
      requestAnimationFrame(animate);
    }

    function setupCalendarScroll(scroller){
      if(!scroller) return;
      scroller.setAttribute('tabindex','0');
      setupHorizontalWheel(scroller);
      const container = scroller.closest('.calendar-container');
      const adjustScale = () => {
        if(!container) return;
        const base = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--calendar-width')) || 0;
        const available = container.parentElement ? container.parentElement.clientWidth : container.clientWidth;
        const scale = base ? Math.min(1, available / base) : 1;
        container.style.setProperty('--calendar-scale', scale);
        if(calendarPopupOpen){
          positionCalendarPopup();
        }
      };
      if('ResizeObserver' in window && container){
        const ro = new ResizeObserver(adjustScale);
        ro.observe(container);
      }
      adjustScale();
      scroller.addEventListener('keydown', e=>{
        if(e.key==='Escape'){
          e.preventDefault();
          closeCalendarPopup();
          dateRangeInput?.focus({ preventScroll:true });
          return;
        }
        if(e.key==='ArrowLeft' || e.key==='ArrowRight'){
          const m = scroller.querySelector('.month') || scroller.querySelector('.month-item');
          const w = m ? m.offsetWidth : 0;
          scroller.scrollLeft += e.key==='ArrowLeft'?-w:w;
          e.preventDefault();
        }
      });
        addPassiveScrollListener(scroller, ()=>{
          const marker = scroller.querySelector('.today-marker');
          if(marker){
            const base = parseFloat(marker.dataset.pos || '0');
            marker.style.left = `${base + Math.round(scroller.scrollLeft)}px`;
          }
        });
      }
      setupCalendarScroll(calendarScroll);
      expiredWasOn = expiredToggle && expiredToggle.checked;

    function scrollCalendarToToday(behavior='auto'){
      const calScroll = $('#datePickerContainer');
      if(!calScroll) return;
      const todayCell = calScroll.querySelector('.day.today');
      if(todayCell){
        const month = todayCell.closest('.month');
        const left = month ? month.offsetLeft : 0;
        calScroll.dataset.todayScroll = left;
        calScroll.scrollTo({left, behavior});
        const marker = calScroll.querySelector('.today-marker');
        if(marker){
          const base = parseFloat(marker.dataset.pos || '0');
          marker.style.left = `${base + left}px`;
        }
      }
    }
    window.scrollCalendarToToday = scrollCalendarToToday;

    function formatDisplay(date){
      const wd = date.toLocaleDateString('en-GB',{weekday:'short'});
      const day = date.getDate();
      const mon = date.toLocaleDateString('en-GB',{month:'short'});
      let str = `${wd} ${day} ${mon}`;
      if(date.getFullYear() !== today.getFullYear()) str += `, ${date.getFullYear()}`;
      return str;
    }

    function orderedRange(){
      if(dateStart && dateEnd){
        return dateStart <= dateEnd ? {start:dateStart,end:dateEnd} : {start:dateEnd,end:dateStart};
      }
      return {start:dateStart,end:dateEnd};
    }

    function sameDay(a,b){ return a.toDateString()===b.toDateString(); }
    function isToday(d){ return sameDay(d,today); }

    function updateRangeClasses(){
      const {start,end} = orderedRange();
      $('#datePicker').querySelectorAll('.day').forEach(day=>{
        const iso = day.dataset.iso;
        if(!iso) return;
        const [yy, mm, dd] = iso.split('-').map(Number);
        const d = new Date(yy, mm - 1, dd);
        day.classList.remove('selected','in-range','range-start','range-end');
        if(start && sameDay(d, start)) day.classList.add('selected','range-start');
        if(end && sameDay(d, end)) day.classList.add('selected','range-end');
        if(start && end && d>start && d<end) day.classList.add('in-range');
      });
    }

    function updateInput(){
      const input = $('#daterange-textbox');
      const {start,end} = orderedRange();
      if(start && end){
        input.value = `${formatDisplay(start)} - ${formatDisplay(end)}`;
      } else if(start){
        input.value = formatDisplay(start);
      } else {
        input.value = '';
      }
      applyFilters();
      updateClearButtons();
    }

    function selectRangeDate(date){
      if(!dateStart || dateEnd){ dateStart = date; dateEnd = null; }
      else { dateEnd = date; }
      updateRangeClasses();
      updateInput();
      if(dateEnd){
        closeCalendarPopup();
      }
    }

    function buildFilterCalendar(minDate, maxDate){
      const container = $('#datePicker');
      container.innerHTML='';
      const cal = document.createElement('div');
      cal.className='calendar';
      let current = new Date(minDate.getFullYear(), minDate.getMonth(),1);
      const end = new Date(maxDate.getFullYear(), maxDate.getMonth(),1);
      const todayDate = new Date();
      todayDate.setHours(0,0,0,0);
      let monthIndex = 0;
      let currentMonthIndex = 0;
      while(current <= end){
        const monthEl = document.createElement('div');
        monthEl.className='month';
        const header = document.createElement('div');
        header.className='calendar-header';
        header.textContent=current.toLocaleDateString('en-GB',{month:'long',year:'numeric'});
        monthEl.appendChild(header);
        const grid = document.createElement('div');
        grid.className='grid';

        const weekdays=['Sun','Mon','Tue','Wed','Thu','Fri','Sat'];
        weekdays.forEach(wd=>{
          const w=document.createElement('div');
          w.className='weekday';
          w.textContent=wd;
          grid.appendChild(w);
        });

        const firstDay = new Date(current.getFullYear(), current.getMonth(),1);
        const startDow = firstDay.getDay();
        const daysInMonth = new Date(current.getFullYear(), current.getMonth()+1,0).getDate();
        const totalCells = 42;
        for(let i=0;i<totalCells;i++){
          const cell=document.createElement('div');
          cell.className='day';
          const dayNum=i-startDow+1;
          if(i<startDow || dayNum>daysInMonth){
            cell.classList.add('empty');
          }else{
            cell.textContent=dayNum;
            const date=new Date(current.getFullYear(), current.getMonth(), dayNum);
            cell.dataset.iso = toISODate(date);
            if(date < todayDate) cell.classList.add('past');
            else cell.classList.add('future');
            if(isToday(date)) cell.classList.add('today');
            if(date >= minDate) cell.addEventListener('click', ()=> selectRangeDate(date));
          }
          grid.appendChild(cell);
        }
        monthEl.appendChild(grid);
        cal.appendChild(monthEl);
        if(current.getFullYear() === todayDate.getFullYear() && current.getMonth() === todayDate.getMonth()){
          currentMonthIndex = monthIndex;
        }
        current.setMonth(current.getMonth()+1);
        monthIndex++;
      }
      container.appendChild(cal);
      updateRangeClasses();
      if(calendarScroll){
        const monthWidth = cal.querySelector('.month').offsetWidth;
        const scrollPos = monthWidth * currentMonthIndex;
        const maxScroll = calendarScroll.scrollWidth - calendarScroll.clientWidth;
        const track = calendarScroll.clientWidth - 20;
        const pos = maxScroll ? scrollPos / maxScroll * track + 10 : 10;
        calendarScroll.querySelector('.today-marker')?.remove();
        const marker = document.createElement('div');
        marker.className = 'today-marker';
        marker.dataset.pos = pos;
        calendarScroll.appendChild(marker);
        marker.addEventListener('click', ()=> scrollCalendarToToday('smooth'));
      }
    }

    buildFilterCalendar(today, maxPickerDate);
    closeCalendarPopup();

    $$('#filterPanel .keyword-clear-button, #filterPanel .daterange-clear-button, #filterPanel .price-clear-button').forEach(btn=> btn.addEventListener('click',()=>{
      if(btn.classList.contains('price-clear-button')){
        const minInputEl = $('#min-price-input');
        const maxInputEl = $('#max-price-input');
        if(minInputEl) minInputEl.value='';
        if(maxInputEl) maxInputEl.value='';
        (minInputEl || maxInputEl)?.focus();
        applyFilters();
        updateClearButtons();
        return;
      }
      const input = btn.parentElement.querySelector('input');
      if(input){
        if(input.id==='daterange-textbox'){
          dateStart = null;
          dateEnd = null;
          updateRangeClasses();
          updateInput();
        } else {
          input.value='';
        }
        input.focus();
        applyFilters();
        updateClearButtons();
      }
    }));
    if(expiredToggle){
      expiredToggle.addEventListener('change', ()=>{
        const input = $('#daterange-textbox');
        const todayDate = new Date();
        todayDate.setHours(0,0,0,0);
        dateStart = null;
        dateEnd = null;
        if(expiredToggle.checked){
          buildFilterCalendar(minPickerDate, maxPickerDate);
        } else {
          buildFilterCalendar(todayDate, maxPickerDate);
        }
        expiredWasOn = expiredToggle.checked;
        updateRangeClasses();
        updateInput();
        closeCalendarPopup();
      });
      if(expiredToggle.checked){
        expiredToggle.dispatchEvent(new Event('change'));
      }
    }
    updateClearButtons();
    updateResetBtn();
    const optionsBtn = $('#optionsBtn');
    const optionsMenu = $('#optionsMenu');
    const favToggle = $('#favToggle');
    const sortButtons = $$('.sort-option');

    function updateSortBtnLabel(text){
      const hasMultiple = optionsMenu.querySelectorAll('button').length > 1;
      if(hasMultiple){
        optionsBtn.innerHTML = `${text}<span class="results-arrow" aria-hidden="true"></span>`;
      } else {
        optionsBtn.textContent = text;
      }
    }

    updateSortBtnLabel(optionsBtn.textContent);

    favToggle.addEventListener('click', ()=>{
      favToTop = !favToTop;
      favSortDirty = favToTop ? false : true;
      favToggle.setAttribute('aria-pressed', favToTop);
      renderLists(filtered);
    });

    sortButtons.forEach(btn=>{
      btn.addEventListener('click', ()=>{
        currentSort = btn.dataset.sort;
        sortButtons.forEach(b=> b.setAttribute('aria-pressed', b===btn ? 'true' : 'false'));
        updateSortBtnLabel(btn.textContent);
        renderLists(filtered);
      });
    });

    optionsBtn.addEventListener('click', e=>{
      e.stopPropagation();
      const open = !optionsMenu.hasAttribute('hidden');
      if(open){
        optionsMenu.setAttribute('hidden','');
        optionsBtn.setAttribute('aria-expanded','false');
      } else {
        optionsMenu.removeAttribute('hidden');
        optionsBtn.setAttribute('aria-expanded','true');
      }
    });
    optionsMenu.addEventListener('click', e=> e.stopPropagation());
      document.addEventListener('click', ()=>{
        optionsMenu.setAttribute('hidden','');
        optionsBtn.setAttribute('aria-expanded','false');
      });

      const recentsBoard = $('#recentsBoard');
      const adBoard = $('.ad-board');
      const boardsContainer = $('.post-mode-boards');
      const postBoard = $('.post-board');
      const recentsButton = $('#recents-button');
      const postsButton = $('#posts-button');
      const mapButton = $('#map-button');
      const boardDisplayCache = new WeakMap();
      let boardsInitialized = false;
      let userClosedPostBoard = false;
      const WIDE_SCREEN_CLUSTER_MIN_WIDTH = 1200;

      function isWideScreenPostBoard(){
        return window.innerWidth >= WIDE_SCREEN_CLUSTER_MIN_WIDTH;
      }

      function autoOpenPostBoardForCluster({ multiIds = [], multiCount = 0, trigger = 'click' } = {}){
        if(trigger !== 'click' && trigger !== 'touch') return;
        if(userClosedPostBoard) return;
        if(!isWideScreenPostBoard()) return;
        const normalizedIds = Array.isArray(multiIds)
          ? multiIds.map(id => String(id)).filter(Boolean)
          : [];
        const numericCount = Number(multiCount);
        const normalizedCount = Number.isFinite(numericCount) && numericCount > 0 ? numericCount : 0;
        const total = Math.max(normalizedIds.length, normalizedCount, 0);
        if(total <= 1) return;
        if(typeof setMode !== 'function') return;
        const wasPostsMode = document.body.classList.contains('mode-posts');
        const hadHistory = document.body.classList.contains('show-history');
        if(hadHistory){
          document.body.classList.remove('show-history');
        }
        if(!wasPostsMode){
          setMode('posts');
        } else if(hadHistory && typeof adjustBoards === 'function'){
          adjustBoards();
        }
      }

      updatePostsButtonState = function(currentZoom){
        const threshold = MARKER_ZOOM_THRESHOLD;
        let zoomValue = Number.isFinite(currentZoom) ? currentZoom : null;
        if(!Number.isFinite(zoomValue) && map && typeof map.getZoom === 'function'){
          try{ zoomValue = map.getZoom(); }catch(err){ zoomValue = null; }
        }
        const postsEnabled = Number.isFinite(zoomValue) ? zoomValue >= threshold : false;
        if(postsButton){
          postsButton.disabled = !postsEnabled;
          postsButton.setAttribute('aria-disabled', postsEnabled ? 'false' : 'true');
          postsButton.classList.toggle('is-disabled', !postsEnabled);
        }
        document.body.classList.toggle('hide-posts-ui', !postsEnabled);
        if(!postsEnabled){
          if(typeof setMode === 'function' && document.body.classList.contains('mode-posts')){
            setMode('map', true);
          }
          document.body.classList.remove('show-history');
          if(typeof adjustBoards === 'function'){ adjustBoards(); }
          if(typeof updateModeToggle === 'function'){ updateModeToggle(); }
        }
      };

      updatePostsButtonState(startZoom);

      function getDefaultBoardDisplay(board){
        if(!board) return 'block';
        if(boardDisplayCache.has(board)) return boardDisplayCache.get(board);
        let value = '';
        try{
          value = getComputedStyle(board).display;
        }catch(err){ value = ''; }
        if(!value || value === 'none'){
          if(board.classList.contains('post-board')) value = 'flex';
          else if(board.classList.contains('ad-board')) value = 'block';
          else value = 'block';
        }
        boardDisplayCache.set(board, value);
        return value;
      }

      function clearBoardHide(board){
        if(!board) return;
        if(board._boardHideHandler){
          board.removeEventListener('transitionend', board._boardHideHandler);
          board._boardHideHandler = null;
        }
        if(board._boardHideTimer){
          clearTimeout(board._boardHideTimer);
          board._boardHideTimer = null;
        }
      }

      function showBoard(board, immediate=false){
        if(!board) return;
        clearBoardHide(board);
        const defaultDisplay = getDefaultBoardDisplay(board);
        board.style.display = defaultDisplay;
        board.setAttribute('aria-hidden','false');
        if(immediate){
          board.classList.add('panel-visible');
          board.style.transform = '';
        } else {
          const wasHidden = !board.classList.contains('panel-visible');
          schedulePanelEntrance(board, wasHidden);
        }
      }

      function hideBoard(board, immediate=false){
        if(!board) return;
        clearBoardHide(board);
        board.setAttribute('aria-hidden','true');
        const finalize = ()=>{
          board.style.display = 'none';
          board._boardHideHandler = null;
          board._boardHideTimer = null;
          try{
            board.style.removeProperty('transform');
          }catch(err){}
        };
        if(immediate){
          board.classList.remove('panel-visible');
          finalize();
          return;
        }
        if(!board.classList.contains('panel-visible')){
          finalize();
          return;
        }
        const handler = event=>{
          if(event && event.target !== board) return;
          board.removeEventListener('transitionend', handler);
          finalize();
        };
        board._boardHideHandler = handler;
        board.addEventListener('transitionend', handler);
        const removeVisible = ()=>{
          if(!board.isConnected){
            board.removeEventListener('transitionend', handler);
            finalize();
            return;
          }
          board.classList.remove('panel-visible');
        };
        if('requestAnimationFrame' in window){
          requestAnimationFrame(removeVisible);
        } else {
          removeVisible();
        }
        board._boardHideTimer = setTimeout(()=>{
          if(board._boardHideHandler){
            board._boardHideHandler();
          }
        }, 400);
      }

      function toggleBoard(board, shouldShow, immediate=false){
        if(shouldShow){
          showBoard(board, immediate);
        } else {
          hideBoard(board, immediate);
        }
      }

      function updateModeToggle(){
        const historyActive = document.body.classList.contains('show-history');
        const isPostsMode = document.body.classList.contains('mode-posts');
        const isMapMode = document.body.classList.contains('mode-map');
        if(recentsButton){
          recentsButton.setAttribute('aria-pressed', historyActive ? 'true' : 'false');
        }
        if(postsButton){
          postsButton.setAttribute('aria-pressed', !historyActive && isPostsMode ? 'true' : 'false');
        }
        if(mapButton){
          mapButton.setAttribute('aria-pressed', isMapMode ? 'true' : 'false');
        }
      }

      function adjustBoards(){
        const small = window.innerWidth < 1200;
        const historyActive = document.body.classList.contains('show-history');
        const isPostsMode = document.body.classList.contains('mode-posts');
        const filterPanel = document.getElementById('filterPanel');
        const filterContent = filterPanel ? filterPanel.querySelector('.panel-content') : null;
        const pinBtn = filterPanel ? filterPanel.querySelector('.pin-panel') : null;
        const filterPinned = !!(filterPanel && filterPanel.classList.contains('show') && pinBtn && pinBtn.getAttribute('aria-pressed') === 'true');
        const historyOpenPost = recentsBoard ? recentsBoard.querySelector('.open-post') : null;
        const postsOpenPost = postBoard ? postBoard.querySelector('.open-post') : null;
        const anyOpenPost = historyOpenPost || postsOpenPost;
        const gap = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--gap')) || 10;
        let filterWidth = filterPinned && filterContent ? filterContent.getBoundingClientRect().width : 0;
        const postWidth = postBoard ? (postBoard.offsetWidth || 530) : 0;
        const historyWidth = recentsBoard ? (recentsBoard.offsetWidth || 530) : 0;
        const boardsWidths = [];
        if(historyActive && recentsBoard){
          boardsWidths.push(historyWidth);
        } else if(postBoard){
          boardsWidths.push(postWidth);
        }
        let totalBoardsWidth = boardsWidths.reduce((sum, w)=> sum + w, 0);
        if(boardsWidths.length > 1){
          totalBoardsWidth += gap * (boardsWidths.length - 1);
        }
        const adWidth = adBoard ? (adBoard.offsetWidth || 440) : 0;
        const shouldShowAds = adBoard && window.innerWidth >= 1900;
        let hideAds = !shouldShowAds || !isPostsMode;
        let requiredWidth = totalBoardsWidth;
        if(filterPinned && filterWidth){
          requiredWidth += filterWidth;
        } else {
          filterWidth = 0;
        }
        if(shouldShowAds && adWidth){
          requiredWidth += adWidth + gap;
        }
        const canAnchor = filterPinned && filterWidth && requiredWidth <= window.innerWidth;
        document.body.classList.toggle('filter-anchored', canAnchor);
        document.documentElement.style.setProperty('--filter-panel-offset', canAnchor ? `${filterWidth}px` : '0px');
        boardsContainer.style.justifyContent = 'flex-start';
        const skipAnimation = !boardsInitialized;
        toggleBoard(recentsBoard, isPostsMode && historyActive, skipAnimation);
        toggleBoard(postBoard, isPostsMode && !historyActive, skipAnimation);
        document.body.classList.toggle('detail-open', !!anyOpenPost);
        if(adBoard){
          toggleBoard(adBoard, isPostsMode && !hideAds && shouldShowAds, skipAnimation);
        }
        document.body.classList.toggle('hide-ads', hideAds);
        updateModeToggle();
        boardsInitialized = true;
      }
      window.adjustBoards = adjustBoards;
      adjustBoards();
      window.addEventListener('resize', adjustBoards);
      window.adjustListHeight();
        setTimeout(()=>{
          if(map && typeof map.resize === 'function'){
            map.resize();
            updatePostPanel();
            applyFilters();
          }
        }, 0);

      recentsButton && recentsButton.addEventListener('click', ()=>{
        const isPostsMode = document.body.classList.contains('mode-posts');
        const historyActive = document.body.classList.contains('show-history');
        if(isPostsMode && historyActive){
          userClosedPostBoard = true;
          setMode('map');
          return;
        }
        setMode('posts');
        document.body.classList.add('show-history');
        renderHistoryBoard();
        adjustBoards();
        setTimeout(()=>{
          if(map && typeof map.resize === 'function'){
            map.resize();
            updatePostPanel();
          }
        }, 300);
        updateModeToggle();
      });

      postsButton && postsButton.addEventListener('click', ()=>{
        const historyActive = document.body.classList.contains('show-history');
        const isPostsMode = document.body.classList.contains('mode-posts');
        if(isPostsMode && !historyActive){
          userClosedPostBoard = true;
          setMode('map');
          return;
        }
        document.body.classList.remove('show-history');
        if(!isPostsMode || historyActive){
          setMode('posts');
          setTimeout(()=>{
            if(map && typeof map.resize === 'function'){
              map.resize();
              updatePostPanel();
            }
          }, 0);
        } else {
          updateModeToggle();
        }
      });

      mapButton && mapButton.addEventListener('click', ()=>{
        const isMapMode = document.body.classList.contains('mode-map');
        if(!isMapMode){
          userClosedPostBoard = true;
          setMode('map');
        } else if(document.body.classList.contains('show-history')){
          document.body.classList.remove('show-history');
          adjustBoards();
          updateModeToggle();
        }
      });

    function buildDetail(p){
      const wrap = document.createElement('div');
      wrap.className = 'open-post';
      wrap.dataset.id = p.id;
      const loc0 = p.locations[0];
      const dsorted = loc0.dates.slice().sort((a,b)=> a.full.localeCompare(b.full));
      const defaultInfo = `💲 ${loc0.price} | 📅 ${dsorted[0].date} - ${dsorted[dsorted.length-1].date}<span style="display:inline-block;margin-left:10px;">(Select Session)</span>`;
      const thumbSrc = thumbUrl(p);
      const headerInner = `
          <div class="title-block">
            <div class="title">${p.title}</div>
            <div class="cat-line"><span class="sub-icon">${subcategoryIcons[p.subcategory]||''}</span> ${p.category} &gt; ${p.subcategory}</div>
          </div>
          <button class="share" aria-label="Share post">
            <svg viewBox="0 0 24 24"><path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.06-.23.09-.46.09-.7s-.03-.47-.09-.7l7.13-4.17A2.99 2.99 0 0 0 18 9a3 3 0 1 0-3-3c0 .24.03.47.09.7L7.96 10.87A3.003 3.003 0 0 0 6 10a3 3 0 1 0 3 3c0-.24-.03-.47-.09-.7l7.13 4.17c.53-.5 1.23-.81 1.96-.81a3 3 0 1 0 0 6 3 3 0 0 0 0-6z"/></svg>
          </button>
          <button class="fav" aria-pressed="${p.fav?'true':'false'}" aria-label="Toggle favourite">
            <svg viewBox="0 0 24 24"><path d="M12 17.3 6.2 21l1.6-6.7L2 9.3l6.9-.6L12 2l3.1 6.7 6.9.6-5.8 4.9L17.8 21 12 17.3z"/></svg>
          </button>
        `;
      const posterName = p.member ? p.member.username : 'Anonymous';
      const postedTime = formatPostTimestamp(p.created);
      const postedMeta = postedTime ? `Posted by ${posterName} · ${postedTime}` : `Posted by ${posterName}`;
      wrap.innerHTML = `
        <div class="post-header">
          ${headerInner}
        </div>
        <div class="post-body">
          <div class="post-details">
            <div class="post-venue-selection-container"></div>
            <div class="post-session-selection-container"></div>
            <div class="location-section">
              <div id="venue-${p.id}" class="venue-dropdown options-dropdown"><button class="venue-btn" aria-haspopup="true" aria-expanded="false"><span class="venue-name">${p.locations[0].venue}</span><span class="venue-address">${p.locations[0].address}</span></button><div class="venue-menu post-venue-menu" hidden><div class="map-container"><div id="map-${p.id}" class="post-map"></div></div><div class="venue-options">${p.locations.map((loc,i)=>`<button data-index="${i}"><span class="venue-name">${loc.venue}</span><span class="venue-address">${loc.address}</span></button>`).join('')}</div></div></div>
              <div id="sess-${p.id}" class="session-dropdown options-dropdown"><button class="sess-btn" aria-haspopup="true" aria-expanded="false">Select Session</button><div class="session-menu options-menu" hidden><div class="calendar-container"><div class="calendar-scroll"><div id="cal-${p.id}" class="post-calendar"></div></div></div><div class="session-options"></div></div></div>
            </div>
            <div class="post-details-info-container">
              <div id="venue-info-${p.id}" class="venue-info"></div>
              <div id="session-info-${p.id}" class="session-info">
                <div>${defaultInfo}</div>
              </div>
            </div>
            <div class="post-details-description-container">
              <div class="desc-wrap"><div class="desc" tabindex="0" aria-expanded="false">${p.desc}</div></div>
              <div class="member-avatar-row"><img src="${memberAvatarUrl(p)}" alt="${posterName} avatar" width="50" height="50"/><span>${postedMeta}</span></div>
            </div>
          </div>
          <div class="post-images">
            <div class="image-box"><div class="image-track"><img id="hero-img" class="lqip" src="${thumbSrc}" data-full="${heroUrl(p)}" alt="" loading="eager" fetchpriority="high" referrerpolicy="no-referrer" onerror="this.onerror=null; this.src='${thumbSrc}';"/></div></div>
            <div class="thumbnail-row"></div>
          </div>
        </div>`;
      wrap.querySelectorAll('.post-header').forEach(head => {
        head.dataset.surfaceBg = CARD_SURFACE;
        head.style.background = CARD_SURFACE;
      });
      wrap.dataset.surfaceBg = CARD_SURFACE;
      wrap.style.background = CARD_SURFACE;
        // progressive hero swap
        (function(){
          const img = wrap.querySelector('#hero-img');
          if(img){
            const full = img.getAttribute('data-full');
            const hi = new Image();
            hi.referrerPolicy = 'no-referrer';
            hi.fetchPriority = 'high';
            hi.onload = ()=>{
              const swap = ()=>{ img.src = full; img.classList.remove('lqip'); img.classList.add('ready'); };
              if(hi.decode){ hi.decode().then(swap).catch(swap); } else { swap(); }
            };
            hi.onerror = ()=>{};
            hi.src = full;
          }
        })();
        return wrap;
    }

      function ensurePostCardForId(id){
        if(!postsWideEl) return null;
        if(!postSentinel || !postsWideEl.contains(postSentinel)){
          renderLists(filtered);
        }
        let cardEl = postsWideEl.querySelector(`.post-card[data-id="${id}"]`);
        if(cardEl) return cardEl;

        const index = sortedPostList.findIndex(item => item && item.id === id);
        if(index === -1) return null;

        while(renderedPostCount <= index){
          const before = renderedPostCount;
          appendPostBatch();
          cardEl = postsWideEl.querySelector(`.post-card[data-id="${id}"]`);
          if(cardEl) return cardEl;
          if(renderedPostCount === before) break;
        }

        return postsWideEl.querySelector(`.post-card[data-id="${id}"]`);
      }

      async function openPost(id, fromHistory=false, fromMap=false, originEl=null){
        lockMap(false);
        touchMarker = null;
        if(hoverPopup){
          let shouldRemovePopup = true;
          if(fromMap && typeof popupIsHovered === 'function'){
            try{
              if(popupIsHovered(hoverPopup)){
                shouldRemovePopup = false;
              }
            }catch(err){
              shouldRemovePopup = true;
            }
          }
          if(shouldRemovePopup){
            runOverlayCleanup(hoverPopup);
            try{ hoverPopup.remove(); }catch(err){}
            hoverPopup = null;
          }
        }
        spinEnabled = false;
        localStorage.setItem('spinGlobe', 'false');
        stopSpin();
        const p = getPostByIdAnywhere(id); if(!p) return;
        activePostId = id;
        selectedVenueKey = null;
        updateSelectedMarkerRing();

        if(!fromHistory){
          if(document.body.classList.contains('show-history')){
            document.body.classList.remove('show-history');
            adjustBoards();
            updateModeToggle();
          }
          if(mode !== 'posts'){
            setMode('posts', true);
            await nextFrame();
          }
        }
        $$('.recents-card[aria-selected="true"], .post-card[aria-selected="true"]').forEach(el=>el.removeAttribute('aria-selected'));
        $$('.mapboxgl-popup.big-map-card .big-map-card[aria-selected="true"]').forEach(el=>el.removeAttribute('aria-selected'));

        const container = fromHistory ? document.getElementById('recentsBoard') : postsWideEl;
        if(!container) return;

        const alreadyOpen = container.querySelector(`.open-post[data-id="${id}"]`);
        if(alreadyOpen){
          return;
        }

        if(originEl && !container.contains(originEl)){
          originEl = null;
        }
        let target = originEl || container.querySelector(`[data-id="${id}"]`);

        (function(){
          const ex = container.querySelector('.open-post');
          if(ex){
            const seenDetailMaps = new Set();
            const cleanupDetailMap = node=>{
              if(!node || !node._detailMap) return;
              const ref = node._detailMap;
              if(!seenDetailMaps.has(ref)){
                if(ref.resizeHandler){
                  window.removeEventListener('resize', ref.resizeHandler);
                }
                if(ref.map && typeof ref.map.remove === 'function'){
                  ref.map.remove();
                }
                seenDetailMaps.add(ref);
              }
              if(ref){
                ref.map = null;
                ref.resizeHandler = null;
              }
              if(node && node.__map){
                node.__map = null;
              }
              delete node._detailMap;
            };
            cleanupDetailMap(ex);
            const mapNode = ex.querySelector('.post-map');
            if(mapNode){
              cleanupDetailMap(mapNode);
            }
            const exId = ex.dataset && ex.dataset.id;
            const prev = getPostByIdAnywhere(exId);
            if(prev){ ex.replaceWith(card(prev, fromHistory ? false : true)); } else { ex.remove(); }
          }
        })();

        if(originEl && !container.contains(originEl)){
          originEl = null;
        }
        target = originEl || container.querySelector(`[data-id="${id}"]`);

        const pointerEvt = window.__lastPointerDown;
        let pointerTarget = null;
        if(pointerEvt && pointerEvt.target instanceof Element){
          let consider = true;
          if(typeof pointerEvt.timeStamp === 'number'){
            const nowTs = (typeof performance !== 'undefined' && typeof performance.now === 'function') ? performance.now() : Date.now();
            const evtTs = pointerEvt.timeStamp;
            if(typeof evtTs === 'number'){
              const diff = nowTs - evtTs;
              if(Number.isFinite(diff) && (diff > 2000 || diff < -2000)){
                consider = false;
              }
            }
          }
          if(consider){
            pointerTarget = pointerEvt.target;
          }
        }
        const pointerCard = pointerTarget ? pointerTarget.closest('.post-card, .recents-card') : null;
        const pointerInsideCardContainer = pointerCard && container.contains(pointerCard);
        const pointerInAdBoard = pointerTarget ? pointerTarget.closest('.ad-board, .ad-panel') : null;
        const shouldAlignToTop = fromMap || (!!pointerInAdBoard && !pointerInsideCardContainer) || pointerInsideCardContainer;

        if(!target && !fromHistory){
          target = ensurePostCardForId(id);
        }

        if(!target){
          target = card(p, fromHistory ? false : true);
          if(!fromHistory && container === postsWideEl){
            if(postSentinel && postSentinel.parentElement === container){
              container.insertBefore(target, postSentinel);
            } else {
              container.appendChild(target);
            }
          } else {
            container.prepend(target);
          }
        } else if(shouldAlignToTop && container.contains(target) && !pointerInsideCardContainer){
          const firstCard = container.querySelector('.open-post, .post-card, .recents-card');
          if(firstCard && firstCard !== target){
            container.insertBefore(target, firstCard);
          } else if(!firstCard){
            container.prepend(target);
          }
        }
        const resCard = resultsEl ? resultsEl.querySelector(`[data-id="${id}"]`) : null;
        if(resCard){
          resCard.setAttribute('aria-selected','true');
          if(fromMap){
            const qb = resCard.closest('.quick-list-board');
            if(qb){
              // intentionally skipping automatic scrolling
            }
          }
        }
        const mapCard = document.querySelector('.mapboxgl-popup.big-map-card .big-map-card');
        if(mapCard) mapCard.setAttribute('aria-selected','true');

        const detail = buildDetail(p);
        target.replaceWith(detail);
        hookDetailActions(detail, p);
        if (typeof updateStickyImages === 'function') {
          updateStickyImages();
        }
        if (typeof initPostLayout === 'function') {
          initPostLayout(container);
          if (typeof updateStickyImages === 'function') {
            updateStickyImages();
          }
        }

        await nextFrame();

        if(fromMap){
          if(typeof window.adjustBoards === 'function'){
            window.adjustBoards();
          }
          if(typeof window.adjustListHeight === 'function'){
            window.adjustListHeight();
          }
        }

        const header = detail.querySelector('.post-header');
        if(header){
          const h = header.offsetHeight;
          header.style.scrollMarginTop = h + 'px';
        }

        if(shouldAlignToTop && container && container.contains(detail)){
          requestAnimationFrame(() => {
            const containerRect = container.getBoundingClientRect();
            const detailRect = detail.getBoundingClientRect();
            if(!containerRect || !detailRect) return;
            const topTarget = container.scrollTop + (detailRect.top - containerRect.top);
            if(typeof container.scrollTo === 'function'){
              container.scrollTo({ top: Math.max(0, topTarget), behavior: 'smooth' });
            } else {
              container.scrollTop = Math.max(0, topTarget);
            }
          });
        }

        // Update history on open (keep newest-first)
        viewHistory = viewHistory.filter(x=>x.id!==id);
        viewHistory.unshift({id:p.id, title:p.title, url:postUrl(p), lastOpened: Date.now()});
        if(viewHistory.length>100) viewHistory.length=100;
        saveHistory();
        if(!fromHistory){
          renderHistoryBoard();
        }
      }

      function closeActivePost(){
        const openEl = document.querySelector('.post-board .open-post, #recentsBoard .open-post');
        if(!openEl){
          document.body.classList.remove('detail-open');
          if(typeof initPostLayout === 'function') initPostLayout(postsWideEl);
          if(typeof window.adjustBoards === 'function') window.adjustBoards();
          return;
        }
        const openBody = openEl.querySelector('.post-body');
        if(openBody){
          openBody.style.removeProperty('--second-post-height');
          openBody.style.removeProperty('min-height');
          if(openBody.dataset) delete openBody.dataset.secondPostHeight;
        }
        const container = openEl.closest('.post-board, #recentsBoard') || postsWideEl;
        const isHistory = container && container.id === 'recentsBoard';
        const id = openEl.dataset ? openEl.dataset.id : null;
        const post = id ? getPostByIdAnywhere(id) : null;
        const detachedColumn = document.querySelector('.post-mode-boards > .post-body');
        if(detachedColumn){
          detachedColumn.classList.remove('is-visible');
          if(detachedColumn.dataset) delete detachedColumn.dataset.openPostId;
          detachedColumn.remove();
        }
        document.body.classList.remove('detail-open');
        $$('.recents-card[aria-selected="true"], .post-card[aria-selected="true"]').forEach(el=> el.removeAttribute('aria-selected'));
        if(post){
          const replacement = card(post, !isHistory);
          openEl.replaceWith(replacement);
        } else {
          openEl.remove();
        }
        activePostId = null;
        selectedVenueKey = null;
        updateSelectedMarkerRing();
        if(typeof initPostLayout === 'function') initPostLayout(postsWideEl);
        if(typeof updateStickyImages === 'function') updateStickyImages();
        if(typeof window.adjustBoards === 'function') window.adjustBoards();
      }

      window.openPost = openPost;
      if(typeof window.__wrapForInputYield === 'function'){
        window.__wrapForInputYield('openPost');
      }

      const resLists = $$('.recents-board');
      resLists.forEach(list=>{
          list.addEventListener('click', (e)=>{
            if(e.target.closest('.fav')) return;
            const cardEl = e.target.closest('.recents-card');
            if(!cardEl) return;
            e.preventDefault();
            const id = cardEl.getAttribute('data-id');
            if(!id) return;
            callWhenDefined('openPost', (fn)=>{
              requestAnimationFrame(() => {
                try{
                  stopSpin();
                  fn(id, true, false, cardEl);
                }catch(err){ console.error(err); }
              });
            });
          }, { capture: true });
        });

      const postsWide = $('.post-board');
      if(postsWide){
        postsWide.addEventListener('click', e=>{
          if(e.target.closest('.fav')) return;
          const cardEl = e.target.closest('.post-card');
          if(cardEl){
            const id = cardEl.getAttribute('data-id');
            if(id){
              e.preventDefault();
              callWhenDefined('openPost', (fn)=>{
                requestAnimationFrame(() => {
                  try{
                    stopSpin();
                    fn(id, false, false, cardEl);
                  }catch(err){ console.error(err); }
                });
              });
            }
            return;
          }
          if(e.target === postsWide && postsWide.querySelector('.open-post')){
            userClosedPostBoard = true;
            setTimeout(()=> setMode('map'), 0);
          }
        }, { capture:true });
      }

      recentsBoard && recentsBoard.addEventListener('click', e=>{
        if(e.target === recentsBoard){
          userClosedPostBoard = true;
          setMode('map');
        }
      });

      function setMode(m, skipFilters = false){
        mode = m;
        document.body.classList.remove('mode-map','mode-posts','hide-posts-ui');
        document.body.classList.add('mode-'+m);
        if(m==='map'){
          document.body.classList.remove('show-history');
        }
        const shouldAdjustListHeight = m === 'posts' && typeof window.adjustListHeight === 'function';
        adjustBoards();
        if(shouldAdjustListHeight){
          window.adjustListHeight();
        }
        updateModeToggle();
        if(m === 'posts'){
          userClosedPostBoard = false;
          const boardEl = document.querySelector('.post-board');
          if(boardEl){
            boardEl.style.width = '';
          }
          if(window.adjust){
            window.adjust();
          }
        }
        if(map){
          if(typeof map.resize === 'function'){
            map.resize();
          }
          updatePostPanel();
        }
        if(m==='posts'){
          spinEnabled = false;
          localStorage.setItem('spinGlobe','false');
          stopSpin();
        }
        if(!skipFilters) applyFilters();
      }
    window.setMode = setMode;

    // Mapbox
    function loadMapbox(cb){
      const mapboxVerRaw = window.MAPBOX_VERSION || 'v3.15.0';
      const mapboxVer = mapboxVerRaw.startsWith('v') ? mapboxVerRaw : `v${mapboxVerRaw}`;
      const mapboxVerNoV = mapboxVer.replace(/^v/, '');
      const cssSources = [
        {
          selector: 'link[href*="mapbox-gl.css"], link[href*="mapbox-gl@"], style[data-mapbox]',
          primary: `https://api.mapbox.com/mapbox-gl-js/${mapboxVer}/mapbox-gl.css`,
          fallback: `https://unpkg.com/mapbox-gl@${mapboxVerNoV}/dist/mapbox-gl.css`
        },
        {
          selector: 'link[href*="mapbox-gl-geocoder.css"], link[href*="mapbox-gl-geocoder@"]',
          primary: 'https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-geocoder/v5.0.0/mapbox-gl-geocoder.css',
          fallback: 'https://unpkg.com/@mapbox/mapbox-gl-geocoder@5.0.0/dist/mapbox-gl-geocoder.css'
        }
      ];

      const finalize = (()=>{
        let called = false;
        return ()=>{
          if(called) return;
          called = true;
          Promise.resolve(ensureMapboxCssFor(document.body))
            .catch(()=>{})
            .finally(()=>{ try{ cb && cb(); }catch(err){ console.error(err); } });
        };
      })();

      function monitorLink(link, onReady, fallbackUrl){
        if(!link || (link.tagName && link.tagName.toLowerCase() === 'style')){
          onReady();
          return;
        }
        if(fallbackUrl && link.dataset && !link.dataset.fallback){
          link.dataset.fallback = fallbackUrl;
        }

        let settled = false;

        function cleanup(){
          link.removeEventListener('load', handleLoad);
          link.removeEventListener('error', handleError);
        }

        function finalize(){
          if(settled){
            return;
          }
          settled = true;
          cleanup();
          onReady();
        }

        function handleLoad(){
          finalize();
        }

        function handleError(){
          const attempts = link.dataset && link.dataset.fallbackErrors ? Number(link.dataset.fallbackErrors) : 0;
          const nextAttempts = (Number.isNaN(attempts) ? 0 : attempts) + 1;
          if(link.dataset){
            link.dataset.fallbackErrors = String(nextAttempts);
          }
          const fallback = link.dataset ? link.dataset.fallback : fallbackUrl;
          if(fallback && link.href !== fallback){
            link.href = fallback;
            return;
          }
          if(fallback && nextAttempts === 1){
            return;
          }
          finalize();
        }

        function needsListeners(){
          if(!link.sheet){
            return true;
          }
          try {
            void link.sheet.cssRules;
            return false;
          } catch(err){
            if(err && (err.name === 'SecurityError' || err.code === 18)){
              return false;
            }
            return true;
          }
        }

        if(needsListeners()){
          link.addEventListener('load', handleLoad, {once:true});
          link.addEventListener('error', handleError);
        } else {
          finalize();
        }
      }

      function ensureCss(index, onReady){
        const {selector, primary, fallback} = cssSources[index];
        const selectors = selector.split(',').map(s => s.trim());
        for(const sel of selectors){
          const candidate = document.querySelector(sel);
          if(candidate){
            if(candidate.tagName && candidate.tagName.toLowerCase() === 'style'){
              onReady();
              return;
            }
            monitorLink(candidate, onReady, fallback);
            return;
          }
        }
        const link = document.createElement('link');
        link.rel = 'stylesheet';
        link.href = primary;
        monitorLink(link, onReady, fallback);
        document.head.appendChild(link);
      }

      if(window.mapboxgl && window.MapboxGeocoder){
        let pending = cssSources.length;
        if(pending === 0){
          finalize();
          return;
        }
        const done = () => {
          if(--pending === 0){
            finalize();
          }
        };
        cssSources.forEach((_, i) => ensureCss(i, done));
        return;
      }

      let cssLoaded = 0;
      const onCss = () => {
        cssLoaded++;
        if(cssLoaded === cssSources.length){
          loadScripts();
        }
      };
      cssSources.forEach((_, i) => ensureCss(i, onCss));

      function loadScripts(){
        const done = (()=>{
          let called = false;
          return ()=>{
            if(called) return;
            called = true;
            finalize();
          };
        })();

        const loadGeocoder = ()=>{
          const g = document.createElement('script');
          g.src='https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-geocoder/v5.0.0/mapbox-gl-geocoder.min.js';
          g.onload = done;
          g.onerror = ()=>{
            const gf = document.createElement('script');
            gf.src='https://unpkg.com/@mapbox/mapbox-gl-geocoder@5.0.0/dist/mapbox-gl-geocoder.min.js';
            gf.onload = done;
            gf.onerror = done;
            document.head.appendChild(gf);
          };
          document.head.appendChild(g);
        };

        const s = document.createElement('script');
        s.src=`https://api.mapbox.com/mapbox-gl-js/${mapboxVer}/mapbox-gl.js`;
        s.onload = loadGeocoder;
        s.onerror = ()=>{
          const sf = document.createElement('script');
          sf.src=`https://unpkg.com/mapbox-gl@${mapboxVerNoV}/dist/mapbox-gl.js`;
          sf.onload = loadGeocoder;
          sf.onerror = done;
          document.head.appendChild(sf);
        };
        document.head.appendChild(s);
      }
    }
    loadMapbox(initMap);

    function addControls(){
      if(typeof MapboxGeocoder === 'undefined'){
        const script = document.createElement('script');
        script.src='https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-geocoder/v5.0.0/mapbox-gl-geocoder.min.js';
        script.onload = addControls;
    script.onerror = ()=> console.error('Mapbox Geocoder failed to load');
    document.head.appendChild(script);
    return;
  }
  const cssLink = document.querySelector('style[data-mapbox], link[href*="mapbox-gl.css"], link[href*="mapbox-gl@"]');
  if(!cssLink || !cssLink.sheet){
    setTimeout(addControls, 50);
    return;
  }
    const sets = [
      {geo:'#geocoder-welcome', locate:'#geolocate-welcome', compass:'#compass-welcome'},
      {geo:'#geocoder-map', locate:'#geolocate-map', compass:'#compass-map'},
      {geo:'#geocoder-filter', locate:'#geolocate-filter', compass:'#compass-filter'},
      {geo:'#geocoder-member', locate:'#geolocate-member', compass:'#compass-member'}
        ];
      const logoLoader = (window.__logoLoading && typeof window.__logoLoading === 'object') ? window.__logoLoading : null;
      const cityZoomLevel = 12;
      sets.forEach((sel, idx)=>{
        const center = map && typeof map.getCenter === 'function' ? map.getCenter() : null;
        const geocoderOptions = {
          accessToken: mapboxgl.accessToken,
          mapboxgl,
          marker:false,
          placeholder:'Location',
          reverseGeocode:true,
          collapsed:false,
          localGeocoder: localVenueGeocoder,
          localGeocoderOnly:false,
          limit: 10
        };
        if(center && Number.isFinite(center.lng) && Number.isFinite(center.lat)){
          geocoderOptions.proximity = { longitude: center.lng, latitude: center.lat };
        }
        const gc = new MapboxGeocoder(geocoderOptions);
        gc.on('result', (e)=>{
          spinEnabled = false;
          localStorage.setItem('spinGlobe','false');
          stopSpin();
          if(mode!=='map') setMode('map');
          if(e && e.result){
            const coords = Array.isArray(e.result.center) ? e.result.center
              : (e.result.geometry && Array.isArray(e.result.geometry.coordinates) ? e.result.geometry.coordinates : null);
            if(Array.isArray(coords) && Number.isFinite(coords[0]) && Number.isFinite(coords[1])){
              setAllGeocoderProximity(coords[0], coords[1]);
            }
          }
          gc.clear();
        });
        const gEl = document.querySelector(sel.geo);
        if(gEl){
          gEl.appendChild(gc.onAdd(map));
          const input = gEl.querySelector('input[type="text"]');
          if(input){
            input.setAttribute('autocomplete','street-address');
            gc._inputReference = input;
          }
          const container = gEl.querySelector('.mapboxgl-ctrl-geocoder');
          if(container) gc._container = container;
        }
        geocoders.push(gc);
        if(idx===1) geocoder = gc;
        const geolocate = new mapboxgl.GeolocateControl({
          positionOptions:{ enableHighAccuracy:true },
          trackUserLocation:false,
          fitBoundsOptions:{ maxZoom: cityZoomLevel }
        });
        let geolocateLogoPending = 0;
        const startGeolocateLoading = () => {
          if(logoLoader && typeof logoLoader.begin === 'function' && geolocateLogoPending === 0){
            try{ logoLoader.begin(); }catch(err){}
            geolocateLogoPending = 1;
          }
        };
        const stopGeolocateLoading = () => {
          if(geolocateLogoPending > 0 && logoLoader && typeof logoLoader.end === 'function'){
            geolocateLogoPending = 0;
            try{ logoLoader.end(); }catch(err){}
          }
        };
        if(geolocate && typeof geolocate.trigger === 'function' && !geolocate.__logoLoadingWrapped){
          const originalTrigger = geolocate.trigger.bind(geolocate);
          geolocate.trigger = function(...args){
            try{ startGeolocateLoading(); }catch(err){}
            return originalTrigger(...args);
          };
          geolocate.__logoLoadingWrapped = true;
        }
        geolocate.on('trackuserlocationstart', () => { startGeolocateLoading(); });
        geolocate.on('geolocate', (event)=>{
          stopGeolocateLoading();
          spinEnabled = false; localStorage.setItem('spinGlobe','false'); stopSpin();
          if(mode!=='map') setMode('map');
          if(event && event.coords){
            setAllGeocoderProximity(event.coords.longitude, event.coords.latitude);
          }
          if(map && typeof map.easeTo === 'function' && event && event.coords){
            let targetZoom = cityZoomLevel;
            if(typeof map.getMaxZoom === 'function'){
              try{
                const maxZoom = map.getMaxZoom();
                if(typeof maxZoom === 'number' && maxZoom < targetZoom){
                  targetZoom = maxZoom;
                }
              }catch(err){}
            }
            const currentZoom = (typeof map.getZoom === 'function') ? map.getZoom() : null;
            const needsZoomAdjust = typeof currentZoom !== 'number' || currentZoom > targetZoom + 0.05;
            const center = [event.coords.longitude, event.coords.latitude];
            if(needsZoomAdjust){
              let currentPitch = null;
              try{
                currentPitch = typeof map.getPitch === 'function' ? map.getPitch() : null;
              }catch(err){
                currentPitch = null;
              }
              const options = { center, zoom: targetZoom, duration: 800, essential: true };
              if(Number.isFinite(currentPitch)){
                options.pitch = currentPitch;
              }
              try{
                map.easeTo(options);
              }catch(err){}
            }
          }
        });
        geolocate.on('error', stopGeolocateLoading);
        geolocate.on('trackuserlocationend', stopGeolocateLoading);
        geolocate.on('outofmaxbounds', stopGeolocateLoading);
        const geoHolder = document.querySelector(sel.locate);
        if(geoHolder){
          const controlEl = geolocate.onAdd(map);
          geoHolder.appendChild(controlEl);
          const geoButton = controlEl && controlEl.querySelector ? controlEl.querySelector('button') : null;
          if(geoButton && !geoButton.dataset.logoSpinBound){
            const triggerLoading = (ev) => {
              if(ev && ev.type === 'keydown'){
                const key = ev.key || ev.code;
                if(key !== 'Enter' && key !== ' ' && key !== 'Space' && key !== 'Spacebar'){
                  return;
                }
              }
              startGeolocateLoading();
            };
            geoButton.addEventListener('pointerdown', triggerLoading);
            geoButton.addEventListener('mousedown', triggerLoading);
            geoButton.addEventListener('touchstart', triggerLoading);
            geoButton.addEventListener('keydown', triggerLoading);
            geoButton.addEventListener('click', triggerLoading);
            geoButton.dataset.logoSpinBound = 'true';
          }
        }
        const nav = new mapboxgl.NavigationControl({showZoom:false, visualizePitch:true});
        const compassHolder = document.querySelector(sel.compass);
        if(compassHolder) compassHolder.appendChild(nav.onAdd(map));
      });
      syncGeocoderProximityToMap();
    }

    async function initMap(){
      if(typeof mapboxgl === 'undefined'){
        console.error('Mapbox GL failed to load');
        return;
      }
      try{
        await ensureMapboxCssFor(document.body);
      }catch(err){}
          mapboxgl.accessToken = MAPBOX_TOKEN;
        if(typeof mapboxgl.setLogLevel === 'function'){
          mapboxgl.setLogLevel('error');
        }
        map = new mapboxgl.Map({
          container:'map',
          style:'mapbox://styles/mapbox/standard',
          projection:'globe',
          center: startCenter,
          zoom: startZoom,
          pitch: startPitch,
          bearing: startBearing,
          attributionControl:true
        });
        try{ ensurePlaceholderSprites(map); }catch(err){}
        const zoomIndicatorEl = document.getElementById('mapZoomIndicator');
        const updateZoomIndicator = () => {
          if(!map || !zoomIndicatorEl || typeof map.getZoom !== 'function') return;
          try{
            const zoomLevel = map.getZoom();
            const pitchLevel = typeof map.getPitch === 'function' ? map.getPitch() : NaN;
            if(Number.isFinite(zoomLevel)){
              const zoomText = `Zoom ${zoomLevel.toFixed(2)}`;
              if(Number.isFinite(pitchLevel)){
                zoomIndicatorEl.textContent = `${zoomText} • Pitch ${Math.round(pitchLevel)}°`;
              } else {
                zoomIndicatorEl.textContent = zoomText;
              }
            } else {
              zoomIndicatorEl.textContent = 'Zoom -- • Pitch --';
            }
          }catch(err){}
        };
        if(zoomIndicatorEl){
          ['zoom','zoomend','pitch','pitchend'].forEach(evt => {
            try{ map.on(evt, updateZoomIndicator); }catch(err){}
          });
          map.once('load', updateZoomIndicator);
          updateZoomIndicator();
        }
// === Pill hooks (safe) ===
try { if (typeof __addOrReplacePill150x40 === 'function') __addOrReplacePill150x40(map); } catch(e){}
if (!map.__pillHooksInstalled) {
  try { map.on('style.load', () => __addOrReplacePill150x40(map)); } catch(e){}
  try { map.on('styleimagemissing', (evt) => { if (evt && evt.id === 'marker-label-bg') __addOrReplacePill150x40(map); }); } catch(e){}
  map.__pillHooksInstalled = true;
}
        const ensureMissingStyleImage = (evt) => {
          if(!evt || !evt.id) return;
          const placeholders = ['mx-federal-5','background','background-stroke','icon','icon-stroke'];
          if(!placeholders.includes(evt.id)) return;
          try{
            if(map.hasImage?.(evt.id)) return;
            map.addImage(evt.id, createTransparentPlaceholder(4), { pixelRatio: 1 });
          }catch(err){}
        };
        try{ map.on('styleimagemissing', ensureMissingStyleImage); }catch(err){}

        const ensureCompositeOnStyleMissing = (evt) => {
          if(!evt || !evt.id) return;
          if(evt.id.startsWith(MARKER_LABEL_COMPOSITE_PREFIX)){
            const isAccent = evt.id.endsWith(MARKER_LABEL_COMPOSITE_ACCENT_SUFFIX);
            const baseId = isAccent ? evt.id.slice(0, -MARKER_LABEL_COMPOSITE_ACCENT_SUFFIX.length) : evt.id;
            const spriteId = baseId.slice(MARKER_LABEL_COMPOSITE_PREFIX.length);
            if(!spriteId){
              return;
            }
            try{
              if(!map.hasImage?.(evt.id)){
                map.addImage(evt.id, createTransparentPlaceholder(markerLabelBackgroundWidthPx, markerLabelBackgroundHeightPx), { pixelRatio: 1 });
                markerLabelCompositePlaceholderIds.add(evt.id);
              }
            }catch(err){}
            const meta = markerLabelCompositeStore.get(spriteId) || {};
            try{
              ensureMarkerLabelComposite(map, spriteId, meta.iconId, meta.labelLine1, meta.labelLine2, meta.isMulti, { priority: meta.priority });
            }catch(err){}
          }
        };
        if(!map.__compositeStyleHookInstalled){
          try{ map.on('styleimagemissing', ensureCompositeOnStyleMissing); }catch(err){}
          map.__compositeStyleHookInstalled = true;
        }

        try{ map.on('style.load', () => { try{ reapplyMarkerLabelComposites(map); }catch(err){} }); }catch(err){}

        const applyStyleAdjustments = () => {
          try{ ensurePlaceholderSprites(map); }catch(err){}
          applyNightSky(map);
          patchMapboxStyleArtifacts(map);
        };
        whenStyleReady(map, applyStyleAdjustments);
        map.on('style.load', applyStyleAdjustments);
        map.on('styledata', () => {
          try{ ensurePlaceholderSprites(map); }catch(err){}
          if(map.isStyleLoaded && map.isStyleLoaded()){
            patchMapboxStyleArtifacts(map);
          }
        });
        ensureMapIcon = attachIconLoader(map);
        const mapLoading = (() => {
          const loader = window.__logoLoading;
          if(!loader || typeof loader.begin !== 'function' || typeof loader.end !== 'function'){
            return null;
          }
          const motionTokens = new Set();
          let tilesPending = false;
          let active = false;

          const isMapMovingNow = () => {
            if(!map) return false;
            try{
              if(typeof map.isMoving === 'function' && map.isMoving()) return true;
              if(typeof map.isZooming === 'function' && map.isZooming()) return true;
              if(typeof map.isRotating === 'function' && map.isRotating()) return true;
              if(typeof map.isEasing === 'function' && map.isEasing()) return true;
            }catch(err){}
            return false;
          };

          const apply = (forceStop = false) => {
            const busy = !forceStop && (tilesPending || motionTokens.size > 0 || isMapMovingNow());
            if(busy){
              if(!active){
                active = true;
                try{ loader.begin('map'); }catch(err){}
              }
            } else if(active){
              active = false;
              try{ loader.end('map'); }catch(err){}
            }
          };

          return {
            apply,
            setTiles(pending){
              if(tilesPending === pending) return;
              tilesPending = pending;
              apply();
            },
            addMotion(token){
              if(motionTokens.has(token)) return;
              motionTokens.add(token);
              apply();
            },
            removeMotion(token){
              if(!motionTokens.has(token)) return;
              motionTokens.delete(token);
              apply();
            },
            clearAll(){
              motionTokens.clear();
              tilesPending = false;
              apply(true);
            }
          };
        })();

        if(mapLoading){
          const updateRenderState = () => {
            let tileBusy = false;
            if(map){
              try{
                if(typeof map.isStyleLoaded === 'function' && !map.isStyleLoaded()){
                  tileBusy = true;
                } else if(typeof map.areTilesLoaded === 'function'){
                  tileBusy = !map.areTilesLoaded();
                }
              }catch(err){
                tileBusy = true;
              }
            }
            mapLoading.setTiles(tileBusy);
            mapLoading.apply();
          };

          map.on('sourcedataloading', () => mapLoading.setTiles(true));
          map.on('render', updateRenderState);
          map.on('idle', () => {
            mapLoading.setTiles(false);
            mapLoading.apply();
          });

          ['move','zoom','rotate','pitch','drag'].forEach(evt => {
            const startEv = `${evt}start`;
            const endEv = `${evt}end`;
            map.on(startEv, () => mapLoading.addMotion(evt));
            map.on(endEv, () => mapLoading.removeMotion(evt));
          });
          ['moveend','zoomend','rotateend','pitchend','dragend'].forEach(evt => {
            map.on(evt, () => mapLoading.apply());
          });
          map.on('remove', () => mapLoading.clearAll());
        }
      map.on('zoomstart', ()=>{
        if(waitForInitialZoom){
          initialZoomStarted = true;
        }
      });
      map.on('zoom', (e)=>{
        const zoomValue = getZoomFromEvent(e);
        if(waitForInitialZoom){
          if(!initialZoomStarted){
            updateZoomState(zoomValue);
            return;
          }
          waitForInitialZoom = false;
          window.waitForInitialZoom = waitForInitialZoom;
          initialZoomStarted = false;
        }
        updateZoomState(zoomValue);
        scheduleCheckLoadPosts({ zoom: zoomValue, target: map });
      });
      map.on('zoomend', ()=>{
        if(markersLoaded) return;
        if(!map || typeof map.getZoom !== 'function') return;
        let currentZoom = NaN;
        try{ currentZoom = map.getZoom(); }catch(err){ currentZoom = NaN; }
        if(!Number.isFinite(currentZoom) || currentZoom < MARKER_PRELOAD_ZOOM){
          return;
        }
        try{ loadPostMarkers(); }catch(err){ console.error(err); }
        markersLoaded = true;
        window.__markersLoaded = true;
      });
      map.on('moveend', ()=>{
        syncGeocoderProximityToMap();
        scheduleCheckLoadPosts({ zoom: lastKnownZoom, target: map });
      });
      addControls();
      try{
        map.scrollZoom.setWheelZoomRate(1/240);
        map.scrollZoom.setZoomRate(1/240);
      }catch(e){}
      map.on('load', ()=>{
        setupSeedLayers(map);
        applyNightSky(map);
        $$('.map-overlay').forEach(el=>el.remove());
        if(spinEnabled){
          startSpin(true);
        }
        updatePostPanel();
        applyFilters();
        updateZoomState(getZoomFromEvent());
        if(!markersLoaded){
          const zoomLevel = Number.isFinite(lastKnownZoom) ? lastKnownZoom : getZoomFromEvent();
          if(Number.isFinite(zoomLevel) && zoomLevel >= MARKER_PRELOAD_ZOOM){
            try{ loadPostMarkers(); }catch(err){ console.error(err); }
            markersLoaded = true;
            window.__markersLoaded = true;
          }
        }
        checkLoadPosts();
      });

      map.on('style.load', ()=>{
        setupSeedLayers(map);
        updateLayerVisibility(lastKnownZoom);
      });

        ['mousedown','wheel','touchstart','dragstart','pitchstart','rotatestart','zoomstart'].forEach(ev=> map.on(ev, haltSpin));
        let suppressNextRefresh = false;
        const refreshMapView = () => {
          if(suppressNextRefresh) return;
          scheduleCheckLoadPosts({ zoom: lastKnownZoom, target: map });
          updatePostPanel();
          updateFilterCounts();
          refreshMarkers();
          refreshInViewMarkerLabelComposites(map);
          const center = map.getCenter().toArray();
          const zoom = map.getZoom();
          const pitch = map.getPitch();
          const bearing = map.getBearing();
          updateBalloonSourceForZoom(zoom);
          localStorage.setItem('mapView', JSON.stringify({center, zoom, pitch, bearing}));
        };
        ['moveend','zoomend','rotateend','pitchend'].forEach(ev => map.on(ev, refreshMapView));
        map.on('dragend', clearMapGeocoder);
        map.on('click', clearMapGeocoder);
        map.on('touchstart', () => requestAnimationFrame(blurAllGeocoderInputs));
      }

    function startSpin(fromCurrent=false){
      if(mode!=='map') setMode('map');
      if(!spinEnabled || spinning || !map) return;
      if(map.getZoom() >= 3) return;
      if(typeof filterPanel !== 'undefined' && filterPanel) closePanel(filterPanel);
      spinning = true;
      hideResultIndicators();
      historyWasActive = document.body.classList.contains('show-history');
      if(historyWasActive){
        document.body.classList.remove('show-history');
        adjustBoards();
        updateModeToggle();
      }
      function step(){
        if(!spinning || !map) return;
        const isBusy = (map.isMoving && map.isMoving()) || (map.areTilesLoaded && !map.areTilesLoaded());
        if(isBusy){
          requestAnimationFrame(step);
          return;
        }
        const c = map.getCenter();
        map.setCenter([c.lng + spinSpeed, c.lat]);
        requestAnimationFrame(step);
      }
      if(fromCurrent){
        requestAnimationFrame(step);
      }else{
        const targetPitch = Number.isFinite(startPitch) ? startPitch : LEGACY_DEFAULT_PITCH;
        map.easeTo({center:[0,0], zoom:startZoom, pitch:targetPitch, essential:true});
        map.once('moveend', () => requestAnimationFrame(step));
      }
    }
    function stopSpin(){
      spinning = false;
      const wasHistory = historyWasActive;
      historyWasActive = false;
      if(wasHistory){
        document.body.classList.add('show-history');
        adjustBoards();
        updateModeToggle();
      }
      const shouldLoadPosts = pendingPostLoad;
      pendingPostLoad = false;
      if(shouldLoadPosts){
        scheduleCheckLoadPosts({ zoom: lastKnownZoom, target: map });
        return;
      }
      applyFilters();
    }

    function haltSpin(e){
      const target = (e && e.originalEvent && e.originalEvent.target) || (e && e.target);
      if(target instanceof Node && logoEls.some(el=>el.contains(target))) return;
      if(spinEnabled || spinning){
        spinEnabled = false;
        localStorage.setItem('spinGlobe','false');
        stopSpin();
      }
    }

    ['pointerdown','wheel','keydown','touchstart'].forEach(ev=>
      document.addEventListener(ev, haltSpin, {capture:true})
    );

    function updateSpinState(){
      const shouldSpin = spinLoadStart && (spinLoadType === 'all' || (spinLoadType === 'new' && firstVisit));
      if(shouldSpin !== spinEnabled){
        spinEnabled = shouldSpin;
        localStorage.setItem('spinGlobe', JSON.stringify(spinEnabled));
        if(spinEnabled) startSpin(); else stopSpin();
      }
    }

    window.spinGlobals = {
      get spinEnabled(){ return spinEnabled; },
      set spinEnabled(v){ spinEnabled = v; },
      get spinLoadStart(){ return spinLoadStart; },
      set spinLoadStart(v){ spinLoadStart = v; },
      get spinLoadType(){ return spinLoadType; },
      set spinLoadType(v){ spinLoadType = v; },
      get spinLogoClick(){ return spinLogoClick; },
      set spinLogoClick(v){ spinLogoClick = v; updateLogoClickState(); },
      startSpin,
      stopSpin,
      updateSpinState,
      updateLogoClickState
    };

    // Map layers
    function collectLocationEntries(post){
      const entries = [];
      const locs = Array.isArray(post?.locations) ? post.locations : [];
      locs.forEach((loc, idx) => {
        if(!loc) return;
        const lng = Number(loc.lng);
        const lat = Number(loc.lat);
        if(!Number.isFinite(lng) || !Number.isFinite(lat)) return;
        entries.push({
          post,
          loc,
          lng,
          lat,
          index: idx,
          key: venueKey(lng, lat)
        });
      });
      if(!entries.length && Number.isFinite(post?.lng) && Number.isFinite(post?.lat)){
        const fallbackVenue = typeof post?.venue === 'string' && post.venue
          ? post.venue
          : (post?.city || '');
        entries.push({
          post,
          loc:{
            venue: fallbackVenue,
            address: post?.city || '',
            lng: post.lng,
            lat: post.lat
          },
          lng: post.lng,
          lat: post.lat,
          index: 0,
          key: venueKey(post.lng, post.lat)
        });
      }
      return entries.filter(entry => entry.key);
    }

    function postsToGeoJSON(list){
      const features = [];
      if(!Array.isArray(list) || !list.length){
        return { type:'FeatureCollection', features };
      }

      const venueGroups = new Map();
      const orphanEntries = [];

      list.forEach(p => {
        if(!p) return;
        const entries = collectLocationEntries(p);
        entries.forEach(entry => {
          if(!entry) return;
          const key = entry.key;
          const post = entry.post || p;
          if(!key){
            orphanEntries.push({ post, entry });
            return;
          }
          let group = venueGroups.get(key);
          if(!group){
            group = { key, entries: [], postIds: new Set() };
            venueGroups.set(key, group);
          }
          group.entries.push({ post, entry });
          if(post && post.id !== undefined && post.id !== null){
            const strId = String(post.id);
            if(strId) group.postIds.add(strId);
          }
        });
      });

      const buildSingleFeature = ({ post, entry }) => {
        if(!post || !entry) return null;
        const key = entry.key || '';
        const baseSub = subcategoryMarkerIds[post.subcategory] || slugify(post.subcategory);
        const labelLines = getMarkerLabelLines(post);
        const combinedLabel = buildMarkerLabelText(post, labelLines);
        const spriteSource = [baseSub || '', labelLines.line1 || '', labelLines.line2 || ''].join('|');
        const labelSpriteId = hashString(spriteSource);
        const featureId = key
          ? `post:${post.id}::${key}::${entry.index}`
          : `post:${post.id}::${entry.index}`;
        const venueName = entry.loc && entry.loc.venue ? entry.loc.venue : getPrimaryVenueName(post);
        return {
          type:'Feature',
          id: featureId,
          properties:{
            id: post.id,
            featureId,
            title: post.title,
            label: combinedLabel,
            labelLine1: labelLines.line1,
            labelLine2: labelLines.line2,
            labelSpriteId,
            venueName,
            city: post.city,
            cat: post.category,
            sub: baseSub,
            baseSub,
            venueKey: key,
            locationIndex: entry.index,
            isMultiVenue: false
          },
          geometry:{ type:'Point', coordinates:[entry.lng, entry.lat] }
        };
      };

      const buildMultiFeature = (group) => {
        if(!group || !group.entries.length) return null;
        const multiCount = group.postIds.size;
        if(multiCount <= 1){
          return group.entries.map(buildSingleFeature).filter(Boolean);
        }
        const primary = group.entries[0];
        if(!primary || !primary.post || !primary.entry) return null;
        const { post, entry } = primary;
        const baseSub = subcategoryMarkerIds[post.subcategory] || slugify(post.subcategory);
        const multiIconId = MULTI_POST_MARKER_ICON_ID;
        const venueName = (() => {
          for(const item of group.entries){
            const candidate = item && item.entry && item.entry.loc && item.entry.loc.venue;
            if(candidate){
              return candidate;
            }
          }
          return getPrimaryVenueName(post);
        })() || '';
        const multiCountLabel = `${multiCount} posts here`;
        const multiVenueText = shortenMarkerLabelText(venueName, markerLabelTextAreaWidthPx);
        const combinedLabel = multiVenueText ? `${multiCountLabel}\n${multiVenueText}` : multiCountLabel;
        const spriteSource = ['multi', multiIconId || '', baseSub || '', multiCountLabel, multiVenueText || ''].join('|');
        const labelSpriteId = hashString(spriteSource);
        const featureId = `venue:${group.key}::${post.id}`;
        const coordinates = [entry.lng, entry.lat];
        const multiIds = Array.from(group.postIds);
        return [{
          type:'Feature',
          id: featureId,
          properties:{
            id: post.id,
            featureId,
            title: multiCountLabel,
            label: combinedLabel,
            labelLine1: multiCountLabel,
            labelLine2: multiVenueText,
            labelSpriteId,
            venueName,
            city: post.city,
            cat: post.category,
            sub: multiIconId,
            baseSub,
            venueKey: group.key,
            locationIndex: entry.index,
            isMultiVenue: true,
            multiCount,
            multiPostIds: multiIds
          },
          geometry:{ type:'Point', coordinates }
        }];
      };

      venueGroups.forEach(group => {
        const result = buildMultiFeature(group);
        if(Array.isArray(result)){
          result.forEach(feature => { if(feature) features.push(feature); });
        }
      });

      orphanEntries.forEach(item => {
        const feature = buildSingleFeature(item);
        if(feature) features.push(feature);
      });

      return {
        type:'FeatureCollection',
        features
      };
    }



    let addingPostSource = false;
    let pendingAddPostSource = false;

    function loadPostMarkers(){
      try{
        addPostSource();
      }catch(err){
        console.error('loadPostMarkers failed', err);
      }
    }

    async function addPostSource(){
      if(!map){
        return;
      }
      if(addingPostSource){
        pendingAddPostSource = true;
        return;
      }
      addingPostSource = true;
      if(map && Number.isFinite(lastKnownZoom) && lastKnownZoom >= MARKER_SPRITE_ZOOM){
        map.__retainAllMarkerSprites = true;
      }
      try{
      const markerList = filtersInitialized && Array.isArray(filtered) ? filtered : posts;
      const collections = getMarkerCollections(markerList);
      const { postsData, signature, featureIndex } = collections;
      markerFeatureIndex = featureIndex instanceof Map ? featureIndex : new Map();
      const featureCount = Array.isArray(postsData.features) ? postsData.features.length : 0;
      if(featureCount > 1000){
        await new Promise(resolve => scheduleIdle(resolve, 120));
      }
      const MARKER_MIN_ZOOM = MARKER_ZOOM_THRESHOLD;
      const existing = map.getSource('posts');
      if(!existing){
        map.addSource('posts', { type:'geojson', data: postsData, promoteId: 'featureId' });
        const source = map.getSource('posts');
        if(source){ source.__markerSignature = signature; }
      } else {
        existing.setData(postsData);
        existing.__markerSignature = signature;
      }
      const iconIds = Object.keys(subcategoryMarkers);
      if(typeof ensureMapIcon === 'function'){
        await Promise.all(iconIds.map(id => ensureMapIcon(id).catch(()=>{})));
      }
      if(typeof ensureMarkerLabelComposite === 'function'){
        const spriteMeta = new Map();
        const zoomLevel = typeof map.getZoom === 'function' ? Number(map.getZoom()) : NaN;
        const zoomEligible = Number.isFinite(zoomLevel) && zoomLevel >= 8;
        const rawBounds = zoomEligible && typeof map.getBounds === 'function' ? normalizeBounds(map.getBounds()) : null;
        const priorityBounds = rawBounds ? expandBounds(rawBounds, { lat: 0.35, lng: 0.35 }) : null;
        const highlightedPostIdSet = new Set();
        lastHighlightedPostIds.forEach(entry => {
          if(!entry) return;
          const rawId = entry.id ?? entry.postId ?? entry.postID ?? entry.postid;
          if(rawId === undefined || rawId === null) return;
          const strId = String(rawId);
          if(strId){
            highlightedPostIdSet.add(strId);
          }
        });
        const usageTimestamp = nowTimestamp();
        postsData.features.forEach(feature => {
          if(!feature || !feature.properties) return;
          const props = feature.properties;
          const spriteId = props.labelSpriteId;
          if(!spriteId || spriteMeta.has(spriteId)) return;
          const coords = Array.isArray(feature.geometry && feature.geometry.coordinates)
            ? feature.geometry.coordinates
            : null;
          let inView = false;
          if(zoomEligible && coords && coords.length >= 2 && priorityBounds){
            const [lng, lat] = coords;
            if(Number.isFinite(lng) && Number.isFinite(lat)){
              inView = pointWithinBounds(lng, lat, priorityBounds);
            }
          }
          const existing = markerLabelCompositeStore.get(spriteId) || {};
          const stored = spriteMeta.get(spriteId);
          const iconId = props.sub || props.baseSub || '';
          const labelLine1 = props.labelLine1 || '';
          const labelLine2 = props.labelLine2 || '';
          const multiIds = Array.isArray(props.multiPostIds) ? props.multiPostIds : [];
          const isMulti = Boolean(props.isMultiVenue || (props.multiCount && Number(props.multiCount) > 1) || multiIds.length > 1);
          const isHighlighted = (() => {
            const ownId = props.id !== undefined && props.id !== null ? String(props.id) : '';
            if(ownId && highlightedPostIdSet.has(ownId)){
              return true;
            }
            return multiIds.some(mid => {
              if(mid === undefined || mid === null) return false;
              return highlightedPostIdSet.has(String(mid));
            });
          })();
          const priority = Boolean(inView || isHighlighted);
          let lastUsed = Number.isFinite(existing.lastUsed) ? existing.lastUsed : 0;
          if(priority){
            lastUsed = usageTimestamp;
          }
          const updatedMeta = Object.assign({}, existing, {
            iconId,
            labelLine1,
            labelLine2,
            isMulti,
            priority,
            lastUsed,
            inView
          });
          markerLabelCompositeStore.set(spriteId, updatedMeta);
          spriteMeta.set(spriteId, {
            iconId,
            labelLine1,
            labelLine2,
            isMulti,
            priority,
            lastUsed,
            inView
          });
        });
        const spriteEntries = Array.from(spriteMeta.entries());
        const compareEntries = (a, b) => {
          const aMeta = a[1] || {};
          const bMeta = b[1] || {};
          const aPriority = aMeta.priority ? 1 : 0;
          const bPriority = bMeta.priority ? 1 : 0;
          if(aPriority !== bPriority){
            return bPriority - aPriority;
          }
          const aLast = Number.isFinite(aMeta.lastUsed) ? aMeta.lastUsed : 0;
          const bLast = Number.isFinite(bMeta.lastUsed) ? bMeta.lastUsed : 0;
          if(aLast !== bLast){
            return bLast - aLast;
          }
          return String(a[0]).localeCompare(String(b[0]));
        };
        spriteEntries.sort(compareEntries);
        const compositeSafetyBuffer = 25;
        let eagerSpriteEntries = [];
        if(zoomEligible){
          eagerSpriteEntries = spriteEntries.filter(([, meta]) => meta && (meta.inView || meta.priority));
          if(Number.isFinite(MARKER_LABEL_COMPOSITE_LIMIT) && MARKER_LABEL_COMPOSITE_LIMIT > 0){
            const maxEager = Math.max(0, MARKER_LABEL_COMPOSITE_LIMIT - Math.max(0, compositeSafetyBuffer));
            if(maxEager <= 0){
              eagerSpriteEntries = [];
            } else if(eagerSpriteEntries.length > maxEager){
              eagerSpriteEntries = eagerSpriteEntries.slice(0, maxEager);
            }
          }
        }
        await Promise.all(eagerSpriteEntries.map(([spriteId, meta]) =>
          ensureMarkerLabelComposite(
            map,
            spriteId,
            meta.iconId,
            meta.labelLine1,
            meta.labelLine2,
            meta.isMulti,
            { priority: meta.priority }
          ).catch(()=>{})
        ));
        enforceMarkerLabelCompositeBudget(map);
      }
      ensureMarkerLabelBackground(map);
      updateMapFeatureHighlights(lastHighlightedPostIds);
      const markerLabelBaseConditions = [
        ['!',['has','point_count']],
        ['has','title']
      ];
      const markerLabelFilter = ['all', ...markerLabelBaseConditions];

      const markerLabelIconImage = ['let', 'spriteId', ['coalesce', ['get','labelSpriteId'], ''],
        ['case',
          ['==', ['var','spriteId'], ''],
          MARKER_LABEL_BG_ID,
          ['concat', MARKER_LABEL_COMPOSITE_PREFIX, ['var','spriteId']]
        ]
      ];

      const markerLabelHighlightIconImage = ['let', 'spriteId', ['coalesce', ['get','labelSpriteId'], ''],
        ['case',
          ['==', ['var','spriteId'], ''],
          MARKER_LABEL_BG_ACCENT_ID,
          ['concat', MARKER_LABEL_COMPOSITE_PREFIX, ['var','spriteId'], MARKER_LABEL_COMPOSITE_ACCENT_SUFFIX]
        ]
      ];

      const highlightedStateExpression = ['boolean', ['feature-state', 'isHighlighted'], false];
      const markerLabelHighlightOpacity = ['case', highlightedStateExpression, 1, 0];
      const markerLabelBaseOpacity = ['case', highlightedStateExpression, 0, 1];

      const markerLabelMinZoom = MARKER_MIN_ZOOM;
      const labelLayersConfig = [
        { id:'marker-label', source:'posts', sortKey: 1100, filter: markerLabelFilter, iconImage: markerLabelIconImage, iconOpacity: markerLabelBaseOpacity, minZoom: markerLabelMinZoom },
        { id:'marker-label-highlight', source:'posts', sortKey: 1101, filter: markerLabelFilter, iconImage: markerLabelHighlightIconImage, iconOpacity: markerLabelHighlightOpacity, minZoom: markerLabelMinZoom }
      ];
      labelLayersConfig.forEach(({ id, source, sortKey, filter, iconImage, iconOpacity, minZoom }) => {
        const layerMinZoom = Number.isFinite(minZoom) ? minZoom : markerLabelMinZoom;
        let layerExists = !!map.getLayer(id);
        if(!layerExists){
          try{
            map.addLayer({
              id,
              type:'symbol',
              source,
              filter: filter || markerLabelFilter,
              minzoom: layerMinZoom,
              layout:{
                'icon-image': iconImage || markerLabelIconImage,
                'icon-size': 1,
                'icon-allow-overlap': true,
                'icon-ignore-placement': true,
                'icon-anchor': 'left',
                'icon-pitch-alignment': 'viewport',
                'symbol-z-order': 'viewport-y',
                'symbol-sort-key': sortKey
              },
              paint:{
                'icon-translate': [markerLabelBgTranslatePx, 0],
                'icon-translate-anchor': 'viewport',
                'icon-opacity': iconOpacity || 1
              }
            });
            layerExists = !!map.getLayer(id);
          }catch(e){
            layerExists = !!map.getLayer(id);
          }
        }
        if(!layerExists){
          return;
        }
        try{ map.setFilter(id, filter || markerLabelFilter); }catch(e){}
        try{ map.setLayoutProperty(id,'icon-image', iconImage || markerLabelIconImage); }catch(e){}
        try{ map.setLayoutProperty(id,'icon-size', 1); }catch(e){}
        try{ map.setLayoutProperty(id,'icon-allow-overlap', true); }catch(e){}
        try{ map.setLayoutProperty(id,'icon-ignore-placement', true); }catch(e){}
        try{ map.setLayoutProperty(id,'icon-anchor','left'); }catch(e){}
        try{ map.setLayoutProperty(id,'icon-pitch-alignment','viewport'); }catch(e){}
        try{ map.setLayoutProperty(id,'symbol-z-order','viewport-y'); }catch(e){}
        try{ map.setLayoutProperty(id,'symbol-sort-key', sortKey); }catch(e){}
        try{ map.setPaintProperty(id,'icon-translate',[markerLabelBgTranslatePx,0]); }catch(e){}
        try{ map.setPaintProperty(id,'icon-translate-anchor','viewport'); }catch(e){}
        try{ map.setPaintProperty(id,'icon-opacity', iconOpacity || 1); }catch(e){}
        try{ map.setLayerZoomRange(id, layerMinZoom, 24); }catch(e){}
      });
      ALL_MARKER_LAYER_IDS.forEach(id=>{
        if(map.getLayer(id)){
          try{ map.moveLayer(id); }catch(e){}
        }
      });
      [
        ['marker-label','icon-opacity-transition'],
        ['marker-label-highlight','icon-opacity-transition']
      ].forEach(([layer, prop])=>{
        if(map.getLayer(layer)){
          try{ map.setPaintProperty(layer, prop, {duration:0}); }catch(e){}
        }
      });
      refreshInViewMarkerLabelComposites(map);
      if(!postSourceEventsBound){
        function createMapCardOverlay(post, opts = {}){
          const { targetLngLat, fixedLngLat, eventLngLat, venueKey: overlayVenueKey = null } = opts;
          const previousKey = selectedVenueKey;
          if(overlayVenueKey){
            selectedVenueKey = overlayVenueKey;
          }
          try{
            const overlayRoot = document.createElement('div');
            overlayRoot.className = 'mapmarker-overlay';
            overlayRoot.setAttribute('aria-hidden', 'true');
            overlayRoot.style.pointerEvents = 'none';
            overlayRoot.style.userSelect = 'none';

            const parseVenueKey = (key)=>{
              if(typeof key !== 'string') return null;
              const parts = key.split(',');
              if(parts.length !== 2) return null;
              const lng = Number(parts[0]);
              const lat = Number(parts[1]);
              if(!Number.isFinite(lng) || !Number.isFinite(lat)) return null;
              return { lng, lat };
            };

            let resolvedVenueKey = typeof overlayVenueKey === 'string' && overlayVenueKey ? overlayVenueKey : '';
            let resolvedCoords = resolvedVenueKey ? parseVenueKey(resolvedVenueKey) : null;
            const sourceCoord = targetLngLat || fixedLngLat || eventLngLat || (Number.isFinite(post?.lng) && Number.isFinite(post?.lat) ? { lng: post.lng, lat: post.lat } : null);
            if(!resolvedCoords && sourceCoord && Number.isFinite(sourceCoord.lng) && Number.isFinite(sourceCoord.lat)){
              resolvedCoords = { lng: Number(sourceCoord.lng), lat: Number(sourceCoord.lat) };
            }
            if(!resolvedVenueKey && resolvedCoords){
              resolvedVenueKey = toVenueCoordKey(resolvedCoords.lng, resolvedCoords.lat);
            }
            if(resolvedVenueKey){
              overlayRoot.dataset.venueKey = resolvedVenueKey;
            } else if(overlayVenueKey){
              overlayRoot.dataset.venueKey = overlayVenueKey;
            } else {
              delete overlayRoot.dataset.venueKey;
            }

            const visibleList = (filtersInitialized && Array.isArray(filtered) && filtered.length) ? filtered : posts;
            const allowedIdSet = new Set(Array.isArray(visibleList) ? visibleList.map(item => {
              if(!item || item.id === undefined || item.id === null) return '';
              return String(item.id);
            }).filter(Boolean) : []);
            let venuePostsAll = [];
            if(resolvedCoords && typeof getPostsAtVenueByCoords === 'function'){
              venuePostsAll = getPostsAtVenueByCoords(resolvedCoords.lng, resolvedCoords.lat) || [];
            } else if(resolvedVenueKey && typeof getPostsAtVenueByCoords === 'function'){
              const coords = parseVenueKey(resolvedVenueKey);
              if(coords){
                venuePostsAll = getPostsAtVenueByCoords(coords.lng, coords.lat) || [];
              }
            }
            let venuePostsVisible = Array.isArray(venuePostsAll) ? venuePostsAll.filter(item => allowedIdSet.has(String(item && item.id))) : [];
            if(!venuePostsVisible.length){
              const fallbackPost = Array.isArray(visibleList) ? visibleList.find(item => item && String(item.id) === String(post && post.id)) : null;
              if(fallbackPost){
                venuePostsVisible = [fallbackPost];
              } else if(post){
                venuePostsVisible = [post];
              }
            }
            const uniqueVenuePosts = [];
            const venuePostIds = new Set();
            venuePostsVisible.forEach(item => {
              if(!item || item.id === undefined || item.id === null) return;
              const idStr = String(item.id);
              if(!idStr || venuePostIds.has(idStr)) return;
              venuePostIds.add(idStr);
              uniqueVenuePosts.push(item);
            });
            if(!uniqueVenuePosts.length && post){
              uniqueVenuePosts.push(post);
              if(post.id !== undefined && post.id !== null){
                venuePostIds.add(String(post.id));
              }
            }
            const multiIds = Array.from(venuePostIds);
            const multiCount = uniqueVenuePosts.length;
            const isMultiVenue = multiCount > 1;
            if(isMultiVenue){
              overlayRoot.dataset.multiIds = multiIds.join(',');
            } else {
              delete overlayRoot.dataset.multiIds;
            }
            const sortedList = Array.isArray(sortedPostList) ? sortedPostList : [];
            let primaryVenuePost = null;
            if(isMultiVenue && sortedList.length){
              primaryVenuePost = sortedList.find(entry => entry && venuePostIds.has(String(entry.id))) || null;
            }
            if(!primaryVenuePost){
              primaryVenuePost = uniqueVenuePosts[0] || post;
            }
            const overlayId = primaryVenuePost && primaryVenuePost.id !== undefined && primaryVenuePost.id !== null
              ? String(primaryVenuePost.id)
              : String(post.id);
            overlayRoot.dataset.id = overlayId;

            const markerContainer = document.createElement('div');
            markerContainer.className = 'small-map-card';
            markerContainer.dataset.id = overlayId;
            markerContainer.setAttribute('aria-hidden', 'true');
            markerContainer.style.pointerEvents = 'none';
            markerContainer.style.userSelect = 'none';

            const markerIcon = new Image();
            try{ markerIcon.decoding = 'async'; }catch(e){}
            markerIcon.alt = '';
            markerIcon.className = 'mapmarker';
            markerIcon.draggable = false;
            markerIcon.loading = 'eager';
            markerIcon.referrerPolicy = 'no-referrer';
            if(isMultiVenue){
              markerIcon.src = SMALL_MULTI_MAP_CARD_ICON_SRC;
              enforceSmallMultiMapCardIcon(markerIcon, overlayRoot);
            } else {
              const markerSources = window.subcategoryMarkers || {};
              const markerIds = window.subcategoryMarkerIds || {};
              const slugifyFn = typeof slugify === 'function' ? slugify : (window.slugify || (str => (str || '').toString().trim().toLowerCase().replace(/[^a-z0-9]+/g,'-').replace(/^-+|-+$/g,'')));
              const markerIdCandidates = [];
              if(post && post.subcategory){
                const mappedId = markerIds[post.subcategory];
                if(mappedId) markerIdCandidates.push(mappedId);
                markerIdCandidates.push(slugifyFn(post.subcategory));
              }
              const markerIconUrl = markerIdCandidates.map(id => (id && markerSources[id]) || null).find(Boolean) || '';
              const markerFallback = 'assets/icons-30/whats-on-category-icon-30.webp';
              markerIcon.onerror = ()=>{
                markerIcon.onerror = null;
                markerIcon.src = markerFallback;
              };
              markerIcon.src = markerIconUrl || markerFallback;
            }
            requestAnimationFrame(() => {
              if(typeof markerIcon.decode === 'function'){
                markerIcon.decode().catch(()=>{});
              }
            });

            const markerPill = new Image();
            try{ markerPill.decoding = 'async'; }catch(e){}
            markerPill.alt = '';
            markerPill.src = 'assets/icons-30/150x40-pill-70.webp';
            markerPill.dataset.defaultSrc = 'assets/icons-30/150x40-pill-70.webp';
            markerPill.dataset.highlightSrc = 'assets/icons-30/150x40-pill-2f3b73.webp';
            markerPill.className = 'mapmarker-pill';
            markerPill.loading = 'eager';
            markerPill.style.opacity = '0.9';
            markerPill.style.visibility = 'visible';
            markerPill.draggable = false;
            requestAnimationFrame(() => {
              if(typeof markerPill.decode === 'function'){
                markerPill.decode().catch(()=>{});
              }
            });

            const labelLines = isMultiVenue ? null : getMarkerLabelLines(post);
            const venueDisplayName = (()=>{
              if(resolvedVenueKey){
                const candidates = uniqueVenuePosts.length ? uniqueVenuePosts : (post ? [post] : []);
                for(const candidate of candidates){
                  const locs = Array.isArray(candidate?.locations) ? candidate.locations : [];
                  const match = locs.find(loc => loc && toVenueCoordKey(loc.lng, loc.lat) === resolvedVenueKey && loc.venue);
                  if(match && match.venue){
                    return match.venue;
                  }
                }
              }
              const fallback = uniqueVenuePosts[0] || post;
              return getPrimaryVenueName(fallback) || '';
            })();
            const multiSmallVenueText = shortenMarkerLabelText(venueDisplayName, markerLabelTextAreaWidthPx);
            const multiBigVenueText = shortenMarkerLabelText(venueDisplayName, mapCardTitleWidthPx);
            const multiCountLabel = `${multiCount} posts here`;
            const markerLabel = document.createElement('div');
            markerLabel.className = 'mapmarker-label';
            if(isMultiVenue){
              markerContainer.classList.add('small-multi-post-map-card');
              const markerLine1 = document.createElement('div');
              markerLine1.className = 'mapmarker-label-line';
              markerLine1.textContent = multiCountLabel;
              const markerLine2 = document.createElement('div');
              markerLine2.className = 'mapmarker-label-line';
              markerLine2.textContent = multiSmallVenueText || venueDisplayName || '';
              markerLabel.append(markerLine1, markerLine2);
            } else if(labelLines){
              const markerLine1 = document.createElement('div');
              markerLine1.className = 'mapmarker-label-line';
              markerLine1.textContent = labelLines.line1;
              markerLabel.appendChild(markerLine1);
              if(labelLines.line2){
                const markerLine2 = document.createElement('div');
                markerLine2.className = 'mapmarker-label-line';
                markerLine2.textContent = labelLines.line2;
                markerLabel.appendChild(markerLine2);
              }
            }

            markerContainer.append(markerPill, markerIcon, markerLabel);

            const cardRoot = document.createElement('div');
            cardRoot.className = 'big-map-card big-map-card--popup';
            if(isMultiVenue){
              cardRoot.classList.add('big-multi-post-map-card');
            }
            cardRoot.dataset.id = overlayId;
            cardRoot.setAttribute('aria-hidden', 'true');
            cardRoot.style.pointerEvents = 'auto';
            cardRoot.style.userSelect = 'none';

            const pillImg = new Image();
            try{ pillImg.decoding = 'async'; }catch(e){}
            pillImg.alt = '';
            pillImg.src = 'assets/icons-30/225x60-pill-99.webp';
            pillImg.className = 'map-card-pill';
            pillImg.style.opacity = '0.9';
            pillImg.draggable = false;

            const thumbImg = new Image();
            try{ thumbImg.decoding = 'async'; }catch(e){}
            thumbImg.alt = '';
            thumbImg.loading = 'eager';
            thumbImg.draggable = false;
            if(isMultiVenue){
              thumbImg.src = 'assets/icons-30/multi-post-icon-50.webp';
              thumbImg.className = 'map-card-thumb';
            } else {
              const thumbFallback = 'assets/funmap-logo-small.png';
              thumbImg.onerror = ()=>{
                thumbImg.onerror = null;
                thumbImg.src = thumbFallback;
              };
              thumbImg.src = thumbUrl(post) || thumbFallback;
              thumbImg.className = 'map-card-thumb';
              thumbImg.referrerPolicy = 'no-referrer';
            }
            requestAnimationFrame(() => {
              if(typeof thumbImg.decode === 'function'){
                thumbImg.decode().catch(()=>{});
              }
            });

            const labelEl = document.createElement('div');
            labelEl.className = 'map-card-label';
            const titleWrap = document.createElement('div');
            titleWrap.className = 'map-card-title';
            if(isMultiVenue){
              [multiCountLabel, multiBigVenueText || venueDisplayName || ''].forEach(line => {
                const lineEl = document.createElement('div');
                lineEl.className = 'map-card-title-line';
                lineEl.textContent = line;
                titleWrap.appendChild(lineEl);
              });
            } else if(labelLines){
              const cardTitleLines = Array.isArray(labelLines.cardTitleLines) && labelLines.cardTitleLines.length
                ? labelLines.cardTitleLines.slice(0, 2)
                : [labelLines.line1, labelLines.line2].filter(Boolean).slice(0, 2);
              cardTitleLines.forEach(line => {
                if(!line) return;
                const lineEl = document.createElement('div');
                lineEl.className = 'map-card-title-line';
                lineEl.textContent = line;
                titleWrap.appendChild(lineEl);
              });
            }
            if(!titleWrap.childElementCount){
              const lineEl = document.createElement('div');
              lineEl.className = 'map-card-title-line';
              lineEl.textContent = '';
              titleWrap.appendChild(lineEl);
            }
            labelEl.appendChild(titleWrap);
            if(!isMultiVenue && labelLines){
              const venueLine = labelLines.venueLine || shortenMarkerLabelText(getPrimaryVenueName(post), mapCardTitleWidthPx);
              if(venueLine){
                const venueEl = document.createElement('div');
                venueEl.className = 'map-card-venue';
                venueEl.textContent = venueLine;
                labelEl.appendChild(venueEl);
              }
            }

            cardRoot.append(pillImg, thumbImg, labelEl);
            overlayRoot.append(markerContainer, cardRoot);
            overlayRoot.classList.add('is-card-visible');
            overlayRoot.style.pointerEvents = '';

            const handleOverlayClick = (ev)=>{
              ev.preventDefault();
              ev.stopPropagation();
              const pid = overlayRoot.dataset.id;
              if(!pid) return;
              callWhenDefined('openPost', (fn)=>{
                requestAnimationFrame(() => {
                  try{
                    touchMarker = null;
                    stopSpin();
                    if(typeof closePanel === 'function' && typeof filterPanel !== 'undefined' && filterPanel){
                      try{ closePanel(filterPanel); }catch(err){}
                    }
                    fn(pid, false, true);
                  }catch(err){ console.error(err); }
                });
              });
            };
            cardRoot.addEventListener('click', handleOverlayClick, { capture: true });
            ['pointerdown','mousedown','touchstart'].forEach(type => {
              cardRoot.addEventListener(type, (ev)=>{
                const pointerType = typeof ev.pointerType === 'string' ? ev.pointerType.toLowerCase() : '';
                const isTouchLike = pointerType === 'touch' || ev.type === 'touchstart';
                if(!isTouchLike){
                  try{ ev.preventDefault(); }catch(err){}
                }
                try{ ev.stopPropagation(); }catch(err){}
              }, { capture: true });
            });
            cardRoot.addEventListener('mouseenter', ()=>{
              window.__overCard = true;
            });
            cardRoot.addEventListener('mouseleave', ()=>{
              window.__overCard = false;
              if(listLocked) return;
              const currentPopup = hoverPopup;
              schedulePopupRemoval(currentPopup, 160);
            });

            const marker = new mapboxgl.Marker({ element: overlayRoot, anchor: 'center' });
            if(typeof marker.setZIndexOffset === 'function'){
              try{ marker.setZIndexOffset(20000); }catch(e){}
            }
            const markerElement = typeof marker.getElement === 'function' ? marker.getElement() : overlayRoot;
            if(markerElement && markerElement.style){
              markerElement.style.zIndex = '20000';
            }
            if(targetLngLat){ marker.setLngLat(targetLngLat); }
            else if(fixedLngLat){ marker.setLngLat(fixedLngLat); }
            else if(eventLngLat){ marker.setLngLat(eventLngLat); }
            marker.addTo(map);
            marker.__fixedLngLat = fixedLngLat;
            window.__overCard = false;
            registerPopup(marker);
            return marker;
          } finally {
            if(overlayVenueKey){
              selectedVenueKey = previousKey;
            }
          }
        }

        const handleMarkerClick = (e)=>{
          stopSpin();
          const f = e.features && e.features[0]; if(!f) return;
          const props = f.properties || {};
          const venueKey = props.venueKey || null;
          const id = props.id;
          const rawMultiIds = Array.isArray(props.multiPostIds) ? props.multiPostIds : [];
          const normalizedMultiIds = rawMultiIds.map(item => String(item)).filter(Boolean);
          const multiCountFromProps = Number(props.multiCount);
          let normalizedMultiCount = Number.isFinite(multiCountFromProps) && multiCountFromProps > 0 ? multiCountFromProps : 0;
          if(!normalizedMultiCount){
            normalizedMultiCount = normalizedMultiIds.length;
          }
          const helperMultiCount = Math.max(normalizedMultiIds.length, normalizedMultiCount, props.isMultiVenue ? 2 : 0);
          const isMultiCluster = helperMultiCount > 1;
          if(id !== undefined && id !== null){
            activePostId = id;
            selectedVenueKey = venueKey;
            updateSelectedMarkerRing();
          }
          const coords = f.geometry && f.geometry.coordinates;
          const hasCoords = Array.isArray(coords) && coords.length >= 2 && Number.isFinite(coords[0]) && Number.isFinite(coords[1]);
          const baseLngLat = hasCoords ? { lng: coords[0], lat: coords[1] } : (e && e.lngLat ? { lng: e.lngLat.lng, lat: e.lngLat.lat } : null);
          const fixedLngLat = baseLngLat || (e && e.lngLat ? { lng: e.lngLat.lng, lat: e.lngLat.lat } : null);
          const targetLngLat = baseLngLat || (e ? e.lngLat : null);
          const touchClick = isTouchDevice || (e.originalEvent && (e.originalEvent.pointerType === 'touch' || e.originalEvent.pointerType === 'pen'));
          if(touchClick){
            if(touchMarker !== id || !hoverPopup){
              touchMarker = id;
              if(hoverPopup){
                runOverlayCleanup(hoverPopup);
                try{ hoverPopup.remove(); }catch(err){}
                hoverPopup = null;
                updateSelectedMarkerRing();
              }
              const p = posts.find(x=>x.id===id);
              if(p){
                hoverPopup = createMapCardOverlay(p, { targetLngLat, fixedLngLat, eventLngLat: e && e.lngLat, venueKey });
                updateSelectedMarkerRing();
              }
            }
            if(isMultiCluster){
              autoOpenPostBoardForCluster({
                multiIds: normalizedMultiIds,
                multiCount: helperMultiCount,
                trigger: 'touch'
              });
            }
            return;
          }
          if(isMultiCluster){
            autoOpenPostBoardForCluster({
              multiIds: normalizedMultiIds,
              multiCount: helperMultiCount,
              trigger: 'click'
            });
          }
        };
      MARKER_INTERACTIVE_LAYERS.forEach(layer => map.on('click', layer, handleMarkerClick));

      map.on('click', e=>{
        const originalTarget = e.originalEvent && e.originalEvent.target;
        const targetEl = originalTarget && typeof originalTarget.closest === 'function'
          ? originalTarget.closest('.mapmarker-overlay')
          : null;
        if(targetEl){
          return;
        }
        const feats = map.queryRenderedFeatures(e.point);
        if(!feats.length){
          if(hoverPopup){
            runOverlayCleanup(hoverPopup);
            try{ hoverPopup.remove(); }catch(err){}
            hoverPopup = null;
          }
          updateSelectedMarkerRing();
          touchMarker = null;
        }
      });

      updateSelectedMarkerRing();

      // Cursor + popup for marker points
      
      const handleMarkerMouseEnter = (e)=>{
        map.getCanvas().style.cursor = 'pointer';
        const f = e.features && e.features[0]; if(!f) return;
        const props = f.properties || {};
        const id = props.id;
        const venueKey = props.venueKey || null;
        const coords = f.geometry && f.geometry.coordinates;
        const hasCoords = Array.isArray(coords) && coords.length >= 2 && Number.isFinite(coords[0]) && Number.isFinite(coords[1]);
        const baseLngLat = hasCoords ? { lng: coords[0], lat: coords[1] } : (e && e.lngLat ? { lng: e.lngLat.lng, lat: e.lngLat.lat } : null);
        const fixedLngLat = baseLngLat || (e && e.lngLat ? { lng: e.lngLat.lng, lat: e.lngLat.lat } : null);
        const targetLngLat = baseLngLat || (e ? e.lngLat : null);
        const p = posts.find(x=>x.id===id);
        if(!p){
          return;
        }
        if(hoverPopup){
          runOverlayCleanup(hoverPopup);
          try{ hoverPopup.remove(); }catch(e){}
          hoverPopup = null;
          updateSelectedMarkerRing();
        }
        hoverPopup = createMapCardOverlay(p, { targetLngLat, fixedLngLat, eventLngLat: e && e.lngLat, venueKey });
        updateSelectedMarkerRing();
      };
      MARKER_INTERACTIVE_LAYERS.forEach(layer => map.on('mouseenter', layer, handleMarkerMouseEnter));

      const onMarkerMove = window.rafThrottle((evt)=>{
        if(hoverPopup && typeof hoverPopup.setLngLat === 'function'){
          const fixed = hoverPopup.__fixedLngLat;
          if(fixed && Number.isFinite(fixed.lng) && Number.isFinite(fixed.lat)){
            hoverPopup.setLngLat(fixed);
          }
        }
      });
      MARKER_INTERACTIVE_LAYERS.forEach(layer => map.on('mousemove', layer, onMarkerMove));

      const handleMarkerMouseLeave = ()=>{
        map.getCanvas().style.cursor = 'grab';
        if(listLocked) return;
        const currentPopup = hoverPopup;
        schedulePopupRemoval(currentPopup, 200);
      };
      MARKER_INTERACTIVE_LAYERS.forEach(layer => map.on('mouseleave', layer, handleMarkerMouseLeave));

      // Maintain pointer cursor for balloons and surface multi-venue cards when applicable
        postSourceEventsBound = true;
      }
      } catch (err) {
        console.error('addPostSource failed', err);
      } finally {
        addingPostSource = false;
        const shouldReplay = pendingAddPostSource;
        pendingAddPostSource = false;
        if(shouldReplay){
          addPostSource();
        }
      }
    }
    window.addPostSource = addPostSource;
    function renderLists(list){
      if(spinning || !postsLoaded) return;
      const sort = currentSort;
      const arr = list.slice();
      if(sort==='az') arr.sort((a,b)=> a.title.localeCompare(b.title));
      if(sort==='soon') arr.sort((a,b)=> a.dates[0].localeCompare(b.dates[0]));
      if(sort==='nearest'){
        let ref = {lng:0,lat:0}; if(map){ const c = map.getCenter(); ref = {lng:c.lng,lat:c.lat}; }
        arr.sort((a,b)=> distKm({lng:a.lng,lat:a.lat}, ref) - distKm({lng:b.lng,lat:b.lat}, ref));
      }
      if(favToTop && !favSortDirty) arr.sort((a,b)=> (b.fav - a.fav));

      const { postsData } = getMarkerCollections(arr);
      const boundsForCount = getVisibleMarkerBoundsForCount();
      const markerTotal = boundsForCount ? countMarkersForVenue(arr, null, boundsForCount) : countMarkersForVenue(arr);

      sortedPostList = arr;
      renderedPostCount = 0;

      if(postBatchObserver) postBatchObserver.disconnect();
      removeScrollListener(postsWideEl, onPostBoardScroll, postBoardScrollOptions);
      postBoardScrollOptions = null;
      if(postSentinel) postSentinel.remove();
      postSentinel = null;

      if(resultsEl) resultsEl.innerHTML = '';
      postsWideEl.innerHTML = '';

      if(markerTotal === 0){
        updateResultCount(0);
        const emptyWrap = document.createElement('div');
        emptyWrap.className = 'post-board-empty';
        const summaryEl = $('#filterSummary');
        const summaryText = summaryEl ? summaryEl.textContent.trim() : '';
        const summaryCopy = document.createElement('div');
        summaryCopy.className = 'filter-summary post-board-empty-summary';
        summaryCopy.textContent = summaryText || 'No results match your filters.';
        emptyWrap.appendChild(summaryCopy);
        const emptyImg = document.createElement('img');
        emptyImg.src = 'assets/monkeys/Firefly_cute-little-monkey-in-red-cape-pointing-up-937096.png';
        emptyImg.alt = 'Cute little monkey in red cape pointing up';
        emptyImg.className = 'post-board-empty-image';
        emptyWrap.appendChild(emptyImg);
        const emptyMsg = document.createElement('p');
        emptyMsg.className = 'post-board-empty-message';
        emptyMsg.textContent = 'There are no posts here. Try moving the map or changing your filter settings.';
        emptyWrap.appendChild(emptyMsg);
        postsWideEl.appendChild(emptyWrap);
        return;
      }

      postSentinel = document.createElement('div');
      postSentinel.style.height = '1px';
      postsWideEl.appendChild(postSentinel);

      if(spinning && arr.length){
        const sample = card(arr[0], true);
        sample.style.visibility = 'hidden';
        postsWideEl.insertBefore(sample, postSentinel);
        const rect = sample.getBoundingClientRect();
        const style = getComputedStyle(sample);
        const cardHeight = rect.height + parseFloat(style.marginBottom || 0);
        postsWideEl.removeChild(sample);
        const max = Math.max(1, Math.floor(postsModeEl.clientHeight / cardHeight));
        appendPostBatch(max);
      } else {
        appendPostBatch(INITIAL_RENDER_COUNT);
      }

      updateResultCount(markerTotal);

      if('IntersectionObserver' in window){
        postBatchObserver = new IntersectionObserver(entries => {
          entries.forEach(entry => {
            if(entry.isIntersecting){
              appendPostBatch();
            }
          });
        }, {root: postsWideEl, rootMargin:'0px 0px 200px 0px'});
        postBatchObserver.observe(postSentinel);
      } else {
        postBoardScrollOptions = addPassiveScrollListener(postsWideEl, onPostBoardScroll);
      }
    }
    function updateResultCount(n){
      const el = $('#resultCount');
      if(!el) return;
      if(spinning){
        el.innerHTML = '';
        el.style.display = 'none';
        return;
      }
      el.innerHTML = `<strong>${n}</strong>`;
      el.style.display = '';
    }
    function formatDates(d){
      if(!d || !d.length) return '';
      const sorted = d.slice().sort();
      const currentYear = new Date().getFullYear();
      const formatPart = (dateObj, includeYear=false)=>{
        const base = dateObj.toLocaleDateString('en-GB',{weekday:'short', day:'numeric', month:'short'}).replace(/,/g,'');
        return includeYear ? `${base}, ${dateObj.getFullYear()}` : base;
      };
      const first = parseISODate(sorted[0]);
      const last = parseISODate(sorted[sorted.length-1]);
      if(sorted.length === 1){
        const includeYear = first.getFullYear() !== currentYear;
        return formatPart(first, includeYear);
      }
      const firstYear = first.getFullYear();
      const lastYear = last.getFullYear();
      const crossYear = firstYear !== lastYear;
      const firstIncludeYear = crossYear && firstYear !== currentYear;
      const lastIncludeYear = (crossYear && lastYear !== currentYear) || (!crossYear && lastYear !== currentYear);
      const startText = formatPart(first, firstIncludeYear);
      const endText = formatPart(last, lastIncludeYear);
      return `${startText} - ${endText}`;
    }

    function parseCreatedToDate(created){
      if(!created) return null;
      const parts = created.split('T');
      if(parts.length < 2) return null;
      const [datePart, rawTime] = parts;
      if(!datePart) return null;
      const hasZ = rawTime.endsWith('Z');
      const timeCore = hasZ ? rawTime.slice(0, -1) : rawTime;
      const [hh = '00', mm = '00', ss = '00', ms = ''] = timeCore.split('-');
      const iso = `${datePart}T${hh.padStart(2,'0')}:${mm.padStart(2,'0')}:${ss.padStart(2,'0')}${ms ? '.' + ms : ''}${hasZ ? 'Z' : ''}`;
      const dt = new Date(iso);
      return Number.isNaN(dt.getTime()) ? null : dt;
    }

    function formatPostTimestamp(created){
      const dt = parseCreatedToDate(created);
      if(!dt) return '';
      const y = dt.getUTCFullYear();
      const m = String(dt.getUTCMonth()+1).padStart(2,'0');
      const d = String(dt.getUTCDate()).padStart(2,'0');
      const hh = String(dt.getUTCHours()).padStart(2,'0');
      const mm = String(dt.getUTCMinutes()).padStart(2,'0');
      return `${y}-${m}-${d} ${hh}:${mm} UTC`;
    }

    function prioritizeVisibleImages(){
      const roots = [postsWideEl];
      if(resultsEl) roots.push(resultsEl);
      roots.forEach(root => {
        const imgs = root.querySelectorAll('img.thumb');
        if(!imgs.length) return;
        if('IntersectionObserver' in window){
          const observerRoot = root === postsWideEl ? root.closest('.post-board') : root;
          const obs = new IntersectionObserver(entries => {
            entries.forEach(entry => {
              if(entry.isIntersecting){
                const img = entry.target;
                if(img.dataset.src){
                  img.addEventListener('load', ()=> img.classList.remove('lqip'), {once:true});
                  img.src = img.dataset.src;
                  img.removeAttribute('data-src');
                }
                img.fetchPriority = 'high';
                obs.unobserve(img);
              }
            });
          }, {root: observerRoot});
          imgs.forEach(img => obs.observe(img));
        } else {
          imgs.forEach(img => {
            img.loading = 'lazy';
            if(img.dataset.src){
              img.addEventListener('load', ()=> img.classList.remove('lqip'), {once:true});
              img.src = img.dataset.src;
              img.removeAttribute('data-src');
            }
          });
        }
      });
    }

    function card(p, wide=false){
      const el = document.createElement('article');
      el.className = wide ? 'post-card' : 'recents-card';
      el.dataset.id = p.id;
      if(wide) el.style.gridTemplateColumns='80px 1fr 36px';
      const thumbSrc = thumbUrl(p);
      const thumb = `<img class="thumb lqip" loading="lazy" src="${thumbSrc}" alt="" referrerpolicy="no-referrer" />`;
        el.innerHTML = `
          ${thumb}
        <div class="meta">
          <div class="title">${p.title}</div>
          <div class="info">
            <div class="cat-line"><span class="sub-icon">${subcategoryIcons[p.subcategory]||''}</span> ${p.category} &gt; ${p.subcategory}</div>
            <div class="loc-line"><span class="badge" title="Venue">📍</span><span>${p.city}</span></div>
            <div class="date-line"><span class="badge" title="Dates">📅</span><span>${formatDates(p.dates)}</span></div>
          </div>
        </div>
        <button class="fav" aria-pressed="${p.fav?'true':'false'}" aria-label="Toggle favourite">
          <svg viewBox="0 0 24 24"><path d="M12 17.3 6.2 21l1.6-6.7L2 9.3l6.9-.6L12 2l3.1 6.7 6.9.6-5.8 4.9L17.8 21 12 17.3z"/></svg>
        </button>
      `;
      el.dataset.surfaceBg = CARD_SURFACE;
      el.style.background = CARD_SURFACE;
      el.querySelector('.fav').addEventListener('click', (e)=>{
        e.stopPropagation();
        p.fav = !p.fav;
        favSortDirty = true;
        document.querySelectorAll(`[data-id="${p.id}"] .fav`).forEach(btn=>{
          btn.setAttribute('aria-pressed', p.fav ? 'true' : 'false');
        });
        renderHistoryBoard();
      });

      const handleHoverHighlight = (state)=> toggleSmallMapCardHoverHighlight(p.id, state);

      el.addEventListener('mouseenter', ()=> handleHoverHighlight(true));
      el.addEventListener('mouseleave', ()=> handleHoverHighlight(false));
      el.dataset.hoverHighlightBound = '1';
      return el;
    }

    document.addEventListener('mouseover', event => {
      const cardEl = event.target.closest('.post-card, .recents-card');
      if(!cardEl || cardEl.dataset.hoverHighlightBound === '1') return;
      const related = event.relatedTarget;
      if(related && cardEl.contains(related)) return;
      const id = cardEl.dataset ? cardEl.dataset.id : null;
      if(!id) return;
      toggleSmallMapCardHoverHighlight(id, true);
    });

    document.addEventListener('mouseout', event => {
      const cardEl = event.target.closest('.post-card, .recents-card');
      if(!cardEl || cardEl.dataset.hoverHighlightBound === '1') return;
      const related = event.relatedTarget;
      if(related && cardEl.contains(related)) return;
      const id = cardEl.dataset ? cardEl.dataset.id : null;
      if(!id) return;
      toggleSmallMapCardHoverHighlight(id, false);
    });

    // History board
    function loadHistory(){ try{ return JSON.parse(localStorage.getItem('openHistoryV2')||'[]'); }catch(e){ return []; } }
    function saveHistory(){ localStorage.setItem('openHistoryV2', JSON.stringify(viewHistory)); }
    function formatLastOpened(ts){
      if(!ts) return '';
      const diff = Date.now() - ts;
      const mins = Math.floor(diff/60000);
      let ago;
      if(mins < 60){
        ago = mins + ' minute' + (mins===1?'':'s');
      } else if(mins < 1440){
        const hrs = Math.floor(mins/60);
        ago = hrs + ' hour' + (hrs===1?'':'s');
      } else {
        const days = Math.floor(mins/1440);
        ago = days + ' day' + (days===1?'':'s');
      }
      const d = new Date(ts);
      const weekday = d.toLocaleDateString('en-GB', {weekday:'short'});
      const day = d.getDate();
      const month = d.toLocaleDateString('en-GB', {month:'short'});
      const year = d.getFullYear();
      const hour = String(d.getHours()).padStart(2,'0');
      const minute = String(d.getMinutes()).padStart(2,'0');
      return `Last opened ${ago} ago - ${weekday} ${day} ${month}, ${year} ${hour}:${minute}`;
    }

    function captureState(){
      const {start,end} = orderedRange();
      const openCats = Object.values(categoryControllers).filter(ctrl=>ctrl.getOpenState && ctrl.getOpenState()).map(ctrl=>ctrl.name);
      return {
        bounds: map ? map.getBounds().toArray() : null,
        kw: $('#keyword-textbox').value,
        date: $('#daterange-textbox').value,
        start: start ? toISODate(start) : null,
        end: end ? toISODate(end) : null,
        expired: $('#expiredToggle').checked,
        minPrice: $('#min-price-input') ? $('#min-price-input').value : '',
        maxPrice: $('#max-price-input') ? $('#max-price-input').value : '',
        cats: [...selection.cats],
        subs: [...selection.subs],
        openCats
      };
    }

    function restoreState(st){
      if(!st) return;
      $('#keyword-textbox').value = st.kw || '';
      if($('#min-price-input')){
        const minEl = $('#min-price-input');
        minEl.value = (st.minPrice || '').toString().replace(/\D+/g,'');
      }
      if($('#max-price-input')){
        const maxEl = $('#max-price-input');
        maxEl.value = (st.maxPrice || '').toString().replace(/\D+/g,'');
      }
      dateStart = st.start ? parseISODate(st.start) : null;
      dateEnd = st.end ? parseISODate(st.end) : null;
      if(!st.start && st.range){
        const parts = st.range.split(' to ').map(s=>s.trim());
        if(parts[0]) dateStart = parseISODate(parts[0]);
        if(parts[1]) dateEnd = parseISODate(parts[1]);
      }
      $('#expiredToggle').checked = st.expired || false;
      if($('#expiredToggle').checked){
        buildFilterCalendar(minPickerDate, maxPickerDate);
      } else {
        buildFilterCalendar(today, maxPickerDate);
      }
      if(dateStart){
        const sIso = toISODate(dateStart);
        const sDisp = fmtShort(sIso);
        if(dateEnd && dateEnd.getTime() !== dateStart.getTime()){
          const eIso = toISODate(dateEnd);
          const eDisp = fmtShort(eIso);
          $('#daterange-textbox').value = `${sDisp} - ${eDisp}`;
        } else {
          $('#daterange-textbox').value = sDisp;
        }
      } else {
        $('#daterange-textbox').value = '';
      }
      expiredWasOn = $('#expiredToggle').checked;
      updateRangeClasses();
      updateInput();
      const savedCatsArray = Array.isArray(st.cats) && st.cats.length ? st.cats : categories.map(cat=>cat.name);
      const savedCats = new Set(savedCatsArray);
      const savedSubsArray = Array.isArray(st.subs) ? st.subs : null;
      const subsToUse = savedSubsArray && savedSubsArray.length ? savedSubsArray : allSubcategoryKeys;
      const openCats = Array.isArray(st.openCats) ? new Set(st.openCats) : null;
      selection.cats = new Set();
      selection.subs = new Set(subsToUse);
      const controllers = Object.values(categoryControllers);
      if(controllers.length){
        controllers.forEach(ctrl=>{
          const active = savedCats.has(ctrl.name);
          ctrl.setActive(active, {silent:true});
          const shouldOpen = active && (openCats ? openCats.has(ctrl.name) : false);
          ctrl.setOpen(shouldOpen);
          ctrl.syncSubs();
        });
      } else {
        selection.cats = new Set(savedCatsArray);
      }
      if(map && st.bounds){
        stopSpin();
        const bounds = new mapboxgl.LngLatBounds(st.bounds);
        map.fitBounds(bounds, {padding:10});
        postPanel = bounds;
      }
      applyFilters();
      updateClearButtons();
      updateCategoryResetBtn();
    }
    function renderHistoryBoard(){
      if(!recentsBoard) return;
      recentsBoard.innerHTML='';
      const validHistory = viewHistory.filter(v => getPostByIdAnywhere(v.id));
      viewHistory = validHistory;
      saveHistory();
      const items = viewHistory.slice(0,100);
      for(const v of items){
        const p = getPostByIdAnywhere(v.id);
        if(!p) continue;
        if(!v.lastOpened) v.lastOpened = Date.now();
        const labelEl = document.createElement('div');
        labelEl.className = 'last-opened-label';
        labelEl.textContent = formatLastOpened(v.lastOpened);
        recentsBoard.appendChild(labelEl);
        const el = card(p);
        recentsBoard.appendChild(el);
      }
      const reminderWrap = document.createElement('div');
      reminderWrap.className = 'recents-board-reminder';
      const reminderImg = document.createElement('img');
      reminderImg.src = 'assets/monkeys/Firefly_cute-little-monkey-in-red-cape-pointing-up-937096.png';
      reminderImg.alt = 'Cute little monkey in red cape pointing up';
      reminderWrap.appendChild(reminderImg);
      const reminderMsg = document.createElement('p');
      reminderMsg.textContent = 'When you log in as a member, I can remember your recent posts and favourites on any device.';
      reminderWrap.appendChild(reminderMsg);
      recentsBoard.appendChild(reminderWrap);
    }

    renderHistoryBoard();

function openPostModal(id){
      const p = getPostByIdAnywhere(id);
      if(!p) return;
      activePostId = id;
      updateSelectedMarkerRing();
      const container = document.getElementById('post-modal-container');
      if(!container) return;
      const modal = container.querySelector('.post-modal');
      modal.innerHTML='';
      const wrap = document.createElement('div');
      wrap.className = 'post-board';
      const detail = buildDetail(p);
      const headerEl = detail.querySelector('.post-header');
      const favBtn = headerEl && headerEl.querySelector('.fav');
      if(headerEl && favBtn){
        const closeBtn = document.createElement('button');
        closeBtn.type='button';
        closeBtn.className='close-post';
        closeBtn.setAttribute('aria-label','Close post');
        closeBtn.textContent='✖';
        closeBtn.style.marginLeft='10px';
        favBtn.after(closeBtn);
        closeBtn.addEventListener('click', e=>{ e.stopPropagation(); closePostModal(); });
      }
      wrap.appendChild(detail);
      modal.appendChild(wrap);
      hookDetailActions(detail, p);
      container.classList.remove('hidden');
      if(!panelStack.includes(container)) panelStack.push(container);
      bringToTop(container);
      requestAnimationFrame(()=>{
        const imgArea = detail.querySelector('.post-images');
        const text = detail.querySelector('.post-details');
        if(headerEl){
          headerEl.style.position='sticky';
          headerEl.style.top='0';
          headerEl.style.zIndex='2';
        }
        if(imgArea && text && text.offsetTop === imgArea.offsetTop){
          imgArea.style.position='sticky';
          imgArea.style.top = headerEl ? headerEl.offsetHeight + 'px' : '0';
        }
      });
      viewHistory = viewHistory.filter(x=>x.id!==id);
      viewHistory.unshift({id:p.id, title:p.title, url:postUrl(p), lastOpened: Date.now()});
      if(viewHistory.length>100) viewHistory.length=100;
      saveHistory(); renderHistoryBoard();
      location.hash = `/post/${p.slug}-${p.created}`;
    }

    function closePostModal(){
      const container = document.getElementById('post-modal-container');
      if(!container) return;
      container.classList.add('hidden');
      const idx = panelStack.indexOf(container);
      if(idx!==-1) panelStack.splice(idx,1);
      const modal = container.querySelector('.post-modal');
      if(modal) modal.innerHTML='';
      location.hash = '';
    }
    window.closePostModal = closePostModal;

    function handleHash(){
      if(!location.hash){
        closePostModal();
        return;
      }
      const m = location.hash.match(/\/post\/([^\/]+)-([^\/]+)$/);
      if(!m) return;
      const slug = decodeURIComponent(m[1]);
      const created = m[2];
      const matchPost = (list) => {
        if(!Array.isArray(list) || !list.length) return null;
        return list.find(x => x && x.slug === slug && x.created === created) || null;
      };
      let post = matchPost(posts);
      if(!post){
        const cache = getAllPostsCache({ allowInitialize: true });
        post = matchPost(cache);
      }
      if(post){ openPostModal(post.id); }
    }

    window.addEventListener('hashchange', handleHash);

    window.addEventListener('resize', ()=>{});

    document.addEventListener('DOMContentLoaded', ()=>{
      const container = document.getElementById('post-modal-container');
      if(container){
        container.addEventListener('click', e=>{ if(e.target===container) closePostModal(); });
      }
      handleHash();
    });

    document.addEventListener('click', (ev)=>{
      const card = ev.target.closest('.mapboxgl-popup.big-map-card .big-map-card');
      if(card){
        ev.preventDefault();
        const pid = card.getAttribute('data-id') || (card.closest('.map-card-list-item') && card.closest('.map-card-list-item').getAttribute('data-id'));
        if(pid){
          callWhenDefined('openPost', (fn)=>{
            requestAnimationFrame(() => {
              try{
                touchMarker = null;
                stopSpin();
                if(typeof closePanel === 'function' && typeof filterPanel !== 'undefined' && filterPanel){
                  try{ closePanel(filterPanel); }catch(err){}
                }
                fn(pid, false, true);
              }catch(err){ console.error(err); }
            });
          });
        }
      }
    }, { capture:true });

    function hookDetailActions(el, p){
      el.querySelectorAll('.post-header').forEach(headerEl => {
        headerEl.addEventListener('click', evt=>{
          if(evt.target.closest('button')) return;
          evt.stopPropagation();
          closeActivePost();
        });
      });
      el.querySelectorAll('.fav').forEach(favBtn => {
        favBtn.addEventListener('click', (e)=>{
          e.stopPropagation();
          p.fav = !p.fav;
          favSortDirty = true;
          document.querySelectorAll(`[data-id="${p.id}"] .fav`).forEach(btn=>{
            btn.setAttribute('aria-pressed', p.fav ? 'true' : 'false');
          });
          const detailEl = el;
          renderHistoryBoard();
          const replacement = postsWideEl.querySelector(`[data-id="${p.id}"]`);
          if(replacement){
            replacement.replaceWith(detailEl);
          }
        });
      });

      el.querySelectorAll('.share').forEach(shareBtn => {
        shareBtn.addEventListener('click', (e)=>{
          e.stopPropagation();
          const url = postUrl(p);
          navigator.clipboard.writeText(url).then(()=>{ showCopyMsg(shareBtn); });
        });
      });

      const descEl = el.querySelector('.post-details .desc');
      if(descEl){
        const toggleDesc = evt => {
          const allowed = ['Enter', ' ', 'Spacebar', 'Space'];
          if(evt.type === 'keydown' && !allowed.includes(evt.key)){
            return;
          }
          evt.preventDefault();
          const expanded = !descEl.classList.contains('expanded');
          descEl.classList.toggle('expanded', expanded);
          descEl.setAttribute('aria-expanded', expanded ? 'true' : 'false');
          const openPostEl = el;
          if(openPostEl){
            openPostEl.classList.toggle('desc-expanded', expanded);
          }
          if(expanded){
            document.body.classList.remove('open-post-sticky-images');
          } else if(typeof updateStickyImages === 'function'){
            updateStickyImages();
          }
        };
        descEl.addEventListener('click', toggleDesc);
        descEl.addEventListener('keydown', toggleDesc);
      }

      const imgs = p.images && p.images.length ? p.images : [heroUrl(p)];
      const thumbCol = el.querySelector('.thumbnail-row');
      const imageBox = el.querySelector('.image-box');
      const imageTrack = imageBox ? imageBox.querySelector('.image-track') : null;
      const baseImg = imageTrack ? imageTrack.querySelector('img') : null;
      const slides = [];
      if(imageBox){
        imageBox._modalImages = imgs.slice();
        try {
          imageBox.dataset.modalImages = JSON.stringify(imgs);
        } catch(err) {
          imageBox.dataset.modalImages = '';
        }
        if(typeof imageBox.dataset.index === 'undefined'){
          imageBox.dataset.index = '0';
        }
      }
      if(baseImg){
        baseImg.dataset.index = '0';
        baseImg.dataset.full = imgs[0];
        if(!baseImg.classList.contains('ready')){
          baseImg.classList.add('lqip');
        }
        slides[0] = baseImg;
      }
      if(imageTrack){
        imageTrack.style.transform = 'translateX(0)';
      }
      for(let i=1;i<imgs.length;i++){
        if(!imageTrack) break;
        const slide = document.createElement('img');
        slide.dataset.index = i;
        slide.dataset.full = imgs[i];
        slide.alt = '';
        slide.decoding = 'async';
        slide.loading = 'lazy';
        slide.classList.add('lqip');
        slide.src = imgs[i];
        imageTrack.appendChild(slide);
        slides[i] = slide;
      }
      if(thumbCol){
        imgs.forEach((url,i)=>{
          const t = document.createElement('img');
          t.src = url;
          t.dataset.full = url;
          t.dataset.index = i;
          t.tabIndex = 0;
          thumbCol.appendChild(t);
        });
      }
      const clampIdx = idx => Math.min(Math.max(idx, 0), imgs.length - 1);
      let currentIdx = 0;
      const ensureSlide = idx => {
        if(!imageTrack) return null;
        if(!slides[idx]){
          const slide = document.createElement('img');
          slide.dataset.index = idx;
          slide.dataset.full = imgs[idx];
          slide.alt = '';
          slide.decoding = 'async';
          slide.loading = 'lazy';
          slide.classList.add('lqip');
          slide.src = imgs[idx];
          imageTrack.appendChild(slide);
          slides[idx] = slide;
        }
        return slides[idx];
      };
      const scrollThumbIntoView = target => {
        if(!thumbCol || !target) return;
        const rowRect = thumbCol.getBoundingClientRect();
        const tRect = target.getBoundingClientRect();
        if(tRect.left < rowRect.left){
          thumbCol.scrollBy({left: tRect.left - rowRect.left - 8, behavior:'smooth'});
        } else if(tRect.right > rowRect.right){
          thumbCol.scrollBy({left: tRect.right - rowRect.right + 8, behavior:'smooth'});
        }
      };
      const moveTo = (idx, {instant=false}={})=>{
        if(!imageTrack) return;
        if(instant){
          imageTrack.style.transition = 'none';
        }
        const apply = ()=>{ imageTrack.style.transform = `translateX(-${idx * 100}%)`; };
        if(instant){
          apply();
          requestAnimationFrame(()=>{ imageTrack.style.transition = ''; });
        } else {
          apply();
        }
      };
      function show(idx, {instant=false}={}){
        idx = clampIdx(idx);
        const t = thumbCol ? thumbCol.querySelector(`img[data-index="${idx}"]`) : null;
        const slide = ensureSlide(idx);
        if(!slide) return;
        const prevIdx = currentIdx;
        const alreadyReady = slide.classList.contains('ready');
        currentIdx = idx;
        if(prevIdx !== idx || instant){
          moveTo(idx, {instant});
        }
        if(imageBox){
          imageBox.dataset.index = idx;
        }
        if(slides.length){
          slides.forEach((img,i)=>{
            if(img){
              img.classList.toggle('active', i===idx);
            }
          });
        }
        if(t && thumbCol){
          thumbCol.querySelectorAll('img').forEach(im=> im.classList.toggle('selected', im===t));
          scrollThumbIntoView(t);
        }
        if(t && slide.src !== t.src){
          slide.src = t.src;
        }
        const full = (t && (t.dataset.full || t.src)) || slide.dataset.full || slide.src;
        if(!slide.dataset.full){
          slide.dataset.full = full;
        }
        if(!alreadyReady || slide.src !== full){
          slide.classList.remove('ready');
          slide.classList.add('lqip');
          const hi = new Image();
          hi.onload = ()=>{
            const swap = ()=>{
              if(slide.dataset.full !== full){ slide.dataset.full = full; }
              slide.src = full;
              slide.classList.remove('lqip');
              slide.classList.add('ready');
            };
            if(hi.decode){ hi.decode().then(swap).catch(swap); } else { swap(); }
          };
          hi.onerror = ()=>{};
          hi.src = full;
        }
      }
      show(0, {instant:true});
      if(thumbCol){
        thumbCol.scrollLeft = 0;
        setupHorizontalWheel(thumbCol);
        thumbCol.addEventListener('click', e=>{
          const t = e.target.closest('img');
          if(!t) return;
          const idx = clampIdx(parseInt(t.dataset.index,10));
          if(currentIdx === idx && t.classList.contains('selected')){
            const fullSrc = t.dataset.full || t.src;
            openImageModal(fullSrc, {images: imgs, startIndex: idx, origin: t});
          } else {
            show(idx);
          }
        });
        thumbCol.addEventListener('keydown', e=>{
          if(e.key==='ArrowDown'){
            e.preventDefault();
            const ni = clampIdx(currentIdx + 1);
            show(ni);
            const nextThumb = thumbCol.querySelector(`img[data-index="${ni}"]`);
            if(nextThumb) nextThumb.focus();
          } else if(e.key==='ArrowUp'){
            e.preventDefault();
            const ni = clampIdx(currentIdx - 1);
            show(ni);
            const prevThumb = thumbCol.querySelector(`img[data-index="${ni}"]`);
            if(prevThumb) prevThumb.focus();
          }
        });
      }
      if(imageBox){
        let dragStartX = null;
        let dragStartY = null;
        let dragActive = false;
        let lastDragTime = 0;
        const resetDragState = ()=>{
          dragStartX = null;
          dragStartY = null;
          dragActive = false;
          if(imageTrack){
            imageTrack.style.transition = '';
          }
        };
        imageBox.addEventListener('click', e=>{
          if(Date.now() - lastDragTime < 400){
            e.preventDefault();
            return;
          }
          const imgTarget = e.target.closest('.image-track img');
          if(!imgTarget) return;
          e.stopPropagation();
          const currentSlide = ensureSlide(currentIdx) || slides[currentIdx] || imgTarget;
          const fullSrc = currentSlide ? (currentSlide.dataset.full || currentSlide.src) : imgs[currentIdx];
          openImageModal(fullSrc, {images: imgs, startIndex: currentIdx, origin: imgTarget});
        });
        imageBox.addEventListener('touchstart', e=>{
          if(e.touches.length !== 1) return;
          dragStartX = e.touches[0].clientX;
          dragStartY = e.touches[0].clientY;
          dragActive = false;
        });
        imageBox.addEventListener('touchmove', e=>{
          if(dragStartX===null || !imageTrack) return;
          const touch = e.touches[0];
          const deltaX = touch.clientX - dragStartX;
          const deltaY = touch.clientY - dragStartY;
          if(!dragActive){
            if(Math.abs(deltaX) < 5) return;
            if(Math.abs(deltaY) > Math.abs(deltaX)){
              resetDragState();
              return;
            }
            dragActive = true;
            imageTrack.style.transition = 'none';
          }
          const width = imageBox.clientWidth || 1;
          let adjustedDelta = deltaX;
          if((currentIdx === 0 && adjustedDelta > 0) || (currentIdx === imgs.length-1 && adjustedDelta < 0)){
            adjustedDelta = 0;
          }
          const deltaPercent = (adjustedDelta / width) * 100;
          const basePercent = -currentIdx * 100;
          imageTrack.style.transform = `translateX(${basePercent + deltaPercent}%)`;
          e.preventDefault();
        }, {passive:false});
        imageBox.addEventListener('touchend', e=>{
          if(dragStartX===null){
            resetDragState();
            return;
          }
          const deltaX = e.changedTouches[0].clientX - dragStartX;
          if(imageTrack){
            imageTrack.style.transition = '';
          }
          if(dragActive){
            const prevIdx = currentIdx;
            let targetIdx = prevIdx;
            const threshold = (imageBox.clientWidth || 1) * 0.15;
            if(deltaX <= -threshold && prevIdx < imgs.length - 1){
              targetIdx = prevIdx + 1;
            } else if(deltaX >= threshold && prevIdx > 0){
              targetIdx = prevIdx - 1;
            }
            lastDragTime = Date.now();
            requestAnimationFrame(()=> show(targetIdx));
          }
          resetDragState();
        });
        imageBox.addEventListener('touchcancel', ()=>{
          if(dragActive && imageTrack){
            imageTrack.style.transition = '';
            requestAnimationFrame(()=> show(currentIdx));
          }
          resetDragState();
        });
      }
      const venueDropdown = el.querySelector(`#venue-${p.id}`);
      const venueBtn = venueDropdown ? venueDropdown.querySelector('.venue-btn') : null;
      const venueMenu = venueDropdown ? venueDropdown.querySelector('.venue-menu') : null;
      const venueOptions = venueMenu ? venueMenu.querySelector('.venue-options') : null;
      let venueCloseTimer = null;
      const venueInfo = el.querySelector(`#venue-info-${p.id}`);
      const sessDropdown = el.querySelector(`#sess-${p.id}`);
      const sessBtn = sessDropdown ? sessDropdown.querySelector('.sess-btn') : null;
      const sessMenu = sessDropdown ? sessDropdown.querySelector('.session-menu') : null;
      const sessionOptions = sessMenu ? sessMenu.querySelector('.session-options') : null;
      const showMenu = menu => { if(menu) menu.removeAttribute('hidden'); };
      const hideMenu = menu => { if(menu) menu.setAttribute('hidden',''); };
      const isMenuOpen = menu => !!(menu && !menu.hasAttribute('hidden'));
      const sessionInfo = el.querySelector(`#session-info-${p.id}`);
      const calendarEl = el.querySelector(`#cal-${p.id}`);
      const mapEl = el.querySelector(`#map-${p.id}`);
      const calContainer = el.querySelector('.calendar-container');
      const calScroll = calContainer ? calContainer.querySelector('.calendar-scroll') : null;
      if(calScroll){
        setupCalendarScroll(calScroll);
      }
      let map, locationMarkers = [], sessionHasMultiple = false, lastClickedCell = null, resizeHandler = null, detailMapRef = null;
      let currentVenueIndex = 0;

      function updateDetailMarkerSelection(selectedIdx = currentVenueIndex){
        if(!Number.isInteger(selectedIdx)){
          selectedIdx = currentVenueIndex;
        }
        locationMarkers.forEach(({ element, index }) => {
          const isSelected = index === selectedIdx;
          element.classList.toggle('is-selected', isSelected);
          element.classList.toggle('is-dimmed', !isSelected);
          element.setAttribute('aria-pressed', isSelected ? 'true' : 'false');
        });
      }
      let sessionCloseTimer = null;
      let ensureMapForVenue = async ()=>{};
        function scheduleSessionMenuClose({waitForScroll=false, targetLeft=null}={}){
          if(!sessMenu) return;
          if(sessionCloseTimer){
            clearTimeout(sessionCloseTimer);
            sessionCloseTimer = null;
          }
          const begin = ()=>{
            requestAnimationFrame(()=>requestAnimationFrame(()=>{
              sessionCloseTimer = setTimeout(()=>{
                hideMenu(sessMenu);
                if(sessBtn) sessBtn.setAttribute('aria-expanded','false');
                sessionCloseTimer = null;
              }, 100);
            }));
          };
          if(waitForScroll && calScroll && targetLeft !== null){
            let attempts = 0;
            const maxAttempts = 60;
            const check = ()=>{
              const distance = Math.abs(calScroll.scrollLeft - targetLeft);
              if(distance <= 0.5 || attempts >= maxAttempts){
                begin();
              } else {
                attempts += 1;
                requestAnimationFrame(check);
              }
            };
            requestAnimationFrame(check);
          } else {
            begin();
          }
        }
        if(mapEl && mapEl._detailMap){
          detailMapRef = mapEl._detailMap;
          map = detailMapRef.map || map;
          resizeHandler = detailMapRef.resizeHandler || resizeHandler;
          if(!el._detailMap){
            el._detailMap = detailMapRef;
          }
        }
      function updateVenue(idx){
        const locations = Array.isArray(p.locations) ? p.locations : [];
        const hasLocations = locations.length > 0;
        let targetIndex = Number.isInteger(idx) ? idx : 0;
        if(hasLocations){
          targetIndex = Math.min(Math.max(targetIndex, 0), locations.length - 1);
        } else {
          targetIndex = 0;
        }
        currentVenueIndex = targetIndex;
        const loc = hasLocations ? locations[targetIndex] : null;

        if(venueOptions){
          const buttons = venueOptions.querySelectorAll('button');
          buttons.forEach((button, optionIndex) => {
            button.classList.toggle('selected', optionIndex === targetIndex);
          });
        }

        if(loc){
          setSelectedVenueHighlight(loc.lng, loc.lat);
        } else {
          setSelectedVenueHighlight();
        }

        updateDetailMarkerSelection(targetIndex);

        if(venueBtn){
          if(loc){
            venueBtn.innerHTML = `<span class="venue-name">${loc.venue}</span><span class="venue-address">${loc.address}</span>${p.locations.length>1?'<span class="results-arrow" aria-hidden="true"></span>':''}`;
          } else {
            venueBtn.innerHTML = `<span class="venue-name">${p.city || ''}</span><span class="venue-address">${p.city || ''}</span>`;
          }
        }

        if(venueInfo){
          if(loc){
            venueInfo.innerHTML = `<strong>${loc.venue}</strong><br>${loc.address}`;
          } else {
            venueInfo.innerHTML = '';
          }
        }

        const hasDates = loc && Array.isArray(loc.dates) && loc.dates.length;
        if(!hasDates){
          sessionHasMultiple = false;
          if(sessionInfo){
            sessionInfo.innerHTML = '';
          }
          ensureMapForVenue();
          return;
        }

        loc.dates.sort((a,b)=> a.full.localeCompare(b.full) || a.time.localeCompare(b.time));

        const currentYear = new Date().getFullYear();
        const parseDate = s => {
          const [yy, mm, dd] = s.split('-').map(Number);
          return new Date(yy, mm - 1, dd);
        };
        const formatDate = d => {
          const y = parseDate(d.full).getFullYear();
          return y !== currentYear ? `${d.date}, ${y}` : d.date;
        };

        if(venueInfo){
          venueInfo.innerHTML = `<strong>${loc.venue}</strong><br>${loc.address}`;
        }
        if(venueBtn){
          venueBtn.innerHTML = `<span class="venue-name">${loc.venue}</span><span class="venue-address">${loc.address}</span>${p.locations.length>1?'<span class="results-arrow" aria-hidden="true"></span>':''}`;
        }

        sessionHasMultiple = loc.dates.length > 1;
        let defaultInfoHTML = '';
        if(sessionInfo){
          const firstDate = loc.dates[0];
          const lastDate = loc.dates[loc.dates.length-1];
          const rangeText = `${formatDate(firstDate)} - ${formatDate(lastDate)}`;
          defaultInfoHTML = `<div>💲 ${loc.price} | 📅 ${rangeText}<span style="display:inline-block;margin-left:10px;">(Select Session)</span></div>`;
          sessionInfo.innerHTML = defaultInfoHTML;
        }

        const dateStrings = Array.from(new Set(loc.dates.map(d=>d.full)));
        const allowedSet = new Set(dateStrings);
        const minDate = parseDate(dateStrings[0]);
        const maxDate = parseDate(dateStrings[dateStrings.length-1]);
        let cal = null;
        let selectedIndex = null;

        const months = [];
        if(minDate && maxDate){
          const cursor = new Date(minDate.getFullYear(), minDate.getMonth(), 1);
          const limit = new Date(maxDate.getFullYear(), maxDate.getMonth(), 1);
          while(cursor <= limit){
            months.push(new Date(cursor));
            cursor.setMonth(cursor.getMonth() + 1);
          }
        }

        function markSelected(){
          if(!calendarEl) return;
          calendarEl.querySelectorAll('.day').forEach(d=> d.classList.remove('selected'));
          if(selectedIndex!==null){
            const dt = loc.dates[selectedIndex];
            const cell = calendarEl.querySelector(`.day[data-iso="${dt.full}"]`);
            if(cell) cell.classList.add('selected');
          }
        }

        function scrollCalendarToMonth(dt, {smooth=false}={}){
          if(!dt || !calendarEl || !calScroll) return null;
          const cell = calendarEl.querySelector(`.day[data-iso="${dt.full}"]`);
          if(!cell) return null;
          const monthEl = cell.closest('.month');
          if(!monthEl) return null;
          const currentLeft = calScroll.scrollLeft;
          let targetLeft = monthEl.offsetLeft;
          if(typeof monthEl.getBoundingClientRect === 'function' && typeof calScroll.getBoundingClientRect === 'function'){
            const monthRect = monthEl.getBoundingClientRect();
            const scrollRect = calScroll.getBoundingClientRect();
            const delta = monthRect.left - scrollRect.left;
            const adjusted = currentLeft + delta;
            if(Number.isFinite(adjusted)){
              targetLeft = adjusted;
            }
          }
          const maxLeft = Math.max(0, calScroll.scrollWidth - calScroll.clientWidth);
          targetLeft = Math.min(Math.max(targetLeft, 0), maxLeft);
          const distance = Math.abs(currentLeft - targetLeft);
          if(typeof calScroll.scrollTo === 'function'){
            if(smooth && distance > 1){
              calScroll.scrollTo({left: targetLeft, behavior: 'smooth'});
              return {targetLeft, waitForScroll: true};
            }
            calScroll.scrollTo({left: targetLeft});
          } else {
            calScroll.scrollLeft = targetLeft;
          }
          return {targetLeft, waitForScroll: false};
        }

        function selectSession(i){
          if(!sessMenu || !sessionOptions) return;
          selectedIndex = Number.isInteger(i) ? i : null;
          sessionOptions.querySelectorAll('button').forEach(b=> b.classList.remove('selected'));
          const btn = selectedIndex !== null ? sessionOptions.querySelector(`button[data-index="${selectedIndex}"]`) : null;
          if(btn) btn.classList.add('selected');
          const dt = selectedIndex !== null ? loc.dates[selectedIndex] : null;
          let waitForScroll = false;
          let targetScrollLeft = null;
          if(dt){
            if(sessionInfo){
              sessionInfo.innerHTML = `<div><strong>${formatDate(dt)} ${dt.time}</strong></div><div>Adults $20, Kids $10, Pensioners $15</div><div>🎫 Buy at venue | ♿ Accessible | 👶 Kid-friendly</div>`;
            }
            if(sessBtn){
              sessBtn.innerHTML = `<span class="session-date">${formatDate(dt)}</span><span class="session-time">${dt.time}</span>${sessionHasMultiple?'<span class="results-arrow" aria-hidden="true"></span>':''}`;
            }
            markSelected();
            const scrollResult = scrollCalendarToMonth(dt, {smooth: true});
            if(scrollResult){
              targetScrollLeft = scrollResult.targetLeft;
              waitForScroll = scrollResult.waitForScroll;
            }
          } else {
            if(sessionInfo){
              sessionInfo.innerHTML = defaultInfoHTML;
            }
            if(sessBtn){
              sessBtn.innerHTML = sessionHasMultiple ? 'Select Session<span class="results-arrow" aria-hidden="true"></span>' : 'Select Session';
              sessBtn.setAttribute('aria-expanded','false');
            }
            markSelected();
          }
          if(isMenuOpen(sessMenu)){
            scheduleSessionMenuClose({waitForScroll, targetLeft: targetScrollLeft});
          } else if(sessBtn){
            sessBtn.setAttribute('aria-expanded','false');
          }
        }

        function showTimePopup(matches){
          if(!calContainer) return;
          const existing = calContainer.querySelector('.time-popup');
          if(existing) existing.remove();
          const popup = document.createElement('div');
          popup.className = 'time-popup';
          popup.innerHTML = `<div class="time-list">${matches.map(m=>`<button data-index="${m.i}">${m.d.time}</button>`).join('')}</div>`;
          calContainer.appendChild(popup);
          if(lastClickedCell){
            const rect = lastClickedCell.getBoundingClientRect();
            const containerRect = calContainer.getBoundingClientRect();
            popup.style.left = (rect.left - containerRect.left) + 'px';
            popup.style.top = (rect.bottom - containerRect.top + 4) + 'px';
          }
          popup.querySelectorAll('button').forEach(b=> b.addEventListener('click',()=>{ selectSession(parseInt(b.dataset.index,10)); popup.remove(); }));
          setTimeout(()=> document.addEventListener('click', function handler(e){ if(!popup.contains(e.target)){ popup.remove(); document.removeEventListener('click', handler); } }),0);
        }

        function renderMonth(monthDate){
          if(!cal) return;
          const monthEl = document.createElement('div');
          monthEl.className='month';
          const header = document.createElement('div');
          header.className='calendar-header';
          header.textContent = monthDate.toLocaleDateString('en-GB',{month:'long',year:'numeric'});
          monthEl.appendChild(header);
          const grid = document.createElement('div');
          grid.className='grid';
          ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'].forEach(wd=>{
            const w=document.createElement('div');
            w.className='weekday';
            w.textContent=wd;
            grid.appendChild(w);
          });
          const firstDay = new Date(monthDate.getFullYear(), monthDate.getMonth(),1);
          const startDow = firstDay.getDay();
          const daysInMonth = new Date(monthDate.getFullYear(), monthDate.getMonth()+1,0).getDate();
          const totalCells = 42;
          for(let i=0;i<totalCells;i++){
            const cell=document.createElement('div');
            cell.className='day';
            const dayNum=i-startDow+1;
            if(i<startDow || dayNum>daysInMonth){
              cell.classList.add('empty');
            }else{
              cell.textContent=dayNum;
              const dateObj=new Date(monthDate.getFullYear(), monthDate.getMonth(), dayNum);
              const iso=toISODate(dateObj);
              cell.dataset.iso = iso;
              if(allowedSet.has(iso)){
                cell.classList.add('available-day');
                cell.addEventListener('mousedown',()=>{ lastClickedCell = cell; });
                cell.addEventListener('click',()=>{
                  const matches = loc.dates.map((dd,i)=>({i,d:dd})).filter(o=> o.d.full===iso);
                  if(matches.length===1){ selectSession(matches[0].i); }
                  else if(matches.length>1){ showTimePopup(matches); }
                });
              } else {
                cell.classList.add('empty');
              }
              if(isToday(dateObj)) cell.classList.add('today');
            }
            grid.appendChild(cell);
          }
          monthEl.appendChild(grid);
          cal.appendChild(monthEl);
        }

        function buildCalendarShell(){
          if(!calendarEl) return;
          calendarEl.innerHTML='';
          cal = document.createElement('div');
          cal.className='calendar';
          calendarEl.appendChild(cal);
          calendarEl.addEventListener('click', e=> e.stopPropagation());
        }

        function finalizeCalendar(){
          markSelected();
        }

        function updateSessionOptionsList(){
          if(sessionOptions){
            sessionOptions.innerHTML = loc.dates.map((d,i)=> `<button data-index="${i}"><span class="session-date">${formatDate(d)}</span><span class="session-time">${d.time}</span></button>`).join('');
            if(sessMenu){
              sessMenu.scrollTop = 0;
            }
            if(sessionHasMultiple){
              if(sessionInfo) sessionInfo.innerHTML = defaultInfoHTML;
              if(sessBtn){ sessBtn.innerHTML = 'Select Session<span class="results-arrow" aria-hidden="true"></span>'; sessBtn.setAttribute('aria-expanded','false'); }
            } else if(loc.dates.length){
              selectSession(0);
            } else {
              if(sessionInfo) sessionInfo.innerHTML = defaultInfoHTML;
              if(sessBtn){ sessBtn.textContent = 'Select Session'; sessBtn.setAttribute('aria-expanded','false'); }
            }
            sessionOptions.querySelectorAll('button').forEach(btn=>{
              btn.addEventListener('click', ()=> selectSession(parseInt(btn.dataset.index,10)));
            });
          }
          setTimeout(()=>{
            if(map && typeof map.resize === 'function') map.resize();
          },0);
        }

        function attachSessionButtonHandler(){
          if(!sessBtn || !sessMenu) return;
          const handler = ()=>{
            const expanded = sessBtn.getAttribute('aria-expanded') === 'true';
            const opening = !expanded;
            sessBtn.setAttribute('aria-expanded', String(opening));
            if(opening){
              showMenu(sessMenu);
              if(selectedIndex !== null){
                const dt = loc.dates[selectedIndex];
                if(dt){
                  requestAnimationFrame(()=> scrollCalendarToMonth(dt));
                }
              }
            } else {
              hideMenu(sessMenu);
            }
          };
          if(sessBtn._sessionToggle){
            sessBtn.removeEventListener('click', sessBtn._sessionToggle);
          }
          sessBtn._sessionToggle = handler;
          sessBtn.addEventListener('click', handler);
        }

        ensureMapForVenue = async function(){
          if(!mapEl) return;

          const allLocations = Array.isArray(p.locations) ? p.locations.filter(item => item && Number.isFinite(item.lng) && Number.isFinite(item.lat)) : [];
          if(!allLocations.length){
            locationMarkers.forEach(({ marker }) => { try{ marker.remove(); }catch(e){} });
            locationMarkers = [];
            return;
          }

          const selectedIdx = Math.min(Math.max(currentVenueIndex, 0), allLocations.length - 1);
          const selectedLoc = allLocations[selectedIdx];
          const center = [selectedLoc.lng, selectedLoc.lat];
          const subId = subcategoryMarkerIds[p.subcategory] || slugify(p.subcategory);
          const markerUrl = subcategoryMarkers[subId];

          const assignDetailRef = ()=>{
            detailMapRef = detailMapRef || {};
            detailMapRef.map = map;
            detailMapRef.resizeHandler = resizeHandler;
            if(mapEl){
              mapEl._detailMap = detailMapRef;
              mapEl.__map = map;
            }
            if(el){
              el._detailMap = detailMapRef;
            }
            if(map){
              MapRegistry.register(map);
            }
          };

          const refreshMarkers = () => {
            if(!map) return;
            locationMarkers.forEach(({ marker }) => { try{ marker.remove(); }catch(e){} });
            locationMarkers = [];
            allLocations.forEach((location, idx) => {
              if(!Number.isFinite(location.lng) || !Number.isFinite(location.lat)){
                return;
              }
              let element;
              if(markerUrl){
                element = new Image();
                element.src = markerUrl;
                element.alt = '';
                element.decoding = 'async';
              } else {
                element = document.createElement('div');
                element.style.background = '#0f172a';
              }
              element.classList.add('post-location-marker');
              element.dataset.index = String(idx);
              element.tabIndex = 0;
              element.setAttribute('role', 'button');
              element.setAttribute('aria-pressed', 'false');
              element.setAttribute('aria-label', `${location.venue} (${location.address})`);
              element.addEventListener('click', () => {
                if(idx === currentVenueIndex) return;
                updateVenue(idx);
              });
              element.addEventListener('keydown', evt => {
                if(evt.key === 'Enter' || evt.key === ' ' || evt.key === 'Spacebar'){
                  evt.preventDefault();
                  element.click();
                }
              });
              const markerInstance = new mapboxgl.Marker({ element, anchor: 'center' }).setLngLat([location.lng, location.lat]).addTo(map);
              locationMarkers.push({ marker: markerInstance, element, index: idx });
            });
            updateDetailMarkerSelection(selectedIdx);
          };

          const fitToLocations = () => {
            if(!map || !allLocations.length){
              return;
            }
            const validPoints = allLocations.filter(location => Number.isFinite(location.lng) && Number.isFinite(location.lat));
            if(!validPoints.length){
              return;
            }
            if(validPoints.length === 1){
              try{
                map.setCenter([validPoints[0].lng, validPoints[0].lat]);
                map.setZoom(10);
              }catch(e){}
              return;
            }
            try{
              const bounds = validPoints.reduce((acc, location) => {
                if(acc){
                  acc.extend([location.lng, location.lat]);
                  return acc;
                }
                return new mapboxgl.LngLatBounds([location.lng, location.lat], [location.lng, location.lat]);
              }, null);
              if(bounds){
                map.fitBounds(bounds, { padding: 40, duration: 0, maxZoom: 10 });
              }
            }catch(e){}
          };

          if(!map){
            setTimeout(async () => {
              if(map) {
                refreshMarkers();
                fitToLocations();
                return;
              }

              await ensureMapboxCssFor(mapEl);

              if (mapEl && mapEl.__map && typeof mapEl.__map.remove === 'function') {
                try { mapEl.__map.remove(); } catch {}
                mapEl.__map = null;
              }
              locationMarkers.forEach(({ marker }) => { try{ marker.remove(); }catch(e){} });
              locationMarkers = [];

              map = new mapboxgl.Map({
                container: mapEl,
                style: mapStyle,
                center,
                zoom: 3,
                interactive: false
              });

              attachIconLoader(map);

              map.on('mousemove', (e) => {
                const has = !!(e.features && e.features.length);
                map.getCanvas().style.cursor = has ? 'pointer' : '';
              });

              armPointerOnSymbolLayers(map);

              const applyDetailStyleAdjustments = () => {
                applyNightSky(map);
                patchMapboxStyleArtifacts(map);
              };
              whenStyleReady(map, applyDetailStyleAdjustments);
              map.on('style.load', applyDetailStyleAdjustments);
              map.on('styledata', () => {
                if(map.isStyleLoaded && map.isStyleLoaded()){
                  patchMapboxStyleArtifacts(map);
                }
              });

              map.on('styleimagemissing', (e) => {
                if (map.hasImage(e.id)) return;

                const base = document.baseURI || window.location.href;
                const candidates = [
                  `assets/icons/subcategories/${e.id}.png`,
                  `assets/icons/${e.id}.png`,
                  `assets/images/icons/${e.id}.png`,
                  `assets/icons-30/${e.id}-30.webp`,
                  `assets/icons/multi-category-icon-blue.png`,
                  `assets/images/icons/multi-category-icon-blue.png`
                ].map(p => new URL(p, base).href);

                (function tryNext(i){
                  if (i >= candidates.length) return;
                  map.loadImage(candidates[i], (err, img) => {
                    if (err || !img) { tryNext(i+1); return; }
                    try { map.addImage(e.id, img, { sdf: true }); } catch {}
                  });
                })(0);
              });

              if(resizeHandler){
                window.removeEventListener('resize', resizeHandler);
              }
              resizeHandler = ()=>{ if(map) map.resize(); };
              window.addEventListener('resize', resizeHandler);

              const ready = () => {
                refreshMarkers();
                fitToLocations();
              };
              if(map.loaded()){
                ready();
              } else {
                map.once('load', ready);
              }

              assignDetailRef();

              setTimeout(()=>{ if(map && typeof map.resize === 'function') map.resize(); },0);
            }, 0);
          } else {
            refreshMarkers();
            fitToLocations();
            setTimeout(()=> map && map.resize(),0);
            assignDetailRef();
          }
        };
        window.ensureMapForVenue = ensureMapForVenue;

        const tasks = [];
        if(mapEl){
          tasks.push(()=> {
            const ensure = typeof window.callWhenDefined === 'function'
              ? window.callWhenDefined
              : function(name, cb, timeoutMs){
                  const start = performance.now(), max = timeoutMs ?? 5000;
                  (function check(){
                    const fn = window[name];
                    if (typeof fn === 'function') { try { cb(fn); } catch(e){} return; }
                    if (performance.now() - start < max) requestAnimationFrame(check);
                  })();
                };
            ensure('ensureMapForVenue', fn => fn());
          });
        }
        if(calendarEl){
          tasks.push(()=> buildCalendarShell());
          months.forEach(monthDate => tasks.push(()=> renderMonth(monthDate)));
          tasks.push(()=> finalizeCalendar());
        }
        tasks.push(()=> updateSessionOptionsList());
        tasks.push(()=> attachSessionButtonHandler());

        function runNext(){
          const task = tasks.shift();
          if(!task) return;
          const start = performance.now();
          try{ task(); }catch(err){}
          if(performance.now() - start > 6){
            setTimeout(runNext, 0);
          } else {
            runNext();
          }
        }
        runNext();
      }

      window.updateVenue = updateVenue;
      window.ensureMapForVenue = ensureMapForVenue;
      if(typeof window.__wrapForInputYield === 'function'){
        window.__wrapForInputYield('updateVenue');
        window.__wrapForInputYield('ensureMapForVenue');
      }

        if(mapEl){
          setTimeout(()=>{
            loadMapbox(()=>{
              updateVenue(0);
              if(venueMenu && venueBtn && venueOptions){
                venueOptions.querySelectorAll('button').forEach(btn=>{
                  if(btn.dataset.index==='0') btn.classList.add('selected');
                  btn.addEventListener('click', ()=>{
                    venueOptions.querySelectorAll('button').forEach(b=> b.classList.remove('selected'));
                    btn.classList.add('selected');
                    updateVenue(parseInt(btn.dataset.index,10));
                    if(venueCloseTimer){
                      clearTimeout(venueCloseTimer);
                    }
                    venueCloseTimer = setTimeout(()=>{
                    hideMenu(venueMenu);
                    venueBtn.setAttribute('aria-expanded','false');
                    venueCloseTimer = null;
                  }, 100);
                  });
                });
                venueBtn.addEventListener('click', ()=>{
                  const expanded = venueBtn.getAttribute('aria-expanded') === 'true';
                  const opening = !expanded;
                  venueBtn.setAttribute('aria-expanded', String(opening));
                  if(opening){
                    showMenu(venueMenu);
                  } else {
                    hideMenu(venueMenu);
                  }
                  if(opening){
                    const adjustMap = ()=>{
                      if(map && typeof map.resize === 'function') map.resize();
                      if(typeof ensureMapForVenue === 'function') ensureMapForVenue();
                    };
                    if(typeof requestAnimationFrame === 'function'){
                      requestAnimationFrame(adjustMap);
                    } else {
                      setTimeout(adjustMap, 0);
                    }
                  }
                });
                document.addEventListener('click', e=>{ if(venueDropdown && !venueDropdown.contains(e.target)){ hideMenu(venueMenu); venueBtn.setAttribute('aria-expanded','false'); } });
              }
              if(sessBtn && sessMenu){
                if(!sessDropdown._sessionOutsideHandler){
                  const outsideHandler = e=>{
                    if(sessDropdown && !sessDropdown.contains(e.target)){
                      hideMenu(sessMenu);
                      sessBtn.setAttribute('aria-expanded','false');
                    }
                  };
                  sessDropdown._sessionOutsideHandler = outsideHandler;
                  document.addEventListener('click', outsideHandler);
                }
              }
              if(map && typeof map.resize === 'function') map.resize();
            });
          },0);
        }
    }

    function inBounds(p){
      if(!postPanel) return true;
      return p.lng >= postPanel.getWest() && p.lng <= postPanel.getEast() &&
             p.lat >= postPanel.getSouth() && p.lat <= postPanel.getNorth();
    }
    function kwMatch(p){ const kw = $('#keyword-textbox').value.trim().toLowerCase(); if(!kw) return true; return (p.title+' '+p.city+' '+p.category+' '+p.subcategory).toLowerCase().includes(kw); }
    function getPriceFilterValues(){
      const minInput = $('#min-price-input');
      const maxInput = $('#max-price-input');
      const rawMin = minInput ? minInput.value.trim() : '';
      const rawMax = maxInput ? maxInput.value.trim() : '';
      let min = rawMin === '' ? null : Number(rawMin);
      let max = rawMax === '' ? null : Number(rawMax);
      if(min !== null && !Number.isFinite(min)) min = null;
      if(max !== null && !Number.isFinite(max)) max = null;
      if(min !== null && max !== null && min > max){ const swap = min; min = max; max = swap; }
      return {min, max};
    }
    function parsePriceRange(value){
      if(typeof value !== 'string') return {min:null, max:null};
      const matches = value.match(/\d+(?:\.\d+)?/g);
      if(!matches || !matches.length) return {min:null, max:null};
      const nums = matches.map(Number).filter(n => Number.isFinite(n));
      if(!nums.length) return {min:null, max:null};
      const min = Math.min(...nums);
      const max = Math.max(...nums);
      return {min, max};
    }
    function priceMatch(p){
      const {min, max} = getPriceFilterValues();
      if(min === null && max === null) return true;
      const ranges = [];
      const addRange = value => {
        const parsed = parsePriceRange(value);
        if(!parsed) return;
        const hasMin = parsed.min !== null;
        const hasMax = parsed.max !== null;
        if(!hasMin && !hasMax) return;
        const normalizedMin = hasMin ? parsed.min : parsed.max;
        const normalizedMax = hasMax ? parsed.max : parsed.min;
        if(normalizedMin === null && normalizedMax === null) return;
        ranges.push({
          min: normalizedMin,
          max: normalizedMax
        });
      };
      addRange(p && p.price);
      if(p && Array.isArray(p.locations)){
        p.locations.forEach(loc => {
          if(loc) addRange(loc.price);
        });
      }
      if(!ranges.length) return false;
      const aggregatedMin = ranges.reduce((acc, range) => {
        const candidate = range.min !== null ? range.min : range.max;
        if(candidate === null) return acc;
        return acc === null ? candidate : Math.min(acc, candidate);
      }, null);
      const aggregatedMax = ranges.reduce((acc, range) => {
        const candidate = range.max !== null ? range.max : range.min;
        if(candidate === null) return acc;
        return acc === null ? candidate : Math.max(acc, candidate);
      }, null);
      if(min !== null && aggregatedMax !== null && aggregatedMax < min) return false;
      if(max !== null && aggregatedMin !== null && aggregatedMin > max) return false;
      const satisfiesBounds = ranges.some(range => {
        if(min !== null && range.max !== null && range.max < min) return false;
        if(max !== null && range.min !== null && range.min > max) return false;
        return true;
      });
      if(!satisfiesBounds) return false;
      return true;
    }
    function dateMatch(p){
      const {start,end} = orderedRange();
      const expiredChk = $('#expiredToggle');
      if(!start && !end){
        if(expiredChk && expiredChk.checked){
          return true;
        }
        const today = new Date(); today.setHours(0,0,0,0);
        return p.dates.some(d => parseISODate(d) >= today);
      }
      return p.dates.some(d => {
        const dt = parseISODate(d);
        if(start && dt < start) return false;
        if(end && dt > end) return false;
        return true;
      });
    }
    function catMatch(p){
      const haveCategoryControllers = Object.keys(categoryControllers).length > 0;
      if(!haveCategoryControllers){
        return true;
      }
      if(selection.cats.size===0){
        return false;
      }
      const cOk = selection.cats.has(p.category);
      if(!cOk) return false;
      if(selection.subs.size===0){
        return false;
      }
      return selection.subs.has(p.category+'::'+p.subcategory);
    }

    function hideResultIndicators(){
      const resultCountEl = $('#resultCount');
      if(resultCountEl){
        resultCountEl.innerHTML = '';
        resultCountEl.style.display = 'none';
      }
      const summaryEl = $('#filterSummary');
      if(summaryEl){
        summaryEl.textContent = '';
      }
    }

    function getVisibleMarkerBoundsForCount(){
      let zoomCandidate = Number.isFinite(lastKnownZoom) ? lastKnownZoom : NaN;
      if(!Number.isFinite(zoomCandidate) && map && typeof map.getZoom === 'function'){
        try {
          zoomCandidate = map.getZoom();
        } catch(err){
          zoomCandidate = NaN;
        }
      }
      if(!Number.isFinite(zoomCandidate) || zoomCandidate < MARKER_ZOOM_THRESHOLD){
        return null;
      }
      const boundsSource = postPanel || (map && typeof map.getBounds === 'function' ? map.getBounds() : null);
      if(!boundsSource) return null;
      return normalizeBounds(boundsSource);
    }

    function updateFilterCounts(){
      if(spinning){
        hideResultIndicators();
        updateResetBtn();
        return;
      }
      if(!postsLoaded) return;
      filtered = posts.filter(p => (spinning || inBounds(p)) && kwMatch(p) && dateMatch(p) && catMatch(p) && priceMatch(p));
      const boundsForCount = getVisibleMarkerBoundsForCount();
      const filteredMarkers = boundsForCount ? countMarkersForVenue(filtered, null, boundsForCount) : countMarkersForVenue(filtered);
      const today = new Date(); today.setHours(0,0,0,0);
      const totalPosts = posts.filter(p => (spinning || inBounds(p)) && p.dates.some(d => parseISODate(d) >= today));
      const totalMarkers = boundsForCount ? countMarkersForVenue(totalPosts, null, boundsForCount) : countMarkersForVenue(totalPosts);
      const summary = $('#filterSummary');
      if(summary){ summary.textContent = `${filteredMarkers} results showing out of ${totalMarkers} results in the area.`; }
      updateResultCount(filteredMarkers);
      updateResetBtn();
    }

    function refreshMarkers(render = true){
      if(spinning) return;
      if(!postsLoaded) return;
      const newAdPosts = filtered.filter(p => p.sponsored);
      const ids = newAdPosts.map(p => p.id).join(',');
      if(adPanel && ids !== adIdsKey){
        adPanel.innerHTML = '';
        adIndex = -1;
        if(adTimer){ clearInterval(adTimer); }
        adPosts = newAdPosts;
        if(adPosts.length){
          showNextAd();
          adTimer = setInterval(showNextAd,20000);
        } else {
          const img = document.createElement('img');
          img.src = 'assets/welcome%20001.jpg';
          img.alt = 'Welcome';
          img.style.width = '100%';
          img.style.height = '100%';
          img.style.objectFit = 'cover';
          adPanel.appendChild(img);
        }
        adIdsKey = ids;
      } else {
        adPosts = newAdPosts;
      }
      if(render) renderLists(filtered);
      syncMarkerSources(filtered);
      updateLayerVisibility(lastKnownZoom);
      filtersInitialized = true;
    }

    function applyFilters(render = true){
      if(spinning){
        hideResultIndicators();
        return;
      }
      updateFilterCounts();
      refreshMarkers(render);
    }

    function showNextAd(){
      if(!adPanel || !adPosts.length) return;
      adIndex = (adIndex + 1) % adPosts.length;
      const p = adPosts[adIndex];
      const slide = document.createElement('a');
      slide.className = 'ad-slide';
      slide.dataset.id = p.id;
      slide.href = postUrl(p);
      const img = new Image();
      img.src = heroUrl(p);
      img.alt = '';
      img.decode().catch(()=>{}).then(()=>{
        slide.appendChild(img);
        const info = document.createElement('div');
        info.className = 'info';
        info.textContent = p.title;
        slide.appendChild(info);
        adPanel.appendChild(slide);
        requestAnimationFrame(()=> slide.classList.add('active'));
        const slides = adPanel.querySelectorAll('.ad-slide');
        if(slides.length > 1){
          const old = slides[0];
          old.classList.remove('active');
          setTimeout(()=> old.remove(),1500);
        }
      });
    }

    function handleAdPanelClick(e){
      const slide = e.target.closest('.ad-slide');
      if(!slide) return;
      e.preventDefault();
      const id = slide.dataset.id;
      requestAnimationFrame(() => {
        callWhenDefined('openPost', (fn)=>{
          Promise.resolve(fn(id)).then(() => {
            requestAnimationFrame(() => {
              const openEl = document.querySelector(`.post-board .open-post[data-id="${id}"]`);
              if(openEl){
                requestAnimationFrame(() => { openEl.scrollIntoView({behavior:'smooth', block:'start'}); });
              }
              document.querySelectorAll('.recents-card[aria-selected="true"]').forEach(el=>el.removeAttribute('aria-selected'));
              const quickCard = document.querySelector(`.recents-board .recents-card[data-id="${id}"]`);
              if(quickCard){
                quickCard.setAttribute('aria-selected','true');
                requestAnimationFrame(() => {
                  quickCard.scrollIntoView({behavior:'smooth', block:'nearest'});
                });
              }
            });
          }).catch(err => console.error(err));
        });
      });
    }

    function initAdBoard(){
      adPanel = document.querySelector('.ad-panel');
      if(!adPanel) return;
      if(!adPanel.__adListenerBound){
        adPanel.addEventListener('click', handleAdPanelClick, { capture: true });
        adPanel.__adListenerBound = true;
      }
    }

    // applyFilters();
    setMode(mode);
    if(historyWasActive && mode === 'posts'){
      document.body.classList.add('show-history');
      adjustBoards();
    }
    window.addEventListener('beforeunload', () => {
      localStorage.setItem('mode', mode);
      localStorage.setItem('historyActive', document.body.classList.contains('show-history') ? 'true' : 'false');
    });
  })();
  
// 0577 helpers (safety)
function isPortrait(id){ let h=0; for(let i=0;i<id.length;i++){ h=(h<<5)-h+id.charCodeAt(i); h|=0; } return Math.abs(h)%2===0; }
function heroUrl(p){ const id = (typeof p==='string')? p : p.id; const port=isPortrait(id); return `https://picsum.photos/seed/${encodeURIComponent(id)}-t/${port?'800/1200':'1200/800'}`; }
function thumbUrl(p){ const id = (typeof p==='string')? p : p.id; const port=isPortrait(id); return `https://picsum.photos/seed/${encodeURIComponent(id)}-t/${port?'200/300':'300/200'}`; }
function getViewportHeight(){
  return window.innerHeight || document.documentElement.clientHeight || 0;
}
const panelStack = [];
function bringToTop(item){
  const idx = panelStack.indexOf(item);
  if(idx!==-1) panelStack.splice(idx,1);
  panelStack.push(item);
  panelStack.forEach((p,i)=>{
    if(p instanceof Element){ p.style.zIndex = 2000 + i; }
  });
}
function registerPopup(p){
  bringToTop(p);
  if(typeof p.on==='function'){
    p.on('close',()=>{
      const i = panelStack.indexOf(p);
      if(i!==-1) panelStack.splice(i,1);
    });
  }
  const el = p.getElement && p.getElement();
  if(el){
    el.addEventListener('mousedown', ()=> bringToTop(p));
  }
}
function savePanelState(m){
  if(!m || !m.id || m.id === 'welcome-modal') return;
  const content = m.querySelector('.panel-content');
  if(!content) return;
  const state = {
    left: content.style.left,
    top: content.style.top,
    width: content.style.width,
    height: content.style.height
  };
  localStorage.setItem(`panel-${m.id}`, JSON.stringify(state));
}
function loadPanelState(m){
  if(!m || !m.id) return false;
  const content = m.querySelector('.panel-content');
  if(!content) return false;
  const saved = JSON.parse(localStorage.getItem(`panel-${m.id}`) || 'null');
  if(saved){
    ['width','height','left','top'].forEach(prop=>{
      if(saved[prop]) content.style[prop] = saved[prop];
    });
    if(saved.left || saved.top) content.style.transform = 'none';
    return true;
  }
  return false;
}
const panelButtons = {
  filterPanel: 'filterBtn',
  memberPanel: 'memberBtn',
  adminPanel: 'adminBtn'
};

const panelScrollOverlayItems = new Set();

function updatePanelScrollOverlay(target){
  if(!target || !target.isConnected) return;
  const overlayWidth = target.offsetWidth - target.clientWidth;
  const value = overlayWidth > 0 ? `${overlayWidth}px` : '0px';
  target.style.setProperty('--panel-scrollbar-overlay', value);
}

function registerPanelScrollOverlay(target){
  if(!target || panelScrollOverlayItems.has(target)) return;
  panelScrollOverlayItems.add(target);
  updatePanelScrollOverlay(target);
  if('ResizeObserver' in window){
    const observer = new ResizeObserver(()=> updatePanelScrollOverlay(target));
    observer.observe(target);
  }
  target.addEventListener('scroll', ()=> updatePanelScrollOverlay(target), { passive: true });
}

function refreshPanelScrollOverlays(){
  document.querySelectorAll('.panel-body').forEach(registerPanelScrollOverlay);
  panelScrollOverlayItems.forEach(updatePanelScrollOverlay);
}

document.addEventListener('DOMContentLoaded', ()=>{
  refreshPanelScrollOverlays();
  window.addEventListener('resize', ()=>{
    requestAnimationFrame(()=>{
      panelScrollOverlayItems.forEach(updatePanelScrollOverlay);
    });
  });
});

(function(){
  const MIN_HEADER_WIDTH = 390;
  const SIDE_MARGIN = 10;
  let mapControls = null;
  let originalParent = null;
  let originalNext = null;
  let header = null;
  let headerButtons = null;
  let viewToggle = null;
  let welcomeModal = null;
  let placedInHeader = false;
  let rafId = null;

  function cacheElements(){
    if(!mapControls || !mapControls.isConnected){
      mapControls = document.querySelector('.map-controls-map');
      if(mapControls){
        if(!originalParent) originalParent = mapControls.parentElement;
        if(!originalNext) originalNext = mapControls.nextElementSibling;
      }
    }
    if(!header || !header.isConnected){
      header = document.querySelector('.header');
    }
    if(header){
      if(!headerButtons || !header.contains(headerButtons)){
        headerButtons = header.querySelector('.header-buttons');
      }
      if(!viewToggle || !header.contains(viewToggle)){
        viewToggle = header.querySelector('.view-toggle');
      }
    } else {
      headerButtons = null;
      viewToggle = null;
    }
    if(!welcomeModal || !welcomeModal.isConnected){
      welcomeModal = document.getElementById('welcome-modal');
    }
    return Boolean(mapControls && header);
  }

  function moveToHeader(){
    if(!cacheElements() || placedInHeader) return;
    const insertBeforeNode = (headerButtons && headerButtons.parentNode === header) ? headerButtons : null;
    if(insertBeforeNode){
      header.insertBefore(mapControls, insertBeforeNode);
    } else {
      header.appendChild(mapControls);
    }
    mapControls.classList.add('in-header');
    placedInHeader = true;
  }

  function moveToOriginal(){
    if(!mapControls || !originalParent || !placedInHeader) return;
    if(originalNext && originalNext.parentNode === originalParent){
      originalParent.insertBefore(mapControls, originalNext);
    } else {
      originalParent.appendChild(mapControls);
    }
    mapControls.classList.remove('in-header');
    mapControls.style.left = '';
    mapControls.style.width = '';
    mapControls.style.maxWidth = '';
    placedInHeader = false;
  }

  function performUpdate(){
    rafId = null;
    if(!cacheElements()) return;
    const welcomeOpen = welcomeModal && welcomeModal.classList.contains('show');
    if(welcomeOpen){
      moveToOriginal();
      return;
    }
    if(!headerButtons || !viewToggle){
      moveToOriginal();
      return;
    }
    const headerRect = header.getBoundingClientRect();
    const viewRect = viewToggle.getBoundingClientRect();
    const buttonsRect = headerButtons.getBoundingClientRect();
    const leftBoundary = Math.max(viewRect.right, headerRect.left) + SIDE_MARGIN;
    const rightBoundary = Math.min(buttonsRect.left, headerRect.right) - SIDE_MARGIN;
    const available = rightBoundary - leftBoundary;
    if(available < MIN_HEADER_WIDTH){
      moveToOriginal();
      return;
    }
    moveToHeader();
    const center = leftBoundary + available / 2;
    mapControls.style.left = (center - headerRect.left) + 'px';
    mapControls.style.width = '';
    mapControls.style.maxWidth = '';
    const ctrlRect = mapControls.getBoundingClientRect();
    if(ctrlRect.width > available){
      moveToOriginal();
    }
  }

  function scheduleUpdate(){
    if(rafId !== null) return;
    rafId = requestAnimationFrame(performUpdate);
  }

  window.addEventListener('resize', scheduleUpdate);
  window.addEventListener('orientationchange', scheduleUpdate);
  document.addEventListener('DOMContentLoaded', scheduleUpdate);
  window.addEventListener('load', scheduleUpdate);
  if(document.readyState !== 'loading') scheduleUpdate();

  const getWelcome = () => {
    if(!welcomeModal || !welcomeModal.isConnected){
      welcomeModal = document.getElementById('welcome-modal');
    }
    return welcomeModal;
  };
  const observedWelcome = getWelcome();
  if(observedWelcome && typeof MutationObserver === 'function'){
    const observer = new MutationObserver(scheduleUpdate);
    observer.observe(observedWelcome, {attributes:true, attributeFilter:['class','style']});
  }

  window.updateHeaderMapControls = scheduleUpdate;
})();

function schedulePanelEntrance(content, force=false){
  if(!content) return;
  if(force){
    content.classList.remove('panel-visible');
  }
  content.style.transform = '';
  if(force || !content.classList.contains('panel-visible')){
    requestAnimationFrame(()=>{
      if(!content.isConnected) return;
      content.classList.add('panel-visible');
    });
  }
}
function openPanel(m){
  const content = m.querySelector('.panel-content') || m.querySelector('.modal-content');
  if(content && m.id !== 'welcome-modal'){
    content.style.width = '';
    content.style.height = '';
  }
  let shouldScheduleEntrance = false;
  if(content){
    const rootStyles = getComputedStyle(document.documentElement);
    const headerH = parseFloat(rootStyles.getPropertyValue('--header-h')) || 0;
    const subH = parseFloat(rootStyles.getPropertyValue('--subheader-h')) || 0;
    const footerH = parseFloat(rootStyles.getPropertyValue('--footer-h')) || 0;
    const safeTop = parseFloat(rootStyles.getPropertyValue('--safe-top')) || 0;
    const viewportHeight = getViewportHeight();
    const innerWidth = window.innerWidth;
    if(m.id==='adminPanel' || m.id==='memberPanel'){
      const topPos = headerH + safeTop;
      const availableHeight = Math.max(0, viewportHeight - footerH - topPos);
      content.style.left='auto';
      content.style.right='0';
      content.style.top=`${topPos}px`;
      content.style.bottom=`${footerH}px`;
      content.style.maxHeight = availableHeight ? `${availableHeight}px` : '';
      content.dataset.side='right';
      if(!content.classList.contains('panel-visible')){
        content.classList.remove('panel-visible');
        shouldScheduleEntrance = true;
      }
    } else if(m.id==='filterPanel'){
      const topPos = headerH + subH + safeTop;
      if(innerWidth < 450){
        content.style.left='0';
        content.style.right='0';
        content.style.top=`${topPos}px`;
        content.style.bottom=`${footerH}px`;
        content.style.maxHeight='';
      } else {
        const availableHeight = Math.max(0, viewportHeight - footerH - topPos);
        content.style.left='0';
        content.style.right='';
        content.style.top=`${topPos}px`;
        content.style.bottom='';
        content.style.maxHeight = availableHeight ? `${availableHeight}px` : '';
      }
      content.dataset.side='left';
      if(!content.classList.contains('panel-visible')){
        content.classList.remove('panel-visible');
        shouldScheduleEntrance = true;
      }
    } else if(m.id==='welcome-modal'){
      const topPos = headerH + safeTop + 10;
      content.style.left='50%';
      content.style.top=`${topPos}px`;
      content.style.transform='translateX(-50%)';
    } else {
      content.style.left='50%';
      content.style.top='50%';
      content.style.transform='translate(-50%, -50%)';
      if(m.id !== 'welcome-modal' && !['adminPanel','memberPanel','filterPanel'].includes(m.id)){
        loadPanelState(m);
      }
    }
  }
  m.classList.add('show');
  m.removeAttribute('aria-hidden');
  m.removeAttribute('inert');
  if(m.id === 'welcome-modal'){
    const mc = document.querySelector('.map-controls-map');
    if(mc) mc.style.display = 'none';
  }
  const btnId = panelButtons[m && m.id];
  if(btnId){
    const btn = document.getElementById(btnId);
    btn && btn.setAttribute('aria-pressed','true');
  }
  localStorage.setItem(`panel-open-${m.id}`,'true');
  if(content && shouldScheduleEntrance){
    schedulePanelEntrance(content);
  }
  if(!m.__bringToTopAdded){
    m.addEventListener('mousedown', ()=> bringToTop(m));
    m.__bringToTopAdded = true;
  }
  bringToTop(m);
  if(map && typeof map.resize === 'function') setTimeout(()=> map.resize(),0);
  if(typeof window.adjustBoards === 'function') setTimeout(()=> window.adjustBoards(), 0);
  if(typeof window.updateHeaderMapControls === 'function') window.updateHeaderMapControls();
  if(content){
    requestAnimationFrame(()=> refreshPanelScrollOverlays());
  }
}

const memberPanelChangeManager = (()=>{
  let panel = null;
  let form = null;
  let saveButton = null;
  let discardButton = null;
  let prompt = null;
  let promptSaveButton = null;
  let promptDiscardButton = null;
  let statusMessage = null;
  let dirty = false;
  let savedState = {};
  let applying = false;
  let initialized = false;
  let statusTimer = null;
  let pendingCloseTarget = null;

  function ensureElements(){
    panel = document.getElementById('memberPanel');
    form = document.getElementById('memberForm');
    if(panel){
      saveButton = panel.querySelector('.save-changes');
      discardButton = panel.querySelector('.discard-changes');
    }
    prompt = document.getElementById('memberUnsavedPrompt');
    if(prompt){
      promptSaveButton = prompt.querySelector('.confirm-save');
      promptDiscardButton = prompt.querySelector('.confirm-discard');
    }
    statusMessage = document.getElementById('memberStatusMessage');
  }

  function getKey(el){
    if(!el) return '';
    return el.name || el.id || '';
  }

  function serializeState(){
    if(!form) return {};
    const data = {};
    form.querySelectorAll('input, select, textarea').forEach(el => {
      const key = getKey(el);
      if(!key) return;
      if(el.type === 'file'){
        data[key] = el.files && el.files.length ? '__FILE_SELECTED__' : '';
        return;
      }
      if(el.type === 'checkbox'){
        data[key] = !!el.checked;
        return;
      }
      if(el.type === 'radio'){
        if(!(key in data)) data[key] = null;
        if(el.checked) data[key] = el.value;
        return;
      }
      data[key] = el.value;
    });
    return data;
  }

  function stateEquals(a, b){
    const keys = new Set([
      ...Object.keys(a || {}),
      ...Object.keys(b || {})
    ]);
    for(const key of keys){
      if((a && a[key]) !== (b && b[key])){
        return false;
      }
    }
    return true;
  }

  function setDirty(value){
    dirty = !!value;
    if(panel){
      panel.classList.toggle('has-unsaved', dirty);
      panel.setAttribute('data-unsaved', dirty ? 'true' : 'false');
    }
    if(discardButton){
      discardButton.disabled = !dirty;
    }
    if(promptDiscardButton){
      promptDiscardButton.disabled = !dirty;
    }
  }

  function updateDirty(){
    if(applying) return;
    ensureElements();
    const current = serializeState();
    setDirty(!stateEquals(current, savedState));
  }

  function showStatus(message){
    ensureElements();
    if(!statusMessage) return;
    statusMessage.textContent = message;
    statusMessage.setAttribute('aria-hidden','false');
    statusMessage.classList.add('show');
    clearTimeout(statusTimer);
    statusTimer = setTimeout(()=>{
      statusMessage.classList.remove('show');
      statusMessage.setAttribute('aria-hidden','true');
    }, 2000);
  }

  function applyState(state){
    if(!form || !state) return;
    applying = true;
    try{
      form.querySelectorAll('input, select, textarea').forEach(el => {
        const key = getKey(el);
        if(!key || !(key in state)) return;
        const value = state[key];
        if(el.type === 'file'){
          const shouldClear = !value;
          if(shouldClear && el.value){
            el.value = '';
          }
          return;
        }
        if(el.type === 'checkbox'){
          const nextChecked = !!value;
          if(el.checked !== nextChecked){
            el.checked = nextChecked;
          }
          return;
        }
        if(el.type === 'radio'){
          const shouldCheck = value === el.value;
          if(el.checked !== shouldCheck){
            el.checked = shouldCheck;
          }
          return;
        }
        const nextValue = value == null ? '' : String(value);
        if(el.value !== nextValue){
          el.value = nextValue;
        }
      });
    } finally {
      applying = false;
      updateDirty();
    }
  }

  function refreshSavedState(){
    savedState = serializeState();
    setDirty(false);
  }

  function closePrompt(){
    if(prompt){
      prompt.classList.remove('show');
      prompt.setAttribute('aria-hidden','true');
    }
  }

  function cancelPrompt(){
    pendingCloseTarget = null;
    closePrompt();
  }

  function openPrompt(target){
    pendingCloseTarget = target || panel;
    if(prompt){
      prompt.classList.add('show');
      prompt.setAttribute('aria-hidden','false');
      setTimeout(()=>{
        if(promptSaveButton) promptSaveButton.focus();
      }, 0);
    }
  }

  function handleSave({ closeAfter } = {}){
    refreshSavedState();
    showStatus('Saved');
    if(closeAfter){
      const target = pendingCloseTarget;
      pendingCloseTarget = null;
      closePrompt();
      if(target) closePanel(target);
    } else {
      pendingCloseTarget = null;
    }
  }

  function notifyDiscard(detail = {}){
    try{
      document.dispatchEvent(new CustomEvent('member-panel:discarded', { detail }));
    }catch(err){
      console.error('Failed to dispatch member discard event', err);
    }
  }

  function discardChanges({ closeAfter } = {}){
    if(form && typeof form.reset === 'function'){
      applying = true;
      try{
        form.reset();
      } finally {
        applying = false;
      }
    }
    applyState(savedState);
    setDirty(false);
    showStatus('Changes Discarded');
    notifyDiscard({ closeAfter: !!closeAfter });
    if(closeAfter){
      const target = pendingCloseTarget;
      pendingCloseTarget = null;
      closePrompt();
      if(target) closePanel(target);
    } else {
      pendingCloseTarget = null;
      closePrompt();
    }
  }

  function formChanged(){
    if(applying) return;
    updateDirty();
  }

  function attachListeners(){
    if(initialized) return;
    ensureElements();
    if(!panel || !form) return;
    form.addEventListener('input', formChanged, true);
    form.addEventListener('change', formChanged, true);
    if(saveButton){
      saveButton.addEventListener('click', e=>{
        e.preventDefault();
        pendingCloseTarget = null;
        handleSave({ closeAfter:false });
      });
    }
    if(discardButton){
      discardButton.addEventListener('click', e=>{
        e.preventDefault();
        pendingCloseTarget = null;
        discardChanges({ closeAfter:false });
      });
    }
    if(promptSaveButton){
      promptSaveButton.addEventListener('click', e=>{
        e.preventDefault();
        handleSave({ closeAfter:true });
      });
    }
    if(promptDiscardButton){
      promptDiscardButton.addEventListener('click', e=>{
        e.preventDefault();
        discardChanges({ closeAfter:true });
      });
    }
    if(prompt){
      prompt.addEventListener('click', e=>{
        if(e.target === prompt) cancelPrompt();
      });
    }
    initialized = true;
    refreshSavedState();
  }

  ensureElements();
  attachListeners();
  document.addEventListener('DOMContentLoaded', () => {
    setTimeout(()=>{
      ensureElements();
      attachListeners();
      refreshSavedState();
    }, 0);
  });

  function isPromptOpen(){
    return !!(prompt && prompt.classList.contains('show'));
  }

  return {
    handlePanelClose(panelEl){
      if(!panel || panelEl !== panel) return false;
      if(isPromptOpen()) return true;
      if(dirty){
        openPrompt(panelEl);
        return true;
      }
      return false;
    },
    handleEscape(panelEl){
      if(isPromptOpen()){
        cancelPrompt();
        return true;
      }
      if(panel && panelEl === panel && dirty){
        openPrompt(panelEl);
        return true;
      }
      return false;
    }
  };
})();

const adminPanelChangeManager = (()=>{
  let panel = null;
  let form = null;
  let saveButton = null;
  let discardButton = null;
  let prompt = null;
  let promptSaveButton = null;
  let promptDiscardButton = null;
  let statusMessage = null;
  let dirty = false;
  let savedState = {};
  let applying = false;
  let statusTimer = null;
  let initialized = false;
  let pendingCloseTarget = null;

  function ensureElements(){
    panel = document.getElementById('adminPanel');
    form = document.getElementById('adminForm');
    if(panel){
      saveButton = panel.querySelector('.save-changes');
      discardButton = panel.querySelector('.discard-changes');
    }
    prompt = document.getElementById('adminUnsavedPrompt');
    if(prompt){
      promptSaveButton = prompt.querySelector('.confirm-save');
      promptDiscardButton = prompt.querySelector('.confirm-discard');
    }
    statusMessage = document.getElementById('adminStatusMessage');
  }

  function trigger(el, type){
    el.dispatchEvent(new Event(type, { bubbles: true }));
  }

  function serializeState(){
    if(!form) return {};
    const data = {};
    const elements = form.querySelectorAll('input, select, textarea');
    elements.forEach(el => {
      if(!el) return;
      const key = el.name || el.id;
      if(!key) return;
      if(el.type === 'file') return;
      if(el.tagName === 'SELECT' && el.multiple){
        data[key] = Array.from(el.options || []).filter(opt => opt.selected).map(opt => opt.value);
        return;
      }
      if(el.type === 'checkbox'){
        data[key] = el.checked;
        return;
      }
      if(el.type === 'radio'){
        if(!(key in data)) data[key] = null;
        if(el.checked) data[key] = el.value;
        return;
      }
      data[key] = el.value;
    });
    form.querySelectorAll('[contenteditable][id]').forEach(el => {
      data[el.id] = el.innerHTML;
    });
    return data;
  }

  function applyState(state){
    if(!form || !state) return;
    applying = true;
    try{
      const elements = form.querySelectorAll('input, select, textarea');
      elements.forEach(el => {
        if(!el) return;
        const key = el.name || el.id;
        if(!key || !(key in state)) return;
        if(el.type === 'file') return;
        if(el.tagName === 'SELECT' && el.multiple){
          const values = Array.isArray(state[key]) ? state[key].map(String) : [];
          let changed = false;
          Array.from(el.options || []).forEach(opt => {
            const shouldSelect = values.includes(opt.value);
            if(opt.selected !== shouldSelect){
              opt.selected = shouldSelect;
              changed = true;
            }
          });
          if(changed) trigger(el, 'change');
          return;
        }
        if(el.type === 'checkbox'){
          const shouldCheck = !!state[key];
          if(el.checked !== shouldCheck){
            el.checked = shouldCheck;
            trigger(el, 'change');
          }
          return;
        }
        if(el.type === 'radio'){
          const shouldCheck = state[key] === el.value;
          if(el.checked !== shouldCheck){
            el.checked = shouldCheck;
            if(shouldCheck) trigger(el, 'change');
          }
          return;
        }
        const nextValue = state[key] === null || state[key] === undefined ? '' : String(state[key]);
        if(el.value !== nextValue){
          el.value = nextValue;
          trigger(el, 'input');
          trigger(el, 'change');
        }
      });
      form.querySelectorAll('[contenteditable][id]').forEach(el => {
        if(!(el.id in state)) return;
        const html = state[el.id] ?? '';
        if(el.innerHTML !== html){
          el.innerHTML = html;
          trigger(el, 'input');
          trigger(el, 'change');
        }
      });
    } finally {
      applying = false;
    }
  }

  function setDirty(value){
    dirty = !!value;
    if(panel){
      panel.classList.toggle('has-unsaved', dirty);
      panel.setAttribute('data-unsaved', dirty ? 'true' : 'false');
    }
    if(discardButton){
      discardButton.disabled = !dirty;
    }
    if(promptDiscardButton){
      promptDiscardButton.disabled = !dirty;
    }
  }

  function refreshSavedState(){
    if(!form) return;
    savedState = serializeState();
    if(window.formbuilderStateManager && typeof window.formbuilderStateManager.save === 'function'){
      window.formbuilderStateManager.save();
    }
    setDirty(false);
  }

  function showStatus(message){
    if(!statusMessage) statusMessage = document.getElementById('adminStatusMessage');
    if(!statusMessage) return;
    statusMessage.textContent = message;
    statusMessage.setAttribute('aria-hidden','false');
    statusMessage.classList.add('show');
    clearTimeout(statusTimer);
    statusTimer = setTimeout(()=>{
      statusMessage.classList.remove('show');
      statusMessage.setAttribute('aria-hidden','true');
    }, 2000);
  }

  function closePrompt(){
    if(prompt){
      prompt.classList.remove('show');
      prompt.setAttribute('aria-hidden','true');
    }
  }

  function cancelPrompt(){
    pendingCloseTarget = null;
    closePrompt();
  }

  function openPrompt(target){
    pendingCloseTarget = target;
    if(prompt){
      prompt.classList.add('show');
      prompt.setAttribute('aria-hidden','false');
      setTimeout(()=>{
        if(promptSaveButton) promptSaveButton.focus();
      }, 0);
    }
  }

  function runSave({ closeAfter } = {}){
    ensureElements();
    let result = null;
    try{
      if(typeof window.saveAdminChanges === 'function'){
        result = window.saveAdminChanges();
      }
    }catch(err){
      console.error('Failed to save admin changes', err);
      if(!closeAfter) cancelPrompt();
      return;
    }
    Promise.resolve(result).then(()=>{
      refreshSavedState();
      showStatus('Saved');
      const panelToClose = closeAfter ? pendingCloseTarget : null;
      if(closeAfter) pendingCloseTarget = null;
      closePrompt();
      if(panelToClose) closePanel(panelToClose);
    }).catch(err => {
      console.error('Failed to save admin changes', err);
    });
  }

  function notifyDiscard(detail = {}){
    try{
      document.dispatchEvent(new CustomEvent('admin-panel:discarded', { detail }));
    }catch(err){
      console.error('Failed to dispatch admin discard event', err);
    }
  }

  function discardChanges({ closeAfter } = {}){
    if(form && typeof form.reset === 'function'){
      applying = true;
      try{
        form.reset();
      } finally {
        applying = false;
      }
    }
    if(window.formbuilderStateManager && typeof window.formbuilderStateManager.restoreSaved === 'function'){
      window.formbuilderStateManager.restoreSaved();
    }
    if(savedState) applyState(savedState);
    setDirty(false);
    showStatus('Changes Discarded');
    notifyDiscard({ closeAfter: !!closeAfter });
    const panelToClose = closeAfter ? pendingCloseTarget : null;
    pendingCloseTarget = null;
    closePrompt();
    if(panelToClose) closePanel(panelToClose);
  }

  function formChanged(){
    if(applying) return;
    setDirty(true);
  }

  function attachListeners(){
    if(initialized) return;
    ensureElements();
    if(!panel || !form) return;
    form.addEventListener('input', formChanged, true);
    form.addEventListener('change', formChanged, true);
    if(saveButton){
      saveButton.addEventListener('click', e=>{
        e.preventDefault();
        pendingCloseTarget = null;
        runSave({ closeAfter:false });
      });
    }
    if(discardButton){
      discardButton.addEventListener('click', e=>{
        e.preventDefault();
        discardChanges({ closeAfter:false });
      });
    }
    if(promptSaveButton){
      promptSaveButton.addEventListener('click', e=>{
        e.preventDefault();
        runSave({ closeAfter:true });
      });
    }
    if(promptDiscardButton){
      promptDiscardButton.addEventListener('click', e=>{
        e.preventDefault();
        discardChanges({ closeAfter:true });
      });
    }
    if(prompt){
      prompt.addEventListener('click', e=>{
        if(e.target === prompt) cancelPrompt();
      });
    }
    initialized = true;
    refreshSavedState();
  }

  ensureElements();
  attachListeners();
  document.addEventListener('DOMContentLoaded', () => {
    setTimeout(()=>{
      ensureElements();
      attachListeners();
      refreshSavedState();
    }, 0);
  });

  function isPromptOpen(){
    return !!(prompt && prompt.classList.contains('show'));
  }

  return {
    hasUnsaved(){
      return !!dirty;
    },
    handlePanelClose(panelEl){
      if(!panel || panelEl !== panel) return false;
      if(isPromptOpen()) return true;
      if(dirty){
        openPrompt(panelEl);
        return true;
      }
      return false;
    },
    handleEscape(panelEl){
      if(isPromptOpen()){
        cancelPrompt();
        return true;
      }
      if(panel && panelEl === panel && dirty){
        openPrompt(panelEl);
        return true;
      }
      return false;
    }
  };
})();




function closePanel(m){
  const btnId = panelButtons[m && m.id];
  if(btnId){
    const btn = document.getElementById(btnId);
    btn && btn.setAttribute('aria-pressed','false');
  }
  const content = m.querySelector('.panel-content') || m.querySelector('.modal-content');
  const active = document.activeElement;
  if(active && m.contains(active)) active.blur();
  if(m.id === 'welcome-modal'){
    const mc = document.querySelector('.map-controls-map');
    if(mc) mc.style.display = '';
  }
  m.setAttribute('inert','');
  if(content && content.dataset.side){
    content.classList.remove('panel-visible');
    content.addEventListener('transitionend', function handler(){
      content.removeEventListener('transitionend', handler);
      m.classList.remove('show');
      m.setAttribute('aria-hidden','true');
      localStorage.setItem(`panel-open-${m.id}`,'false');
      const idx = panelStack.indexOf(m);
      if(idx!==-1) panelStack.splice(idx,1);
      if(map && typeof map.resize === 'function') setTimeout(()=> map.resize(),0);
      if(typeof window.adjustBoards === 'function') setTimeout(()=> window.adjustBoards(), 0);
    }, {once:true});
  } else {
    m.classList.remove('show');
    m.setAttribute('aria-hidden','true');
    localStorage.setItem(`panel-open-${m.id}`,'false');
    const idx = panelStack.indexOf(m);
    if(idx!==-1) panelStack.splice(idx,1);
    if(map && typeof map.resize === 'function') setTimeout(()=> map.resize(),0);
    if(typeof window.adjustBoards === 'function') setTimeout(()=> window.adjustBoards(), 0);
  }
  if(typeof window.updateHeaderMapControls === 'function') window.updateHeaderMapControls();
}






const welcomeModalEl = document.getElementById('welcome-modal');
if(welcomeModalEl){
  const welcomeControls = welcomeModalEl.querySelector('.map-controls-welcome');
  welcomeModalEl.addEventListener('click', e => {
    if(welcomeControls && welcomeControls.contains(e.target)) return;
    closePanel(welcomeModalEl);
  });
  const welcomeContent = welcomeModalEl.querySelector('.modal-content');
  if(welcomeContent){
    welcomeContent.addEventListener('click', e => {
      if(welcomeControls && welcomeControls.contains(e.target)) return;
      closePanel(welcomeModalEl);
    });
  }
}
function requestClosePanel(m){
  if(m){
    if(m.id === 'adminPanel' && adminPanelChangeManager.handlePanelClose(m)){
      return;
    }
    if(m.id === 'memberPanel' && memberPanelChangeManager.handlePanelClose(m)){
      return;
    }
  }
  closePanel(m);
}
function togglePanel(m){
  if(m.classList.contains('show')){
    requestClosePanel(m);
  } else {
    openPanel(m);
  }
}
function movePanelToEdge(panel, side){
  if(!panel) return;
  const content = panel.querySelector('.panel-content') || panel.querySelector('.modal-content');
  if(!content) return;
  const header = document.querySelector('.header');
  const topPos = header ? header.getBoundingClientRect().bottom : 0;
  content.style.top = `${topPos}px`;
  if(side === 'left'){
    content.dataset.side='left';
    content.style.left = '0';
    content.style.right = 'auto';
    schedulePanelEntrance(content, true);
  } else {
    content.dataset.side='right';
    content.style.left = 'auto';
    content.style.right = '0';
    schedulePanelEntrance(content, true);
  }
}
function repositionPanels(){
  ['adminPanel','memberPanel','filterPanel'].forEach(id=>{
    const panel = document.getElementById(id);
    if(panel && panel.classList.contains('show')){
      const content = panel.querySelector('.panel-content');
      if(!content) return;
      const w = content.style.width;
      const h = content.style.height;
      openPanel(panel);
      content.style.width = w;
      content.style.height = h;
    }
  });
}
function handleEsc(){
  const top = panelStack[panelStack.length-1];
  if(!top){
    const {container} = ensureImageModalReady();
    if(container && !container.classList.contains('hidden')){
      closeImageModal(container);
    }
    return;
  }
  if(top instanceof Element){
    if(top.id === 'adminPanel' && adminPanelChangeManager.handleEscape(top)){
      return;
    }
    if(top.id === 'memberPanel' && memberPanelChangeManager.handleEscape(top)){
      return;
    }
    if(top.id === 'post-modal-container'){
      closePostModal();
    } else {
      requestClosePanel(top);
    }
  } else if(typeof top.remove==='function'){
    panelStack.pop();
    top.remove();
  }
}
document.addEventListener('keydown', e=>{
  if(e.key==='Escape') handleEsc();
  else if(e.key==='ArrowLeft' || e.key==='ArrowRight'){
    const top = panelStack[panelStack.length-1];
    if(window.innerWidth >= 450 && top && (top.id==='adminPanel' || top.id==='memberPanel')){
      movePanelToEdge(top, e.key==='ArrowLeft' ? 'left' : 'right');
    }
  }
});

let pointerStartedInFilterContent = false;

function handleDocInteract(e){
  if(e.target.closest('.image-modal-container')) return;
  if(logoEls.some(el => el.contains(e.target))) return;
  if(e.target.closest('#filterBtn')) return;
  const welcome = document.getElementById('welcome-modal');
  if(welcome && welcome.classList.contains('show')){
    const controls = welcome.querySelector('.map-controls-welcome');
    if(!controls || !controls.contains(e.target)){
      closePanel(welcome);
    }
  }
  const filterPanel = document.getElementById('filterPanel');
  const fromPointerDown = !!e.__fromPointerDown;
  if(filterPanel && filterPanel.classList.contains('show')){
    const content = filterPanel.querySelector('.panel-content');
    const pinBtn = filterPanel.querySelector('.pin-panel');
    const pinned = pinBtn && pinBtn.getAttribute('aria-pressed')==='true';
    const startedInside = pointerStartedInFilterContent;
    if(content && !content.contains(e.target) && !pinned){
      if(startedInside && !fromPointerDown){
        pointerStartedInFilterContent = false;
        return;
      }
      closePanel(filterPanel);
      pointerStartedInFilterContent = false;
      return;
    }
    if(!fromPointerDown){
      pointerStartedInFilterContent = false;
    }
  } else if(!fromPointerDown){
    pointerStartedInFilterContent = false;
  }
}

document.addEventListener('click', handleDocInteract);
document.addEventListener('pointerdown', (e) => {
  const target = e.target;
  const filterPanel = document.getElementById('filterPanel');
  const content = filterPanel ? filterPanel.querySelector('.panel-content') : null;
  pointerStartedInFilterContent = !!(filterPanel && filterPanel.classList.contains('show') && content && content.contains(target));
  requestAnimationFrame(() => handleDocInteract({ target, __fromPointerDown: true }));
});

// Panels and admin/member interactions
(function(){
  const memberBtn = document.getElementById('memberBtn');
  const adminBtn = document.getElementById('adminBtn');
  const filterBtn = document.getElementById('filterBtn');
  const memberPanel = document.getElementById('memberPanel');
  const adminPanel = document.getElementById('adminPanel');
  const filterPanel = document.getElementById('filterPanel');

  if(memberBtn && memberPanel){
    memberBtn.addEventListener('click', ()=> togglePanel(memberPanel));
  }
  if(adminBtn && adminPanel){
    adminBtn.addEventListener('click', ()=> togglePanel(adminPanel));
  }
  filterBtn && filterBtn.addEventListener('click', ()=> togglePanel(filterPanel));
  document.querySelectorAll('.panel .close-panel').forEach(btn=>{
    btn.addEventListener('click', ()=>{
      const panel = btn.closest('.panel');
      requestClosePanel(panel);
    });
  });
  document.querySelectorAll('.panel .move-left').forEach(btn=>{
    btn.addEventListener('click', e=>{
      e.stopPropagation();
      const panel = btn.closest('.panel');
      movePanelToEdge(panel, 'left');
    });
  });
  document.querySelectorAll('.panel .move-right').forEach(btn=>{
    btn.addEventListener('click', e=>{
      e.stopPropagation();
      const panel = btn.closest('.panel');
      movePanelToEdge(panel, 'right');
    });
  });

  document.querySelectorAll('#filterPanel .pin-panel').forEach(btn=>{
    btn.addEventListener('click', e=>{
      e.stopPropagation();
      const pressed = btn.getAttribute('aria-pressed')==='true';
      btn.setAttribute('aria-pressed', pressed ? 'false' : 'true');
      if(typeof window.adjustBoards === 'function') setTimeout(()=> window.adjustBoards(), 0);
    });
  });

  document.querySelectorAll('.panel .panel-header').forEach(header=>{
    header.addEventListener('mousedown', e=>{
      if(e.target.closest('button')) return;
      const panel = header.closest('.panel');
      const content = panel ? panel.querySelector('.panel-content') : null;
      if(!content) return;
      bringToTop(panel);
      const rect = content.getBoundingClientRect();
      const startX = e.clientX;
      const startLeft = rect.left;
      const onMove = (ev)=>{
        const dx = ev.clientX - startX;
        let newLeft = startLeft + dx;
        const maxLeft = window.innerWidth - rect.width;
        if(newLeft < 0) newLeft = 0;
        if(newLeft > maxLeft) newLeft = maxLeft;
        content.style.left = `${newLeft}px`;
        content.style.right = 'auto';
      };
      const throttledMove = rafThrottle(onMove);
      function onUp(){
        document.removeEventListener('mousemove', throttledMove);
        document.removeEventListener('mouseup', onUp);
      }
      document.addEventListener('mousemove', throttledMove);
      document.addEventListener('mouseup', onUp);
    });
  });

    const welcomeModal = document.getElementById('welcome-modal');
    [memberPanel, adminPanel, welcomeModal].forEach(m=>{
      if(m && localStorage.getItem(`panel-open-${m.id}`) === 'true'){
        openPanel(m);
      }
    });
    if(welcomeModal && !localStorage.getItem('welcome-seen')){
      openWelcome();
      localStorage.setItem('welcome-seen','true');
    }
    const shouldOpenFilter = window.innerWidth >= 1300 && localStorage.getItem('panel-open-filterPanel') === 'true';
    if(filterPanel && shouldOpenFilter){
      openPanel(filterPanel);
    }
  document.querySelectorAll('.panel').forEach(panel=>{
    const content = panel.querySelector('.panel-content');
    if(content){
      const defaultWidth = panel.id === 'filterPanel' ? '380px' : '440px';
      content.style.width = defaultWidth;
      content.style.maxWidth = defaultWidth;
      content.style.top = 'calc(var(--header-h) + var(--safe-top))';
      content.style.bottom = 'var(--footer-h)';
      content.style.height = 'calc(100vh - var(--header-h) - var(--safe-top) - var(--footer-h))';
      content.style.maxHeight = 'calc(100vh - var(--header-h) - var(--safe-top) - var(--footer-h))';
    }
  });

  const adminTabs = document.querySelectorAll('#adminPanel .tab-bar button');
  const adminPanels = document.querySelectorAll('#adminPanel .tab-panel');
  adminTabs.forEach(btn=>{
    btn.addEventListener('click', ()=>{
      adminTabs.forEach(b=>b.setAttribute('aria-selected','false'));
      adminPanels.forEach(p=>p.classList.remove('active'));
      btn.setAttribute('aria-selected','true');
      const panel = document.getElementById(`tab-${btn.dataset.tab}`);
      panel && panel.classList.add('active');
    });
  });

  const colorAreas = [
    {key:'header', label:'Header', selectors:{bg:['.header'], text:['.header']}},
    {key:'body', label:'Body', selectors:{bg:['body'], border:[], hoverBorder:[], activeBorder:[]}},
    {key:'list', label:'List', selectors:{bg:['.quick-list-board'], text:['.quick-list-board'], title:['.quick-list-board .recents-card .t','.quick-list-board .recents-card .title'], btn:['.quick-list-board button','.quick-list-board .sq','.quick-list-board .tiny','.quick-list-board .btn'], btnText:['.quick-list-board button','.quick-list-board .sq','.quick-list-board .tiny','.quick-list-board .btn'], card:['.quick-list-board .recents-card']}},
    {key:'post-board', label:'Closed Posts', selectors:{bg:['.post-board'], text:['.post-board','.post-board .posts'], title:['.post-board .post-card .t','.post-board .post-card .title','.post-board .open-post .t','.post-board .open-post .title'], btn:['.post-board button'], btnText:['.post-board button'], card:['.post-board .post-card','.post-board .open-post']}},
    {key:'open-post', label:'Open Posts', selectors:{text:['.open-post','.open-post .venue-info','.open-post .session-info'], title:['.open-post .t','.open-post .title'], btn:['.open-post button'], btnText:['.open-post button'], card:['.open-post'], header:['.open-post .post-header'], image:['.open-post .image-box'], menu:['.open-post .venue-menu button','.open-post .session-menu button']}},
    {key:'map', label:'Map', selectors:{popupBg:['.mapboxgl-popup.big-map-card .mapboxgl-popup-content','.mapboxgl-popup.big-map-card .big-map-card','.mapboxgl-popup.big-map-card .chip','.mapboxgl-popup.big-map-card .chip-small','.mapboxgl-popup.big-map-card .map-card-list-item'], popupText:['.mapboxgl-popup.big-map-card .big-map-card','.mapboxgl-popup.big-map-card .map-card-title','.mapboxgl-popup.big-map-card .map-card-venue','.mapboxgl-popup.big-map-card .chip','.mapboxgl-popup.big-map-card .chip-small','.mapboxgl-popup.big-map-card .map-card-list-item'], title:['.mapboxgl-popup.big-map-card .map-card-title','.mapboxgl-popup.big-map-card .chip .t','.mapboxgl-popup.big-map-card .chip .title','.mapboxgl-popup.big-map-card .chip-small .t','.mapboxgl-popup.big-map-card .chip-small .title']}},
    {key:'filter', label:'Filter Panel', selectors:{bg:['#filterPanel .panel-content'], text:['#filterPanel .panel-content'], title:['#filterPanel .panel-content .t','#filterPanel .panel-content .title'], btn:['#filterPanel button:not([class*="mapboxgl-"])','#filterPanel .sq','#filterPanel .tiny'], btnText:['#filterPanel button:not([class*="mapboxgl-"])','#filterPanel .sq','#filterPanel .tiny']}},
    {key:'calendar', label:'Calendar', selectors:{bg:['.calendar'], text:['.calendar .day'], weekday:['.calendar .weekday'], title:['.calendar .calendar-header'], header:['.calendar .calendar-header']}},
  {key:'adminPanel', label:'Admin Panel', selectors:{bg:['#adminPanel .panel-content'], text:['#adminPanel .panel-content'], title:['#adminPanel .panel-content .t','#adminPanel .panel-content .title'], btn:['#adminPanel button','#adminPanel #spinType span'], btnText:['#adminPanel button','#adminPanel #spinType span']}},
  {key:'welcome-modal', label:'Welcome Modal', selectors:{bg:['#welcome-modal .modal-content'], text:['#welcome-modal .modal-content'], title:['#welcome-modal .modal-content .t','#welcome-modal .modal-content .title'], btn:['#welcome-modal button:not([class*"mapboxgl-"])'], btnText:['#welcome-modal button:not([class*"mapboxgl-"])']}},
  {key:'memberPanel', label:'Member Panel', selectors:{bg:['#memberPanel .panel-content'], text:['#memberPanel .panel-content'], title:['#memberPanel .panel-content .t','#memberPanel .panel-content .title'], btn:['#memberPanel button'], btnText:['#memberPanel button']}},
  {key:'imagePanel', label:'Image Modal', selectors:{bg:['.image-modal-container'], text:['.image-modal-container .image-modal']}}
];

  function storeTitleDefaults(){
    colorAreas.forEach(area=>{
      (area.selectors.title||[]).forEach(sel=>{
        document.querySelectorAll(sel).forEach(el=>{
          const cs = getComputedStyle(el);
          el.dataset.titleDefaultColor = cs.color;
          el.dataset.titleDefaultFont = cs.fontFamily;
          el.dataset.titleDefaultSize = cs.fontSize;
          el.dataset.titleDefaultWeight = cs.fontWeight;
          el.dataset.titleDefaultShadow = cs.textShadow;
        });
      });
    });
    const varMap = {'today-c':'--today', 'sessionAvailable-c':'--session-available', 'sessionSelected-c':'--session-selected'};
    Object.entries(varMap).forEach(([id,varName])=>{
      const el = document.getElementById(id);
      if(el){
        const val = getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
        if(val) el.value = val;
      }
    });
  }

  function restoreTitleDefaults(area){
    (area.selectors.title||[]).forEach(sel=>{
      document.querySelectorAll(sel).forEach(el=>{
        if(el.dataset.titleDefaultColor) el.style.color = el.dataset.titleDefaultColor;
        if(el.dataset.titleDefaultFont) el.style.fontFamily = el.dataset.titleDefaultFont;
        if(el.dataset.titleDefaultSize) el.style.fontSize = el.dataset.titleDefaultSize;
        if(el.dataset.titleDefaultWeight) el.style.fontWeight = el.dataset.titleDefaultWeight;
        if(el.dataset.titleDefaultShadow) el.style.textShadow = el.dataset.titleDefaultShadow;
      });
    });
  }

  storeTitleDefaults();

  const headerEl = document.querySelector('.header');
  if(headerEl && 'ResizeObserver' in window){
    const headerObserver = new ResizeObserver(()=>{
      updateLayoutVars();
    });
    headerObserver.observe(headerEl);
  }

  window.addEventListener('resize', updateLayoutVars);
  window.addEventListener('resize', updateStickyImages);
  window.addEventListener('load', updateLayoutVars);
  updateLayoutVars();
  if (typeof updateStickyImages === 'function') {
    updateStickyImages();
  }
  if(typeof window.__wrapForInputYield === 'function'){
    ['openPost','updateVenue','togglePanel','ensureMapForVenue'].forEach(name => window.__wrapForInputYield(name));
  }
})();
</script>

<div class="image-modal-container hidden">
  <div class="image-modal"></div>
</div>

<div id="post-modal-container" class="hidden">
  <div class="post-modal"></div>
</div>

<script>
  (function(){
    const ns = 'http://www.w3.org/2000/svg';
    const SHAPES = {
      circle(){ const c=document.createElementNS(ns,'circle'); c.setAttribute('cx','0'); c.setAttribute('cy','0'); c.setAttribute('r','50'); return c; },
      tallEllipse(){ const e=document.createElementNS(ns,'ellipse'); e.setAttribute('cx','0'); e.setAttribute('cy','0'); e.setAttribute('rx','40'); e.setAttribute('ry','55'); return e; },
      heart(){ const p=document.createElementNS(ns,'path'); p.setAttribute('d','M0,-30 C-30,-70 -70,-20 -35,15 Q0,55 35,15 C70,-20 30,-70 0,-30Z'); return p; },
      star(){ const p=document.createElementNS(ns,'path'); p.setAttribute('d','M0,-55 L14,-17 L47,-17 L23,5 L35,45 L0,25 L-35,45 L-23,5 L-47,-17 L-14,-17 Z'); return p; },
      triangle(){ const p=document.createElementNS(ns,'path'); p.setAttribute('d','M0,55 L50,-45 L-50,-45 Z'); return p; },
      rectangle(){ const r=document.createElementNS(ns,'rect'); r.setAttribute('x','-35'); r.setAttribute('y','-55'); r.setAttribute('width','70'); r.setAttribute('height','110'); r.setAttribute('rx','20'); r.setAttribute('ry','20'); return r; },
      square(){ const r=document.createElementNS(ns,'rect'); r.setAttribute('x','-45'); r.setAttribute('y','-45'); r.setAttribute('width','90'); r.setAttribute('height','90'); r.setAttribute('rx','20'); r.setAttribute('ry','20'); return r; },
      diamond(){ const p=document.createElementNS(ns,'path'); p.setAttribute('d','M0,-55 L45,0 0,55 -45,0 Z'); return p; },
      pentagon(){ const p=document.createElementNS(ns,'path'); p.setAttribute('d','M0,-55 L52,-17 L32,45 -32,45 -52,-17 Z'); return p; },
      hexagon(){ const p=document.createElementNS(ns,'path'); p.setAttribute('d','M0,-55 L47,-27 L47,27 0,55 -47,27 -47,-27 Z'); return p; }
    };

    function hslToHex(h, s, l){
      s/=100; l/=100;
      const k = n => (n + h/30) % 12;
      const a = s * Math.min(l, 1-l);
      const f = n => l - a * Math.max(-1, Math.min(k(n)-3, Math.min(9-k(n),1)));
      return '#' + [f(0),f(8),f(4)].map(x=>Math.round(x*255).toString(16).padStart(2,'0')).join('');
    }
    const COLORS = Array.from({length:100}, (_,i)=>hslToHex(i*3.6,100,50));

    function createBalloon(shapeName, color, size){
      const svg = document.createElementNS(ns,'svg');
      svg.setAttribute('viewBox','-60 -80 120 160');
      svg.setAttribute('width', size);
      svg.setAttribute('height', size);
      svg.dataset.color = color;
      svg.setAttribute('title', size + 'px ' + color);
      const body = SHAPES[shapeName]();
      body.setAttribute('fill', color);
      body.setAttribute('stroke', '#000');
      body.setAttribute('stroke-width', '1');
      svg.appendChild(body);
      const tie = document.createElementNS(ns,'path');
      tie.setAttribute('d','M-8,55 L0,60 L8,55 Z');
      tie.setAttribute('fill','#000');
      tie.setAttribute('stroke','#000');
      tie.setAttribute('stroke-width','1');
      svg.appendChild(tie);
      const string = document.createElementNS(ns,'line');
      string.setAttribute('x1','0'); string.setAttribute('y1','60');
      string.setAttribute('x2','0'); string.setAttribute('y2','80');
      string.setAttribute('stroke','#fff');
      string.setAttribute('stroke-width','2');
      svg.appendChild(string);
      const gleam = document.createElementNS(ns,'ellipse');
      gleam.setAttribute('cx','-20'); gleam.setAttribute('cy','-20');
      gleam.setAttribute('rx','10'); gleam.setAttribute('ry','6');
      gleam.setAttribute('fill','#fff');
      svg.appendChild(gleam);
      return svg;
    }

    window.SHAPES = SHAPES;
    window.COLORS = COLORS;
    window.createBalloon = createBalloon;

    const buttons = document.getElementById('balloonShapeButtons');
    const shapeMenuBtn = document.getElementById('shapeMenuBtn');
    const grid = document.getElementById('balloonGrid');
    const sizeSlider = document.getElementById('balloonSize');
    const sizeValue = document.getElementById('balloonSizeValue');
    const svgCode = document.getElementById('balloonSvgCode');
    const copyBtn = document.getElementById('copySvgCode');
    let currentTemplate = '';

    sizeValue.textContent = sizeSlider.value;
    copyBtn.addEventListener('click', ()=>{ navigator.clipboard.writeText(svgCode.value); });

    if(shapeMenuBtn){
      shapeMenuBtn.addEventListener('click', ()=>{
        const expanded = shapeMenuBtn.getAttribute('aria-expanded') === 'true';
        shapeMenuBtn.setAttribute('aria-expanded', String(!expanded));
        buttons.hidden = expanded;
      });
      document.addEventListener('click', e=>{
        if(!shapeMenuBtn.contains(e.target) && !buttons.contains(e.target)){
          buttons.hidden = true;
          shapeMenuBtn.setAttribute('aria-expanded','false');
        }
      });
    }

    sizeSlider.addEventListener('input', ()=>{
      sizeValue.textContent = sizeSlider.value;
      renderFromSvg(currentTemplate);
    });

    function selectSvg(svg){
      grid.querySelectorAll('svg').forEach(s=>s.classList.remove('selected'));
      svg.classList.add('selected');
      svgCode.value = svg.outerHTML;
      currentTemplate = svg.outerHTML;
      if(document.hasFocus()){
        try{
          navigator.clipboard.writeText(svg.outerHTML);
        }catch(e){
          console.error('clipboard write failed', e);
        }
      }
    }

    function renderFromSvg(template){
      if(!template){ return; }
      grid.innerHTML='';
      COLORS.forEach(color=>{
        const colored = template.replace(/fill="(?!#fff)[^"]*"/g, `fill="${color}"`);
        const doc = new DOMParser().parseFromString(colored,'image/svg+xml');
        let svg = doc && doc.documentElement ? doc.documentElement : null;
        if(!svg || svg.nodeName.toLowerCase() !== 'svg'){
          svg = doc.querySelector ? doc.querySelector('svg') : null;
        }
        if(!svg){
          console.warn('Unable to render SVG preview for template', colored);
          return;
        }
        svg = svg.cloneNode(true);
        svg.setAttribute('width', sizeSlider.value);
        svg.setAttribute('height', sizeSlider.value);
        svg.dataset.color = color;
        svg.setAttribute('title', sizeSlider.value + 'px ' + color);
        svg.addEventListener('click', ()=> selectSvg(svg));
        grid.appendChild(svg);
      });
      const first = grid.querySelector('svg');
      if(first){
        first.classList.add('selected');
        svgCode.value = first.outerHTML;
        currentTemplate = first.outerHTML;
      }
    }

    function render(name){
      grid.innerHTML='';
      COLORS.forEach(color=>{
        const svg = createBalloon(name, color, sizeSlider.value);
        svg.addEventListener('click', ()=> selectSvg(svg));
        grid.appendChild(svg);
      });
      const first = grid.querySelector('svg');
      if(first){
        first.classList.add('selected');
        svgCode.value = first.outerHTML;
        currentTemplate = first.outerHTML;
      }
    }

    svgCode.addEventListener('input', ()=>{
      currentTemplate = svgCode.value;
      renderFromSvg(currentTemplate);
    });

    const LABELS = {
      circle:'circle',
      tallEllipse:'tall ellipse',
      heart:'heart',
      star:'soft star',
      triangle:'soft triangle',
      rectangle:'tall rectangle',
      square:'square',
      diamond:'diamond',
      pentagon:'pentagon',
      hexagon:'hexagon'
    };

    Object.keys(SHAPES).forEach((name,idx)=>{
      const btn = document.createElement('button');
      btn.type = 'button';
      btn.className = 'shape-button';
      btn.appendChild(createBalloon(name, '#000', 24));
      btn.appendChild(document.createTextNode(LABELS[name] || name));
      btn.addEventListener('click', ()=>{
        document.querySelectorAll('#map-balloon-container .shape-button').forEach(b=>b.classList.remove('active'));
        btn.classList.add('active');
        render(name);
        if(shapeMenuBtn){
          shapeMenuBtn.textContent = LABELS[name] || name;
          shapeMenuBtn.setAttribute('aria-expanded','false');
          buttons.hidden = true;
        }
      });
      if(idx===0) btn.classList.add('active');
      buttons.appendChild(btn);
    });

    const firstShape = Object.keys(SHAPES)[0];
    render(firstShape);
    if(shapeMenuBtn){ shapeMenuBtn.textContent = LABELS[firstShape] || firstShape; }
  })();
</script>
<script>
(function(){
  const ICON_BASE = window.ICON_BASE || {};
  const subcategoryIcons = window.subcategoryIcons || (window.subcategoryIcons = {});
  const subcategoryMarkers = window.subcategoryMarkers || (window.subcategoryMarkers = {});
  const subcategoryMarkerIds = window.subcategoryMarkerIds || (window.subcategoryMarkerIds = {});
  const categoryShapes = window.categoryShapes || (window.categoryShapes = {});
  const shapeList = Object.keys(window.SHAPES || {});
  let colorIdx = 0;
  const cats = window.categories || [];
  cats.forEach((cat, idx) => {
    const shape = shapeList[idx % shapeList.length];
    categoryShapes[cat.name] = shape;
    cat.subs.forEach(sub => {
      const color = window.COLOR_NAMES[colorIdx % window.COLOR_NAMES.length];
      colorIdx++;
      const slug = slugify(sub);
      const iconPrefix = ICON_BASE[cat.name];
      const icon20 = `assets/icons-20/${iconPrefix}-${color}-20.webp`;
      const icon30 = `assets/icons-30/${iconPrefix}-${color}-30.webp`;
      subcategoryIcons[sub] = `<img src="${icon20}" width="20" height="20" alt="">`;
      subcategoryMarkerIds[sub] = slug;
      subcategoryMarkers[slug] = icon30;
    });
  });
  const specialSubIconPaths = {
    'Other Events': {
      icon20: 'assets/icons-20/whats-on-category-icon-red-20.webp',
      icon30: 'assets/icons-30/whats-on-category-icon-red-30.webp'
    },
    'Other Opportunities': {
      icon20: 'assets/icons-20/opportunities-category-icon-red-20.webp',
      icon30: 'assets/icons-30/opportunities-category-icon-red-30.webp'
    },
    'Other Learning': {
      icon20: 'assets/icons-20/learning-category-icon-red-20.webp',
      icon30: 'assets/icons-30/learning-category-icon-red-30.webp'
    }
  };
  Object.entries(specialSubIconPaths).forEach(([name, paths]) => {
    subcategoryIcons[name] = `<img src="${paths.icon20}" width="20" height="20" alt="">`;
    const slug = subcategoryMarkerIds[name] || slugify(name);
    subcategoryMarkers[slug] = paths.icon30;
    subcategoryMarkers[name] = paths.icon30;
  });
  document.dispatchEvent(new CustomEvent('subcategory-icons-ready'));
  if(window.postsLoaded && window.__markersLoaded){ addPostSource(); }
})();
</script>

<script>
document.addEventListener('DOMContentLoaded', () => {
  const editor = document.getElementById('welcomeMessageEditor');
  const hidden = document.getElementById('welcomeMessage');
  if(editor && hidden){
    const placeholder = editor.getAttribute('data-placeholder') || '';
    hidden.value = hidden.value || placeholder;
    editor.innerHTML = hidden.value;
    editor.addEventListener('input', () => hidden.value = editor.innerHTML);
    document.querySelectorAll('.wysiwyg-toolbar button').forEach(btn => {
      btn.addEventListener('mousedown', (event) => {
        event.preventDefault();
        editor.focus();
        document.execCommand(btn.dataset.command, false, null);
        hidden.value = editor.innerHTML;
      });
    });
  }
});
</script>

<script>
document.addEventListener('DOMContentLoaded', () => {
  document.querySelectorAll('#adminPanel input[type="checkbox"]').forEach(cb => {
    if (cb.closest('.switch')) return;
    if (cb.closest('.subcategory-form-toggle')) return;
    const wrapper = document.createElement('label');
    wrapper.className = 'switch';
    cb.parentNode.insertBefore(wrapper, cb);
    wrapper.appendChild(cb);
    const slider = document.createElement('span');
    slider.className = 'slider';
    cb.after(slider);
  });
});
</script>

<script>
document.addEventListener('DOMContentLoaded', () => {
  const colorInput = document.getElementById('postModeBgColor');
  const opacityInput = document.getElementById('postModeBgOpacity');
  const opacityVal = document.getElementById('postModeBgOpacityVal');
  const root = document.documentElement;
  const settings = JSON.parse(localStorage.getItem('admin-settings-current') || '{}');
  function hexToRgb(hex){
    const r = parseInt(hex.slice(1,3),16);
    const g = parseInt(hex.slice(3,5),16);
    const b = parseInt(hex.slice(5,7),16);
    return `${r},${g},${b}`;
  }

  function apply(){
    const color = colorInput.value || '#000000';
    const opacity = opacityInput.value;
    root.style.setProperty('--post-mode-bg-color', hexToRgb(color));
    root.style.setProperty('--post-mode-bg-opacity', opacity);
    opacityVal.textContent = Number(opacity).toFixed(2);
  }

  if(colorInput && opacityInput && opacityVal){
    colorInput.value = settings.postModeBgColor || '#000000';
    opacityInput.value = settings.postModeBgOpacity ?? 0;
    apply();
    const save = () => {
      settings.postModeBgColor = colorInput.value;
      settings.postModeBgOpacity = opacityInput.value;
      localStorage.setItem('admin-settings-current', JSON.stringify(settings));
    };
    colorInput.addEventListener('input', () => { apply(); save(); });
    opacityInput.addEventListener('input', () => { apply(); save(); });
    const prev = window.saveAdminChanges;
    window.saveAdminChanges = () => { save(); if(typeof prev === 'function') prev(); };
  }
});
</script>

<script>
document.addEventListener('DOMContentLoaded', () => {
  const vp = document.getElementById('viewport');
  const updateViewport = () => {
    if (!vp) return;
    if (window.innerWidth < 650) {
      vp.setAttribute('content','width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no');
    } else {
      vp.setAttribute('content','width=device-width, initial-scale=1');
    }
  };
  updateViewport();
  window.addEventListener('resize', updateViewport);
  window.addEventListener('orientationchange', updateViewport);

  const fsBtn = document.getElementById('fullscreenBtn');
  if (fsBtn) {
    const docEl = document.documentElement;
    const canFS = docEl.requestFullscreen || docEl.webkitRequestFullscreen || docEl.mozRequestFullScreen || docEl.msRequestFullscreen;
    const enabled = document.fullscreenEnabled || document.webkitFullscreenEnabled || document.mozFullScreenEnabled || document.msFullscreenEnabled;
    if (!canFS || enabled === false) {
      fsBtn.style.display = 'none';
    } else {
      const getFull = () => document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement;
      const updateFsState = () => {
        fsBtn.setAttribute('aria-pressed', getFull() ? 'true' : 'false');
      };
      updateFsState();
      ['fullscreenchange','webkitfullscreenchange','mozfullscreenchange','MSFullscreenChange'].forEach(evt => {
        document.addEventListener(evt, updateFsState);
      });
      fsBtn.addEventListener('click', () => {
        const isFull = getFull();
        if (!isFull) {
          const req = docEl.requestFullscreen || docEl.webkitRequestFullscreen || docEl.mozRequestFullScreen || docEl.msRequestFullscreen;
          if (req) {
            try {
              const result = req.call(docEl);
              if (result && typeof result.catch === 'function') result.catch(() => {});
            } catch (err) {
              updateFsState();
            }
          }
        } else {
          const exit = document.exitFullscreen || document.webkitExitFullscreen || document.mozCancelFullScreen || document.msExitFullscreen;
          if (exit) {
            try {
              const result = exit.call(document);
              if (result && typeof result.catch === 'function') result.catch(() => {});
            } catch (err) {
              updateFsState();
            }
          }
        }
      });
    }
  }

  if (window.innerWidth >= 650) return;

  const posts = document.querySelector('.post-board');
  if (!posts) return;

  let defaultSize = parseFloat(getComputedStyle(posts).fontSize);
  let startDist = null;
  let enlarged = false;

  function distance(t1, t2){
    return Math.hypot(t1.clientX - t2.clientX, t1.clientY - t2.clientY);
  }

  posts.addEventListener('touchstart', e => {
    if (e.target.tagName === 'IMG') return;
    if (e.touches.length === 2) {
      startDist = distance(e.touches[0], e.touches[1]);
    }
  });

  posts.addEventListener('touchmove', e => {
    if (e.target.tagName === 'IMG') return;
    if (e.touches.length === 2 && startDist) {
      const scale = distance(e.touches[0], e.touches[1]) / startDist;
      if (!enlarged && scale > 1.2) {
        posts.style.fontSize = (defaultSize * 1.2) + 'px';
        enlarged = true;
      } else if (enlarged && scale < 0.8) {
        posts.style.fontSize = defaultSize + 'px';
        enlarged = false;
      }
      e.preventDefault();
    }
  }, { passive: false });

  posts.addEventListener('touchend', e => {
    if (e.touches.length < 2) startDist = null;
  });

  posts.querySelectorAll('img').forEach(img => {
    img.addEventListener('click', e => { e.stopPropagation(); openImageModal(img.src, {origin: img}); });
    img.addEventListener('touchstart', e => {
      if (e.touches.length === 2) {
        e.preventDefault();
        e.stopPropagation();
        openImageModal(img.src, {origin: img});
      }
    }, { passive: false });
  });
});
</script>
<script>
document.addEventListener('DOMContentLoaded', () => {
  document.querySelectorAll('input[type="color"]').forEach(el => {
    if(!el.value) el.value = '#000000';
  });
});
</script>
<script>
document.addEventListener('DOMContentLoaded', () => {
  document.addEventListener('wheel', e => {
    if(e.target.closest('.post-board, .panel-content, .options-menu, .calendar-scroll')){
      e.stopPropagation();
    }
  });
  const postsPanel = document.querySelector('.post-board');
  const postsBg = document.querySelector('.post-mode-background');
  if(postsPanel){
    postsPanel.addEventListener('click', e => {
      if(e.target === postsPanel || e.target.classList.contains('posts')){
        e.stopPropagation();
      }
    });
  }
  if(postsBg){
    postsBg.addEventListener('click', e => e.stopPropagation());
  }
});
</script>
<script>
let boardAdjustCleanup = null;

function ensureImageModalReady(){
  const container = document.querySelector('.image-modal-container');
  if(!container) return {container:null, modal:null};
  const modal = container.querySelector('.image-modal');
  if(!container._listenerAdded){
    container.addEventListener('click', e => {
      if(e.target === container){
        closeImageModal(container);
      }
    });
    container._listenerAdded = true;
  }
  if(modal && !modal._closeListenerAdded){
    modal.addEventListener('click', e => {
      if(!e.target.closest('img')){
        closeImageModal(container);
      }
    });
    modal._closeListenerAdded = true;
  }
  return {container, modal};
}

function closeImageModal(container){
  const target = container || ensureImageModalReady().container;
  if(!target) return;
  const modal = target.querySelector('.image-modal');
  if(modal) modal.innerHTML = '';
  target.classList.add('hidden');
  if(target.dataset){
    delete target.dataset.activeSrc;
    delete target.dataset.activeIndex;
  }
  target._imageModalState = null;
  target._imageModalImg = null;
}

function advanceImageModal(container, modal, step=1){
  if(!container || !modal) return;
  const state = container._imageModalState;
  if(!state || !Array.isArray(state.images) || state.images.length <= 1) return;
  const len = state.images.length;
  state.index = ((state.index + step) % len + len) % len;
  renderImageModalImage(container, modal);
}

function renderImageModalImage(container, modal){
  if(!container || !modal) return;
  const state = container._imageModalState;
  if(!state || !Array.isArray(state.images) || !state.images.length) return;
  let img = container._imageModalImg;
  if(!img || img.parentNode !== modal){
    modal.innerHTML = '';
    img = document.createElement('img');
    img.addEventListener('click', e => {
      e.stopPropagation();
      advanceImageModal(container, modal, 1);
    });
    container._imageModalImg = img;
    modal.appendChild(img);
  }
  const src = state.images[state.index];
  if(img.getAttribute('src') !== src){
    img.src = src;
  }
  if(container.dataset){
    container.dataset.activeSrc = src;
    container.dataset.activeIndex = String(state.index);
  }
}

function normalizeImageModalSrc(value){
  if(!value) return '';
  try {
    return new URL(value, window.location.href).href;
  } catch(err){
    return String(value);
  }
}

function resolveImageModalContext(config){
  const result = {images: [], index: 0, gallery: null};
  if(!config) return result;
  const src = typeof config.src === 'string' ? config.src : '';
  const providedImages = Array.isArray(config.images) ? config.images.filter(Boolean) : null;
  const originEl = config.origin instanceof Element ? config.origin : null;
  let galleryRoot = config.gallery instanceof Element ? config.gallery : null;
  const findGalleryFrom = el => {
    if(!el) return null;
    const fromImageBox = el.closest && el.closest('.image-box');
    if(fromImageBox) return fromImageBox;
    const postImages = el.closest && el.closest('.post-images');
    if(postImages){
      const box = postImages.querySelector('.image-box');
      if(box) return box;
    }
    const openPost = el.closest && el.closest('.open-post');
    if(openPost){
      const box = openPost.querySelector('.image-box');
      if(box) return box;
    }
    return null;
  };
  if(!galleryRoot && originEl){
    galleryRoot = findGalleryFrom(originEl);
  }
  let images = providedImages && providedImages.length ? providedImages.slice() : null;
  if((!images || !images.length) && galleryRoot){
    if(Array.isArray(galleryRoot._modalImages) && galleryRoot._modalImages.length){
      images = galleryRoot._modalImages.slice();
    } else if(galleryRoot.dataset && galleryRoot.dataset.modalImages){
      try {
        const parsed = JSON.parse(galleryRoot.dataset.modalImages);
        if(Array.isArray(parsed) && parsed.length){
          images = parsed.slice();
        }
      } catch(err){}
    }
  }
  if((!images || !images.length) && galleryRoot){
    const trackImgs = Array.from(galleryRoot.querySelectorAll('.image-track img'));
    if(trackImgs.length){
      images = trackImgs.map(im => (im.dataset && im.dataset.full) ? im.dataset.full : im.src);
    }
  }
  if(!images || !images.length){
    images = src ? [src] : [];
  }
  let index = null;
  if(typeof config.startIndex === 'number' && Number.isFinite(config.startIndex)){
    index = config.startIndex;
  } else if(typeof config.startIndex === 'string'){
    const parsedStart = parseInt(config.startIndex, 10);
    if(Number.isFinite(parsedStart)){
      index = parsedStart;
    }
  }
  const originImg = originEl && originEl.tagName === 'IMG' ? originEl : (originEl && originEl.querySelector ? originEl.querySelector('img') : null);
  if(index === null && originImg && originImg.dataset && originImg.dataset.index){
    const parsed = parseInt(originImg.dataset.index, 10);
    if(Number.isFinite(parsed)){
      index = parsed;
    }
  }
  if(index === null && galleryRoot && galleryRoot.dataset && galleryRoot.dataset.index){
    const parsed = parseInt(galleryRoot.dataset.index, 10);
    if(Number.isFinite(parsed)){
      index = parsed;
    }
  }
  if(index === null && src){
    const found = images.indexOf(src);
    if(found !== -1){
      index = found;
    } else {
      const normalizedSrc = normalizeImageModalSrc(src);
      for(let i=0;i<images.length;i++){
        if(normalizeImageModalSrc(images[i]) === normalizedSrc){
          index = i;
          break;
        }
      }
    }
  }
  if(index === null){
    index = 0;
  }
  index = Math.max(0, Math.min(index, images.length ? images.length - 1 : 0));
  result.images = images;
  result.index = index;
  result.gallery = galleryRoot;
  return result;
}

function openImageModal(srcOrConfig, options){
  const base = (typeof srcOrConfig === 'object' && srcOrConfig !== null && !Array.isArray(srcOrConfig))
    ? Object.assign({}, srcOrConfig)
    : {src: srcOrConfig};
  if(options && typeof options === 'object'){
    Object.assign(base, options);
  }
  if(typeof base.src !== 'string' || !base.src){
    return;
  }
  const {container, modal} = ensureImageModalReady();
  if(!container || !modal) return;
  document.querySelectorAll('.image-modal-container').forEach(other => {
    if(other !== container && !other.classList.contains('hidden')){
      closeImageModal(other);
    }
  });
  const context = resolveImageModalContext(base);
  if(!context.images.length) return;
  container._imageModalState = {
    images: context.images.slice(),
    index: context.index,
    gallery: context.gallery || null
  };
  renderImageModalImage(container, modal);
  container.classList.remove('hidden');
}

function initPostLayout(board){
  if(typeof boardAdjustCleanup === 'function'){
    boardAdjustCleanup();
    boardAdjustCleanup = null;
  }
  const scheduleMapResize = mapInstance => {
    if(!mapInstance) return;
    if(typeof mapInstance.resize === 'function'){
      requestAnimationFrame(()=>{
        try { mapInstance.resize(); } catch(err){}
      });
    }
  };
  if(!(board instanceof Element)){
    document.documentElement.style.removeProperty('--post-header-h');
    if(typeof window.adjustBoards === 'function') window.adjustBoards();
    return;
  }
  const openPost = board.querySelector('.open-post');
  if(!openPost){
    document.body.classList.remove('detail-open');
    document.body.classList.remove('hide-map-calendar');
    document.documentElement.style.removeProperty('--post-header-h');
    if(typeof window.adjustBoards === 'function') window.adjustBoards();
    return;
  }
  document.body.classList.add('detail-open');
  document.body.classList.remove('hide-map-calendar');
  const postBody = openPost.querySelector('.post-body');
  if(postBody){
    postBody.removeAttribute('hidden');
    postBody.classList.remove('is-visible');
    if(postBody.dataset) delete postBody.dataset.openPostId;
  }
  const triggerDetailMapResize = target => {
    if(!target) return;
    const mapNode = target.querySelector ? target.querySelector('.post-map') : null;
    const ref = target._detailMap || (mapNode && mapNode._detailMap) || null;
    const mapInstance = ref && ref.map;
    if(mapInstance && typeof mapInstance.resize === 'function'){
      scheduleMapResize(mapInstance);
    }
  };
  triggerDetailMapResize(postBody);
  const thumbRow = postBody ? postBody.querySelector('.thumbnail-row') : null;
  const selectedImageBox = postBody ? postBody.querySelector('.selected-image, .image-box') : null;
  ensureImageModalReady();
  if(thumbRow){
    thumbRow.scrollLeft = 0;
  }
  if(thumbRow && !thumbRow._imageModalListener){
    thumbRow.addEventListener('dblclick', e => {
      const img = e.target.closest('img');
      if(img){
        e.preventDefault();
        e.stopPropagation();
        openImageModal(img.src, {origin: img});
      }
    });
    thumbRow._imageModalListener = true;
  }
  if(selectedImageBox && !selectedImageBox._imageModalListener){
    selectedImageBox.addEventListener('click', evt => {
      const currentTarget = (evt && evt.currentTarget instanceof Element)
        ? evt.currentTarget
        : selectedImageBox;
      const clickedImageBox = (evt && evt.target instanceof Element)
        ? evt.target.closest('.image-box')
        : null;
      if(clickedImageBox){
        return;
      }
      const parseIndex = value => {
        if(typeof value === 'undefined') return null;
        const parsed = parseInt(value, 10);
        return Number.isFinite(parsed) ? parsed : null;
      };
      let galleryRoot = null;
      if(currentTarget instanceof Element){
        if(currentTarget.classList.contains('image-box')){
          galleryRoot = currentTarget;
        } else {
          const postImages = typeof currentTarget.closest === 'function'
            ? currentTarget.closest('.post-images')
            : null;
          const parent = currentTarget.parentElement;
          const host = postImages || parent;
          if(host instanceof Element){
            galleryRoot = host.querySelector('.image-box');
          }
        }
      }
      const activeImg = galleryRoot ? galleryRoot.querySelector('.image-track img.active') : null;
      let img = activeImg || (currentTarget instanceof Element ? currentTarget.querySelector('img') : null);
      if(!img && galleryRoot){
        img = galleryRoot.querySelector('img');
      }
      if(!(img instanceof Element)){
        return;
      }
      if(evt && typeof evt.preventDefault === 'function') evt.preventDefault();
      if(evt && typeof evt.stopPropagation === 'function') evt.stopPropagation();
      let startIndex = null;
      if(activeImg && activeImg.dataset){
        startIndex = parseIndex(activeImg.dataset.index);
      }
      if(startIndex === null && galleryRoot && galleryRoot.dataset){
        startIndex = parseIndex(galleryRoot.dataset.index);
      }
      if(startIndex === null && img.dataset){
        startIndex = parseIndex(img.dataset.index);
      }
      const options = {origin: img};
      if(galleryRoot){
        options.gallery = galleryRoot;
      }
      if(startIndex !== null){
        options.startIndex = startIndex;
      }
      const src = (img.dataset && img.dataset.full) ? img.dataset.full : img.src;
      openImageModal(src, options);
    });
    selectedImageBox._imageModalListener = true;
  }
  if(typeof updateStickyImages === 'function'){
    updateStickyImages();
  }
  const updateMetrics = () => {
    if(typeof updateStickyImages === 'function'){
      updateStickyImages();
    }
    if(openPost){
      const header = openPost.querySelector('.post-header');
      if(header){
        document.documentElement.style.setProperty('--post-header-h', header.offsetHeight + 'px');
      } else {
        document.documentElement.style.removeProperty('--post-header-h');
      }
    }
    triggerDetailMapResize(postBody);
    if(typeof window.adjustBoards === 'function') window.adjustBoards();
  };
  updateMetrics();
  window.addEventListener('resize', updateMetrics);
  window.addEventListener('load', updateMetrics);
  boardAdjustCleanup = () => {
    window.removeEventListener('resize', updateMetrics);
    window.removeEventListener('load', updateMetrics);
  };
}

document.addEventListener('DOMContentLoaded', () => {
  initPostLayout(document.querySelector('.post-board'));
});
</script>

<script>
// Wait helpers if your app exposes callWhenDefined; otherwise poll.
(function(){
  function whenDefined(name, cb){
    if (window.callWhenDefined) return window.callWhenDefined(name, cb);
    const iv = setInterval(() => {
      if (typeof window[name] === 'function') { clearInterval(iv); cb(window[name]); }
    }, 20);
  }

  // Debounce/guard in-flight jobs by name
  const _inflight = new Map();
  function guardOnce(name, fn){
    return async function guarded(...args){
      if (_inflight.get(name)) return; // drop duplicates
      _inflight.set(name, true);
      try { return await fn.apply(this, args); }
      finally { _inflight.delete(name); }
    };
  }

  const factories = new Map([
    ['hookDetailActions', (orig) => {
      const wrapped = rafThrottle(function(...args){
        scheduleIdle(() => orig.apply(this, args));
      });
      return guardOnce('hookDetailActions', wrapped);
    }],
    ['ensureMapForVenue', (orig) => {
      let token = 0;
      return guardOnce('ensureMapForVenue', function(...args){
        const myToken = ++token;
        // Defer heavy create to idle; newest call wins.
        scheduleIdle(async () => {
          if (myToken !== token) return;
          try { await orig.apply(this, args); } catch(e) { /* swallow */ }
        }, 300);
      });
    }]
  ]);

  function applyWrapper(name){
    const factory = factories.get(name);
    if (!factory) return;
    whenDefined(name, (orig) => {
      if (typeof orig !== 'function' || orig.__inputWrapped) return;
      const wrapped = factory(orig);
      if (typeof wrapped === 'function'){
        wrapped.__inputWrapped = true;
        window[name] = wrapped;
      }
    });
  }

  ['hookDetailActions','ensureMapForVenue'].forEach(applyWrapper);

  window.__wrapForInputYield = function(name){
    applyWrapper(name);
  };
})();
</script>
</body>
</html>
