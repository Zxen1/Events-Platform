// === Centralized API Request Manager (Deduplication) ===
const apiRequestInFlight = new Map();

/**
 * Make a deduplicated API request - prevents multiple simultaneous calls to the same endpoint
 * Each caller gets a fresh clone of the response so the body can be read independently
 * @param {string} url - The API endpoint URL
 * @param {Object} options - Fetch options (method, body, headers, etc.)
 * @param {number} cacheTime - Unused (kept for compatibility, caching removed to prevent body consumption issues)
 * @returns {Promise} The fetch response (cloned for each caller)
 */
async function apiRequest(url, options = {}, cacheTime = 0) {
  const cacheKey = `${options.method || 'GET'}:${url}:${options.body ? JSON.stringify(options.body) : ''}`;
  
  // Check if request is already in flight - return a cloned response
  if (apiRequestInFlight.has(cacheKey)) {
    const inFlightPromise = apiRequestInFlight.get(cacheKey);
    // Clone the response so each caller can read the body independently
    return inFlightPromise.then(response => response.clone());
  }
  
  // Create the request promise
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout
  
  const requestPromise = fetch(url, {
    ...options,
    signal: controller.signal
  })
    .then(response => {
      clearTimeout(timeoutId);
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      // Return original response (will be cloned for each caller)
      return response;
    })
    .catch(error => {
      clearTimeout(timeoutId);
      throw error;
    })
    .finally(() => {
      // Remove from in-flight after a delay to allow clones
      setTimeout(() => {
        apiRequestInFlight.delete(cacheKey);
      }, 1000);
    });
  
  // Store in-flight request
  apiRequestInFlight.set(cacheKey, requestPromise);
  
  // Return a clone so the original can be cloned again for other callers
  return requestPromise.then(response => response.clone());
}

// Expose globally for other scripts
window.apiRequest = apiRequest;

// === Currency Helpers ===
// Parse option_value format "countryCode currencyCode" (e.g., "us USD")
function parseCurrencyValue(optionValue) {
  if (!optionValue || typeof optionValue !== 'string') return { countryCode: null, currencyCode: optionValue || '' };
  const parts = optionValue.trim().split(' ');
  if (parts.length >= 2) {
    return { countryCode: parts[0].toLowerCase(), currencyCode: parts.slice(1).join(' ') };
  }
  return { countryCode: null, currencyCode: optionValue };
}

// Get flag HTML element (no margin - added via CSS where needed)
function getFlagHTML(countryCode) {
  if (!countryCode) return '';
  return `<span class="dropdown-flag"><img src="assets/flags/${countryCode}.svg" alt="" /></span>`;
}

// Get display HTML for currency dropdown option with flag icon
// opt = { value: "us USD", label: "US Dollar" }
function getCurrencyDisplayText(opt) {
  if (!opt) return '';
  const { countryCode, currencyCode } = parseCurrencyValue(opt.value);
  const label = opt.label || '';
  const flagHTML = countryCode ? getFlagHTML(countryCode) : '';
  return `${flagHTML}<span class="dropdown-text">${currencyCode} - ${label}</span>`;
}

// Get all currency options with parsed values
function getCurrencyOptions() {
  if (Array.isArray(window.currencyData) && window.currencyData.length > 0) {
    return window.currencyData;
  }
  return [];
}

// Get button HTML for currency (flag + code only, for the dropdown button)
function getCurrencyButtonHTML(countryCode, currencyCode) {
  const flagHTML = countryCode ? getFlagHTML(countryCode) : '';
  return `${flagHTML}<span class="dropdown-text">${currencyCode}</span>`;
}

// Find country code for a currency code (for initial button display)
function findCurrencyCountryCode(currencyCode) {
  const options = getCurrencyOptions();
  for (let i = 0; i < options.length; i++) {
    const { countryCode, currencyCode: code } = parseCurrencyValue(options[i].value);
    if (code === currencyCode) return countryCode;
  }
  return null;
}

// Find full option object for a currency code
function findCurrencyOption(currencyCode) {
  const options = getCurrencyOptions();
  for (let i = 0; i < options.length; i++) {
    const { currencyCode: code } = parseCurrencyValue(options[i].value);
    if (code === currencyCode) return options[i];
  }
  return null;
}

// === Phone Prefix Helpers ===
// Parse option_value format "countryCode prefix" (e.g., "us +1")
function parsePhonePrefixValue(optionValue) {
  if (!optionValue || typeof optionValue !== 'string') return { countryCode: null, prefix: optionValue || '' };
  const parts = optionValue.trim().split(' ');
  if (parts.length >= 2) {
    return { countryCode: parts[0].toLowerCase(), prefix: parts.slice(1).join(' ') };
  }
  return { countryCode: null, prefix: optionValue };
}

// Get display HTML for phone prefix dropdown option with flag icon
// opt = { value: "us +1", label: "United States" }
function getPhonePrefixDisplayText(opt) {
  if (!opt) return '';
  const { countryCode, prefix } = parsePhonePrefixValue(opt.value);
  const label = opt.label || '';
  const flagHTML = countryCode ? getFlagHTML(countryCode) : '';
  return `${flagHTML}<span class="dropdown-text">${prefix} - ${label}</span>`;
}

// Get all phone prefix options
function getPhonePrefixOptions() {
  if (Array.isArray(window.phonePrefixData) && window.phonePrefixData.length > 0) {
    return window.phonePrefixData;
  }
  return [];
}

// Get button HTML for phone prefix (flag + prefix only, for the dropdown button)
function getPhonePrefixButtonHTML(countryCode, prefix) {
  const flagHTML = countryCode ? getFlagHTML(countryCode) : '';
  return `${flagHTML}<span class="dropdown-text">${prefix}</span>`;
}

// === Dropdown Keyboard Navigation ===
// Allows typing letters to jump to matching options by label (country name)
// Does not trigger virtual keyboard on touch devices
function setupDropdownKeyboardNav(menuElement, closeMenuCallback) {
  let searchString = '';
  let searchTimeout = null;
  
  const keydownHandler = (e) => {
    // Only handle letter keys (from physical keyboard, not IME)
    if (e.key.length === 1 && /^[a-zA-Z]$/.test(e.key) && !e.isComposing) {
      e.preventDefault();
      
      // Clear previous timeout and append to search string
      if (searchTimeout) clearTimeout(searchTimeout);
      searchString += e.key.toUpperCase();
      
      // Find matching option by label (country/currency name)
      const options = menuElement.querySelectorAll('.menu-option[data-label]');
      for (const opt of options) {
        const label = (opt.dataset.label || '').toUpperCase();
        if (label && label.startsWith(searchString)) {
          opt.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
          opt.focus();
          break;
        }
      }
      
      // Reset search string after 800ms of no typing
      searchTimeout = setTimeout(() => {
        searchString = '';
      }, 800);
    }
    // Escape closes the menu
    else if (e.key === 'Escape') {
      e.preventDefault();
      if (typeof closeMenuCallback === 'function') {
        closeMenuCallback();
      }
      cleanup();
    }
    // Enter selects focused option
    else if (e.key === 'Enter') {
      const focused = menuElement.querySelector('.menu-option:focus');
      if (focused) {
        e.preventDefault();
        focused.click();
      }
    }
    // Arrow keys for navigation
    else if (e.key === 'ArrowDown' || e.key === 'ArrowUp') {
      e.preventDefault();
      const options = Array.from(menuElement.querySelectorAll('.menu-option[data-label]'));
      if (options.length === 0) return;
      
      const focused = menuElement.querySelector('.menu-option:focus');
      let currentIndex = focused ? options.indexOf(focused) : -1;
      
      if (e.key === 'ArrowDown') {
        currentIndex = currentIndex < options.length - 1 ? currentIndex + 1 : 0;
      } else {
        currentIndex = currentIndex > 0 ? currentIndex - 1 : options.length - 1;
      }
      
      options[currentIndex].scrollIntoView({ block: 'nearest', behavior: 'smooth' });
      options[currentIndex].focus();
    }
  };
  
  const cleanup = () => {
    document.removeEventListener('keydown', keydownHandler);
    if (searchTimeout) clearTimeout(searchTimeout);
    searchString = '';
  };
  
  document.addEventListener('keydown', keydownHandler);
  
  return cleanup;
}

// Alias for backwards compatibility
function setupCurrencyMenuKeyboardNav(menuElement, closeMenuCallback) {
  return setupDropdownKeyboardNav(menuElement, closeMenuCallback);
}

// === Shared login verifier ===
async function verifyUserLogin(username, password) {
  try {
    const res = await fetch('/gateway.php?action=verify-login', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ username, password })
    });

    const text = await res.text();

    let data;
    try {
      data = JSON.parse(text);
    } catch {
      console.error('verifyUserLogin failed: invalid JSON response', text);
      return { success: false };
    }

    if(!data || typeof data !== 'object'){
      return { success: false };
    }

    return data;
  } catch (e) {
    console.error('verifyUserLogin failed', e);
    return { success: false };
  }
}

function normalizeCategorySortOrderValue(raw) {
  if (typeof raw === 'number' && Number.isFinite(raw)) {
    return raw;
  }
  if (typeof raw === 'string') {
    const trimmed = raw.trim();
    if (trimmed !== '') {
      const parsed = Number(trimmed);
      if (Number.isFinite(parsed)) {
        return parsed;
      }
    }
  }
  return null;
}

function getBaseFieldset(fieldset){
  if(typeof fieldset !== 'string' || !fieldset.trim()){
    return '';
  }
  // Extract base type from formats like "description [field=2]" or "text-area [field=15]"
  const match = fieldset.match(/^([^\s\[]+)/);
  return match ? match[1].trim() : fieldset.trim();
}

function compareCategoriesForDisplay(a, b) {
  if (a === b) {
    return 0;
  }
  if (!a || typeof a !== 'object') {
    return !b || typeof b !== 'object' ? 0 : 1;
  }
  if (!b || typeof b !== 'object') {
    return -1;
  }
  const orderA = normalizeCategorySortOrderValue(a.sort_order ?? a.sortOrder);
  const orderB = normalizeCategorySortOrderValue(b.sort_order ?? b.sortOrder);
  if (orderA !== null && orderB !== null && orderA !== orderB) {
    return orderA - orderB;
  }
  if (orderA !== null && orderB === null) {
    return -1;
  }
  if (orderA === null && orderB !== null) {
    return 1;
  }
  const nameA = typeof a.name === 'string' ? a.name : '';
  const nameB = typeof b.name === 'string' ? b.name : '';
  const nameCompare = nameA.localeCompare(nameB, undefined, { sensitivity: 'accent', numeric: true });
  if (nameCompare !== 0) {
    return nameCompare;
  }
  return 0;
}

function getSortedCategoryEntries(list) {
  if (!Array.isArray(list)) {
    return [];
  }
  return list.map((category, index) => ({ category, index }))
    .sort((a, b) => {
      const cmp = compareCategoriesForDisplay(a.category, b.category);
      if (cmp !== 0) {
        return cmp;
      }
      return a.index - b.index;
    });
}

function getSortedCategories(list) {
  return getSortedCategoryEntries(list).map(entry => entry.category);
}

// === Checkout Options Rendering ===
function closeAllCheckoutEditPanels(exceptPanel){
  document.querySelectorAll('.checkout-options-edit-panel').forEach(function(panel){
    if(panel !== exceptPanel){
      panel.hidden = true;
      const card = panel.closest('.checkout-option-card');
      if(card) card.classList.remove('edit-open');
      const btn = card && card.querySelector('.checkout-options-edit-btn');
      if(btn) btn.setAttribute('aria-expanded', 'false');
    }
  });
}

function renderCheckoutOptions(checkoutOptions, siteCurrency){
  const container = document.getElementById('checkoutOptionsTiers');
  if(!container) return;
  
  container.innerHTML = '';
  
  if(!checkoutOptions || !checkoutOptions.length){
    container.innerHTML = '<div class="checkout-option-empty">No checkout options configured.</div>';
    return;
  }
  
  checkoutOptions.forEach(function(option){
    const tierCard = document.createElement('div');
    tierCard.className = 'checkout-option-card' + (option.is_active ? '' : ' inactive');
    tierCard.dataset.id = option.id;
    
    const flagfallPrice = option.checkout_flagfall_price !== undefined ? option.checkout_flagfall_price : 0;
    const priceDisplay = flagfallPrice === 0 ? 'Free' : (siteCurrency + ' ' + flagfallPrice.toFixed(2));
    const basicDayRate = option.checkout_basic_day_rate !== undefined && option.checkout_basic_day_rate !== null ? parseFloat(option.checkout_basic_day_rate).toFixed(2) : '';
    const discountDayRate = option.checkout_discount_day_rate !== undefined && option.checkout_discount_day_rate !== null ? parseFloat(option.checkout_discount_day_rate).toFixed(2) : '';
    const isFeatured = option.checkout_featured === 1 || option.checkout_featured === true;
    const featuredBadgeText = isFeatured ? 'featured' : 'standard';
    
    tierCard.innerHTML = `
      <div class="checkout-option-header">
        <span class="checkout-option-title-display">${escapeHtml(option.checkout_title) || 'Untitled'}</span>
        <span class="checkout-option-tier-badge ${featuredBadgeText}">${featuredBadgeText}</span>
        <button type="button" class="checkout-options-edit-btn" aria-haspopup="true" aria-expanded="false" title="Edit">
          <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor" aria-hidden="true"><path d="M12.854 1.146a.5.5 0 0 1 .707 0l1.293 1.293a.5.5 0 0 1 0 .707l-8.939 8.939a.5.5 0 0 1-.233.131l-3.5.875a.5.5 0 0 1-.606-.606l.875-3.5a.5.5 0 0 1 .131-.233l8.939-8.939z"/></svg>
        </button>
      </div>
      <div class="checkout-options-edit-panel" hidden>
        <div class="checkout-option-field">
          <label>Title</label>
          <input type="text" class="checkout-option-title" value="${escapeHtml(option.checkout_title)}" placeholder="Title" />
        </div>
        <label class="checkout-option-active">
          <input type="checkbox" ${option.is_active ? 'checked' : ''} />
          <span>Active</span>
        </label>
        <div class="checkout-option-field">
          <label>Description</label>
          <textarea class="checkout-option-description" placeholder="Description">${escapeHtml(option.checkout_description || '')}</textarea>
        </div>
        <div class="checkout-option-field sidebar-field" style="display: flex; gap: 20px;">
          <label>
            <input type="checkbox" class="checkout-option-featured" ${isFeatured ? 'checked' : ''} />
            Featured
          </label>
          <label>
            <input type="checkbox" class="checkout-option-sidebar" ${option.checkout_sidebar_ad ? 'checked' : ''} />
            Sidebar Ad
          </label>
        </div>
        <div class="checkout-option-field">
          <label>Flagfall Price</label>
          <input type="number" class="checkout-option-price" value="${flagfallPrice.toFixed(2)}" step="0.01" min="0" />
        </div>
        <div class="checkout-option-field">
          <label>Basic Day Rate</label>
          <input type="number" class="checkout-option-basic-day-rate" value="${basicDayRate}" step="0.01" min="0" placeholder="N/A" />
        </div>
        <div class="checkout-option-field">
          <label>Discount Day Rate</label>
          <input type="number" class="checkout-option-discount-day-rate" value="${discountDayRate}" step="0.01" min="0" placeholder="N/A" />
        </div>
        <div class="checkout-option-calculator">
          <div class="checkout-option-field">
            <label>Price Calculator (Sandbox)</label>
            <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
              <input type="number" class="checkout-option-calc-days" value="" placeholder="Days" min="1" step="1" style="width: 100px;" />
              <span style="font-weight: 600;">=</span>
              <span class="checkout-option-calc-total" style="min-width: 120px;">${siteCurrency} 0.00</span>
            </div>
          </div>
        </div>
        <button type="button" class="checkout-option-delete button--delete">Delete</button>
      </div>
    `;
    
    // Edit button handler
    const editBtn = tierCard.querySelector('.checkout-options-edit-btn');
    const editPanel = tierCard.querySelector('.checkout-options-edit-panel');
    editBtn.addEventListener('click', function(){
      const isOpen = !editPanel.hidden;
      closeAllCheckoutEditPanels(editPanel);
      editPanel.hidden = isOpen;
      tierCard.classList.toggle('edit-open', !isOpen);
      editBtn.setAttribute('aria-expanded', isOpen ? 'false' : 'true');
    });
    
    // Title input updates display
    const titleInput = tierCard.querySelector('.checkout-option-title');
    const titleDisplay = tierCard.querySelector('.checkout-option-title-display');
    if(titleInput && titleDisplay){
      titleInput.addEventListener('input', function(){
        titleDisplay.textContent = titleInput.value.trim() || 'Untitled';
      });
    }
    
    // Featured checkbox updates badge (form's event delegation handles dirty state)
    const featuredCheckbox = tierCard.querySelector('.checkout-option-featured');
    const tierBadge = tierCard.querySelector('.checkout-option-tier-badge');
    featuredCheckbox.addEventListener('change', function(){
      const isFeatured = featuredCheckbox.checked;
      tierBadge.className = 'checkout-option-tier-badge ' + (isFeatured ? 'featured' : 'standard');
      tierBadge.textContent = isFeatured ? 'featured' : 'standard';
      // No need to manually mark dirty - form's event delegation handles it
    });
    
    // Price calculator logic
    const calcDaysInput = tierCard.querySelector('.checkout-option-calc-days');
    const calcTotalSpan = tierCard.querySelector('.checkout-option-calc-total');
    const priceInput = tierCard.querySelector('.checkout-option-price');
    const basicDayRateInput = tierCard.querySelector('.checkout-option-basic-day-rate');
    const discountDayRateInput = tierCard.querySelector('.checkout-option-discount-day-rate');
    
    function updateCalculator(){
      if(!calcDaysInput || !calcTotalSpan) return;
      
      const days = parseFloat(calcDaysInput.value) || 0;
      if(days <= 0){
        calcTotalSpan.textContent = siteCurrency + ' 0.00';
        return;
      }
      
      const flagfall = parseFloat(priceInput.value) || 0;
      let dayRate = null;
      
      if(days >= 365){
        // Use discount day rate for 365+ days
        const discountRateValue = discountDayRateInput.value.trim();
        dayRate = discountRateValue !== '' ? parseFloat(discountRateValue) : null;
      } else {
        // Use basic day rate for less than 365 days
        const basicRateValue = basicDayRateInput.value.trim();
        dayRate = basicRateValue !== '' ? parseFloat(basicRateValue) : null;
      }
      
      if(dayRate === null || isNaN(dayRate)){
        calcTotalSpan.textContent = siteCurrency + ' ' + flagfall.toFixed(2);
        return;
      }
      
      const total = flagfall + (dayRate * days);
      calcTotalSpan.textContent = siteCurrency + ' ' + total.toFixed(2);
    }
    
    // Update calculator when days input changes
    if(calcDaysInput){
      calcDaysInput.addEventListener('input', updateCalculator);
      calcDaysInput.addEventListener('change', updateCalculator);
    }
    
    // Update calculator when pricing fields change
    if(priceInput){
      priceInput.addEventListener('input', updateCalculator);
      priceInput.addEventListener('change', updateCalculator);
    }
    if(basicDayRateInput){
      basicDayRateInput.addEventListener('input', updateCalculator);
      basicDayRateInput.addEventListener('change', updateCalculator);
    }
    if(discountDayRateInput){
      discountDayRateInput.addEventListener('input', updateCalculator);
      discountDayRateInput.addEventListener('change', updateCalculator);
    }
    
    // No manual event listeners needed - form's event delegation handles all inputs automatically
    // Checkout option inputs are inside the form, so they're caught by form's 'input' and 'change' listeners
    
    // Delete button handler
    tierCard.querySelector('.checkout-option-delete').addEventListener('click', async function(){
      const optionTitle = tierCard.querySelector('.checkout-option-title').value || 'this checkout option';
      const confirmed = await window.showConfirmDialog({
        titleText: 'Delete Checkout Option',
        messageText: `Delete "${optionTitle}"?`,
        confirmLabel: 'Delete',
        focusCancel: true
      });
      if(confirmed){
        tierCard.remove();
        if(window.adminPanelModule && typeof window.adminPanelModule.markDirty === 'function'){
          window.adminPanelModule.markDirty();
        }
      }
    });
    
    container.appendChild(tierCard);
  });
  
  // Add tier button handler
  const addBtn = document.querySelector('.add-checkout-option');
  if(addBtn && !addBtn.dataset.initialized){
    addBtn.dataset.initialized = 'true';
    addBtn.addEventListener('click', function(){
      const newOption = {
        id: 'new-' + Date.now(),
        checkout_key: '',
        checkout_title: 'New Tier',
        checkout_description: '',
      checkout_flagfall_price: 0,
      checkout_basic_day_rate: null,
      checkout_discount_day_rate: null,
        checkout_currency: siteCurrency,
      checkout_featured: 0,
        checkout_sidebar_ad: false,
        is_active: true
      };
      renderCheckoutOptions([...getCheckoutOptionsFromUI(), newOption], siteCurrency);
      if(window.adminPanelModule && typeof window.adminPanelModule.markDirty === 'function'){
        window.adminPanelModule.markDirty();
      }
    });
  }
}

function getCheckoutOptionsFromUI(){
  const container = document.getElementById('checkoutOptionsTiers');
  if(!container) return [];
  
  const options = [];
  container.querySelectorAll('.checkout-option-card').forEach(function(card){
    const basicDayRateInput = card.querySelector('.checkout-option-basic-day-rate');
    const discountDayRateInput = card.querySelector('.checkout-option-discount-day-rate');
    const priceInput = card.querySelector('.checkout-option-price');
    
    // Parse and round to 2 decimal places for money values
    const flagfallPrice = priceInput ? Math.round((parseFloat(priceInput.value) || 0) * 100) / 100 : 0;
    const basicDayRate = basicDayRateInput && basicDayRateInput.value.trim() !== '' ? Math.round(parseFloat(basicDayRateInput.value) * 100) / 100 : null;
    const discountDayRate = discountDayRateInput && discountDayRateInput.value.trim() !== '' ? Math.round(parseFloat(discountDayRateInput.value) * 100) / 100 : null;
    
    const titleInput = card.querySelector('.checkout-option-title');
    const descriptionInput = card.querySelector('.checkout-option-description');
    const featuredCheckbox = card.querySelector('.checkout-option-featured');
    const sidebarCheckbox = card.querySelector('.checkout-option-sidebar');
    const activeCheckbox = card.querySelector('.checkout-option-active input');
    
    if(!titleInput){
      console.warn('Checkout option title input not found for card:', card);
      return; // Skip this card if title input is missing
    }
    
    options.push({
      id: card.dataset.id,
      checkout_title: (titleInput.value || '').trim(),
      checkout_description: descriptionInput ? (descriptionInput.value || '').trim() : '',
      checkout_flagfall_price: flagfallPrice,
      checkout_basic_day_rate: basicDayRate,
      checkout_discount_day_rate: discountDayRate,
      checkout_featured: featuredCheckbox && featuredCheckbox.checked ? 1 : 0,
      checkout_sidebar_ad: sidebarCheckbox && sidebarCheckbox.checked ? 1 : 0,
      is_active: activeCheckbox && activeCheckbox.checked ? 1 : 0
    });
  });
  return options;
}

function escapeHtml(str){
  if(!str) return '';
  return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
}

// === Message Utility Functions ===
// In-memory cache for messages to avoid repeated network requests
const messagesCache = {
  user: null,      // Cached user messages (msg_user, msg_member)
  admin: null,     // Cached admin messages (includes all)
  lastFetch: 0,    // Timestamp of last fetch
  maxAge: 60000    // Cache valid for 60 seconds
};

/**
 * Invalidate message cache (call after admin saves messages)
 */
function invalidateMessagesCache(){
  messagesCache.user = null;
  messagesCache.admin = null;
  messagesCache.lastFetch = 0;
}
window.invalidateMessagesCache = invalidateMessagesCache;

/**
 * Load messages from database with in-memory caching
 * @param {boolean} includeAdmin - If true, includes admin and email messages (for admin panel)
 * @returns {Promise<Object>} Object mapping message_key to message data
 */
async function loadMessagesFromDatabase(includeAdmin = false){
  try {
    const cacheKey = includeAdmin ? 'admin' : 'user';
    const now = Date.now();
    
    // Return cached messages if still valid
    if(messagesCache[cacheKey] && (now - messagesCache.lastFetch) < messagesCache.maxAge){
      return messagesCache[cacheKey];
    }
    
    // Use deduplicated API request (5 second cache to prevent rapid duplicate calls)
    const response = await apiRequest('/gateway.php?action=get-admin-settings&include_messages=true', {}, 5000);
    
    if(!response.ok){
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    const result = await response.json();
    
    if(!result.success || !result.messages){
      console.warn('Failed to load messages from database:', result.message || result.messages_error);
      return {};
    }
    
    // Flatten messages by message_key for easy lookup
    const messagesMap = {};
    result.messages.forEach(container => {
      if(!container.messages || !Array.isArray(container.messages)) return;
      
      container.messages.forEach(message => {
        // Filter visibility: users see only msg_user and msg_member, exclude msg_email
        // Admin sees everything when includeAdmin is true
        if(!includeAdmin){
          const visibleContainers = ['msg_user', 'msg_member'];
          if(!visibleContainers.includes(message.container_key || container.container_key)){
            return; // Skip admin and email messages for regular users
          }
          // Also check is_visible flag
          if(message.is_visible === false || message.is_visible === 0){
            return; // Skip hidden messages
          }
        }
        
        // Only include active messages
        if(message.is_active !== false && message.is_active !== 0){
          messagesMap[message.message_key] = message;
        }
      });
    });
    
    // Cache the result
    messagesCache[cacheKey] = messagesMap;
    messagesCache.lastFetch = now;
    
    return messagesMap;
  } catch(error){
    if(error.name === 'AbortError'){
      console.error('Message loading timed out after 10 seconds');
    } else {
      console.error('Error loading messages from database:', error);
    }
    // Return empty object on error - UI will use fallback text
    return {};
  }
}

/**
 * Replace placeholders in message text (e.g., {name} -> actual value)
 * @param {string} text - Message text with placeholders
 * @param {Object} placeholders - Object with placeholder values
 * @returns {string} Message with placeholders replaced
 */
function replacePlaceholders(text, placeholders = {}){
  if(!text || typeof text !== 'string'){
    return text || '';
  }
  
  return text.replace(/\{(\w+)\}/g, (match, key) => {
    return placeholders[key] !== undefined ? String(placeholders[key]) : match;
  });
}

/**
 * Get a message by key from the database
 * @param {string} messageKey - The message_key to look up
 * @param {Object} placeholders - Object with placeholder values to replace
 * @param {boolean} includeAdmin - If true, includes admin/email messages (for admin panel)
 * @returns {Promise<string>} The message text with placeholders replaced, or empty string if not found
 */
async function getMessage(messageKey, placeholders = {}, includeAdmin = false){
  if(!messageKey || typeof messageKey !== 'string'){
    return '';
  }
  
  const messages = await loadMessagesFromDatabase(includeAdmin);
  const message = messages[messageKey];
  
  if(!message){
    console.warn(`Message not found: ${messageKey}`);
    return '';
  }
  
  return replacePlaceholders(message.message_text || '', placeholders);
}

/**
 * Get a message synchronously - NO CACHING, returns empty string for sync calls
 * Use getMessage() async function instead for proper message loading
 * @param {string} messageKey - The message_key to look up
 * @param {Object} placeholders - Object with placeholder values to replace
 * @param {boolean} includeAdmin - If true, looks in admin messages
 * @returns {string} Empty string - use async getMessage() instead
 */
function getMessageSync(messageKey, placeholders = {}, includeAdmin = false){
  // NO CACHING - sync version deprecated, use async getMessage() instead
  console.warn(`getMessageSync called for: ${messageKey}. Use async getMessage() instead.`);
  return '';
}

/**
 * Update all elements with data-message-key attributes when messages load
 * This handles both initial elements and dynamically created ones
 * @param {boolean} includeAdmin - If true, includes admin messages
 */
async function updateAllMessageElements(includeAdmin = false){
  try {
    // Wait for messages to be loaded
    const messages = await loadMessagesFromDatabase(includeAdmin);
    
    // Find all elements with data-message-key attribute (including dynamically created ones)
    const allElements = document.querySelectorAll('[data-message-key]');
    
    for(const el of allElements){
      // CRITICAL: SKIP message items in the messages tab - they're already properly formatted
      // These have complex HTML structure with labels, edit panels, input transforms, etc.
      // If we update these with textContent, we'll destroy the entire messages tab UI
      // DO NOT REMOVE THIS CHECK - it prevents breaking the messages tab
      if(el.closest('.messages-list') || el.closest('.message-item')){
        continue;
      }
      
      const messageKey = el.dataset.messageKey;
      if(!messageKey) continue;
      
      const message = messages[messageKey];
      if(message && message.message_text){
        const text = replacePlaceholders(message.message_text, {});
        if(text){
          el.textContent = text;
        }
      }
    }
  } catch(error){
    console.error('Error updating message elements:', error);
  }
}

/**
 * Set up a MutationObserver to automatically update message elements when they're added to DOM
 */
function setupMessageObserver(){
  if(window.messageObserver) return; // Already set up
  
  window.messageObserver = new MutationObserver((mutations) => {
    // Check if any new elements with data-message-key were added
    let shouldUpdate = false;
    for(const mutation of mutations){
      for(const node of mutation.addedNodes){
        if(node.nodeType === Node.ELEMENT_NODE){
          if(node.hasAttribute && node.hasAttribute('data-message-key')){
            shouldUpdate = true;
            break;
          }
          // Also check children
          if(node.querySelectorAll && node.querySelectorAll('[data-message-key]').length > 0){
            shouldUpdate = true;
            break;
          }
        }
      }
      if(shouldUpdate) break;
    }
    
    // Update messages if new elements were added
    if(shouldUpdate){
      // Debounce to avoid too many updates
      if(window.messageUpdateTimeout){
        clearTimeout(window.messageUpdateTimeout);
      }
      window.messageUpdateTimeout = setTimeout(() => {
        updateAllMessageElements(true).catch(err => {
          console.warn('Failed to update message elements:', err);
        });
      }, 100);
    }
  });
  
  // Observe the entire document for new elements
  window.messageObserver.observe(document.body, {
    childList: true,
    subtree: true
  });
}

// Make message functions globally available
window.getMessage = getMessage;
window.getMessageSync = getMessageSync;
window.loadMessagesFromDatabase = loadMessagesFromDatabase;
window.replacePlaceholders = replacePlaceholders;
window.updateAllMessageElements = updateAllMessageElements;

function handlePromptKeydown(event, context){
  if(!context || !context.prompt || typeof context.cancelPrompt !== 'function'){
    return;
  }
  const { prompt, cancelButton, cancelPrompt } = context;
  if(event.key !== 'Enter' || event.defaultPrevented){
    return;
  }
  if(!prompt.contains(event.target)){
    return;
  }
  const active = document.activeElement;
  const activeInPrompt = !!(active && prompt.contains(active));
  const isCancelFocused = activeInPrompt && cancelButton && active === cancelButton;
  const nothingFocusable = !activeInPrompt || active === prompt || active === document.body;
  if(isCancelFocused || nothingFocusable){
    event.preventDefault();
    cancelPrompt();
  }
}

// Extracted from <script>
(function(){
      const LOADING_CLASS = 'is-loading';
      let pendingCount = 0;
      let logoImg = null;
      let updatePending = false;
      let stopRequested = false;
      let stopTimeoutId = null;

      function handleAnimationLoop(){
        if(stopRequested && pendingCount === 0){
          finalizeStop();
        }
      }

      function ensureLogo(){
        if(!logoImg){
          logoImg = document.querySelector('.button--header-logo-small img');
          if(logoImg && !logoImg.__logoAnimationBound){
            try{
              logoImg.addEventListener('animationiteration', handleAnimationLoop);
              logoImg.addEventListener('animationend', handleAnimationLoop);
            }catch(err){}
            logoImg.__logoAnimationBound = true;
          }
        }
        return logoImg;
      }

      function finalizeStop(){
        const img = ensureLogo();
        if(!img){
          return;
        }
        stopRequested = false;
        if(stopTimeoutId){
          clearTimeout(stopTimeoutId);
          stopTimeoutId = null;
        }
        if(img.classList && img.classList.contains(LOADING_CLASS)){
          img.classList.remove(LOADING_CLASS);
        } else if(!img.classList && img.style){
          img.style.animation = '';
        }
      }

      function requestStop(){
        const img = ensureLogo();
        if(!img){
          return;
        }
        if(pendingCount > 0){
          return;
        }
        let isAnimating = false;
        if(img.classList){
          isAnimating = img.classList.contains(LOADING_CLASS);
        } else if(img.style){
          isAnimating = typeof img.style.animation === 'string' && img.style.animation !== '';
        }
        if(!isAnimating){
          finalizeStop();
          return;
        }
        if(stopRequested){
          return;
        }
        stopRequested = true;
        if(stopTimeoutId){
          clearTimeout(stopTimeoutId);
        }
        stopTimeoutId = setTimeout(()=>{
          if(stopRequested && pendingCount === 0){
            finalizeStop();
          }
        }, 1200);
      }

      function applyState(){
        updatePending = false;
        const img = ensureLogo();
        if(!img){
          return;
        }
        if(pendingCount > 0){
          stopRequested = false;
          if(stopTimeoutId){
            clearTimeout(stopTimeoutId);
            stopTimeoutId = null;
          }
          if(img.classList && !img.classList.contains(LOADING_CLASS)){
            img.classList.add(LOADING_CLASS);
          } else if(!img.classList){
            img.style.animation = 'logo-rotate 1s linear infinite';
          }
        } else {
          requestStop();
        }
      }

      function scheduleUpdate(){
        if(updatePending){
          return;
        }
        updatePending = true;
        if(typeof requestAnimationFrame === 'function'){
          requestAnimationFrame(applyState);
        } else {
          setTimeout(applyState, 0);
        }
      }

      function begin(){
        pendingCount++;
        scheduleUpdate();
      }

      function end(){
        if(pendingCount > 0){
          pendingCount--;
        }
        scheduleUpdate();
      }

      if(document.readyState === 'complete' || document.readyState === 'interactive'){
        ensureLogo();
        scheduleUpdate();
      } else {
        document.addEventListener('DOMContentLoaded', () => {
          ensureLogo();
          scheduleUpdate();
        });
      }

      window.addEventListener('pageshow', () => {
        ensureLogo();
        scheduleUpdate();
      });

      const originalFetch = window.fetch;
      if(typeof originalFetch === 'function'){
        window.fetch = function(...args){
          begin();
          let finished = false;
          const finalize = () => {
            if(finished) return;
            finished = true;
            end();
          };
          try{
            const response = originalFetch.apply(this, args);
            Promise.resolve(response).then(finalize, finalize);
            return response;
          } catch(err){
            finalize();
            throw err;
          }
        };
      }

      if('XMLHttpRequest' in window && XMLHttpRequest.prototype){
        const originalSend = XMLHttpRequest.prototype.send;
        if(typeof originalSend === 'function'){
          XMLHttpRequest.prototype.send = function(...args){
            begin();
            let finalized = false;
            const finalize = () => {
              if(finalized) return;
              finalized = true;
              this.removeEventListener('loadend', finalize);
              end();
            };
            this.addEventListener('loadend', finalize);
            try{
              return originalSend.apply(this, args);
            } catch(err){
              finalize();
              throw err;
            }
          };
        }
      }

      const loaderApi = (()=>{
        const api = {
          begin(){ begin(); },
          end(){ end(); },
          track(promise){
            if(!promise || typeof promise.then !== 'function'){
              return promise;
            }
            let settled = false;
            begin();
            const finalize = () => {
              if(settled) return;
              settled = true;
              end();
            };
            Promise.resolve(promise).then(finalize, finalize);
            return promise;
          }
        };
        return api;
      })();

      const existingLoader = window.__logoLoading && typeof window.__logoLoading === 'object'
        ? window.__logoLoading
        : {};
      existingLoader.begin = loaderApi.begin;
      existingLoader.end = loaderApi.end;
      existingLoader.track = loaderApi.track;
      existingLoader.trackPromise = loaderApi.track;
      window.__logoLoading = existingLoader;
    })();

// Extracted from <script>
// --- tiny scheduler helpers ---
  function rafThrottle(fn){
    let scheduled = false, lastArgs, lastThis;
    return function throttled(...args){
      lastArgs = args; lastThis = this;
      if (scheduled) return;
      scheduled = true;
      requestAnimationFrame(() => { scheduled = false; fn.apply(lastThis, lastArgs); });
    };
  }

  // Prefer idle time, but don't stall forever.
  function scheduleIdle(fn, timeout=200){
    if ('requestIdleCallback' in window) {
      requestIdleCallback(fn, { timeout });
    } else {
      setTimeout(fn, Math.min(timeout, 50));
    }
  }

  function withPassiveDefault(options){
    if(options === undefined){
      return { passive: true };
    }
    if(typeof options === 'boolean'){
      return { capture: options, passive: true };
    }
    if(typeof options === 'object' && options !== null && options.passive === undefined){
      return Object.assign({}, options, { passive: true });
    }
    return options;
  }

  function addPassiveScrollListener(target, listener, options){
    if(!target || typeof target.addEventListener !== 'function') return null;
    const opts = withPassiveDefault(options);
    target.addEventListener('scroll', listener, opts);
    return opts;
  }

  function removeScrollListener(target, listener, options){
    if(!target || typeof target.removeEventListener !== 'function') return;
    let capture = false;
    if(typeof options === 'boolean'){
      capture = options;
    } else if(typeof options === 'object' && options !== null){
      capture = !!options.capture;
    }
    target.removeEventListener('scroll', listener, capture);
  }

// Extracted from <script>
(function(){
  const ASSET_VERSION = 'v=20240705';
  const assetPattern = /^(?:\.\/)?assets\//;

  function withVersion(url){
    if (!url || url.includes('?')) return url;
    if (!assetPattern.test(url)) return url;
    if (url.startsWith('./')) {
      return `./${url.slice(2)}?${ASSET_VERSION}`;
    }
    return `${url}?${ASSET_VERSION}`;
  }

  function toAbsoluteUrl(url){
    if (!url) return url;
    try {
      return new URL(url, window.location.href).href;
    } catch (err) {
      return url;
    }
  }

  function bustCacheAttributes(){
    const attrs = ['src', 'href'];
    attrs.forEach((attr) => {
      document.querySelectorAll(`[${attr}]`).forEach((node) => {
        const current = node.getAttribute(attr);
        const updated = withVersion(current);
        if (updated && updated !== current) {
          node.setAttribute(attr, updated);
        }
      });
    });

    document.querySelectorAll('[srcset]').forEach((node) => {
      const srcset = node.getAttribute('srcset');
      if (!srcset) return;
      const rewritten = srcset
        .split(',')
        .map((entry) => {
          const trimmed = entry.trim();
          if (!trimmed) return trimmed;
          const parts = trimmed.split(/\s+/, 2);
          const nextUrl = withVersion(parts[0]);
          if (!nextUrl || nextUrl === parts[0]) return trimmed;
          return parts[1] ? `${nextUrl} ${parts[1]}` : nextUrl;
        })
        .join(', ');
      if (rewritten !== srcset) {
        node.setAttribute('srcset', rewritten);
      }
    });
  }

  function updateManifest(){
    const link = document.querySelector('link[rel="manifest"]');
    if (!link) return;
    const manifest = {
      name: 'Events Platform',
      short_name: 'Events',
      icons: [
        {
          src: toAbsoluteUrl(withVersion('assets/favicons/android-chrome-192x192.png')),
          sizes: '192x192',
          type: 'image/png'
        },
        {
          src: toAbsoluteUrl(withVersion('assets/favicons/android-chrome-512x512.png')),
          sizes: '512x512',
          type: 'image/png'
        }
      ],
      theme_color: '#ffffff',
      background_color: '#ffffff',
      display: 'standalone'
    };
    const serialized = encodeURIComponent(JSON.stringify(manifest));
    link.setAttribute('href', `data:application/manifest+json;charset=utf-8,${serialized}`);
  }

  function hideGeocoderIconFromAT(){
    let applied = false;
    document.querySelectorAll('.mapboxgl-ctrl-geocoder--icon').forEach((icon) => {
      if (icon.getAttribute('aria-hidden') === 'true') return;
      icon.setAttribute('aria-hidden', 'true');
      icon.setAttribute('role', 'presentation');
      applied = true;
    });
    return applied;
  }

  function setupGeocoderObserver(){
    const observer = new MutationObserver(() => {
      if (hideGeocoderIconFromAT()) {
        /* noop */
      }
    });
    observer.observe(document.body, { childList: true, subtree: true });
    setTimeout(() => observer.disconnect(), 5000);
  }

  document.addEventListener('DOMContentLoaded', () => {
    bustCacheAttributes();
    updateManifest();
    hideGeocoderIconFromAT();
    setupGeocoderObserver();
    
    // Set up observer for dynamically created elements (do this immediately)
    setupMessageObserver();
    
    // Messages are now loaded on-demand when needed (when panels open or when getMessage() is called)
    // No longer loading on startup - welcome messages are in admin_settings
  });
})();

// Extracted from <script>
if (typeof slugify !== 'function') {
  function slugify(text) {
    return String(text)
      .normalize('NFD')
      .replace(/[\u0300-\u036f]/g, '')
      .toLowerCase()
      .trim()
      .replace(/[^a-z0-9]+/g, '-')
      .replace(/^-+|-+$/g, '');
  }
}

// Extracted from <script>

// Extracted from <script>
let __userInteractionObserved = false;
let __notifyMapOnInteraction = null;

// Remember where the user actually clicked/tapped
    document.addEventListener('pointerdown', (e) => {
      window.__lastPointerDown = e;
      __userInteractionObserved = true;
      if(typeof __notifyMapOnInteraction === 'function'){
        const fn = __notifyMapOnInteraction;
        __notifyMapOnInteraction = null;
        try{ fn(); }catch(err){ console.error(err); }
      }
    }, { capture: true });

    document.addEventListener('touchstart', () => {
      __userInteractionObserved = true;
      if(typeof __notifyMapOnInteraction === 'function'){
        const fn = __notifyMapOnInteraction;
        __notifyMapOnInteraction = null;
        try{ fn(); }catch(err){ console.error(err); }
      }
    }, { capture: true, passive: true });

    document.addEventListener('keydown', () => {
      __userInteractionObserved = true;
      if(typeof __notifyMapOnInteraction === 'function'){
        const fn = __notifyMapOnInteraction;
        __notifyMapOnInteraction = null;
        try{ fn(); }catch(err){ console.error(err); }
      }
    }, { capture: true });

// Extracted from <script>

  async function ensureMapboxCssFor(container) {
    const ver = (window.MAPBOX_VERSION || "v3.15.0").replace(/^v/,'v');
    const cssHref = `https://api.mapbox.com/mapbox-gl-js/${ver}/mapbox-gl.css`;

    const doc = (container && container.ownerDocument) || document;
    const root = container && container.getRootNode && container.getRootNode();

    // For Shadow DOM maps, inject right into the shadow root
    if (root && root.host && typeof ShadowRoot !== "undefined" && root instanceof ShadowRoot) {
      if (!root.querySelector('style[data-mapbox-gl]')) {
        const s = document.createElement('style');
        s.setAttribute('data-mapbox-gl','');
        s.textContent = `@import url('${cssHref}');`;
        root.prepend(s);
      }
      return;
    }

    // Normal document (or iframe document)
    let link = doc.getElementById('mapbox-gl-css');
    if (!link) {
      link = doc.createElement('link');
      link.id = 'mapbox-gl-css';
      link.rel = 'stylesheet';
      link.href = cssHref;
      doc.head.appendChild(link);
    }
    if (link.sheet) return;
    await new Promise(res => link.addEventListener('load', res, { once: true }));
  }

  (async () => {
    try {
      await ensureMapboxCssFor(document.body);
    } catch(e){}
  })();

  (function(){
    const q = [];
    let scheduled = false;
    function flush(){
      scheduled = false;
      const budget = 6;
      let start = performance.now();
      while(q.length){
        const fn = q.shift();
        try{ fn && fn(); }catch(err){ console.error(err); }
        if(performance.now() - start > budget){
          if(typeof requestAnimationFrame === 'function'){
            requestAnimationFrame(flush);
          } else {
            setTimeout(flush, 16);
          }
          return;
        }
      }
    }
    window.deferToAnimationFrame = function(cb){
      q.push(cb);
      if(!scheduled){
        scheduled = true;
        if(typeof requestAnimationFrame === 'function'){
          requestAnimationFrame(flush);
        } else {
          setTimeout(flush, 16);
        }
      }
    };
  })();

  // Helper: do nothing until style is truly loaded
  function whenStyleReady(map, fn){
    if (map.isStyleLoaded && map.isStyleLoaded()) { fn(); return; }
    const onLoad = () => { map.off('load', onLoad); fn(); };
    map.on('load', onLoad);
  }

  function applyNightSky(mapInstance){
    if(!mapInstance) return;
    if(typeof mapInstance.setFog === 'function'){
      try {
        mapInstance.setFog({
          color: 'rgba(11,13,23,0.6)',
          'high-color': 'rgba(27,32,53,0.7)',
          'horizon-blend': 0.15,
          'space-color': '#010409',
          'star-intensity': 0.6
        });
      } catch(err){}
    }
    if(typeof mapInstance.getLayer !== 'function'){
      return;
    }
    let skyLayerId = null;
    const skyPaint = {
      'sky-type': 'gradient',
      'sky-gradient-center': [0, 0],
      'sky-gradient-radius': 80,
      'sky-gradient': [
        'interpolate',
        ['linear'],
        ['sky-radial-progress'],
        0.0, 'rgba(6,10,20,1)',
        0.6, '#0b1d51',
        1.0, '#1a2a6c'
      ],
      'sky-opacity': 1
    };
    try {
      if(mapInstance.getLayer('sky')){
        skyLayerId = 'sky';
      } else if(mapInstance.getLayer('night-sky')){
        skyLayerId = 'night-sky';
      } else if(typeof mapInstance.addLayer === 'function'){
        mapInstance.addLayer({
          id:'night-sky',
          type:'sky',
          paint: skyPaint
        });
        skyLayerId = 'night-sky';
      }
    } catch(err){
      if(!skyLayerId && typeof mapInstance.getLayer === 'function' && mapInstance.getLayer('sky')){
        skyLayerId = 'sky';
      }
    }
    if(!skyLayerId || typeof mapInstance.setPaintProperty !== 'function'){
      return;
    }
    Object.entries(skyPaint).forEach(([prop, value]) => {
      try { mapInstance.setPaintProperty(skyLayerId, prop, value); } catch(err){}
    });
  }

  /**
   * Apply starting address - fly map to the configured starting location
   * Only called when user has no saved location from previous interaction
   * @param {Object} mapInstance - Mapbox map instance
   * @param {string} address - Address string (can be coordinates like "40.7128,-74.0060" or place name)
   */
  async function applyStartingAddress(mapInstance, address){
    if(!mapInstance || !address) return;
    
    const trimmed = address.trim();
    if(!trimmed) return;
    
    // Check if it looks like coordinates (lat,lng or lng,lat)
    const coordMatch = trimmed.match(/^(-?\d+\.?\d*)\s*,\s*(-?\d+\.?\d*)$/);
    if(coordMatch){
      const num1 = parseFloat(coordMatch[1]);
      const num2 = parseFloat(coordMatch[2]);
      
      // Determine if it's lat,lng or lng,lat based on value ranges
      // Latitude: -90 to 90, Longitude: -180 to 180
      let lng, lat;
      if(Math.abs(num1) <= 90 && Math.abs(num2) <= 180){
        // Assume lat,lng format (common user input)
        lat = num1;
        lng = num2;
      } else if(Math.abs(num2) <= 90 && Math.abs(num1) <= 180){
        // Assume lng,lat format (GeoJSON/Mapbox format)
        lng = num1;
        lat = num2;
      } else {
        console.warn('[Starting Address] Invalid coordinates:', trimmed);
        return;
      }
      
      try {
        const zoomLevel = window._startingZoom || 10;
        mapInstance.flyTo({
          center: [lng, lat],
          zoom: zoomLevel,
          duration: 2000
        });
      } catch(err){
        console.warn('[Starting Address] Failed to fly to coordinates:', err);
      }
      return;
    }
    
    // Not coordinates - geocode the address using Mapbox Geocoding API
    try {
      const accessToken = mapboxgl.accessToken;
      if(!accessToken){
        console.warn('[Starting Address] No Mapbox access token available');
        return;
      }
      
      const response = await fetch(
        `https://api.mapbox.com/geocoding/v5/mapbox.places/${encodeURIComponent(trimmed)}.json?access_token=${accessToken}&limit=1`
      );
      
      if(!response.ok){
        console.warn('[Starting Address] Geocoding request failed');
        return;
      }
      
      const data = await response.json();
      if(data.features && data.features.length > 0){
        const [lng, lat] = data.features[0].center;
        const zoomLevel = window._startingZoom || 10;
        mapInstance.flyTo({
          center: [lng, lat],
          zoom: zoomLevel,
          duration: 2000
        });
      } else {
        console.warn('[Starting Address] No results found for:', trimmed);
      }
    } catch(err){
      console.warn('[Starting Address] Geocoding failed:', err);
    }
  }

  function createTransparentPlaceholder(width, height){
    const canvas = document.createElement('canvas');
    const w = Math.max(1, Number.isFinite(width) ? width : (width || 2));
    const h = Math.max(1, Number.isFinite(height) ? height : (Number.isFinite(width) ? width : (width || 2)));
    canvas.width = w;
    canvas.height = h;
    const ctx = canvas.getContext('2d');
    if(ctx){
      ctx.clearRect(0, 0, w, h);
    }
    return canvas;
  }

  function ensurePlaceholderSprites(mapInstance){
    if(!mapInstance || typeof mapInstance.addImage !== 'function') return;
    const required = ['mx-federal-5','background','background-stroke','icon','icon-stroke'];
    const install = () => {
      required.forEach(name => {
        try{
          if(mapInstance.hasImage?.(name)) return;
          const size = name === 'mx-federal-5' ? 2 : 4;
          const options = { pixelRatio: 1 };
          if(name !== 'mx-federal-5'){
            options.sdf = true;
          }
          mapInstance.addImage(name, createTransparentPlaceholder(size), options);
        }catch(err){}
      });
    };
    if(typeof mapInstance.isStyleLoaded === 'function' && !mapInstance.isStyleLoaded()){
      if(!mapInstance.__placeholderSpriteReady){
        const onStyleLoad = () => {
          try{ install(); }catch(err){}
          try{ mapInstance.off?.('style.load', onStyleLoad); }catch(err){}
          mapInstance.__placeholderSpriteReady = null;
        };
        mapInstance.__placeholderSpriteReady = onStyleLoad;
        try{ mapInstance.on('style.load', onStyleLoad); }catch(err){}
      }
      return;
    }
    install();
  }

  const isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0) || (window.matchMedia && window.matchMedia('(pointer: coarse)').matches);

// ============================================================================
// MAP MARKERS & MAP CARDS SYSTEM
// ============================================================================
// All code related to map markers (icons), marker clustering, and map cards (pills) is organized here.
// Note: Markers are icons centered over lat/lng coordinates. Pills are map card backgrounds.
// Clusters are grouping icons used at low zoom levels.
// Sections:
// 1. Constants & Configuration (lines ~1005-1202)
// 2. Text Measurement & Formatting Helpers (lines ~1022-1183)
// 3. Map Card System (lines ~1387-1547) - Map card background images (pills)
// 5. Marker Clustering (lines ~2546-2912) - Cluster icons that group nearby markers
// 6. Small Map Card DOM Functions (lines ~3219-3447)
// 7. Marker Data Building & Collections (lines ~3448-6663)
// 8. Map Source Integration (lines ~19001+)
// ============================================================================

  const markerIconSize = 1;
  const markerIconBaseSizePx = 30;
  const basePillWidthPx = 150;
  const basePillHeightPx = 40;
  let accentPillWidthPx = null;
  let accentPillHeightPx = null;
  const markerLabelTextGapPx = 5;
  const markerLabelMarkerInsetPx = 5;
  const markerLabelTextRightPaddingPx = 5;
  const markerLabelTextPaddingPx = 10; // Fixed padding for labels (no icon reference)
  const markerLabelTextAreaWidthPx = Math.max(0, basePillWidthPx - markerLabelTextPaddingPx - markerLabelTextRightPaddingPx);
  const markerLabelTextAreaWidthPxSmall = 100; // For small map cards (non-multi-post venue)
  const markerLabelTextSize = 12;
  const markerLabelTextLineHeight = 1.2;
  const markerLabelPillLeftOffsetPx = -20; // Left edge of pill is 20px left of lat/lng
  const markerLabelTextLeftOffsetPx = 20; // Left edge of label is 20px right of lat/lng
  const markerLabelEllipsisChar = '\u2026';
  const mapCardTitleWidthPx = 165;
  let markerLabelMeasureContext = null;

  // --- Section 2: Text Measurement & Formatting Helpers ---
  // Moved to map.js - use window.MapCardComposites functions (graceful fallback if map.js fails)
  const mapComposites = window.MapCardComposites || {};
  const ensureMarkerLabelMeasureContext = mapComposites.ensureMarkerLabelMeasureContext || function(){};
  const markerLabelMeasureFont = mapComposites.markerLabelMeasureFont || '11px "Open Sans", sans-serif';
  const shortenMarkerLabelText = mapComposites.shortenMarkerLabelText || function(t){ return t; };
  const splitTextAcrossLines = mapComposites.splitTextAcrossLines || function(t){ return [t]; };
  const getPrimaryVenueName = mapComposites.getPrimaryVenueName || function(){ return ''; };
  const getMarkerLabelLines = mapComposites.getMarkerLabelLines || function(){ return { line1: '', line2: '', venueLine: '' }; };
  const buildMarkerLabelText = mapComposites.buildMarkerLabelText || function(){ return ''; };

  // Map card constants - now in map.js, access via window.MapCardComposites (graceful fallback)
  const MARKER_LABEL_BG_ID = mapComposites.MARKER_LABEL_BG_ID || 'small-map-card-pill';
  const MARKER_LABEL_BG_ACCENT_ID = mapComposites.MARKER_LABEL_BG_ACCENT_ID || 'big-map-card-pill';
  const VISIBLE_MARKER_LABEL_LAYERS = mapComposites.VISIBLE_MARKER_LABEL_LAYERS || [];
  // Mapbox GL JS enforces a hard limit on the number of images that can be
  // registered with a style (currently ~1000).
  const MARKER_SPRITE_RETAIN_ZOOM = 12;

  function nowTimestamp(){
    try{
      if(typeof performance !== 'undefined' && typeof performance.now === 'function'){
        return performance.now();
      }
    }catch(err){}
    return Date.now();
  }


  // --- Section 3: Map Card System ---
  // Pill sprite functions moved to map.js - use window.MapCardComposites functions (NO FALLBACKS)
  const loadMarkerLabelImage = window.MapCardComposites.loadMarkerLabelImage;
  const convertImageDataToCanvas = window.MapCardComposites.convertImageDataToCanvas;
  const buildMarkerLabelPillSprite = window.MapCardComposites.buildMarkerLabelPillSprite;
  const ensureMarkerLabelPillSprites = window.MapCardComposites.ensureMarkerLabelPillSprites;


  // --- Section 4: Composite Sprite System for Map Cards ---
  // Moved to map.js - all map card composite code is now in map.js

  // Moved to map.js - use window.MapCardComposites.generateMarkerImageFromId (NO FALLBACKS)
  const generateMarkerImageFromId = window.MapCardComposites.generateMarkerImageFromId;




  function patchLayerFiltersForMissingLayer(mapInstance, style){
    if(!mapInstance || typeof mapInstance.setFilter !== 'function') return;
    const layers = style && Array.isArray(style.layers) ? style.layers : [];
    if(!layers.length) return;

    const shouldSkipLayer = (layer) => {
      if(!layer) return true;
      const meta = layer.metadata || {};
      const featureComponent = layer['mapbox:featureComponent'] || meta['mapbox:featureComponent'];
      const featureSet = layer['mapbox:featureset'] || meta['mapbox:featureset'];
      if(featureSet) return true;
      if(typeof featureComponent === 'string' && featureComponent.includes('place-label')) return true;
      if(typeof layer.id === 'string' && layer.id.includes('place-label')) return true;
      if(typeof layer.source === 'string' && layer.source.includes('place-label')) return true;
      return false;
    };

    function patchExpression(expr){
      if(!Array.isArray(expr)){
        return { expr, changed:false };
      }
      const op = expr[0];
      let changed = false;
      const result = expr.map((item, idx) => {
        if(idx === 0) return item;
        const patched = patchExpression(item);
        if(patched.changed) changed = true;
        return patched.expr;
      });

      if((op === 'number' || op === 'to-number') && result.length > 1){
        const target = result[1];
        if(Array.isArray(target)){
          const already = target[0] === 'coalesce'
            && Array.isArray(target[1])
            && target[1][0] === 'get'
            && target[1][1] === 'layer';
          if(!already && target[0] === 'get' && target[1] === 'layer'){
            result[1] = ['coalesce', target, 0];
            changed = true;
          }
        }
      }

      return { expr: result, changed };
    }

    layers.forEach(layer => {
      if(!layer || !layer.id || !layer.filter) return;
      if(shouldSkipLayer(layer)) return;
      try{
        const patched = patchExpression(layer.filter);
        if(!patched.changed) return;
        mapInstance.setFilter(layer.id, patched.expr);
      }catch(err){}
    });
  }

  function patchTerrainSource(mapInstance, style){
    if(!mapInstance || typeof mapInstance.setTerrain !== 'function') return;
    const terrain = style && style.terrain;
    if(!terrain || !terrain.source) return;
    const sources = style.sources || {};
    const originalSource = sources[terrain.source];
    if(!originalSource) return;

    const dedicatedId = 'terrain-dem-dedicated';
    const ensureDedicatedSource = () => {
      if(mapInstance.getSource?.(dedicatedId)) return true;
      try {
        const clone = JSON.parse(JSON.stringify(originalSource));
        mapInstance.addSource(dedicatedId, clone);
        return !!mapInstance.getSource?.(dedicatedId);
      } catch(err){}
      return false;
    };

    const currentTerrain = typeof mapInstance.getTerrain === 'function' ? mapInstance.getTerrain() : null;
    if(currentTerrain && currentTerrain.source === dedicatedId && typeof currentTerrain.cutoff === 'number' && currentTerrain.cutoff > 0){
      return;
    }

    const hasDedicated = ensureDedicatedSource();
    const targetSource = hasDedicated ? dedicatedId : terrain.source;
    const nextTerrain = Object.assign({}, terrain, { source: targetSource });
    if(typeof nextTerrain.cutoff !== 'number' || nextTerrain.cutoff <= 0){
      nextTerrain.cutoff = 0.01;
    }
    try { mapInstance.setTerrain(nextTerrain); } catch(err){}
  }

  function patchMapboxStyleArtifacts(mapInstance){
    if(!mapInstance || typeof mapInstance.getStyle !== 'function') return;
    if(mapInstance.isStyleLoaded && !mapInstance.isStyleLoaded()) return;
    let style;
    try{
      style = mapInstance.getStyle();
    }catch(err){
      return;
    }
    if(!style) return;
    try{ ensurePlaceholderSprites(mapInstance); }catch(err){}
    try{ patchLayerFiltersForMissingLayer(mapInstance, style); }catch(err){}
    try{ patchTerrainSource(mapInstance, style); }catch(err){}
  }

  // Attach pointer cursor only after style is ready, and re-attach if style changes later.
  function armPointerOnSymbolLayers(map){
    const POINTER_READY_IDS = new Set([
      'small-map-card-pill', // Obsolete but kept for cleanup
      'big-map-card-pill', // Obsolete but kept for cleanup
      'small-map-card-composite', // Active composite layer
      'big-map-card-composite', // Active composite layer
      'post-clusters'
    ]);

    function shouldAttachPointer(layer){
      if (!layer || layer.type !== 'symbol') return false;
      if (POINTER_READY_IDS.has(layer.id)) return true;
      if (typeof layer.source === 'string' && layer.source === 'posts') return true;
      if (layer.metadata && layer.metadata.cursor === 'pointer') return true;
      return false;
    }

    function attach(){
      if (!map.getStyle || !map.isStyleLoaded || !map.isStyleLoaded()) return;
      const st = map.getStyle();
      if (!st || !st.layers) return;

      map.__cursorArmed = map.__cursorArmed || new Set();
      st.layers.forEach(l => {
        if (!shouldAttachPointer(l) || map.__cursorArmed.has(l.id)) return;
        map.on('mouseenter', l.id, () => map.getCanvas().style.cursor = 'pointer');
        map.on('mouseleave', l.id, () => map.getCanvas().style.cursor = 'grab');
        map.__cursorArmed.add(l.id);
      });
    }

    // First time once the style is fully loaded
    whenStyleReady(map, attach);

    // If the style changes later, reattach *after* the new style finishes
    map.on('styledata', () => {
      if (map.isStyleLoaded && map.isStyleLoaded()) attach();
    });
  }
  const callWhenDefined = window.callWhenDefined || function(name, invoke, timeoutMs){
    const start = performance.now(), max = timeoutMs ?? 5000;
    (function wait(){
      const fn = window[name];
      if (typeof fn === 'function') {
        try { invoke(fn); } catch(e){}
        return;
      }
      if (performance.now() - start < max) requestAnimationFrame(wait);
    })();
  };
  window.callWhenDefined = window.callWhenDefined || callWhenDefined;

  let startPitch, startBearing, logoEls = [], geocoder;
  const LEGACY_DEFAULT_PITCH = 0;
  const geocoders = [];
  let lastGeocoderProximity = null;

  function setAllGeocoderProximity(lng, lat){
    if(!Number.isFinite(lng) || !Number.isFinite(lat)) return;
    // Temporarily disable proximity biasing to broaden search results.
    lastGeocoderProximity = null;
  }

  function syncGeocoderProximityToMap(){
    if(!map || typeof map.getCenter !== 'function') return;
    try{
      const center = map.getCenter();
      if(center && Number.isFinite(center.lng) && Number.isFinite(center.lat)){
        setAllGeocoderProximity(center.lng, center.lat);
      }
    }catch(err){}
  }
  const CARD_SURFACE = 'linear-gradient(rgba(0,0,0,0.8),rgba(0,0,0,0.6))';
  const CARD_HIGHLIGHT = '#2e3a72';
  const MapRegistry = {
    list: [],
    limit: 4,
    register(map){
      if(!map) return;
      if(this.list.includes(map)) return;
      this.list.push(map);
      if(typeof map.once === 'function'){
        map.once('remove', () => {
          this.list = this.list.filter(m => m !== map);
        });
      }
      if(this.list.length > this.limit){
        const victim = this.list.shift();
        try{ victim && typeof victim.remove === 'function' && victim.remove(); }catch(err){}
      }
    }
  };

  function getGeocoderInput(gc){
    if(!gc) return null;
    if(gc._inputReference) return gc._inputReference;
    if(gc._inputEl) return gc._inputEl;
    if(gc._container) return gc._container.querySelector('input[type="text"]');
    return null;
  }

  function blurAllGeocoderInputs(){
    geocoders.forEach(gc => {
      const input = getGeocoderInput(gc);
      if(input && typeof input.blur === 'function'){
        input.blur();
      }
    });
  }

  function clearMapGeocoder(){
    if(!geocoder || typeof geocoder.clear !== 'function') return;
    const before = document.activeElement;
    geocoder.clear();
    const after = document.activeElement;
    requestAnimationFrame(() => {
      [after, before, getGeocoderInput(geocoder)].forEach(el => {
        if(el && el.tagName === 'INPUT' && typeof el.blur === 'function'){
          el.blur();
        }
      });
      blurAllGeocoderInputs();
    });
  }

  function closeWelcomeModalIfOpen(){
    const welcome = document.getElementById('welcome-modal');
    if(welcome && welcome.classList.contains('show')){
      closePanel(welcome);
    }
  }

  (function(){
    const MAPBOX_TOKEN = "pk.eyJ1IjoienhlbiIsImEiOiJjbWViaDRibXEwM2NrMm1wcDhjODg4em5iIn0.2A9teACgwpiCy33uO4WZJQ";

    let mode = localStorage.getItem('mode') || 'map';
    const DEFAULT_SPIN_SPEED = 0.3;
    // Welcome message will be loaded from DB

    const firstVisit = !localStorage.getItem('hasVisited');
    localStorage.setItem('hasVisited','1');
    if(firstVisit){
      mode = 'map';
      localStorage.setItem('mode','map');
      localStorage.setItem('historyActive','false');
      ['filterPanel','memberPanel','adminPanel'].forEach(id => {
        localStorage.setItem(`panel-open-${id}`,'false');
      });
    }
    // Only use saved view if valid - no random fallback
    let savedView = null;
    try{
      const savedViewStr = localStorage.getItem('mapView');
      if(savedViewStr){
        savedView = JSON.parse(savedViewStr);
      }
    }catch(err){
      console.error('Failed to parse saved map view:', err);
      // Don't use fallback - will need to get center from backend or show error
    }

    // Map center is a UI preference - use saved location if available
    let startCenter = null; // Will be set from saved location or admin starting location
    let startZoom = null;
    let hasSavedUserLocation = false; // Track if user has a saved location from interaction
    if(savedView && savedView.center && Array.isArray(savedView.center) && savedView.center.length === 2){
      startCenter = savedView.center;
      startZoom = savedView.zoom || 1.5;
      hasSavedUserLocation = true;
    }
    // If no saved location, startCenter will be set from admin settings when they load
    window._hasSavedUserLocation = hasSavedUserLocation;
    let lastKnownZoom = startZoom;
    const hasSavedPitch = typeof savedView?.pitch === 'number';
    const initialPitch = hasSavedPitch ? savedView.pitch : LEGACY_DEFAULT_PITCH;
    startPitch = window.startPitch = initialPitch;
    // Restore bearing from saved view if available (don't reset to 0)
    const hasSavedBearing = typeof savedView?.bearing === 'number';
    startBearing = window.startBearing = hasSavedBearing ? savedView.bearing : 0;

      let map, mapLoading = null, spinning = false, historyWasActive = localStorage.getItem('historyActive') === 'true', expiredWasOn = false, dateStart = null, dateEnd = null,
          spinLoadStart = false,
          spinLoadType = 'everyone',
          spinLogoClick = true,
          spinZoomMax = 4,
          spinSpeed = 0.3,
          spinEnabled = false,
          mapCardDisplay = 'hover_only',
          waitForMapTiles = true,
          mapStyle = window.mapStyle = 'mapbox://styles/mapbox/standard';
      
      // Title will be set when settings load from backend
      
      // Initialize system image pickers using iconpicker interface
      function initializeSystemImagePickers(settings){
        const imagePickers = [
          { buttonId: 'systemImageBigLogoButton', containerId: 'systemImageBigLogoContainer', previewId: 'systemImageBigLogoPreview', settingKey: 'big_logo', label: 'Big Logo' },
          { buttonId: 'systemImageSmallLogoButton', containerId: 'systemImageSmallLogoContainer', previewId: 'systemImageSmallLogoPreview', settingKey: 'small_logo', label: 'Small Logo' },
          { buttonId: 'systemImageFaviconButton', containerId: 'systemImageFaviconContainer', previewId: 'systemImageFaviconPreview', settingKey: 'favicon', label: 'Favicon' },
          { buttonId: 'systemImageSmallMapCardPillButton', containerId: 'systemImageSmallMapCardPillContainer', previewId: 'systemImageSmallMapCardPillPreview', settingKey: 'small_map_card_pill', label: 'Small Map Card Pill' },
          { buttonId: 'systemImageBigMapCardPillButton', containerId: 'systemImageBigMapCardPillContainer', previewId: 'systemImageBigMapCardPillPreview', settingKey: 'big_map_card_pill', label: 'Big Map Card Pill' },
          { buttonId: 'systemImageHoverMapCardPillButton', containerId: 'systemImageHoverMapCardPillContainer', previewId: 'systemImageHoverMapCardPillPreview', settingKey: 'hover_map_card_pill', label: 'Hover Map Card Pill' },
          { buttonId: 'systemImageMultiPostIconButton', containerId: 'systemImageMultiPostIconContainer', previewId: 'systemImageMultiPostIconPreview', settingKey: 'multi_post_icon', label: 'Multi Post Icon' },
          { buttonId: 'systemImageMarkerClusterButton', containerId: 'systemImageMarkerClusterContainer', previewId: 'systemImageMarkerClusterPreview', settingKey: 'marker_cluster_icon', label: 'Marker Cluster Icon' }
        ];
        
        imagePickers.forEach(picker => {
          const button = document.getElementById(picker.buttonId);
          const container = document.getElementById(picker.containerId);
          
          if(!button || !container) return;
          
          // For new menu structure (settings tab logo menus), build button structure
          let buttonImg = button.querySelector('.menu-button-img--system-image-picker, .menu-button-img--icon-picker');
          let buttonLabel = button.querySelector('.menu-button-label--system-image-picker, .menu-button-label--icon-picker');
          
          // If button structure doesn't exist yet, it's the old structure - skip for now
          // (map tab still uses old structure, we'll convert later)
          if(!buttonImg || !buttonLabel){
            // Old structure - check for preview
            const preview = document.getElementById(picker.previewId);
            if(!preview) return;
            
            const previewImg = preview.querySelector('img');
            const previewLabel = preview.querySelector('span');
            
            // Load initial value from settings
            const initialPath = settings[picker.settingKey] || '';
            if(initialPath && previewImg){
              previewImg.src = initialPath;
              preview.classList.add('has-image');
              if(previewLabel) previewLabel.textContent = '';
              button.textContent = 'Change Icon';
            }
            
            // Attach system image picker functionality (uses system-images folder)
            if(typeof window.attachSystemImagePicker === 'function'){
              window.attachSystemImagePicker(button, container, {
                getCurrentPath: () => settings[picker.settingKey] || '',
                onSelect: async (value) => {
                  if(value){
                    if(previewImg) previewImg.src = value;
                    preview.classList.add('has-image');
                    if(previewLabel) previewLabel.textContent = '';
                    button.textContent = 'Change Icon';
                    
                    // Update local settings immediately
                    settings[picker.settingKey] = value;
                    
                    // Get map instance - try multiple methods
                    let mapInstance = null;
                    if(typeof window.getMapInstance === 'function'){
                      mapInstance = window.getMapInstance();
                    } else if(typeof map !== 'undefined' && map){
                      mapInstance = map;
                    } else if(typeof window.map !== 'undefined' && window.map){
                      mapInstance = window.map;
                    }
                    
                    // Save to admin_settings FIRST
                    const settingsToSave = {};
                    settingsToSave[picker.settingKey] = value;
                    
                    try {
                      const response = await fetch('/gateway.php?action=save-admin-settings', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' },
                        body: JSON.stringify(settingsToSave)
                      });
                      if(!response.ok){
                        throw new Error(`HTTP error! status: ${response.status}`);
                      }
                      const data = await response.json();
                      if(!data.success){
                        throw new Error(data.message || 'Save failed');
                      }
                      console.log(`${picker.label} saved to database.`);
                      
                      // Now refresh map with saved value
                      if(picker.settingKey === 'marker_cluster_icon' && mapInstance && typeof mapInstance.hasImage === 'function'){
                        // Handle cluster icon update
                        const CLUSTER_ICON_ID = 'cluster-icon';
                        const CLUSTER_LAYER_ID = 'post-clusters';
                        if(mapInstance.hasImage(CLUSTER_ICON_ID)){
                          mapInstance.removeImage(CLUSTER_ICON_ID);
                        }
                        const img = await loadMarkerLabelImage(value);
                        if(img && img.width > 0 && img.height > 0){
                          const pixelRatio = img.width >= 256 ? 2 : 1;
                          mapInstance.addImage(CLUSTER_ICON_ID, img, { pixelRatio });
                          const layer = mapInstance.getLayer(CLUSTER_LAYER_ID);
                          if(layer){
                            mapInstance.setLayoutProperty(CLUSTER_LAYER_ID, 'icon-image', CLUSTER_ICON_ID);
                          }
                        }
                      } else if(picker.settingKey === 'small_map_card_pill' || picker.settingKey === 'big_map_card_pill' || picker.settingKey === 'hover_map_card_pill'){
                        // Update window.adminSettings immediately for instant effect
                        if(!window.adminSettings) window.adminSettings = {};
                        window.adminSettings[picker.settingKey] = value;
                        // Refresh map card styles
                        if(window.MapCards && window.MapCards.refreshMapCardStyles){
                          window.MapCards.refreshMapCardStyles();
                        }
                      } else if(picker.settingKey === 'multi_post_icon'){
                        // Update both stores immediately
                        if(!window.adminSettings) window.adminSettings = {};
                        window.adminSettings.multi_post_icon = value;
                        if(window.subcategoryMarkers){
                          window.subcategoryMarkers['multi-post-icon'] = value;
                        }
                        // Refresh marker icons
                        if(window.MapCards && window.MapCards.refreshAllMarkerIcons){
                          window.MapCards.refreshAllMarkerIcons();
                        }
                      } else if(picker.settingKey === 'big_logo'){
                        // Update welcome modal logo immediately
                        if(!window.adminSettings) window.adminSettings = {};
                        window.adminSettings.big_logo = value;
                        const welcomeLogo = document.querySelector('.welcome-logo');
                        if(welcomeLogo){
                          welcomeLogo.src = value;
                        }
                      } else if(picker.settingKey === 'small_logo'){
                        // Update header logo immediately
                        if(!window.adminSettings) window.adminSettings = {};
                        window.adminSettings.small_logo = value;
                        const headerLogo = document.querySelector('.button--header-logo-small img');
                        if(headerLogo){
                          headerLogo.src = value;
                        }
                      } else if(picker.settingKey === 'favicon'){
                        // Update favicon immediately
                        if(!window.adminSettings) window.adminSettings = {};
                        window.adminSettings.favicon = value;
                        const faviconLinks = document.querySelectorAll('link[rel="icon"], link[rel="shortcut icon"]');
                        faviconLinks.forEach(link => {
                          link.href = value;
                        });
                      }
                    } catch(err) {
                      console.error(`Failed to save/update ${picker.label}:`, err);
                      alert(`Failed to save ${picker.label}: ${err.message}`);
                    }
                  } else {
                    // Handle "No Icon" selection - clear the icon
                    if(previewImg) previewImg.src = '';
                    preview.classList.remove('has-image');
                    if(previewLabel) previewLabel.textContent = 'No Icon';
                    button.textContent = 'Choose Icon';
                    settings[picker.settingKey] = '';
                    
                    // Save empty value to database
                    const settingsToSave = {};
                    settingsToSave[picker.settingKey] = '';
                    try {
                      await fetch('/gateway.php?action=save-admin-settings', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' },
                        body: JSON.stringify(settingsToSave)
                      });
                    } catch(err) {
                      console.error(`Failed to clear ${picker.label}:`, err);
                    }
                  }
                },
                label: `Choose icon for ${picker.label}`,
                parentMenu: container.closest('.panel-field'),
                iconFolder: (() => {
                  const systemImagesFolderInput = document.getElementById('adminSystemImagesFolder');
                  return systemImagesFolderInput?.value.trim() || settings.system_images_folder || window.systemImagesFolder || null;
                })()
              });
            }
          } else {
            // New menu structure (settings tab)
            // Load initial value from settings
            const initialPath = settings[picker.settingKey] || '';
            if(initialPath){
              buttonImg.src = initialPath;
              button.classList.add('has-image');
              // Extract filename from path
              const pathParts = initialPath.split('/');
              const filename = pathParts[pathParts.length - 1] || initialPath;
              buttonLabel.textContent = filename;
            } else {
              button.classList.remove('has-image');
              buttonLabel.textContent = 'Choose Image';
            }
            
            // Attach system image picker functionality (uses system-images folder)
            if(typeof window.attachSystemImagePicker === 'function'){
              window.attachSystemImagePicker(button, container, {
                getCurrentPath: () => settings[picker.settingKey] || '',
                onSelect: async (value) => {
                  if(value){
                    buttonImg.src = value;
                    button.classList.add('has-image');
                    // Extract filename from path
                    const pathParts = value.split('/');
                    const filename = pathParts[pathParts.length - 1] || value;
                    buttonLabel.textContent = filename;
                  
                  // Update local settings immediately
                  settings[picker.settingKey] = value;
                  
                  // Get map instance - try multiple methods
                  let mapInstance = null;
                  if(typeof window.getMapInstance === 'function'){
                    mapInstance = window.getMapInstance();
                  } else if(typeof map !== 'undefined' && map){
                    mapInstance = map;
                  } else if(typeof window.map !== 'undefined' && window.map){
                    mapInstance = window.map;
                  }
                  
                  // Save to admin_settings FIRST
                  const settingsToSave = {};
                  settingsToSave[picker.settingKey] = value;
                  
                  try {
                    const response = await fetch('/gateway.php?action=save-admin-settings', {
                      method: 'POST',
                      headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' },
                      body: JSON.stringify(settingsToSave)
                    });
                    if(!response.ok){
                      throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    const data = await response.json();
                    if(!data.success){
                      throw new Error(data.message || 'Save failed');
                    }
                    console.log(`${picker.label} saved to database.`);
                    
                    // Now refresh map with saved value
                    if(picker.settingKey === 'marker_cluster_icon' && mapInstance && typeof mapInstance.hasImage === 'function'){
                      // Handle cluster icon update
                      const CLUSTER_ICON_ID = 'cluster-icon';
                      const CLUSTER_LAYER_ID = 'post-clusters';
                      if(mapInstance.hasImage(CLUSTER_ICON_ID)){
                        mapInstance.removeImage(CLUSTER_ICON_ID);
                      }
                      const img = await loadMarkerLabelImage(value);
                      if(img && img.width > 0 && img.height > 0){
                        const pixelRatio = img.width >= 256 ? 2 : 1;
                        mapInstance.addImage(CLUSTER_ICON_ID, img, { pixelRatio });
                        const layer = mapInstance.getLayer(CLUSTER_LAYER_ID);
                        if(layer){
                          mapInstance.setLayoutProperty(CLUSTER_LAYER_ID, 'icon-image', CLUSTER_ICON_ID);
                        }
                      }
                    } else if(picker.settingKey === 'small_map_card_pill' || picker.settingKey === 'big_map_card_pill' || picker.settingKey === 'hover_map_card_pill'){
                      // Update window.adminSettings immediately for instant effect
                      if(!window.adminSettings) window.adminSettings = {};
                      window.adminSettings[picker.settingKey] = value;
                      // Refresh map card styles
                      if(window.MapCards && window.MapCards.refreshMapCardStyles){
                        window.MapCards.refreshMapCardStyles();
                      }
                    } else if(picker.settingKey === 'multi_post_icon'){
                      // Update both stores immediately
                      if(!window.adminSettings) window.adminSettings = {};
                      window.adminSettings.multi_post_icon = value;
                      if(window.subcategoryMarkers){
                        window.subcategoryMarkers['multi-post-icon'] = value;
                      }
                      // Refresh marker icons
                      if(window.MapCards && window.MapCards.refreshAllMarkerIcons){
                        window.MapCards.refreshAllMarkerIcons();
                      }
                    } else if(picker.settingKey === 'big_logo'){
                      // Update welcome modal logo immediately
                      if(!window.adminSettings) window.adminSettings = {};
                      window.adminSettings.big_logo = value;
                      const welcomeLogo = document.querySelector('.welcome-logo');
                      if(welcomeLogo){
                        welcomeLogo.src = value;
                      }
                    } else if(picker.settingKey === 'small_logo'){
                      // Update header logo immediately
                      if(!window.adminSettings) window.adminSettings = {};
                      window.adminSettings.small_logo = value;
                      const headerLogo = document.querySelector('.button--header-logo-small img');
                      if(headerLogo){
                        headerLogo.src = value;
                      }
                    } else if(picker.settingKey === 'favicon'){
                      // Update favicon immediately
                      if(!window.adminSettings) window.adminSettings = {};
                      window.adminSettings.favicon = value;
                      const faviconLinks = document.querySelectorAll('link[rel="icon"], link[rel="shortcut icon"]');
                      faviconLinks.forEach(link => {
                        link.href = value;
                      });
                    }
                  } catch(err) {
                    console.error(`Failed to save/update ${picker.label}:`, err);
                    alert(`Failed to save ${picker.label}: ${err.message}`);
                  }
                } else {
                  // Handle "No Icon" selection - clear the icon
                  buttonImg.src = '';
                  button.classList.remove('has-image');
                  buttonLabel.textContent = 'Choose Image';
                  settings[picker.settingKey] = '';
                  
                  // Save empty value to database
                  const settingsToSave = {};
                  settingsToSave[picker.settingKey] = '';
                  try {
                    await fetch('/gateway.php?action=save-admin-settings', {
                      method: 'POST',
                      headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' },
                      body: JSON.stringify(settingsToSave)
                    });
                  } catch(err) {
                    console.error(`Failed to clear ${picker.label}:`, err);
                  }
                }
              },
              label: `Choose icon for ${picker.label}`,
              parentMenu: container.closest('.panel-field'),
              iconFolder: (() => {
                const systemImagesFolderInput = document.getElementById('adminSystemImagesFolder');
                return systemImagesFolderInput?.value.trim() || settings.system_images_folder || window.systemImagesFolder || null;
              })()
            });
          }
          }
        });
      }
      
      // Flag to track if admin settings have been loaded - prevents saving empty values
      window._adminSettingsLoaded = false;
      
      // Promise for map creation to wait on (settings load is fast - just DB query)
      let resolveAdminSettings;
      window._adminSettingsReady = new Promise(resolve => { resolveAdminSettings = resolve; });

      // Performance timing: Track startup component load times
      // Use performance.now() for consistent relative timing
      const pageStartTime = performance.now();
      window.__startupTimings = {
        start: pageStartTime,
        components: {},
        // Function to log all timings
        log: function(){
          const now = performance.now();
          const total = now - this.start;
          console.group(' Startup Performance Timings');
          console.log(`Total time: ${total.toFixed(2)}ms`);
          console.log('');
          // Sort by duration (longest first)
          const sorted = Object.keys(this.components).sort((a, b) => {
            return this.components[b].duration - this.components[a].duration;
          });
          sorted.forEach(key => {
            const comp = this.components[key];
            const pct = total > 0 ? ((comp.duration / total) * 100).toFixed(1) : '0.0';
            const status = comp.error ? '' : '';
            console.log(`${status} ${key}: ${comp.duration.toFixed(2)}ms (${pct}%)`);
            if(comp.error) console.log(`   Error: ${comp.error}`);
            if(comp.tilesLoaded !== undefined) console.log(`   Tiles loaded: ${comp.tilesLoaded}`);
          });
          console.groupEnd();
        }
      };
      
      // Mark header as ready (header is in HTML, just needs to be measured)
      const headerEl = document.querySelector('header');
      if(headerEl){
        const headerEnd = performance.now();
        window.__startupTimings.components.header = {
          start: pageStartTime,
          end: headerEnd,
          duration: headerEnd - pageStartTime
        };
      }
      
      // Load admin settings from database (includes messages for welcome modal)
      (async function loadAdminSettings(){
        const adminSettingsStart = performance.now();
        try {
          const response = await apiRequest('/gateway.php?action=get-admin-settings&include_messages=true', {
            method: 'GET',
            headers: { 'Accept': 'application/json' },
          }, 5000); // 5 second cache
          if(response.ok){
            const data = await response.json();
            if(data.success && data.settings){
              // Store admin settings globally for access by welcome modal and other components
              if(!window.adminSettings) window.adminSettings = {};
              Object.assign(window.adminSettings, data.settings);
              
              // Cache messages immediately (for welcome modal - no second API call needed)
              if(data.messages && Array.isArray(data.messages)){
                const messagesMap = {};
                data.messages.forEach(container => {
                  if(!container.messages || !Array.isArray(container.messages)) return;
                  container.messages.forEach(message => {
                    if(message.is_active !== false && message.is_active !== 0){
                      messagesMap[message.message_key] = message;
                    }
                  });
                });
                // Cache for both user and admin (includes all messages)
                messagesCache.user = messagesMap;
                messagesCache.admin = messagesMap;
                messagesCache.lastFetch = Date.now();
              }
              
              // Update the local variables directly first
              spinLoadStart = data.settings.spin_on_load || false;
              spinLoadType = data.settings.spin_load_type || 'everyone';
              spinLogoClick = data.settings.spin_on_logo !== undefined ? data.settings.spin_on_logo : true;
              spinZoomMax = data.settings.spin_zoom_max || 4;
              spinSpeed = data.settings.spin_speed || 0.3;
              mapCardDisplay = data.settings.map_card_display || 'hover_only';
              waitForMapTiles = data.settings.wait_for_map_tiles !== undefined ? data.settings.wait_for_map_tiles : true;
              
              // Store icon folder path globally
              window.iconFolder = data.settings.icon_folder || 'assets/category-icons';
              
              // Store system images folder globally - no fallback
              if(data.settings.system_images_folder && typeof data.settings.system_images_folder === 'string' && data.settings.system_images_folder.trim()){
                window.systemImagesFolder = data.settings.system_images_folder.trim();
              } else {
                window.systemImagesFolder = null;
              }
              
              // Update multi-post icon from database if available
              if(data.settings.multi_post_icon && typeof data.settings.multi_post_icon === 'string' && data.settings.multi_post_icon.trim()){
                const multiPostIconPath = data.settings.multi_post_icon.trim();
                if(window.subcategoryMarkers){
                  window.subcategoryMarkers['multi-post-icon'] = multiPostIconPath;
                }
              }
              
              // Store marker cluster icon globally (used by ensureClusterIconImage)
              if(data.settings.marker_cluster_icon && typeof data.settings.marker_cluster_icon === 'string' && data.settings.marker_cluster_icon.trim()){
                window._markerClusterIcon = data.settings.marker_cluster_icon.trim();
              }
              
              // Apply map shadow and console filter settings (no localStorage caching)
              if(data.settings.map_shadow !== undefined){
                window._mapShadow = data.settings.map_shadow;
                // Update slider if it exists
                const opacityInput = document.getElementById('postModeBgOpacity');
                if(opacityInput){
                  opacityInput.value = data.settings.map_shadow;
                }
              }
              if(data.settings.map_shadow_mode !== undefined){
                // Store in memory for shadow system to use
                window._mapShadowMode = data.settings.map_shadow_mode;
                // Set radio buttons
                const postOnlyRadio = document.getElementById('mapShadowModePostOnly');
                const alwaysRadio = document.getElementById('mapShadowModeAlways');
                if(postOnlyRadio && alwaysRadio){
                  if(data.settings.map_shadow_mode === 'always'){
                    alwaysRadio.checked = true;
                  } else {
                    postOnlyRadio.checked = true;
                  }
                }
              }
              
              // Apply shadow after settings are loaded
              if(typeof window.applyMapShadow === 'function'){
                setTimeout(() => {
                  window.applyMapShadow();
                }, 100);
              }
              if(data.settings.console_filter !== undefined){
                window._consoleFilterEnabled = data.settings.console_filter;
              }
              
              // Mark admin settings as loaded
              const adminSettingsEnd = performance.now();
              window.__startupTimings.components.adminSettings = {
                start: adminSettingsStart,
                end: adminSettingsEnd,
                duration: adminSettingsEnd - adminSettingsStart
              };
              
              // Apply welcome_enabled setting (no localStorage caching)
              if(data.settings.welcome_enabled !== undefined){
                window._welcomeEnabled = data.settings.welcome_enabled;
                
                // If welcome is enabled, show it immediately on page load
                // Messages are already cached above - no additional API call needed
                // Note: welcome can always be shown via logo click regardless of localStorage
                if(data.settings.welcome_enabled){
                  const welcomeModalStart = performance.now();
                  const welcomeModal = document.getElementById('welcome-modal');
                  if(welcomeModal && typeof window.openWelcome === 'function'){
                    window.openWelcome();
                    const welcomeModalEnd = performance.now();
                    window.__startupTimings.components.welcomeModal = {
                      start: welcomeModalStart,
                      end: welcomeModalEnd,
                      duration: welcomeModalEnd - welcomeModalStart
                    };
                    // Don't set welcome-seen here - it will be set when user closes the modal
                  }
                }
              }
              
              // Message category names and icons are loaded fresh from settings each time
              // No localStorage caching needed
              
              // Update document title with site name and tagline
              if(data.settings.site_name){
                let pageTitle = data.settings.site_name;
                if(data.settings.site_tagline){
                  pageTitle += ' - ' + data.settings.site_tagline;
                }
                document.title = pageTitle;
              }
              
              // Apply logo settings from admin settings
              if(data.settings.big_logo && typeof data.settings.big_logo === 'string' && data.settings.big_logo.trim()){
                const welcomeLogo = document.querySelector('.welcome-logo');
                if(welcomeLogo){
                  const welcomeControls = document.querySelector('#welcomeBody .map-controls-welcome');
                  welcomeLogo.onload = () => {
                    welcomeLogo.classList.add('loaded');
                    if(welcomeControls) welcomeControls.classList.add('visible');
                  };
                  welcomeLogo.src = data.settings.big_logo.trim();
                  // If already cached, onload may not fire
                  if(welcomeLogo.complete){
                    welcomeLogo.classList.add('loaded');
                    if(welcomeControls) welcomeControls.classList.add('visible');
                  }
                }
              }
              if(data.settings.small_logo && typeof data.settings.small_logo === 'string' && data.settings.small_logo.trim()){
                const headerLogo = document.querySelector('.button--header-logo-small img');
                if(headerLogo){
                  headerLogo.onload = () => headerLogo.classList.add('loaded');
                  headerLogo.src = data.settings.small_logo.trim();
                  if(headerLogo.complete) headerLogo.classList.add('loaded');
                }
              }
              if(data.settings.favicon && typeof data.settings.favicon === 'string' && data.settings.favicon.trim()){
                const faviconPath = data.settings.favicon.trim();
                // Update all favicon link elements
                const faviconLinks = document.querySelectorAll('link[rel="icon"], link[rel="shortcut icon"]');
                faviconLinks.forEach(link => {
                  link.href = faviconPath;
                });
              }
              
              // Calculate if spin should be enabled
              const shouldSpin = spinLoadStart && (spinLoadType === 'everyone' || (spinLoadType === 'new_users' && firstVisit));
              spinEnabled = shouldSpin;
              
              // Apply the state immediately
              if(shouldSpin){
                if(typeof startSpin === 'function') startSpin();
              } else {
                if(typeof stopSpin === 'function') stopSpin();
              }
              
              // Update logo click state
              if(typeof updateLogoClickState === 'function') updateLogoClickState();
              
              // Initialize UI controls with database values
              const spinLoadStartCheckbox = document.getElementById('spinLoadStart');
              const spinTypeRadios = document.querySelectorAll('input[name="spinType"]');
              const spinLogoClickCheckbox = document.getElementById('spinLogoClick');
              const spinZoomMaxInput = document.getElementById('spinZoomMax');
              
              if(spinLoadStartCheckbox){
                spinLoadStartCheckbox.checked = spinLoadStart;
              }
              if(spinTypeRadios.length){
                spinTypeRadios.forEach(radio => {
                  radio.checked = (radio.value === spinLoadType);
                });
              }
              if(spinLogoClickCheckbox){
                spinLogoClickCheckbox.checked = spinLogoClick;
              }
              const spinZoomMaxSlider = document.getElementById('spinZoomMax');
              const spinZoomMaxDisplay = document.getElementById('spinZoomMaxDisplay');
              if(spinZoomMaxSlider && spinZoomMaxDisplay){
                spinZoomMaxSlider.value = spinZoomMax;
                spinZoomMaxDisplay.textContent = spinZoomMax;
              }
              const spinSpeedSlider = document.getElementById('spinSpeed');
              const spinSpeedDisplay = document.getElementById('spinSpeedDisplay');
              if(spinSpeedSlider && spinSpeedDisplay){
                spinSpeedSlider.value = spinSpeed;
                spinSpeedDisplay.textContent = spinSpeed.toFixed(1);
              }
              
              // Initialize map card display radios
              const mapCardDisplayRadios = document.querySelectorAll('input[name="mapCardDisplay"]');
              if(mapCardDisplayRadios.length){
                mapCardDisplayRadios.forEach(radio => {
                  radio.checked = (radio.value === mapCardDisplay);
                });
              }
              
              // Initialize wait for map tiles checkbox
              const waitForMapTilesCheckbox = document.getElementById('waitForMapTiles');
              if(waitForMapTilesCheckbox){
                waitForMapTilesCheckbox.checked = waitForMapTiles;
              }
              
              // Apply map card display setting
              document.body.setAttribute('data-map-card-display', mapCardDisplay);
              
              // Store starting address setting globally
              if(data.settings.starting_address){
                window._startingAddress = data.settings.starting_address;
              }
              
              // Store starting coordinates globally
              if(data.settings.starting_lat !== undefined){
                window._startingLat = parseFloat(data.settings.starting_lat);
              }
              if(data.settings.starting_lng !== undefined){
                window._startingLng = parseFloat(data.settings.starting_lng);
              }
              
              // Store starting zoom setting globally (default to 10 if not set)
              window._startingZoom = data.settings.starting_zoom !== undefined ? parseFloat(data.settings.starting_zoom) : 10;
              
              // Set startCenter/startZoom from admin starting location if user has no saved location
              // ONLY uses coordinates - no geocoding on page load (admin saves coordinates via geocoder)
              if(!window._hasSavedUserLocation){
                if(window._startingLat && window._startingLng &&
                   Number.isFinite(window._startingLat) && Number.isFinite(window._startingLng)){
                  startCenter = [window._startingLng, window._startingLat];
                  startZoom = window._startingZoom || 10;
                } else {
                  // No coordinates - admin needs to set starting location via geocoder
                  startCenter = [0, 0];
                  startZoom = 1.5;
                }
              }
              
              // Initialize Starting Address input
              const startingAddressInput = document.getElementById('adminStartingAddress');
              if(startingAddressInput && data.settings.starting_address){
                startingAddressInput.value = data.settings.starting_address;
              }
              
              // Initialize Starting Zoom slider
              const startingZoomSlider = document.getElementById('startingZoom');
              const startingZoomDisplay = document.getElementById('startingZoomDisplay');
              if(startingZoomSlider && startingZoomDisplay){
                startingZoomSlider.value = window._startingZoom;
                startingZoomDisplay.textContent = Math.round(window._startingZoom).toString();
              }
              
              // Add refresh map cards button handler
              // Add change listeners for map card display radios
              mapCardDisplayRadios.forEach(radio => {
                radio.addEventListener('change', async () => {
                  if(radio.checked){
                    mapCardDisplay = radio.value;
                    document.body.setAttribute('data-map-card-display', mapCardDisplay);
                    
                    // Clear all hover states when switching modes
                    if(window.MapCards && window.MapCards.clearAllMapCardHoverStates){
                      window.MapCards.clearAllMapCardHoverStates();
                    }
                    
                    // Update map immediately (no reload required)
                    if(typeof window.updateMapCardLayerOpacity === 'function'){
                      window.updateMapCardLayerOpacity(mapCardDisplay);
                    }
                    
                    // Update hover handlers - always use marker-icon only for precise hover zone
                    const mapInstance = typeof window.getMapInstance === 'function' ? window.getMapInstance() : null;
                    if(mapInstance && typeof window.handleMarkerHover === 'function' && typeof window.handleMarkerHoverEnd === 'function'){
                      // Remove old hover handlers from all possible layers (including obsolete ones for cleanup)
                      const allPossibleLayers = ['mapmarker-icon', 'small-map-card-pill', 'big-map-card-pill', 'small-map-card-composite', 'big-map-card-composite'];
                      allPossibleLayers.forEach(layer => {
                        try {
                          mapInstance.off('mouseenter', layer, window.handleMarkerHover);
                          mapInstance.off('mouseleave', layer, window.handleMarkerHoverEnd);
                        } catch(e) {}
                      });
                      
                      // Always use marker-icon only for precise hover zone
                      try {
                        mapInstance.on('mouseenter', 'mapmarker-icon', window.handleMarkerHover);
                        mapInstance.on('mouseleave', 'mapmarker-icon', window.handleMarkerHoverEnd);
                      } catch(e) {}
                    }
                    
                    // Update click and cursor handlers to match new display mode
                    if(typeof window.attachClickHandlers === 'function'){
                      window.attachClickHandlers();
                    }
                    if(typeof window.attachCursorHandlers === 'function'){
                      window.attachCursorHandlers();
                    }
                    
                    // Auto-save to database
                    try {
                      await fetch('/gateway.php?action=save-admin-settings', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ map_card_display: mapCardDisplay })
                      });
                    } catch (e) {
                      console.error('Failed to save map card display setting:', e);
                    }
                  }
                });
              });
              
              // Initialize icon folder input
              const iconFolderInput = document.getElementById('adminIconFolder');
              if(iconFolderInput){
                iconFolderInput.value = window.iconFolder;
              }
              
              // Initialize system images folder input
              const systemImagesFolderInput = document.getElementById('adminSystemImagesFolder');
              if(systemImagesFolderInput){
                const systemImagesFolder = data.settings.system_images_folder && typeof data.settings.system_images_folder === 'string' ? data.settings.system_images_folder.trim() : '';
                systemImagesFolderInput.value = systemImagesFolder;
                window.systemImagesFolder = systemImagesFolder;
              }
              
              // Initialize system image pickers
              if(typeof initializeSystemImagePickers === 'function'){
                initializeSystemImagePickers(data.settings);
              }
              
              // Initialize general website settings
              const websiteNameInput = document.getElementById('adminWebsiteName');
              if(websiteNameInput && data.settings.site_name){
                websiteNameInput.value = data.settings.site_name;
              }
              
              const websiteTaglineInput = document.getElementById('adminWebsiteTagline');
              if(websiteTaglineInput && data.settings.site_tagline){
                websiteTaglineInput.value = data.settings.site_tagline;
              }
              
              const websiteCurrencyBtn = document.getElementById('adminWebsiteCurrency');
              const websiteCurrencyMenu = document.getElementById('adminWebsiteCurrency-menu');
              const websiteCurrencyWrapper = websiteCurrencyBtn ? websiteCurrencyBtn.closest('.options-dropdown') : null;
              if(websiteCurrencyBtn && websiteCurrencyMenu && websiteCurrencyWrapper){
                // Populate dropdown from picklist
                if(data.picklist && data.picklist.currency){
                  // Store currency data with labels globally for member dropdowns
                  window.currencyData = data.picklist.currency.map(opt => ({
                    value: opt.value,
                    label: opt.label
                  }));
                  // Store phone prefix data globally (same data source pattern)
                  if(data.picklist['phone-prefix']){
                    window.phonePrefixData = data.picklist['phone-prefix'].map(opt => ({
                      value: opt.value,
                      label: opt.label
                    }));
                  }
                  
                  const websiteCurrencyArrow = document.createElement('span');
                  websiteCurrencyArrow.className = 'dropdown-arrow';
                  websiteCurrencyArrow.setAttribute('aria-hidden', 'true');
                  
                  // Populate menu with currency options
                  data.picklist.currency.forEach(function(opt){
                    const { countryCode, currencyCode } = parseCurrencyValue(opt.value);
                    const optionBtn = document.createElement('button');
                    optionBtn.type = 'button';
                    optionBtn.className = 'menu-option';
                    optionBtn.innerHTML = getCurrencyDisplayText(opt);
                    optionBtn.dataset.value = currencyCode;
                    optionBtn.dataset.countryCode = countryCode || '';
                    optionBtn.dataset.label = opt.label || '';
                    optionBtn.addEventListener('click', (e) => {
                      e.stopPropagation();
                      websiteCurrencyBtn.innerHTML = getCurrencyDisplayText(opt);
                      websiteCurrencyBtn.appendChild(websiteCurrencyArrow);
                      websiteCurrencyBtn.dataset.value = currencyCode;
                      websiteCurrencyMenu.hidden = true;
                      websiteCurrencyBtn.setAttribute('aria-expanded', 'false');
                    });
                    websiteCurrencyMenu.appendChild(optionBtn);
                  });
                  
                  // Set selected value
                  if(data.settings.site_currency){
                    const siteOpt = findCurrencyOption(data.settings.site_currency);
                    if(siteOpt){
                      websiteCurrencyBtn.innerHTML = getCurrencyDisplayText(siteOpt);
                    } else {
                      websiteCurrencyBtn.textContent = data.settings.site_currency;
                    }
                    websiteCurrencyBtn.dataset.value = data.settings.site_currency;
                  }
                  websiteCurrencyBtn.appendChild(websiteCurrencyArrow);
                  
                  // Toggle menu on button click
                  websiteCurrencyBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const open = !websiteCurrencyMenu.hasAttribute('hidden');
                    if(open){
                      websiteCurrencyMenu.hidden = true;
                      websiteCurrencyBtn.setAttribute('aria-expanded', 'false');
                    } else {
                      websiteCurrencyMenu.hidden = false;
                      websiteCurrencyBtn.setAttribute('aria-expanded', 'true');
                      
                      // Setup keyboard navigation
                      const cleanupKeyboardNav = setupDropdownKeyboardNav(websiteCurrencyMenu, () => {
                        websiteCurrencyMenu.hidden = true;
                        websiteCurrencyBtn.setAttribute('aria-expanded', 'false');
                      });
                      
                      const outsideHandler = (ev) => {
                        if(!websiteCurrencyWrapper.contains(ev.target)){
                          websiteCurrencyMenu.hidden = true;
                          websiteCurrencyBtn.setAttribute('aria-expanded', 'false');
                          cleanupKeyboardNav();
                          document.removeEventListener('click', outsideHandler);
                          document.removeEventListener('pointerdown', outsideHandler);
                        }
                      };
                      setTimeout(() => {
                        document.addEventListener('click', outsideHandler);
                        document.addEventListener('pointerdown', outsideHandler);
                      }, 0);
                    }
                  });
                  websiteCurrencyMenu.addEventListener('click', (e) => e.stopPropagation());
                }
              }
              
              // Render checkout options
              if(data.checkout_options && Array.isArray(data.checkout_options)){
                renderCheckoutOptions(data.checkout_options, data.settings.site_currency || 'USD');
                // Refresh saved state after checkout options are rendered to capture the initial state
                setTimeout(() => {
                  if(window.adminPanelModule && typeof window.adminPanelModule.markSaved === 'function'){
                    window.adminPanelModule.markSaved();
                  }
                }, 50);
              }
              
              const contactEmailInput = document.getElementById('adminContactEmail');
              if(contactEmailInput && data.settings.contact_email){
                contactEmailInput.value = data.settings.contact_email;
              }
              
              const supportEmailInput = document.getElementById('adminSupportEmail');
              if(supportEmailInput && data.settings.support_email){
                supportEmailInput.value = data.settings.support_email;
              }
              
              const maintenanceModeCheckbox = document.getElementById('adminMaintenanceMode');
              if(maintenanceModeCheckbox){
                maintenanceModeCheckbox.checked = data.settings.maintenance_mode === true || data.settings.maintenance_mode === 'true';
              }
              
              const welcomeEnabledCheckbox = document.getElementById('adminWelcomeEnabled');
              if(welcomeEnabledCheckbox){
                welcomeEnabledCheckbox.checked = data.settings.welcome_enabled !== false && data.settings.welcome_enabled !== 'false';
              }
              
              // Initialize console filter checkbox
              const consoleFilterCheckbox = document.getElementById('adminEnableConsoleFilter');
              if(consoleFilterCheckbox && !consoleFilterCheckbox.dataset.autoSaveAdded){
                consoleFilterCheckbox.dataset.autoSaveAdded = 'true';
                
                // Track if we're programmatically setting the checkbox (to avoid triggering change event)
                let isSettingProgrammatically = false;
                const savedState = window._consoleFilterEnabled === true;
                isSettingProgrammatically = true;
                consoleFilterCheckbox.checked = savedState;
                isSettingProgrammatically = false;
                
                // Store original console.warn to restore when disabling
                const originalConsoleWarn = console.warn;
                let consoleFilterActive = false;
                
                // Function to enable console filter
                function enableConsoleFilter(){
                  if(consoleFilterActive) return;
                  
                  const suppressedWarnings = [
                    /featureNamespace.*selector/i,
                    /cutoff.*disabled.*terrain/i,
                  ];
                  
                  console.warn = function(...args) {
                    const message = args.join(' ');
                    if(!suppressedWarnings.some(pattern => pattern.test(message))){
                      originalConsoleWarn.apply(console, args);
                    }
                  };
                  
                  consoleFilterActive = true;
                  console.log('%c[Console Filter Active]', 'color: #00ff00; font-weight: bold;', 
                    'Suppressing', suppressedWarnings.length, 'warning patterns.');
                }
                
                // Function to disable console filter
                function disableConsoleFilter(){
                  if(!consoleFilterActive) return;
                  console.warn = originalConsoleWarn;
                  consoleFilterActive = false;
                  console.log('%c[Console Filter Disabled]', 'color: #ff9900; font-weight: bold;');
                }
                
                // Enable filter if it was enabled on page load
                if(savedState){
                  enableConsoleFilter();
                }
                
                consoleFilterCheckbox.addEventListener('change', async (event) => {
                  // Skip if this change was programmatic
                  if(isSettingProgrammatically){
                    return;
                  }
                  
                  // Only process user-initiated events (not programmatic changes)
                  if(event.isTrusted === false){
                    return;
                  }
                  
                  const enabled = consoleFilterCheckbox.checked;
                  window._consoleFilterEnabled = enabled;
                  
                  // Enable/disable filter immediately
                  if(enabled){
                    enableConsoleFilter();
                  } else {
                    disableConsoleFilter();
                  }
                  
                  // Auto-save to database
                  try {
                    await fetch('/gateway.php?action=save-admin-settings', {
                      method: 'POST',
                      headers: { 'Content-Type': 'application/json' },
                      body: JSON.stringify({ console_filter: enabled })
                    });
                  } catch (e) {
                    console.error('Failed to save console filter setting:', e);
                  }
                });
              }
            }
              // Mark settings as loaded - safe to save now
              window._adminSettingsLoaded = true;
              resolveAdminSettings();
              console.log('[Admin Settings] Loaded successfully - saving enabled');
              
              // Refresh saved state to capture all loaded settings as the baseline
              // This ensures the save button only enables when there are actual changes
              setTimeout(() => {
                if(window.adminPanelModule && typeof window.adminPanelModule.markSaved === 'function'){
                  window.adminPanelModule.markSaved();
                }
              }, 100);
          }
        } catch(err){
          console.error('Failed to load admin settings from database:', err);
          // Mark admin settings as failed
          const adminSettingsEnd = performance.now();
          if(!window.__startupTimings.components.adminSettings){
            window.__startupTimings.components.adminSettings = {
              start: adminSettingsStart,
              end: adminSettingsEnd,
              duration: adminSettingsEnd - adminSettingsStart,
              error: err.message || 'Unknown error'
            };
          }
          // Don't use defaults - error should be visible
          // Settings remain unloaded - saving will be blocked
          window._adminSettingsLoaded = false;
          resolveAdminSettings(); // Still resolve so map doesn't hang
        }
      })();
      let markersLoaded = false;
      window.__markersLoaded = false;
      const MARKER_ZOOM_THRESHOLD = 8;
      const MARKER_SPRITE_ZOOM = MARKER_SPRITE_RETAIN_ZOOM;
      const ZOOM_VISIBILITY_PRECISION = 1000;
      const MARKER_VISIBILITY_BUCKET = Math.round(MARKER_ZOOM_THRESHOLD * ZOOM_VISIBILITY_PRECISION);
      const MARKER_PRELOAD_OFFSET = 0.2;
      const MARKER_PRELOAD_ZOOM = Math.max(MARKER_ZOOM_THRESHOLD - MARKER_PRELOAD_OFFSET, 0);
      // Map card layers only - marker-icon is completely separate
      const MARKER_LAYER_IDS = [
        'hover-fill',
        'small-map-card-pill',
        'big-map-card-pill'
      ];
      const ALL_MARKER_LAYER_IDS = [...MARKER_LAYER_IDS];
      const MID_ZOOM_MARKER_CLASS = 'map--midzoom-markers';
      const SPRITE_MARKER_CLASS = 'map--sprite-markers';

      // --- Section 5: Marker Clustering ---
      // Cluster icons group nearby posts at low zoom levels. They are replaced by individual markers at higher zoom.
      const CLUSTER_SOURCE_ID = 'post-cluster-source';
        const CLUSTER_LAYER_ID = 'post-clusters';
        const CLUSTER_LAYER_IDS = [CLUSTER_LAYER_ID];
        const CLUSTER_ICON_ID = 'cluster-icon';
        let CLUSTER_ICON_URL = null; // Loaded from admin_settings
        const CLUSTER_MIN_ZOOM = 0;
        const CLUSTER_MAX_ZOOM = MARKER_ZOOM_THRESHOLD;
        let clusterLayersVisible = true;

        async function ensureClusterIconImage(mapInstance){
          // Use cluster icon URL from main settings load (no additional API call)
          if(window._markerClusterIcon){
            CLUSTER_ICON_URL = window._markerClusterIcon;
          }
          
          return new Promise(resolve => {
            if(!mapInstance || typeof mapInstance.hasImage !== 'function'){
              resolve();
              return;
            }
            if(mapInstance.hasImage(CLUSTER_ICON_ID)){
              resolve();
              return;
            }
            const handleImage = (image)=>{
              if(!image){
                resolve();
                return;
              }
              try{
                if(!mapInstance.hasImage(CLUSTER_ICON_ID) && image.width > 0 && image.height > 0){
                  const pixelRatio = image.width >= 256 ? 2 : 1;
                  mapInstance.addImage(CLUSTER_ICON_ID, image, { pixelRatio });
                }
              }catch(err){ console.error(err); }
              resolve();
            };
            // Only load if URL is valid
            if(!CLUSTER_ICON_URL || typeof CLUSTER_ICON_URL !== 'string' || !CLUSTER_ICON_URL.trim()){
              resolve();
              return;
            }
            
            try{
              if(typeof mapInstance.loadImage === 'function'){
                mapInstance.loadImage(CLUSTER_ICON_URL, (err, image)=>{
                  if(err){ console.error(err); resolve(); return; }
                  handleImage(image);
                });
                return;
              }
            }catch(err){ console.error(err); resolve(); return; }
            if(typeof Image !== 'undefined'){
              const img = new Image();
              img.crossOrigin = 'anonymous';
              img.onload = ()=>handleImage(img);
              img.onerror = ()=>resolve();
              img.src = CLUSTER_ICON_URL;
              return;
            }
            resolve();
          });
        }

        function formatClusterCount(count){
          if(!Number.isFinite(count) || count <= 0){
            return '0';
          }
          if(count >= 1000000){
            const value = count / 1000000;
            const formatted = value >= 10 ? Math.round(value) : Math.round(value * 10) / 10;
            return `${formatted}m`;
          }
          if(count >= 1000){
            const value = count / 1000;
            const formatted = value >= 10 ? Math.round(value) : Math.round(value * 10) / 10;
            return `${formatted}k`;
          }
          return String(count);
        }

        function getClusterGridSize(zoom){
          const z = Number.isFinite(zoom) ? zoom : 0;
          if(z >= 7.5) return 0.5;
          if(z >= 6) return 1;
          if(z >= 4) return 2.5;
          if(z >= 2) return 5;
          return 10;
        }

        const clampClusterLat = (lat)=> Math.max(-85, Math.min(85, lat));

        function groupPostsForClusterZoom(postsSource, zoom){
          const gridSizeRaw = getClusterGridSize(zoom);
          const gridSize = gridSizeRaw > 0 ? gridSizeRaw : 5;
          const groups = new Map();
          postsSource.forEach(post => {
            if(!post || !Number.isFinite(post.lng) || !Number.isFinite(post.lat)) return;
            const lng = Number(post.lng);
            const lat = clampClusterLat(Number(post.lat));
            const col = Math.floor((lng + 180) / gridSize);
            const row = Math.floor((lat + 90) / gridSize);
            const key = `${col}|${row}`;
            let bucket = groups.get(key);
            if(!bucket){
              bucket = { count:0, sumLng:0, sumLat:0, posts: [] };
              groups.set(key, bucket);
            }
            bucket.count += 1;
            bucket.sumLng += lng;
            bucket.sumLat += lat;
            bucket.posts.push(post);
          });
          return { groups };
        }

        let lastClusterGroupingDetails = { key: null, zoom: null, groups: new Map() };

        function buildClusterFeatureCollection(zoom){
          const allowInitialize = true; // ensure clusters have data even before marker zoom threshold
          const postsSource = getAllPostsCache({ allowInitialize });
          if(!Array.isArray(postsSource) || postsSource.length === 0){
            const emptyGroups = new Map();
            const groupingKey = getClusterBucketKey(zoom);
            lastClusterGroupingDetails = { key: groupingKey, zoom, groups: emptyGroups };
            return { type:'FeatureCollection', features: [] };
          }
          const { groups } = groupPostsForClusterZoom(postsSource, zoom);
          const features = [];
          groups.forEach((bucket, key) => {
            if(!bucket || bucket.count <= 0) return;
            const avgLng = bucket.sumLng / bucket.count;
            const avgLat = bucket.sumLat / bucket.count;
            features.push({
              type:'Feature',
              properties:{
                count: bucket.count,
                label: formatClusterCount(bucket.count),
                bucket: key
              },
              geometry:{ type:'Point', coordinates:[avgLng, avgLat] }
            });
          });
          const groupingKey = getClusterBucketKey(zoom);
          lastClusterGroupingDetails = { key: groupingKey, zoom, groups };
          return { type:'FeatureCollection', features };
        }

        function computeChildClusterTarget(bucket, currentZoom, maxAllowedZoom){
          if(!bucket || !Array.isArray(bucket.posts) || bucket.posts.length <= 1){
            return null;
          }
          const safeCurrent = Number.isFinite(currentZoom) ? currentZoom : 0;
          const safeMax = Number.isFinite(maxAllowedZoom) ? maxAllowedZoom : safeCurrent;
          if(!(safeMax > safeCurrent)){
            return null;
          }
          const step = 0.25;
          const maxIterations = Math.max(1, Math.ceil((safeMax - safeCurrent) / step) + 1);
          for(let i=0;i<maxIterations;i++){
            const candidateZoom = Math.min(safeMax, safeCurrent + (i + 1) * step);
            if(!(candidateZoom > safeCurrent)){
              continue;
            }
            const { groups } = groupPostsForClusterZoom(bucket.posts, candidateZoom);
            const childBuckets = Array.from(groups.values()).filter(child => child && child.count > 0);
            if(childBuckets.length <= 1){
              continue;
            }
            let totalCount = 0;
            let sumLng = 0;
            let sumLat = 0;
            childBuckets.forEach(child => {
              const childCenterLng = child.sumLng / child.count;
              const childCenterLat = child.sumLat / child.count;
              totalCount += child.count;
              sumLng += childCenterLng * child.count;
              sumLat += childCenterLat * child.count;
            });
            if(totalCount <= 0){
              continue;
            }
            return {
              center: [sumLng / totalCount, sumLat / totalCount],
              zoom: candidateZoom
            };
          }
          return null;
        }

        let lastClusterBucketKey = null;

        function getClusterBucketKey(zoom){
          const size = getClusterGridSize(zoom);
          return Number.isFinite(size) ? size.toFixed(2) : 'default';
        }

        function updateClusterSourceForZoom(zoom){
          if(!map) return;
          const source = map.getSource && map.getSource(CLUSTER_SOURCE_ID);
          if(!source || typeof source.setData !== 'function') return;
          const zoomValue = Number.isFinite(zoom) ? zoom : (typeof map.getZoom === 'function' ? map.getZoom() : 0);
          const bucketKey = getClusterBucketKey(zoomValue);
          if(lastClusterBucketKey === bucketKey) return;
          try{
            const data = buildClusterFeatureCollection(zoomValue);
            source.setData(data);
            lastClusterBucketKey = bucketKey;
          }catch(err){ console.error(err); }
        }

        function resetClusterSourceState(){
          lastClusterBucketKey = null;
          lastClusterGroupingDetails = { key: null, zoom: null, groups: new Map() };
        }

        function setupSeedLayers(mapInstance){
          if(!mapInstance) return;
          // Ensure cluster layers are ready even at low zoom on initial load
          const currentZoom = typeof mapInstance.getZoom === 'function' ? mapInstance.getZoom() : 0;
          if(!Number.isFinite(currentZoom)){
            if(!mapInstance.__seedLayerZoomGate){
              const handleZoomGate = ()=>{
                const readyZoom = typeof mapInstance.getZoom === 'function' ? mapInstance.getZoom() : 0;
                if(Number.isFinite(readyZoom)){
                  mapInstance.off('zoomend', handleZoomGate);
                  mapInstance.__seedLayerZoomGate = null;
                  setupSeedLayers(mapInstance);
                }
              };
              mapInstance.__seedLayerZoomGate = handleZoomGate;
              mapInstance.on('zoomend', handleZoomGate);
            }
            return;
          }
          if(mapInstance.__seedLayerZoomGate){
            mapInstance.off('zoomend', mapInstance.__seedLayerZoomGate);
            mapInstance.__seedLayerZoomGate = null;
          }
          ensureClusterIconImage(mapInstance).then(()=>{
            try{
              if(mapInstance.getLayer(CLUSTER_LAYER_ID)) mapInstance.removeLayer(CLUSTER_LAYER_ID);
            }catch(err){ console.error(err); }

            let clusterSource = null;
            try{
              clusterSource = mapInstance.getSource && mapInstance.getSource(CLUSTER_SOURCE_ID);
            }catch(err){ clusterSource = null; }
            const emptyData = (typeof EMPTY_FEATURE_COLLECTION !== 'undefined') ? EMPTY_FEATURE_COLLECTION : { type:'FeatureCollection', features: [] };
            try{
              if(clusterSource && typeof clusterSource.setData === 'function'){
                clusterSource.setData(emptyData);
              } else {
                if(clusterSource){
                  try{ mapInstance.removeSource(CLUSTER_SOURCE_ID); }catch(removeErr){ console.error(removeErr); }
                }
                mapInstance.addSource(CLUSTER_SOURCE_ID, { type:'geojson', data: emptyData });
              }
            }catch(err){ console.error(err); }

            try{
              mapInstance.addLayer({
                id: CLUSTER_LAYER_ID,
                type: 'symbol',
                source: CLUSTER_SOURCE_ID,
                minzoom: CLUSTER_MIN_ZOOM,
                maxzoom: CLUSTER_MAX_ZOOM,
                layout: {
                  'icon-image': CLUSTER_ICON_ID,
                  'icon-size': ['interpolate', ['linear'], ['zoom'], 0, 0.4, 7.5, 1],
                  'icon-allow-overlap': true,
                  'icon-ignore-placement': true,
                  'icon-anchor': 'bottom',
                  'text-field': ['to-string', ['coalesce', ['get','label'], ['get','count']]],
                  'text-size': 12,
                  'text-offset': [0, -1.35],
                  'text-font': ['Open Sans Bold','Arial Unicode MS Bold'],
                  'text-allow-overlap': true,
                  'text-ignore-placement': true,
                  'symbol-z-order': 'viewport-y',
                  'symbol-sort-key': 900
                },
                paint: {
                  'text-color': '#ffffff',
                  'text-halo-color': 'rgba(0,0,0,0.45)',
                  'text-halo-width': 1.2,
                  'icon-opacity': 0.95
                },
                metadata:{ cursor:'pointer' }
              });
            }catch(err){ console.error(err); }

            resetClusterSourceState();
            const currentZoomValue = mapInstance.getZoom ? mapInstance.getZoom() : CLUSTER_MIN_ZOOM;
            updateClusterSourceForZoom(currentZoomValue);
            const shouldShow = Number.isFinite(currentZoomValue) ? currentZoomValue < CLUSTER_MAX_ZOOM : true;
            try{
              mapInstance.setLayoutProperty(CLUSTER_LAYER_ID, 'visibility', shouldShow ? 'visible' : 'none');
            }catch(err){}
            clusterLayersVisible = shouldShow;
          });

          if(!mapInstance.__clusterEventsBound){
            const handleClusterClick = (e)=>{
              if(e && typeof e.preventDefault === 'function') e.preventDefault();
              const feature = e && e.features && e.features[0];
              if(!feature) return;
              const coords = feature.geometry && feature.geometry.coordinates;
              if(!Array.isArray(coords) || coords.length < 2) return;
              const currentZoom = typeof mapInstance.getZoom === 'function' ? mapInstance.getZoom() : 0;
              const maxZoom = typeof mapInstance.getMaxZoom === 'function' ? mapInstance.getMaxZoom() : 22;
              const maxAllowedZoom = Number.isFinite(maxZoom)
                ? Math.min(maxZoom, CLUSTER_MAX_ZOOM)
                : CLUSTER_MAX_ZOOM;
              const safeCurrentZoom = Number.isFinite(currentZoom) ? currentZoom : 0;
              const bucketKey = feature.properties && feature.properties.bucket;
              const grouping = lastClusterGroupingDetails && lastClusterGroupingDetails.groups instanceof Map
                ? lastClusterGroupingDetails.groups
                : null;
              const bucketData = grouping && bucketKey ? grouping.get(bucketKey) : null;
              const childZoomLimit = Number.isFinite(maxZoom)
                ? Math.min(maxZoom, Math.max(maxAllowedZoom, 12))
                : 12;
              const childTarget = computeChildClusterTarget(bucketData, safeCurrentZoom, childZoomLimit);
              const hasChildTarget = childTarget && Array.isArray(childTarget.center) && childTarget.center.length >= 2;
              const targetCenter = hasChildTarget
                ? [childTarget.center[0], childTarget.center[1]]
                : [coords[0], coords[1]];
              const desiredLeafZoom = Number.isFinite(maxZoom) ? Math.min(12, maxZoom) : 12;
              let finalZoom;
              if(hasChildTarget){
                const childZoom = childTarget && Number.isFinite(childTarget.zoom)
                  ? Math.min(childTarget.zoom, childZoomLimit)
                  : NaN;
                finalZoom = Number.isFinite(childZoom) ? childZoom : safeCurrentZoom;
                if(finalZoom < safeCurrentZoom){
                  finalZoom = safeCurrentZoom;
                }
              } else {
                finalZoom = Number.isFinite(desiredLeafZoom) ? desiredLeafZoom : safeCurrentZoom;
                if(finalZoom < safeCurrentZoom){
                  finalZoom = safeCurrentZoom;
                }
              }
              if(!Number.isFinite(finalZoom)){
                finalZoom = safeCurrentZoom;
              }
              let currentPitch = null;
              try{
                currentPitch = typeof mapInstance.getPitch === 'function' ? mapInstance.getPitch() : null;
              }catch(err){
                currentPitch = null;
              }
              try{
                const flight = { center: targetCenter, zoom: finalZoom, essential: true };
                if(Number.isFinite(currentPitch)){
                  flight.pitch = currentPitch;
                }
                if(typeof mapInstance.flyTo === 'function'){
                  mapInstance.flyTo(Object.assign({}, flight, {
                    speed: 1.35,
                    curve: 1.5,
                    easing: t => 1 - Math.pow(1 - t, 3)
                  }));
                } else {
                  mapInstance.easeTo(Object.assign({}, flight, { duration: 650, easing: t => 1 - Math.pow(1 - t, 3) }));
                }
              }catch(err){ console.error(err); }
            };
            mapInstance.on('click', CLUSTER_LAYER_ID, handleClusterClick);
            mapInstance.on('mouseenter', CLUSTER_LAYER_ID, ()=>{ mapInstance.getCanvas().style.cursor = 'pointer'; });
            mapInstance.on('mouseleave', CLUSTER_LAYER_ID, ()=>{ mapInstance.getCanvas().style.cursor = 'grab'; });
            mapInstance.__clusterEventsBound = true;
          }
          if(mapInstance === map){
            updateLayerVisibility(lastKnownZoom);
          }
        }
        logoEls = [document.querySelector('.button--header-logo-small')].filter(Boolean);
        let ensureMapIcon = null;
      function updateLogoClickState(){
        logoEls.forEach(el=>{
          el.style.cursor = 'pointer';
          el.style.pointerEvents = 'auto';
        });
      }
      updateLogoClickState();

      // Scale welcome modal map controls to match logo width
      function scaleWelcomeControls(){
        const controls = document.querySelector('#welcomeBody .map-controls-welcome');
        const modalContent = document.querySelector('#welcome-modal .modal-content');
        if(!controls || !modalContent) return;
        
        // Reset zoom to measure natural width
        controls.style.zoom = '1';
        
        // Wait a frame for layout to recalculate after zoom reset
        requestAnimationFrame(() => {
          const controlsWidth = controls.offsetWidth;
          const targetWidth = modalContent.offsetWidth - 40; // Modal minus padding
          
          if(controlsWidth > 0 && targetWidth > 0){
            const scale = targetWidth / controlsWidth;
            controls.style.zoom = scale;
            
            // Apply inverse zoom to suggestions dropdown so text stays normal size
            const suggestions = controls.querySelector('.mapboxgl-ctrl-geocoder .suggestions');
            if(suggestions){
              suggestions.style.zoom = 1 / scale;
            }
            // Also set CSS variable for dynamic inverse zoom
            controls.style.setProperty('--inverse-zoom', 1 / scale);
          }
        });
      }
        
      async function openWelcome(){
        const popup = document.getElementById('welcome-modal');
        if(!popup) return;
        
        openPanel(popup);
        const body = document.getElementById('welcomeBody');
        if(body){
          body.style.padding = '20px';
        }
        
        // Scale controls to match logo width (delay for modal layout to settle)
        setTimeout(() => scaleWelcomeControls(), 50);
      }
      window.openWelcome = openWelcome;

      function toggleWelcome(){
        const popup = document.getElementById('welcome-modal');
        if(popup.classList.contains('show')){
          closePanel(popup);
        } else {
          openWelcome();
        }
      }

      logoEls.forEach(el=>{
        el.addEventListener('click', (e) => {
          e.stopPropagation();
          if(spinning){
            toggleWelcome();
            return;
          }
          if(spinLogoClick && map && map.getZoom() <= spinZoomMax){
            spinEnabled = true;
            startSpin(true);
          }
          toggleWelcome();
        });
      });
    // 'Post Panel' is defined as the current map bounds
    let postPanel = null;
    let posts = [], filtered = [], adPosts = [], adIndex = -1, adTimer = null, adPanel = null, adIdsKey = '', pendingPostLoad = false;
    let filtersInitialized = false;
    let favToTop = false, favSortDirty = true, currentSort = 'az';
    let selection = { cats: new Set(), subs: new Set() };
    let viewHistory = loadHistory();
    let postSourceEventsBound = false;
    let touchMarker = null;
    let activePostId = null;
    let markerFeatureIndex = new Map();
    let lastHighlightedPostIds = [];
    let highlightedFeatureKeys = [];
    let hoveredPostIds = [];
    // Function to update feature states (isExpanded, isActive) for map card composites based on click/open state
    function updateMarkerLabelHighlightIconSize(){
      if(!map || typeof map.setFeatureState !== 'function') return;
      
      const openPostEl = document.querySelector('.open-post[data-id]');
      const openPostId = openPostEl && openPostEl.dataset ? String(openPostEl.dataset.id || '') : '';
      const clickedPostId = activePostId !== undefined && activePostId !== null ? String(activePostId) : '';
      const expandedPostId = openPostId || clickedPostId;
      
      // Reset all features to not expanded/active
      highlightedFeatureKeys.forEach(entry => {
        try{ 
          map.setFeatureState({ source: entry.source, id: entry.id }, { isExpanded: false, isActive: false }); 
        }catch(err){}
      });
      
      // Also reset all features in markerFeatureIndex to ensure clean state
      if(markerFeatureIndex instanceof Map){
        markerFeatureIndex.forEach((entries, postId) => {
          if(entries && Array.isArray(entries)){
            entries.forEach(entry => {
              if(!entry) return;
              const source = entry.source || 'posts';
              const featureId = entry.id;
              if(featureId !== undefined && featureId !== null && String(postId) !== String(expandedPostId)){
                try{ 
                  map.setFeatureState({ source: source, id: featureId }, { isExpanded: false, isActive: false }); 
                }catch(err){}
              }
            });
          }
        });
      }
      
      // Set expanded and active state for clicked/open post
      if(expandedPostId){
        const entries = markerFeatureIndex instanceof Map ? markerFeatureIndex.get(expandedPostId) : null;
        if(entries && entries.length){
          entries.forEach(entry => {
            if(!entry) return;
            const source = entry.source || 'posts';
            const featureId = entry.id;
            if(featureId !== undefined && featureId !== null){
              try{ 
                map.setFeatureState({ source: source, id: featureId }, { isExpanded: true, isActive: true }); 
              }catch(err){}
            }
          });
        }
      }
    }
    
    function updateMapFeatureHighlights(targets){
      const input = Array.isArray(targets) ? targets : [targets];
      const seen = new Set();
      const normalized = [];
      const highlightSpriteIds = new Set();
      input.forEach(entry => {
        if(entry === undefined || entry === null) return;
        let idValue;
        let venueKeyValue = null;
        if(typeof entry === 'object' && !Array.isArray(entry)){
          const rawId = entry.id ?? entry.postId ?? entry.postID ?? entry.postid;
          if(rawId === undefined || rawId === null) return;
          idValue = String(rawId);
          const rawVenue = entry.venueKey ?? entry.venue_key ?? entry.venue;
          if(rawVenue !== undefined && rawVenue !== null){
            const venueString = String(rawVenue).trim();
            if(venueString){
              venueKeyValue = venueString;
            }
          }
        } else {
          idValue = String(entry);
        }
        if(!idValue) return;
        const dedupeKey = venueKeyValue ? `${idValue}::${venueKeyValue}` : idValue;
        if(seen.has(dedupeKey)) return;
        seen.add(dedupeKey);
        normalized.push({ id: idValue, venueKey: venueKeyValue });
      });
      lastHighlightedPostIds = normalized.map(item => ({ id: item.id, venueKey: item.venueKey }));
      if(!map || typeof map.setFeatureState !== 'function'){
        if(!normalized.length){
          highlightedFeatureKeys = [];
        }
        return;
      }
      if(!normalized.length){
        highlightedFeatureKeys.forEach(entry => {
          try{ map.setFeatureState({ source: entry.source, id: entry.id }, { isHighlighted: false }); }
          catch(err){}
        });
        highlightedFeatureKeys = [];
        return;
      }
      const nextEntries = [];
      const nextKeys = new Set();
      const extractVenueFromId = (featureId)=>{
        if(typeof featureId !== 'string') return '';
        const parts = featureId.split('::');
        return parts.length >= 3 ? String(parts[1] || '') : '';
      };
      normalized.forEach(target => {
        if(!target || !target.id) return;
        const entries = markerFeatureIndex instanceof Map ? markerFeatureIndex.get(target.id) : null;
        if(!entries || !entries.length) return;
        entries.forEach(entry => {
          if(!entry) return;
          const source = entry.source || 'posts';
          const featureId = entry.id;
          if(featureId === undefined || featureId === null) return;
          if(target.venueKey){
            const entryVenueKey = entry.venueKey ? String(entry.venueKey) : extractVenueFromId(featureId);
            if(!entryVenueKey || entryVenueKey !== target.venueKey){
              return;
            }
          }
          const compositeKey = `${source}::${featureId}`;
          if(nextKeys.has(compositeKey)) return;
          nextKeys.add(compositeKey);
          nextEntries.push({ source, id: featureId });
          if(entry.spriteId){
            const spriteValue = String(entry.spriteId);
            if(spriteValue){
              highlightSpriteIds.add(spriteValue);
            }
          }
        });
      });
      highlightedFeatureKeys.forEach(entry => {
        const compositeKey = `${entry.source}::${entry.id}`;
        if(nextKeys.has(compositeKey)) return;
        try{ map.setFeatureState({ source: entry.source, id: entry.id }, { isHighlighted: false }); }
        catch(err){}
      });
      nextEntries.forEach(entry => {
        try{ map.setFeatureState({ source: entry.source, id: entry.id }, { isHighlighted: true }); }
        catch(err){}
      });
      highlightedFeatureKeys = nextEntries;
      
      // Update icon-size based on click/open state
      updateMarkerLabelHighlightIconSize();
      if(highlightSpriteIds.size){
        highlightSpriteIds.forEach(spriteId => {
        });
      }
    }
    let selectedVenueKey = null;
    const BASE_URL = (()=>{ let b = location.origin + location.pathname.split('/post/')[0]; if(!b.endsWith('/')) b+='/'; return b; })();

    const $ = (sel, root=document) => root.querySelector(sel);
    const $$ = (sel, root=document) => Array.from(root.querySelectorAll(sel));
    const clamp = (n, a, b)=> Math.max(a, Math.min(b, n));
    const toRad = d => d * Math.PI / 180;
    function distKm(a,b){ const dLat = toRad(b.lat - a.lat), dLng = toRad(b.lng - a.lng); const s = Math.sin(dLat/2)**2 + Math.cos(toRad(a.lat))*Math.cos(toRad(b.lat))*Math.sin(Math.PI*(b.lng - a.lng)/360)**2; return 2 * 6371 * Math.asin(Math.sqrt(s)); }
    const sleep = ms => new Promise(r=>setTimeout(r,ms));
    const nextFrame = ()=> new Promise(r=> requestAnimationFrame(()=>r()));

    // Ensure result lists occupy available space between the header and footer
    function adjustListHeight(){
      const rootStyles = getComputedStyle(document.documentElement);
      const headerH = parseFloat(rootStyles.getPropertyValue('--header-h')) || 0;
      const subH = parseFloat(rootStyles.getPropertyValue('--subheader-h')) || 0;
      const footerH = parseFloat(rootStyles.getPropertyValue('--footer-h')) || 0;
      const safeTop = parseFloat(rootStyles.getPropertyValue('--safe-top')) || 0;
      let viewportHeight = getViewportHeight();
      if(!Number.isFinite(viewportHeight) || viewportHeight <= 0){
        viewportHeight = headerH + subH + footerH + safeTop;
      }
      let availableHeight = Math.max(0, viewportHeight - headerH - subH - footerH - safeTop);
      if(!Number.isFinite(availableHeight) || availableHeight < 0){
        availableHeight = 0;
      }
      const root = document.documentElement;
      if(root){
        const fullHeight = (Number.isFinite(viewportHeight) && viewportHeight > 0)
          ? viewportHeight
          : (availableHeight + headerH + subH + footerH + safeTop);
        if(Number.isFinite(fullHeight) && fullHeight > 0){
          root.style.setProperty('--vh', `${(fullHeight / 100)}px`);
        }
        if(availableHeight > 0){
          root.style.setProperty('--panel-area-height', `${availableHeight}px`);
          root.style.setProperty('--boards-area-height', `${availableHeight}px`);
        } else {
          root.style.removeProperty('--panel-area-height');
          root.style.removeProperty('--boards-area-height');
        }
      }
      document.querySelectorAll('.recents-board, .quick-list-board, .post-board, .ad-board').forEach(list=>{
        if(availableHeight > 0){
          const value = `${availableHeight}px`;
          list.style.height = value;
          list.style.maxHeight = value;
          list.style.minHeight = value;
        } else {
          list.style.removeProperty('height');
          list.style.removeProperty('max-height');
          list.style.removeProperty('min-height');
        }
      });
    }
    window.adjustListHeight = adjustListHeight;
    if(window.visualViewport){
      window.visualViewport.addEventListener('resize', adjustListHeight);
      addPassiveScrollListener(window.visualViewport, adjustListHeight);
    }
    window.addEventListener('resize', adjustListHeight);
    window.addEventListener('orientationchange', adjustListHeight);

    let stickyScrollHandler = null;
      function updateStickyImages(){
        const root = document.documentElement;
        const openPost = document.querySelector('.post-board .open-post');
        const body = openPost ? openPost.querySelector('.post-body') : null;
        const imgArea = body ? body.querySelector('.post-images') : null;
        const cardHeader = openPost ? openPost.querySelector('.post-card') : null;
        document.body.classList.remove('hide-map-calendar');
        if(!openPost || !body || !imgArea || !cardHeader){
          document.body.classList.remove('open-post-sticky-images');
          root.style.removeProperty('--open-post-header-h');
          return;
        }
        root.style.setProperty('--open-post-header-h', cardHeader.offsetHeight + 'px');
        document.body.classList.add('open-post-sticky-images');
      }

    window.updateStickyImages = updateStickyImages;

    function updateLayoutVars(){
      const root = document.documentElement;
      const header = document.querySelector('.container--header');
      if(header){
        const headerStyles = getComputedStyle(header);
        const safeTop = parseFloat(headerStyles.paddingTop) || 0;
        const rect = header.getBoundingClientRect();
        let measured = Number.isFinite(rect.height) ? rect.height : 0;
        if(!measured || measured <= safeTop){
          const fallbackOffset = Number.isFinite(header.offsetHeight) ? header.offsetHeight : 0;
          measured = fallbackOffset;
        }
        if(!measured || measured <= safeTop){
          const fallbackScroll = Number.isFinite(header.scrollHeight) ? header.scrollHeight : 0;
          measured = fallbackScroll;
        }
        measured = Math.max(0, measured - safeTop);
        if(!measured){
          const rootStyles = getComputedStyle(root);
          const current = parseFloat(rootStyles.getPropertyValue('--header-h')) || 0;
          if(current > 0){
            measured = current;
          }
        }
        if(measured > 0){
          root.style.setProperty('--header-h', `${measured}px`);
        }
      }
      if(typeof window.adjustListHeight === 'function'){
        window.adjustListHeight();
      }
    }
    window.updateLayoutVars = updateLayoutVars;

    function updatePostPanel(){ if(map) postPanel = map.getBounds(); }

    // === 0528 helpers: contextmenu list (robust positioning + locking) ===
    let listLocked = false;
    function lockMap(lock){
      listLocked = lock;
      const fn = lock ? 'disable' : 'enable';
      try{ map.dragPan[fn](); }catch(e){}
      try{ map.scrollZoom[fn](); }catch(e){}
      try{ map.boxZoom[fn](); }catch(e){}
      try{ map.keyboard[fn](); }catch(e){}
      try{ map.doubleClickZoom[fn](); }catch(e){}
      try{ map.touchZoomRotate[fn](); }catch(e){}
    }
    // Get interactive layers based on map card display mode
    // Moved to map.js - use window.MapCardComposites.getMarkerInteractiveLayers
    const getMarkerInteractiveLayers = window.MapCardComposites && window.MapCardComposites.getMarkerInteractiveLayers 
      ? window.MapCardComposites.getMarkerInteractiveLayers 
      : function(){ return ['mapmarker-icon']; };
    window.__overCard = window.__overCard || false;

    function getPopupElement(popup){
      return popup && typeof popup.getElement === 'function' ? popup.getElement() : null;
    }


    // Moved to map.js - use window.MapCardComposites functions (NO FALLBACKS)
    const MULTI_POST_MARKER_ICON_ID = window.MapCardComposites.MULTI_POST_MARKER_ICON_ID;
    
    // Note: DOM-related map card container functions were removed from map.js and are not used here

    function escapeAttrValue(value){
      const raw = String(value);
      if(typeof window !== 'undefined' && window.CSS && typeof window.CSS.escape === 'function'){
        try{ return window.CSS.escape(raw); }catch(err){ /* fall through */ }
      }
      return raw.replace(/"/g, '\\"').replace(/\\/g, '\\\\');
    }


    function syncPostCardHighlights(){
      const highlightClass = 'is-map-highlight';
      const isSurfaceHighlightTarget = (el)=> !!(el && el.classList && el.classList.contains('post-card'));
      const restoreHighlightBackground = (el)=>{
        if(!isSurfaceHighlightTarget(el) || !el.dataset) return;
        if(Object.prototype.hasOwnProperty.call(el.dataset, 'prevHighlightBackground')){
          const prev = el.dataset.prevHighlightBackground;
          delete el.dataset.prevHighlightBackground;
          if(prev){
            el.style.background = prev;
            return;
          }
        }
        if(Object.prototype.hasOwnProperty.call(el.dataset, 'surfaceBg')){
          el.style.background = el.dataset.surfaceBg;
        } else {
          el.style.removeProperty('background');
        }
      };
      const applyHighlightBackground = (el)=>{
        if(!isSurfaceHighlightTarget(el) || !el.dataset) return;
        if(!Object.prototype.hasOwnProperty.call(el.dataset, 'prevHighlightBackground')){
          el.dataset.prevHighlightBackground = el.style.background || '';
        }
        el.style.background = CARD_HIGHLIGHT;
      };
      const restoreAttr = (el)=>{
        if(!el || !el.dataset) return;
        if(Object.prototype.hasOwnProperty.call(el.dataset, 'prevAriaSelected')){
          const prev = el.dataset.prevAriaSelected;
          if(prev){
            el.setAttribute('aria-selected', prev);
          } else {
            el.removeAttribute('aria-selected');
          }
          delete el.dataset.prevAriaSelected;
        }
      };
      document.querySelectorAll(`.post-card.${highlightClass}`).forEach(el => {
        el.classList.remove(highlightClass);
        restoreAttr(el);
        restoreHighlightBackground(el);
      });

      let fallbackId = '';
      if(activePostId !== undefined && activePostId !== null){
        fallbackId = String(activePostId);
      } else {
        const openEl = document.querySelector('.post-board .open-post[data-id]');
        fallbackId = openEl && openEl.dataset ? String(openEl.dataset.id || '') : '';
      }
      // Use window.hoveredPostIds if set (from map.js), otherwise local variable
      const currentHoveredIds = Array.isArray(window.hoveredPostIds) ? window.hoveredPostIds : hoveredPostIds;
      const idsToHighlight = Array.from(new Set([
        fallbackId,
        ...currentHoveredIds.map(entry => entry.id)
      ].filter(Boolean)));
      if(!idsToHighlight.length){
        updateMapFeatureHighlights([]);
        return;
      }
      const applyHighlight = (el)=>{
        if(!el) return;
        if(el.dataset && !Object.prototype.hasOwnProperty.call(el.dataset, 'prevAriaSelected')){
          el.dataset.prevAriaSelected = el.hasAttribute('aria-selected') ? el.getAttribute('aria-selected') : '';
        }
        el.classList.add(highlightClass);
        el.setAttribute('aria-selected', 'true');
        applyHighlightBackground(el);
      };
      const globalVenueKey = typeof selectedVenueKey === 'string' && selectedVenueKey ? String(selectedVenueKey).trim() : '';
      const highlightTargets = [];
      const targetSeen = new Set();
      idsToHighlight.forEach(id => {
        const strId = String(id);
        const selectorId = escapeAttrValue(strId);
        const listCard = postsWideEl ? postsWideEl.querySelector(`.post-card[data-id="${selectorId}"]`) : null;
        applyHighlight(listCard);
        // Don't highlight open post cards - they should maintain their #1f2750 background
        const preferredVenue = globalVenueKey;
        const normalizedVenue = preferredVenue ? String(preferredVenue).trim() : '';
        const dedupeKey = normalizedVenue ? `${strId}::${normalizedVenue}` : strId;
        if(!targetSeen.has(dedupeKey)){
          targetSeen.add(dedupeKey);
          highlightTargets.push({ id: strId, venueKey: normalizedVenue || null });
        }
      });
      // Also include hovered posts with their venue keys
      currentHoveredIds.forEach(entry => {
        if(!entry || !entry.id) return;
        const strId = String(entry.id);
        const normalizedVenue = entry.venueKey ? String(entry.venueKey).trim() : '';
        const dedupeKey = normalizedVenue ? `${strId}::${normalizedVenue}` : strId;
        if(!targetSeen.has(dedupeKey)){
          targetSeen.add(dedupeKey);
          highlightTargets.push({ id: strId, venueKey: normalizedVenue || null });
        }
      });
      updateMapFeatureHighlights(highlightTargets);
    }
    
    // Add postcard hover handlers to trigger mapcard highlight
    const handlePostcardHover = (e) => {
      const postcard = e.target.closest('.post-card');
      if(!postcard || !postcard.dataset || !postcard.dataset.id) return;
      const id = String(postcard.dataset.id);
      hoveredPostIds = [{ id: id, venueKey: null }];
      window.hoveredPostIds = hoveredPostIds;
      syncPostCardHighlights();
      // Sync map card hover state (use findMarkerByPostId for multi-post support)
      if(window.MapCards){
        const markerInfo = window.MapCards.findMarkerByPostId ? window.MapCards.findMarkerByPostId(id) : null;
        if(markerInfo && window.MapCards.setMapCardHover){
          window.MapCards.setMapCardHover(markerInfo.markerId);
        }
      }
    };
    
    const handlePostcardLeave = (e) => {
      const postcard = e.target.closest('.post-card');
      if(!postcard) return;
      // Only clear if we're actually leaving the postcard (not moving to a child)
      const relatedTarget = e.relatedTarget;
      if(!relatedTarget || !postcard.contains(relatedTarget)){
        const id = postcard.dataset.id;
        hoveredPostIds = [];
        window.hoveredPostIds = hoveredPostIds;
        syncPostCardHighlights();
        // Remove map card hover state (use findMarkerByPostId for multi-post support)
        if(window.MapCards && id){
          const markerInfo = window.MapCards.findMarkerByPostId ? window.MapCards.findMarkerByPostId(id) : null;
          if(markerInfo && window.MapCards.removeMapCardHover){
            window.MapCards.removeMapCardHover(markerInfo.markerId);
          }
        }
      }
    };
    
    // Expose hover state and sync function to window for map.js access
    window.hoveredPostIds = hoveredPostIds;
    window.syncPostCardHighlights = syncPostCardHighlights;
    
    // Add postcard hover handlers using event delegation on .post-board
    const postsWideElForHover = document.querySelector('.post-board');
    if(postsWideElForHover){
      postsWideElForHover.addEventListener('mouseenter', handlePostcardHover, true);
      postsWideElForHover.addEventListener('mouseleave', handlePostcardLeave, true);
    }

    function hashString(str){
      let hash = 0;
      for(let i=0;i<str.length;i++){
        hash = ((hash << 5) - hash) + str.charCodeAt(i);
        hash |= 0;
      }
      return hash.toString(36);
    }

// --- Section 6: Marker Data Building & Collections ---
function countMarkersForVenue(postsAtVenue, venueKey, bounds){
  if(!Array.isArray(postsAtVenue) || !postsAtVenue.length){
    return 0;
  }
  const key = typeof venueKey === 'string' && venueKey ? venueKey : null;
  const normalizedBounds = bounds ? normalizeBounds(bounds) : null;
  const markerInBounds = (lng, lat)=>{
    const lon = Number(lng);
    const la = Number(lat);
    if(!Number.isFinite(lon) || !Number.isFinite(la)) return false;
    if(!normalizedBounds) return true;
    return pointWithinBounds(lon, la, normalizedBounds);
  };
  if(key){
    return postsAtVenue.reduce((total, post) => {
      if(!post) return total;
      let count = 0;
      if(Array.isArray(post.locations) && post.locations.length){
        count = post.locations.reduce((sum, loc) => {
          if(!loc) return sum;
          const lng = Number(loc.lng);
          const lat = Number(loc.lat);
          if(!Number.isFinite(lng) || !Number.isFinite(lat)) return sum;
          if(toVenueCoordKey(lng, lat) !== key) return sum;
          return markerInBounds(lng, lat) ? sum + 1 : sum;
        }, 0);
      }
      if(!count && Number.isFinite(post.lng) && Number.isFinite(post.lat) && toVenueCoordKey(post.lng, post.lat) === key && markerInBounds(post.lng, post.lat)){
        count = 1;
      }
      return total + (count || 0);
    }, 0);
  }
  return postsAtVenue.reduce((total, post) => {
    if(!post) return total;
    let count = 0;
    if(Array.isArray(post.locations) && post.locations.length){
      count += post.locations.reduce((sum, loc) => {
        if(!loc) return sum;
        const lng = Number(loc.lng);
        const lat = Number(loc.lat);
        if(!Number.isFinite(lng) || !Number.isFinite(lat)) return sum;
        return markerInBounds(lng, lat) ? sum + 1 : sum;
      }, 0);
    }
    if((!Array.isArray(post.locations) || !post.locations.length) && Number.isFinite(post.lng) && Number.isFinite(post.lat) && markerInBounds(post.lng, post.lat)){
      count += 1;
    }
    return total + count;
  }, 0);
}

function mulberry32(a){ return function(){var t=a+=0x6D2B79F5; t=Math.imul(t^t>>>15, t|1); t^=t+Math.imul(t^t>>>7, t|61); return ((t^t>>>14)>>>0)/4294967296; }; }
    const rnd = mulberry32(42);

    const cities = [
      {n:"Melbourne, Australia", c:[144.9631,-37.8136]},
      {n:"Sydney, Australia", c:[151.2093,-33.8688]},
      {n:"London, UK", c:[-0.1276,51.5072]},
      {n:"New York, USA", c:[-74.0060,40.7128]},
      {n:"Tokyo, Japan", c:[139.6917,35.6895]},
      {n:"Paris, France", c:[2.3522,48.8566]},
      {n:"Rio de Janeiro, Brazil", c:[-43.1729,-22.9068]},
      {n:"Cape Town, South Africa", c:[18.4241,-33.9249]},
      {n:"Reykjavk, Iceland", c:[-21.8174,64.1265]},
      {n:"Mumbai, India", c:[72.8777,19.0760]}
    ];

    // NO CACHING - Always fetch fresh formbuilder snapshot for development

    function getSavedFormbuilderSnapshot(){
      if(window.formbuilderStateManager && typeof window.formbuilderStateManager.getSaved === 'function'){
        try{
          const snapshot = window.formbuilderStateManager.getSaved();
          if(snapshot && typeof snapshot === 'object'){
            return snapshot;
          }
        }catch(err){
          console.error('Failed to read saved formbuilder snapshot', err);
          return null;
        }
      }
      return null;
    }

    async function fetchSavedFormbuilderSnapshot(){
      // Use deduplicated request with cache
      try{
        const response = await apiRequest('/gateway.php?action=get-form', {
          method: 'GET',
          headers: { 'Accept': 'application/json' },
        }, 10000); // 10 second cache for form data
        
        const text = await response.text();
        let data;
        try{
          data = JSON.parse(text);
        }catch(parseErr){
          throw new Error('The server returned an unexpected response.');
        }
        if(!response.ok || !data || data.success !== true || !data.snapshot){
          const message = data && typeof data.message === 'string' && data.message.trim()
            ? data.message.trim()
            : 'Unable to load form definitions.';
          throw new Error(message);
        }
        return data.snapshot;
      } catch(error) {
        throw error;
      }
    }

    if(typeof window !== 'undefined'){
      window.fetchSavedFormbuilderSnapshot = fetchSavedFormbuilderSnapshot;
    }

    function cloneFieldValue(value){
      if(value === null || value === undefined){
        return null;
      }
      if(Array.isArray(value)){
        return value.map(cloneFieldValue).filter(v => v !== null && v !== undefined);
      }
      if(value && typeof value === 'object'){
        try{
          return JSON.parse(JSON.stringify(value));
        }catch(err){
          return { ...value };
        }
      }
      return value;
    }

    const DEFAULT_FORMBUILDER_SNAPSHOT = {
      categories: [],
      currencies: [],
      categoryIconPaths: {},
      subcategoryIconPaths: {},
      fieldsets: []
    };

    function resolveFieldsetDisplayName(option){
      if(!option || typeof option !== 'object'){
        return '';
      }
      const candidates = [
        option.fieldset_name,
        option.fieldsetName,
        option.fieldset_name,
        option.name,
        option.label
      ];
      for(const candidate of candidates){
        if(typeof candidate === 'string'){
          const trimmed = candidate.trim();
          if(trimmed){
            return trimmed;
          }
        }
      }
      return '';
    }

    function normalizeFieldsetOptions(options){
      const list = Array.isArray(options)
        ? options
        : Array.isArray(options && options.fieldsets)
          ? options.fieldsets
          : [];
      const normalized = [];
      const seen = new Set();
      const pushOption = (value, label, source=null)=>{
        const trimmedValue = typeof value === 'string' ? value.trim() : '';
        if(!trimmedValue){
          return;
        }
        const dedupeKey = trimmedValue.toLowerCase();
        if(seen.has(dedupeKey)){
          return;
        }
        const trimmedLabel = typeof label === 'string' ? label.trim() : '';
        const sourceName = resolveFieldsetDisplayName(source);
        const displayName = sourceName || trimmedLabel || trimmedValue;
        const option = {
          value: trimmedValue,
          label: displayName,
          name: displayName,
          fieldsetName: displayName,
          fieldset_name: displayName,
          fieldsetKey: trimmedValue,
          fieldset_key: trimmedValue
        };
        if(source && typeof source === 'object'){
          // Preserve ALL properties from source (especially id and fieldset_tooltip)
          Object.keys(source).forEach(key => {
            if(source[key] !== undefined && source[key] !== null){
              option[key] = source[key];
            }
          });
          // Override with specific normalized values
          if(typeof source.placeholder === 'string' && source.placeholder){
            option.placeholder = source.placeholder;
          }
          if(typeof source.type === 'string' && source.type){
            option.type = source.type;
          }
          if(typeof source.formbuilder_editable !== 'undefined'){
            // Handle both boolean (true/false) and numeric (0/1) values from database
            option.formbuilder_editable = source.formbuilder_editable === true || source.formbuilder_editable === 1 || source.formbuilder_editable === '1';
          }
          if(typeof source.sort_order !== 'undefined'){
            option.sort_order = source.sort_order;
          }
        }
        normalized.push(option);
        seen.add(dedupeKey);
      };
      list.forEach(item => {
        if(item && typeof item === 'object'){
          const value = typeof item.value === 'string' && item.value.trim()
            ? item.value.trim()
            : typeof item.key === 'string' && item.key.trim()
              ? item.key.trim()
              : typeof item.fieldset_key === 'string' && item.fieldset_key.trim()
                ? item.fieldset_key.trim()
                : typeof item.fieldsetKey === 'string' && item.fieldsetKey.trim()
                  ? item.fieldsetKey.trim()
                  : typeof item.id === 'number' && Number.isFinite(item.id)
                        ? String(item.id)
                        : typeof item.id === 'string' && item.id.trim()
                          ? item.id.trim()
                          : '';
          if(!value){
            return;
          }
          const label = typeof item.name === 'string' && item.name.trim()
            ? item.name.trim()
            : typeof item.fieldset_name === 'string' && item.fieldset_name.trim()
              ? item.fieldset_name.trim()
              : typeof item.fieldsetName === 'string' && item.fieldsetName.trim()
                ? item.fieldsetName.trim()
                : '';
          pushOption(value, label, item);
          return;
        }
        if(typeof item === 'string'){
          const trimmed = item.trim();
          if(trimmed){
            pushOption(trimmed, trimmed);
          }
        }
      });
      return normalized;
    }

    function normalizeCategoriesSnapshot(sourceCategories){
      const list = Array.isArray(sourceCategories) ? sourceCategories : [];
      const parseId = value => {
        if(typeof value === 'number' && Number.isInteger(value) && value >= 0){
          return value;
        }
        if(typeof value === 'string' && value.trim() && /^\d+$/.test(value.trim())){
          return parseInt(value.trim(), 10);
        }
        return null;
      };
      const normalized = list.map(item => {
        if(!item || typeof item !== 'object') return null;
        const name = typeof item.name === 'string' ? item.name : '';
        if(!name) return null;
        const subIdsSource = (item.subIds && typeof item.subIds === 'object' && !Array.isArray(item.subIds)) ? item.subIds : {};
        const rawSubs = Array.isArray(item.subs) ? item.subs : [];
        const subs = [];
        const subIdMap = {};
        rawSubs.forEach(entry => {
          if(typeof entry === 'string'){
            const subName = entry.trim();
            if(!subName) return;
            subs.push(subName);
            if(Object.prototype.hasOwnProperty.call(subIdsSource, entry)){
              const parsed = parseId(subIdsSource[entry]);
              if(parsed !== null){
                subIdMap[subName] = parsed;
              }
            }
            return;
          }
          if(entry && typeof entry === 'object'){
            const subName = typeof entry.name === 'string' ? entry.name.trim() : '';
            if(!subName) return;
            subs.push(subName);
            const parsed = parseId(entry.id);
            if(parsed !== null){
              subIdMap[subName] = parsed;
            } else if(Object.prototype.hasOwnProperty.call(subIdsSource, subName)){
              const fromMap = parseId(subIdsSource[subName]);
              if(fromMap !== null){
                subIdMap[subName] = fromMap;
              }
            }
          }
        });
        const rawSubFields = (item.subFields && typeof item.subFields === 'object' && !Array.isArray(item.subFields)) ? item.subFields : {};
        const subFields = {};
        subs.forEach(sub => {
          const fields = Array.isArray(rawSubFields[sub]) ? rawSubFields[sub].map(cloneFieldValue).filter(f => f !== null && f !== undefined) : [];
          subFields[sub] = fields;
        });
        const sortOrder = normalizeCategorySortOrderValue(item.sort_order ?? item.sortOrder);
        const subHidden = (item.subHidden && typeof item.subHidden === 'object' && !Array.isArray(item.subHidden)) ? item.subHidden : {};
        const subFees = (item.subFees && typeof item.subFees === 'object' && !Array.isArray(item.subFees)) ? item.subFees : {};
        return { id: parseId(item.id), name, subs, subFields, subIds: subIdMap, subHidden, subFees, sort_order: sortOrder };
      }).filter(Boolean);
      const base = normalized.length ? normalized : DEFAULT_FORMBUILDER_SNAPSHOT.categories.map(cat => ({
        id: null,
        name: cat.name,
        subs: cat.subs.slice(),
        subIds: cat.subs.reduce((acc, sub) => {
          acc[sub] = null;
          return acc;
        }, {}),
        subFields: cat.subs.reduce((acc, sub) => {
          acc[sub] = [];
          return acc;
        }, {}),
        subHidden: {},
        subFees: {},
        sort_order: normalizeCategorySortOrderValue(cat && (cat.sort_order ?? cat.sortOrder))
      }));
      base.forEach(cat => {
        if(!cat.subFields || typeof cat.subFields !== 'object' || Array.isArray(cat.subFields)){
          cat.subFields = {};
        }
        if(!cat.subIds || typeof cat.subIds !== 'object' || Array.isArray(cat.subIds)){
          cat.subIds = {};
        }
        if(!cat.subHidden || typeof cat.subHidden !== 'object' || Array.isArray(cat.subHidden)){
          cat.subHidden = {};
        }
        if(!cat.subFees || typeof cat.subFees !== 'object' || Array.isArray(cat.subFees)){
          cat.subFees = {};
        }
        cat.subs.forEach(sub => {
          if(!Array.isArray(cat.subFields[sub])){
            cat.subFields[sub] = [];
          }
          if(!Object.prototype.hasOwnProperty.call(cat.subIds, sub)){
            cat.subIds[sub] = null;
          }
        });
        cat.sort_order = normalizeCategorySortOrderValue(cat.sort_order ?? cat.sortOrder);
      });
      return base;
    }

    function normalizeFormbuilderSnapshot(snapshot){
      const normalizedCategories = normalizeCategoriesSnapshot(snapshot && snapshot.categories);
      const rawCurrencies = (snapshot && Array.isArray(snapshot.currencies)) ? snapshot.currencies : [];
      const normalizedCurrencies = Array.from(new Set(rawCurrencies
        .map(code => typeof code === 'string' ? code.trim().toUpperCase() : '')
        .filter(Boolean)));
      const normalizedFieldsets = normalizeFieldsetOptions(
        snapshot && snapshot.fieldsets
      );
      const normalizedCategoryIconPaths = normalizeIconPathMap(snapshot && snapshot.categoryIconPaths);
      const normalizedSubcategoryIconPaths = normalizeIconPathMap(snapshot && snapshot.subcategoryIconPaths);
      const normalizedCheckoutOptions = normalizeCheckoutOptions(snapshot && snapshot.checkout_options);
      // Normalize banned words
      const normalizedBannedWords = (snapshot && Array.isArray(snapshot.banned_words))
        ? snapshot.banned_words.filter(w => typeof w === 'string' && w.trim()).map(w => w.toLowerCase().trim())
        : [];
      // Build fieldset limits map from fieldsets (for simple fieldsets like title, description)
      const fieldsetLimits = {};
      if(snapshot && Array.isArray(snapshot.fieldsets)){
        snapshot.fieldsets.forEach(fs => {
          const key = fs.fieldset_key || fs.key || '';
          if(key){
            fieldsetLimits[key] = {
              min_length: fs.min_length !== undefined && fs.min_length !== null ? parseInt(fs.min_length, 10) : null,
              max_length: fs.max_length !== undefined && fs.max_length !== null ? parseInt(fs.max_length, 10) : null,
              show_limit: fs.show_limit !== undefined ? !!fs.show_limit : true
            };
          }
        });
      }
      // Build field limits map from fields table (for sub-fields like item-name, venue-name, address-line)
      const fieldLimits = {};
      if(snapshot && snapshot.field_limits && typeof snapshot.field_limits === 'object'){
        Object.keys(snapshot.field_limits).forEach(fieldKey => {
          const limits = snapshot.field_limits[fieldKey];
          if(limits){
            fieldLimits[fieldKey] = {
              min_length: limits.min_length !== undefined && limits.min_length !== null ? parseInt(limits.min_length, 10) : null,
              max_length: limits.max_length !== undefined && limits.max_length !== null ? parseInt(limits.max_length, 10) : null,
              show_limit: limits.show_limit !== undefined ? !!limits.show_limit : true
            };
          }
        });
      }
      return {
        categories: normalizedCategories,
        currencies: normalizedCurrencies,
        categoryIconPaths: normalizedCategoryIconPaths,
        subcategoryIconPaths: normalizedSubcategoryIconPaths,
        fieldsets: normalizedFieldsets,
        checkoutOptions: normalizedCheckoutOptions,
        bannedWords: normalizedBannedWords,
        fieldsetLimits: fieldsetLimits,
        fieldLimits: fieldLimits
      };
    }

    window.getSavedFormbuilderSnapshot = getSavedFormbuilderSnapshot;
    window.normalizeFormbuilderSnapshot = normalizeFormbuilderSnapshot;

    function getPersistedFormbuilderSnapshotFromGlobals(){
      if(typeof window === 'undefined'){
        return null;
      }
      // Note: Do NOT include window.initialFormbuilderSnapshot here - it's a local placeholder
      // that may have been created before server data loaded. Only use truly persisted snapshots.
      const candidates = [
        window.__persistedFormbuilderSnapshot,
        window.__PERSISTED_FORMBUILDER_SNAPSHOT__,
        window.__FORMBUILDER_SNAPSHOT__,
        window.persistedFormbuilderSnapshot,
        window.formbuilderSnapshot,
        window.formBuilderSnapshot,
        window.__initialFormbuilderSnapshot
      ];
      for(const candidate of candidates){
        // Only use snapshots that have categories AND currencies loaded
        if(candidate && typeof candidate === 'object' && 
           Array.isArray(candidate.categories) && candidate.categories.length > 0 &&
           Array.isArray(candidate.currencies) && candidate.currencies.length > 0){
          return candidate;
        }
      }
      return null;
    }

    // NO CACHING - Always fetch fresh formbuilder snapshot for development

    function getFormbuilderSnapshotPromise() {
      // Check cache first - if already loaded, return immediately
      if (window.__persistedFormbuilderSnapshot && typeof window.__persistedFormbuilderSnapshot === 'object') {
        return Promise.resolve(window.__persistedFormbuilderSnapshot);
      }
      // Check for inline snapshot
      const inlineSnapshot = getPersistedFormbuilderSnapshotFromGlobals();
      if (inlineSnapshot) {
        window.__persistedFormbuilderSnapshot = inlineSnapshot;
        return Promise.resolve(inlineSnapshot);
      }
      // Only fetch if not cached
      if (typeof fetchSavedFormbuilderSnapshot === 'function') {
        return fetchSavedFormbuilderSnapshot().then(snapshot => {
          window.__persistedFormbuilderSnapshot = snapshot;
          return snapshot;
        }).catch(err => {
          console.error('Failed to load formbuilder snapshot', err);
          throw err;
        });
      }
      return Promise.resolve(null);
    }

    if (typeof window !== 'undefined') {
      window.getFormbuilderSnapshotPromise = getFormbuilderSnapshotPromise;
    }

    // NO FALLBACKS - wait for backend snapshot only
    // Note: This will throw if snapshot is not available - errors should be visible
    // For backward compatibility during initialization, create normalized structure
    // but this should not be used if backend snapshot fails
    const getInitialSnapshot = () => {
      const inline = getPersistedFormbuilderSnapshotFromGlobals();
      if(inline && typeof inline === 'object'){
        return normalizeFormbuilderSnapshot(inline);
      }
      // If no inline snapshot, return normalized empty structure
      // This should only be used if backend snapshot is not yet loaded
      return normalizeFormbuilderSnapshot(null);
    };
    const initialFormbuilderSnapshot = getInitialSnapshot();
    function sanitizeFieldsetOptions(options){
      const list = Array.isArray(options) ? options : normalizeFieldsetOptions(options);
      const sanitized = [];
      const seenValues = new Set();
      list.forEach(option => {
        if(option && typeof option === 'object'){
          const rawValue = typeof option.value === 'string' ? option.value.trim() : '';
          if(!rawValue){
            return;
          }
          const dedupeKey = rawValue.toLowerCase();
          if(seenValues.has(dedupeKey)){
            return;
          }
          seenValues.add(dedupeKey);
          const displayName = resolveFieldsetDisplayName(option) || rawValue;
          const sanitizedOption = {
            ...option,
            value: rawValue,
            label: displayName,
            name: displayName,
            fieldsetName: displayName,
            fieldset_name: displayName,
            fieldsetKey: rawValue,
            fieldset_key: rawValue
          };
          // Explicitly preserve fieldset_tooltip if it exists
          if(option.fieldset_tooltip !== undefined){
            sanitizedOption.fieldset_tooltip = option.fieldset_tooltip;
          }
          sanitized.push(sanitizedOption);
          return;
        }
        if(typeof option === 'string'){
          const trimmed = option.trim();
          if(!trimmed){
            return;
          }
          const dedupeKey = trimmed.toLowerCase();
          if(seenValues.has(dedupeKey)){
            return;
          }
          seenValues.add(dedupeKey);
          sanitized.push({
            value: trimmed,
            label: trimmed,
            name: trimmed,
            fieldsetName: trimmed,
            fieldset_name: trimmed,
            fieldsetKey: trimmed,
            fieldset_key: trimmed
          });
        }
      });
      // Sort by sort_order (editable fields with sort_order=100 will be at bottom)
      sanitized.sort((a, b) => {
        const orderA = (typeof a.sort_order === 'number' ? a.sort_order : (a.sort_order ? parseInt(a.sort_order, 10) : 0)) || 0;
        const orderB = (typeof b.sort_order === 'number' ? b.sort_order : (b.sort_order ? parseInt(b.sort_order, 10) : 0)) || 0;
        if(orderA !== orderB){
          return orderA - orderB;
        }
        // If same sort_order, maintain original order (don't sort alphabetically)
        return 0;
      });
      return sanitized;
    }
    const categories = window.categories = initialFormbuilderSnapshot.categories;
    // Currency codes come from backend via currency field options
    window.currencies = Array.isArray(initialFormbuilderSnapshot.currencies) ? initialFormbuilderSnapshot.currencies : [];
    const categoryIcons = window.categoryIcons = window.categoryIcons || {};
    const subcategoryIcons = window.subcategoryIcons = window.subcategoryIcons || {};
    const categoryIconPaths = window.categoryIconPaths = window.categoryIconPaths || {};
    const subcategoryIconPaths = window.subcategoryIconPaths = window.subcategoryIconPaths || {};
    assignMapLike(categoryIconPaths, normalizeIconPathMap(initialFormbuilderSnapshot.categoryIconPaths));
    assignMapLike(subcategoryIconPaths, normalizeIconPathMap(initialFormbuilderSnapshot.subcategoryIconPaths));
    const snapshotFieldsetOptions = Array.isArray(initialFormbuilderSnapshot.fieldsets)
      ? initialFormbuilderSnapshot.fieldsets
      : [];
    const finalFieldsetOptions = sanitizeFieldsetOptions(snapshotFieldsetOptions);
    initialFormbuilderSnapshot.fieldsets = finalFieldsetOptions.map(option => ({ ...option }));
    const FORM_FIELDSETS = window.FORM_FIELDSETS = initialFormbuilderSnapshot.fieldsets.map(option => ({ ...option }));
    const CHECKOUT_OPTIONS = window.CHECKOUT_OPTIONS = Array.isArray(initialFormbuilderSnapshot.checkoutOptions)
      ? initialFormbuilderSnapshot.checkoutOptions.map(opt => ({ ...opt }))
      : [];
    const BANNED_WORDS = window.BANNED_WORDS = Array.isArray(initialFormbuilderSnapshot.bannedWords)
      ? [...initialFormbuilderSnapshot.bannedWords]
      : [];
    // FIELD_LIMITS: keyed by fieldset_key (for simple fieldsets like title, description)
    const FIELD_LIMITS = window.FIELD_LIMITS = (initialFormbuilderSnapshot.fieldsetLimits && typeof initialFormbuilderSnapshot.fieldsetLimits === 'object')
      ? { ...initialFormbuilderSnapshot.fieldsetLimits }
      : {};
    // FIELD_RAW_LIMITS: keyed by field_key (for sub-fields like item-name, venue-name, address-line)
    const FIELD_RAW_LIMITS = window.FIELD_RAW_LIMITS = (initialFormbuilderSnapshot.fieldLimits && typeof initialFormbuilderSnapshot.fieldLimits === 'object')
      ? { ...initialFormbuilderSnapshot.fieldLimits }
      : {};
    window.__formbuilderSnapshot = initialFormbuilderSnapshot;
    
    // Bad word masking: replaces bad words with first letter + asterisks (e.g., "fuck" -> "f***")
    function maskBadWords(text){
      if(!text || typeof text !== 'string') return text;
      const bannedWords = window.BANNED_WORDS || [];
      if(!bannedWords.length) return text;
      let result = text;
      bannedWords.forEach(word => {
        if(!word || word.length < 2) return;
        // Create regex that matches the word (case insensitive, whole word)
        const escapedWord = word.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        const regex = new RegExp(`\\b${escapedWord}\\b`, 'gi');
        result = result.replace(regex, match => {
          return match.charAt(0) + '*'.repeat(match.length - 1);
        });
      });
      return result;
    }
    window.maskBadWords = maskBadWords;
    
    // Get limits for a fieldset (keyed by fieldset_key like 'title', 'description')
    function getFieldLimits(fieldsetKey){
      const limits = window.FIELD_LIMITS || {};
      return limits[fieldsetKey] || { min_length: null, max_length: null, show_limit: true };
    }
    window.getFieldLimits = getFieldLimits;
    
    // Get limits for a field (keyed by field_key like 'item-name', 'venue-name', 'address-line')
    function getFieldLimitsByKey(fieldKey){
      const limits = window.FIELD_RAW_LIMITS || {};
      return limits[fieldKey] || { min_length: null, max_length: null, show_limit: true };
    }
    window.getFieldLimitsByKey = getFieldLimitsByKey;
    
    // Create character counter element for text inputs AND enforce maxlength
    function createCharCounter(input, maxLength, minLength){
      const counter = document.createElement('span');
      counter.className = 'char-counter';
      counter.style.cssText = 'font-size: 11px; color: var(--text-muted, #888); margin-left: 8px; display: none;';
      
      // ENFORCE maxlength via HTML attribute (prevents most excessive input)
      if(maxLength !== null && maxLength > 0){
        input.setAttribute('maxlength', maxLength);
      }
      
      // Handle paste events to truncate oversized content safely
      input.addEventListener('paste', (e) => {
        if(maxLength === null || maxLength <= 0) return;
        
        const pastedText = (e.clipboardData || window.clipboardData)?.getData('text') || '';
        const currentValue = input.value || '';
        const selectionStart = input.selectionStart ?? currentValue.length;
        const selectionEnd = input.selectionEnd ?? currentValue.length;
        
        // Calculate what the new value would be after paste
        const beforeSelection = currentValue.slice(0, selectionStart);
        const afterSelection = currentValue.slice(selectionEnd);
        const newValue = beforeSelection + pastedText + afterSelection;
        
        // If paste would exceed maxlength, truncate and prevent default
        if(newValue.length > maxLength){
          e.preventDefault();
          const availableSpace = maxLength - beforeSelection.length - afterSelection.length;
          const truncatedPaste = pastedText.slice(0, Math.max(0, availableSpace));
          const finalValue = beforeSelection + truncatedPaste + afterSelection;
          input.value = finalValue.slice(0, maxLength);
          // Trigger input event for any listeners
          input.dispatchEvent(new Event('input', { bubbles: true }));
        }
      });
      
      const updateCounter = () => {
        const len = (input.value || '').length;
        const remaining = maxLength - len;
        
        // Show counter when within 10 chars of max or over limit
        if(remaining <= 10 || remaining < 0){
          counter.style.display = 'inline';
          if(remaining < 0){
            counter.textContent = `${Math.abs(remaining)} over limit`;
            counter.style.color = 'var(--error-color, #e74c3c)';
            counter.style.fontWeight = '600';
          } else if(remaining === 0){
            counter.textContent = '0 remaining';
            counter.style.color = 'var(--warning-color, #f39c12)';
            counter.style.fontWeight = '600';
          } else {
            counter.textContent = `${remaining} remaining`;
            counter.style.color = 'var(--warning-color, #f39c12)';
            counter.style.fontWeight = 'normal';
          }
        } else {
          counter.style.display = 'none';
        }
      };
      
      input.addEventListener('input', updateCounter);
      input.addEventListener('change', updateCounter);
      // Initial update
      updateCounter();
      
      return counter;
    }
    window.createCharCounter = createCharCounter;
    
    // Protect any text input with maxlength enforcement (standalone helper)
    // Use this for inputs that don't need a visible counter but still need protection
    function protectInputMaxLength(input, maxLength){
      if(!input || maxLength === null || maxLength === undefined || maxLength <= 0) return;
      
      // Set maxlength attribute
      input.setAttribute('maxlength', maxLength);
      
      // Handle paste events to truncate oversized content safely
      input.addEventListener('paste', (e) => {
        const pastedText = (e.clipboardData || window.clipboardData)?.getData('text') || '';
        const currentValue = input.value || '';
        const selectionStart = input.selectionStart ?? currentValue.length;
        const selectionEnd = input.selectionEnd ?? currentValue.length;
        
        // Calculate what the new value would be after paste
        const beforeSelection = currentValue.slice(0, selectionStart);
        const afterSelection = currentValue.slice(selectionEnd);
        const newValue = beforeSelection + pastedText + afterSelection;
        
        // If paste would exceed maxlength, truncate and prevent default
        if(newValue.length > maxLength){
          e.preventDefault();
          const availableSpace = maxLength - beforeSelection.length - afterSelection.length;
          const truncatedPaste = pastedText.slice(0, Math.max(0, availableSpace));
          const finalValue = beforeSelection + truncatedPaste + afterSelection;
          input.value = finalValue.slice(0, maxLength);
          // Trigger input event for any listeners
          input.dispatchEvent(new Event('input', { bubbles: true }));
        }
      });
    }
    window.protectInputMaxLength = protectInputMaxLength;
    
    // GLOBAL PASTE PROTECTION: Catches ALL paste events on text inputs/textareas
    // This is a universal security layer that protects even third-party inputs (like Mapbox geocoder)
    // Default security limit prevents browser crashes from massive paste attacks
    const DEFAULT_SECURITY_LIMIT = 10000;
    document.addEventListener('paste', (e) => {
      const target = e.target;
      if(!target) return;
      
      // Only handle text inputs and textareas
      const isTextInput = target.tagName === 'INPUT' && 
        (!target.type || target.type === 'text' || target.type === 'search' || target.type === 'url' || target.type === 'email' || target.type === 'tel');
      const isTextarea = target.tagName === 'TEXTAREA';
      if(!isTextInput && !isTextarea) return;
      
      // Get maxlength from element, or use default security limit
      let maxLength = DEFAULT_SECURITY_LIMIT;
      if(target.hasAttribute('maxlength')){
        const attrValue = parseInt(target.getAttribute('maxlength'), 10);
        if(attrValue > 0) maxLength = attrValue;
      }
      
      const pastedText = (e.clipboardData || window.clipboardData)?.getData('text') || '';
      if(!pastedText) return;
      
      const currentValue = target.value || '';
      const selectionStart = target.selectionStart ?? currentValue.length;
      const selectionEnd = target.selectionEnd ?? currentValue.length;
      
      // Calculate what the new value would be after paste
      const beforeSelection = currentValue.slice(0, selectionStart);
      const afterSelection = currentValue.slice(selectionEnd);
      const newValue = beforeSelection + pastedText + afterSelection;
      
      // If paste would exceed limit, truncate and prevent default
      if(newValue.length > maxLength){
        e.preventDefault();
        e.stopPropagation();
        const availableSpace = maxLength - beforeSelection.length - afterSelection.length;
        const truncatedPaste = pastedText.slice(0, Math.max(0, availableSpace));
        const finalValue = beforeSelection + truncatedPaste + afterSelection;
        target.value = finalValue.slice(0, maxLength);
        // Trigger input event for any listeners
        target.dispatchEvent(new Event('input', { bubbles: true }));
      }
    }, true); // Use capture phase to intercept before other handlers
    
    // Create limit hint element as tooltip icon (combines custom tooltip + char limits)
    function createLimitHint(minLength, maxLength, customTooltip){
      const hint = document.createElement('span');
      hint.className = 'char-limit-hint';
      hint.style.cssText = 'margin-left: 6px; cursor: help; opacity: 0.6; font-size: 12px; position: relative; display: inline-block;';
      hint.textContent = '';
      hint.setAttribute('aria-label', 'Character limit info');
      
      // Build tooltip text: custom tooltip + char limits (always appended)
      let tooltipText = '';
      if(customTooltip && typeof customTooltip === 'string' && customTooltip.trim()){
        tooltipText = customTooltip.trim();
      }
      
      // Always append char limits
      let charLimitText = '';
      if(minLength !== null && maxLength !== null){
        charLimitText = `${minLength}-${maxLength} characters`;
      } else if(maxLength !== null){
        charLimitText = `Maximum ${maxLength} characters`;
      } else if(minLength !== null){
        charLimitText = `Minimum ${minLength} characters`;
      }
      
      if(charLimitText){
        if(tooltipText){
          tooltipText = `${tooltipText}\n\n${charLimitText}`;
        } else {
          tooltipText = charLimitText;
        }
      }
      
      if(!tooltipText){
        hint.style.display = 'none';
        return hint;
      }
      
      // Create styled tooltip popup (matching website style)
      // Append to body to escape form field stacking context
      const popup = document.createElement('div');
      popup.className = 'message-hover-popup';
      popup.style.position = 'fixed';
      popup.style.background = 'rgba(17,17,17,0.98)';
      popup.style.border = '1px solid rgba(255,255,255,0.2)';
      popup.style.borderRadius = '8px';
      popup.style.padding = '12px';
      popup.style.minWidth = '280px';
      popup.style.maxWidth = '400px';
      popup.style.boxShadow = '0 8px 24px rgba(0,0,0,0.6)';
      popup.style.zIndex = '87';
      popup.style.opacity = '0';
      popup.style.pointerEvents = 'none';
      popup.style.transform = 'translateY(-8px)';
      popup.style.transition = 'opacity 0.2s ease, transform 0.2s ease';
      popup.style.display = 'flex';
      popup.style.flexDirection = 'column';
      popup.style.gap = '10px';
      popup.style.whiteSpace = 'pre-line';
      popup.style.wordWrap = 'break-word';
      document.body.appendChild(popup);
      
      // Split tooltip into description and char limits
      const description = document.createElement('div');
      description.className = 'message-popup-description';
      description.style.fontSize = '13px';
      description.style.color = 'rgba(255,255,255,0.7)';
      description.style.lineHeight = '1.4';
      
      if(customTooltip && typeof customTooltip === 'string' && customTooltip.trim()){
        description.textContent = customTooltip.trim();
        popup.appendChild(description);
      }
      
      if(charLimitText){
        const limitsDiv = document.createElement('div');
        limitsDiv.style.fontSize = '12px';
        limitsDiv.style.color = 'rgba(255,255,255,0.6)';
        limitsDiv.style.lineHeight = '1.5';
        limitsDiv.style.marginTop = customTooltip ? '8px' : '0';
        limitsDiv.style.paddingTop = customTooltip ? '8px' : '0';
        limitsDiv.style.borderTop = customTooltip ? '1px solid rgba(255,255,255,0.1)' : 'none';
        limitsDiv.textContent = charLimitText;
        popup.appendChild(limitsDiv);
      }
      
      // Position tooltip relative to hint element on hover
      let updatePosition = () => {
        const rect = hint.getBoundingClientRect();
        popup.style.left = `${rect.left}px`;
        popup.style.top = `${rect.bottom + 8}px`;
      };
      
      // Hover effect for icon
      hint.addEventListener('mouseenter', () => { 
        hint.style.opacity = '1';
        updatePosition();
        popup.style.opacity = '1';
        popup.style.transform = 'translateY(0)';
      });
      hint.addEventListener('mouseleave', () => { 
        hint.style.opacity = '0.6';
        popup.style.opacity = '0';
        popup.style.transform = 'translateY(-8px)';
      });
      
      // Update position on scroll/resize
      window.addEventListener('scroll', updatePosition, true);
      window.addEventListener('resize', updatePosition);
      
      return hint;
    }
    window.createLimitHint = createLimitHint;
    
    const getFormFieldsetLabel = (value)=>{
      const match = FORM_FIELDSETS.find(opt => opt.value === value);
      if(!match){
        return '';
      }
      const label = resolveFieldsetDisplayName(match);
      if(label){
        return label;
      }
      return typeof value === 'string' ? value : '';
    };
    const VENUE_TIME_AUTOFILL_STATE = new WeakMap();
    const VENUE_CURRENCY_STATE = new WeakMap();
    let LAST_SELECTED_VENUE_CURRENCY = '';

    function venueSessionCreatePricingTier(){
      return { name: '', currency: 'USD', price: '' };
    }
    function venueSessionCreateSeatingArea(){
      return { name: '', tiers: [venueSessionCreatePricingTier()] };
    }
    function venueSessionCreateSessionTime(){
      return {
        time: '',
        seating_areas: [venueSessionCreateSeatingArea()],
        samePricingAsAbove: true,
        samePricingSourceIndex: 0,
        tierAutofillLocked: false
      };
    }
    function venueSessionCreateSession(){
      return { date: '', times: [venueSessionCreateSessionTime()] };
    }
    function venueSessionCreateVenue(){
      return { name: '', address: '', location: null, feature: null, sessions: [venueSessionCreateSession()] };
    }
    function normalizeVenueSessionPricingTier(tier){
      let obj = tier;
      if(!obj || typeof obj !== 'object'){
        obj = venueSessionCreatePricingTier();
      }
      if(typeof obj.name !== 'string') obj.name = '';
      if(typeof obj.currency !== 'string') obj.currency = '';
      if(typeof obj.price !== 'string') obj.price = '';
      return obj;
    }
    function normalizeVenueSessionSeatingArea(seatingArea){
      let obj = seatingArea;
      if(!obj || typeof obj !== 'object'){
        obj = venueSessionCreateSeatingArea();
      }
      if(typeof obj.name !== 'string') obj.name = '';
      if(!Array.isArray(obj.pricing_tiers)){
        obj.pricing_tiers = [venueSessionCreatePricingTier()];
      } else {
        for(let i = 0; i < obj.pricing_tiers.length; i++){
          obj.pricing_tiers[i] = normalizeVenueSessionPricingTier(obj.pricing_tiers[i]);
        }
        if(obj.pricing_tiers.length === 0){
          obj.pricing_tiers.push(venueSessionCreatePricingTier());
        }
      }
      return obj;
    }
    function normalizeVenueSessionSessionTime(time){
      let obj = time;
      if(!obj || typeof obj !== 'object'){
        obj = venueSessionCreateSessionTime();
      }
      if(typeof obj.time !== 'string') obj.time = '';
      if(!Array.isArray(obj.seating_areas)){
        obj.seating_areas = [venueSessionCreateSeatingArea()];
      } else {
        for(let i = 0; i < obj.seating_areas.length; i++){
          obj.seating_areas[i] = normalizeVenueSessionSeatingArea(obj.seating_areas[i]);
        }
        if(obj.seating_areas.length === 0){
          obj.seating_areas.push(venueSessionCreateSeatingArea());
        }
      }
      obj.samePricingAsAbove = obj.samePricingAsAbove !== false;
      obj.tierAutofillLocked = obj && obj.tierAutofillLocked === true;
      const sourceIndex = Number(obj.samePricingSourceIndex);
      obj.samePricingSourceIndex = Number.isInteger(sourceIndex) && sourceIndex >= 0 ? sourceIndex : 0;
      return obj;
    }
    function normalizeVenueSessionSession(session){
      let obj = session;
      if(!obj || typeof obj !== 'object'){
        obj = venueSessionCreateSession();
      }
      if(typeof obj.date !== 'string') obj.date = '';
      if(!Array.isArray(obj.session_times)){
        obj.session_times = [venueSessionCreateSessionTime()];
      } else {
        for(let i = 0; i < obj.session_times.length; i++){
          obj.session_times[i] = normalizeVenueSessionSessionTime(obj.session_times[i]);
        }
        if(obj.session_times.length === 0){
          obj.session_times.push(venueSessionCreateSessionTime());
        }
      }
      return obj;
    }
    function normalizeVenueSessionVenue(opt){
      let obj = opt;
      if(!obj || typeof obj !== 'object'){
        obj = venueSessionCreateVenue();
      }
      if(typeof obj.name !== 'string') obj.name = '';
      if(typeof obj.address !== 'string') obj.address = '';
      if(obj.location && typeof obj.location === 'object'){
        const lng = Number(obj.location.lng);
        const lat = Number(obj.location.lat);
        obj.location = (Number.isFinite(lng) && Number.isFinite(lat)) ? { lng, lat } : null;
      } else {
        obj.location = null;
      }
      if(obj.feature && typeof obj.feature !== 'object'){
        obj.feature = null;
      }
      if(!Array.isArray(obj.sessions)){
        obj.sessions = [venueSessionCreateSession()];
      } else {
        for(let i = 0; i < obj.sessions.length; i++){
          obj.sessions[i] = normalizeVenueSessionSession(obj.sessions[i]);
        }
        if(obj.sessions.length === 0){
          obj.sessions.push(venueSessionCreateSession());
        }
      }
      return obj;
    }
    function normalizeVenueSessionOptions(options){
      let list = options;
      if(!Array.isArray(list)){
        list = [];
      }
      for(let i = 0; i < list.length; i++){
        list[i] = normalizeVenueSessionVenue(list[i]);
      }
      if(list.length === 0){
        list.push(venueSessionCreateVenue());
      }
      return list;
    }
    function cloneVenueSessionPricingTier(tier){
      const base = venueSessionCreatePricingTier();
      if(tier && typeof tier === 'object'){
        if(typeof tier.name === 'string') base.name = tier.name;
        if(typeof tier.currency === 'string') base.currency = tier.currency;
        if(typeof tier.price === 'string') base.price = tier.price;
      }
      return base;
    }
    function cloneVenueSessionSeatingArea(seatingArea){
      const base = venueSessionCreateSeatingArea();
      base.name = (seatingArea && typeof seatingArea.name === 'string') ? seatingArea.name : '';
      const pricingTiers = seatingArea && Array.isArray(seatingArea.pricing_tiers) ? seatingArea.pricing_tiers : [];
      base.pricing_tiers = pricingTiers.length ? pricingTiers.map(cloneVenueSessionPricingTier) : [venueSessionCreatePricingTier()];
      return base;
    }
    function cloneVenueSessionSessionTime(time){
      const base = venueSessionCreateSessionTime();
      base.time = (time && typeof time.time === 'string') ? time.time : '';
      const seatingAreas = time && Array.isArray(time.seating_areas) ? time.seating_areas : [];
      base.seating_areas = seatingAreas.length ? seatingAreas.map(cloneVenueSessionSeatingArea) : [venueSessionCreateSeatingArea()];
      base.samePricingAsAbove = !!(time && time.samePricingAsAbove);
      const sourceIndex = Number(time && time.samePricingSourceIndex);
      base.samePricingSourceIndex = Number.isInteger(sourceIndex) && sourceIndex >= 0 ? sourceIndex : 0;
      base.tierAutofillLocked = !!(time && time.tierAutofillLocked);
      return base;
    }
    function cloneVenueSessionSession(session){
      const base = venueSessionCreateSession();
      base.date = (session && typeof session.date === 'string') ? session.date : '';
      const times = session && Array.isArray(session.session_times) ? session.session_times : [];
      base.session_times = times.length ? times.map(cloneVenueSessionSessionTime) : [venueSessionCreateSessionTime()];
      return base;
    }
    function cloneVenueSessionFeature(feature){
      if(!feature || typeof feature !== 'object') return null;
      try{
        return JSON.parse(JSON.stringify(feature));
      }catch(err){
        return { ...feature };
      }
    }
    function cloneVenueSessionVenue(venue){
      const base = venueSessionCreateVenue();
      base.name = (venue && typeof venue.name === 'string') ? venue.name : '';
      base.address = (venue && typeof venue.address === 'string') ? venue.address : '';
      if(venue && venue.location && typeof venue.location === 'object'){
        const lng = Number(venue.location.lng);
        const lat = Number(venue.location.lat);
        if(Number.isFinite(lng) && Number.isFinite(lat)){
          base.location = { lng, lat };
        }
      }
      if(venue && venue.feature && typeof venue.feature === 'object'){
        base.feature = cloneVenueSessionFeature(venue.feature);
      }
      const sessions = venue && Array.isArray(venue.sessions) ? venue.sessions : [];
      base.sessions = sessions.length ? sessions.map(cloneVenueSessionSession) : [venueSessionCreateSession()];
      return base;
    }
    window.normalizeVenueSessionOptions = normalizeVenueSessionOptions;
    window.cloneVenueSessionVenue = cloneVenueSessionVenue;
    function getVenueAutofillState(field, venue){
      let fieldState = VENUE_TIME_AUTOFILL_STATE.get(field);
      if(!fieldState){
        fieldState = new WeakMap();
        VENUE_TIME_AUTOFILL_STATE.set(field, fieldState);
      }
      let state = fieldState.get(venue);
      if(!state){
        state = { slots: [] };
        fieldState.set(venue, state);
      }
      return state;
    }
    function resetVenueAutofillState(field){
      VENUE_TIME_AUTOFILL_STATE.delete(field);
    }

    // Fields now come from backend via fieldsets table, no hardcoded defaults
    const OPEN_ICON_PICKERS = window.__openIconPickers || new Set();
    window.__openIconPickers = OPEN_ICON_PICKERS;

    function toIconIdKey(id){
      return Number.isInteger(id) ? `id:${id}` : '';
    }
    function toIconNameKey(name){
      return typeof name === 'string' && name ? `name:${name.toLowerCase()}` : '';
    }

    function normalizeIconAssetPath(path){
      const normalized = baseNormalizeIconPath(path);
      if(!normalized){
        return '';
      }
      if(/^(?:https?:)?\/\//i.test(normalized) || normalized.startsWith('data:')){
        return normalized;
      }
      return normalized;
    }

    const existingNormalizeIconPath = (typeof window !== 'undefined' && typeof window.normalizeIconPath === 'function')
      ? window.normalizeIconPath
      : null;
    if(typeof window !== 'undefined'){
      window.normalizeIconPath = (path)=>{
        const initial = existingNormalizeIconPath ? existingNormalizeIconPath(path) : path;
        return normalizeIconAssetPath(initial);
      };
    }

    function normalizeIconPathMap(source){
      const normalized = {};
      if(!source || typeof source !== 'object'){
        return normalized;
      }
      Object.keys(source).forEach(key => {
        const rawValue = source[key];
        const value = typeof rawValue === 'string' ? normalizeIconAssetPath(rawValue) : '';
        if(typeof key !== 'string'){
          return;
        }
        const trimmed = key.trim();
        if(!trimmed){
          return;
        }
        if(/^id:\d+$/i.test(trimmed)){
          normalized[trimmed.toLowerCase()] = value;
          return;
        }
        if(/^[0-9]+$/.test(trimmed)){
          normalized[`id:${trimmed}`] = value;
          return;
        }
        if(/^name:/i.test(trimmed)){
          const rest = trimmed.slice(5).toLowerCase();
          if(rest){
            normalized[`name:${rest}`] = value;
          }
          return;
        }
        normalized[`name:${trimmed.toLowerCase()}`] = value;
      });
      return normalized;
    }

    function normalizeCheckoutOptions(options){
      if(!Array.isArray(options)){
        return [];
      }
      return options.map(opt => {
        if(!opt || typeof opt !== 'object'){
          return null;
        }
        return {
          id: typeof opt.id === 'number' ? opt.id : (parseInt(opt.id, 10) || 0),
          checkout_key: typeof opt.checkout_key === 'string' ? opt.checkout_key : '',
          checkout_title: typeof opt.checkout_title === 'string' ? opt.checkout_title : '',
          checkout_description: typeof opt.checkout_description === 'string' ? opt.checkout_description : '',
          checkout_flagfall_price: Math.round((typeof opt.checkout_flagfall_price === 'number' ? opt.checkout_flagfall_price : parseFloat(opt.checkout_flagfall_price) || 0) * 100) / 100,
          checkout_basic_day_rate: opt.checkout_basic_day_rate !== undefined && opt.checkout_basic_day_rate !== null ? Math.round((typeof opt.checkout_basic_day_rate === 'number' ? opt.checkout_basic_day_rate : parseFloat(opt.checkout_basic_day_rate)) * 100) / 100 : null,
          checkout_discount_day_rate: opt.checkout_discount_day_rate !== undefined && opt.checkout_discount_day_rate !== null ? Math.round((typeof opt.checkout_discount_day_rate === 'number' ? opt.checkout_discount_day_rate : parseFloat(opt.checkout_discount_day_rate)) * 100) / 100 : null,
          checkout_currency: typeof opt.checkout_currency === 'string' ? opt.checkout_currency : 'USD',
          checkout_featured: opt.checkout_featured === 1 || opt.checkout_featured === true ? 1 : 0,
          checkout_sidebar_ad: opt.checkout_sidebar_ad === 1 || opt.checkout_sidebar_ad === true ? 1 : 0,
          is_active: opt.is_active === false || opt.is_active === 0 ? false : true
        };
      }).filter(Boolean);
    }

    function lookupIconPath(map, id, name){
      const idKey = toIconIdKey(id);
      if(idKey && Object.prototype.hasOwnProperty.call(map, idKey)){
        return { path: map[idKey], found: true };
      }
      const nameKey = toIconNameKey(name);
      if(nameKey && Object.prototype.hasOwnProperty.call(map, nameKey)){
        return { path: map[nameKey], found: true };
      }
      return { path: '', found: false };
    }
    function writeIconPath(map, id, name, path){
      const idKey = toIconIdKey(id);
      if(idKey){
        map[idKey] = path;
      }
      const nameKey = toIconNameKey(name);
      if(nameKey){
        map[nameKey] = path;
      }
    }
    function renameIconNameKey(map, oldName, newName){
      const oldKey = toIconNameKey(oldName);
      const newKey = toIconNameKey(newName);
      if(!oldKey || !newKey || oldKey === newKey){
        if(oldKey && !newKey){
          delete map[oldKey];
        }
        return;
      }
      if(Object.prototype.hasOwnProperty.call(map, oldKey) && !Object.prototype.hasOwnProperty.call(map, newKey)){
        map[newKey] = map[oldKey];
      }
      delete map[oldKey];
    }
    function deleteIconKeys(map, id, name){
      const idKey = toIconIdKey(id);
      if(idKey){
        delete map[idKey];
      }
      const nameKey = toIconNameKey(name);
      if(nameKey){
        delete map[nameKey];
      }
    }
    function closeAllIconPickers(){
      Array.from(OPEN_ICON_PICKERS).forEach(close => {
        try{ close(); }catch(err){}
      });
    }
    function closeFieldEditPanels({ exceptPanel = null, exceptButton = null } = {}){
      document.querySelectorAll('.field-edit-panel').forEach(panel => {
        if(panel === exceptPanel) return;
        panel.hidden = true;
        const host = panel.closest('.subcategory-field-row, .form-field');
        if(host && host.classList){
          host.classList.remove('field-edit-open');
        }
      });
      document.querySelectorAll('.field-edit-btn[aria-expanded="true"]').forEach(btn => {
        if(btn === exceptButton) return;
        btn.setAttribute('aria-expanded', 'false');
      });
    }
    function baseNormalizeIconPath(path){
      if(typeof path !== 'string') return '';
      const trimmed = path.trim();
      if(!trimmed) return '';
      return trimmed.replace(/^\/+/, '');
    }
    function applyNormalizeIconPath(path){
      if(typeof window !== 'undefined' && typeof window.normalizeIconPath === 'function'){
        try{
          const overridden = window.normalizeIconPath(path);
          if(typeof overridden !== 'undefined'){
            return baseNormalizeIconPath(overridden);
          }
        }catch(err){}
      }
      return baseNormalizeIconPath(path);
    }
    function getCategoryIconPath(category){
      if(!category) return '';
      const lookup = lookupIconPath(categoryIconPaths, category.id, category.name);
      if(lookup.found){
        return lookup.path || '';
      }
      return '';
    }
    function getSubcategoryIconPath(category, subName){
      const id = category && category.subIds && Object.prototype.hasOwnProperty.call(category.subIds, subName)
        ? category.subIds[subName]
        : null;
      const lookup = lookupIconPath(subcategoryIconPaths, id, subName);
      if(lookup.found){
        return lookup.path || '';
      }
      return '';
    }
    const subcategoryMarkers = window.subcategoryMarkers = window.subcategoryMarkers || {};
    // Multi-post icon will be loaded from database in loadAdminSettings() - no fallback
    categories.forEach(cat => {
      if(!cat || typeof cat !== 'object') return;
      if(!cat.subFields || typeof cat.subFields !== 'object' || Array.isArray(cat.subFields)){
        cat.subFields = {};
      }
      (cat.subs || []).forEach(subName => {
        if(!Array.isArray(cat.subFields[subName])){
          cat.subFields[subName] = [];
        }
      });
    });

    function extractIconSrc(html){
      if(typeof html !== 'string'){ return ''; }
      const trimmed = html.trim();
      if(!trimmed){ return ''; }
      if(typeof document === 'undefined'){ return ''; }
      if(!extractIconSrc.__parser){
        extractIconSrc.__parser = document.createElement('div');
      }
      const parser = extractIconSrc.__parser;
      parser.innerHTML = trimmed;
      const img = parser.querySelector('img');
      const src = img ? (img.getAttribute('src') || '').trim() : '';
      parser.innerHTML = '';
      return src;
    }

    // --- Icon loader: ensures Mapbox images are available and quiets missing-image logs ---
    function attachIconLoader(mapInstance){
      if(!mapInstance) return () => Promise.resolve(false);
      const KNOWN = [
        'freebies','live-sport','volunteers','goods-and-services','clubs','artwork',
        'live-gigs','for-sale','education-centres','tutors'
      ];
      const pending = new Map();

      const urlsFor = (name) => {
        const urls = [];
        const seen = new Set();
        const pushUrl = (url) => {
          if(!url || seen.has(url)){
            return;
          }
          seen.add(url);
          urls.push(url);
        };
        const markers = window.subcategoryMarkers || {};
        const manual = markers[name] || null;
        const shouldLookupLocal = Boolean(manual);
        if(manual){
          pushUrl(manual);
        }
        return { urls, shouldLookupLocal };
      };

      function loadImageCompat(url){
        return new Promise((resolve, reject) => {
          if(typeof mapInstance.loadImage === 'function'){
            mapInstance.loadImage(url, (err, img) => err ? reject(err) : resolve(img));
          } else {
            fetch(url)
              .then(r => r.ok ? r.blob() : Promise.reject(url))
              .then(blob => createImageBitmap(blob))
              .then(resolve)
              .catch(reject);
          }
        });
      }

      function pickPixelRatio(url, img){
        if(typeof url === 'string' && /@2x\.[^./]+$/i.test(url)){
          return 2;
        }
        return 1;
      }

      function placeholder(name){
        const canvas = document.createElement('canvas');
        canvas.width = 48;
        canvas.height = 48;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#222';
        ctx.beginPath();
        ctx.arc(24, 24, 24, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 20px system-ui, sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText((name && name[0] ? name[0] : '?').toUpperCase(), 24, 24);
        return canvas;
      }

      async function addIcon(name){
        if(!name) return false;
        if(mapInstance.hasImage?.(name)) return true;
        if(pending.has(name)) return pending.get(name);
        const task = (async () => {
          const { urls, shouldLookupLocal } = urlsFor(name);
          if(!urls.length && !shouldLookupLocal){
            try{ mapInstance.addImage(name, placeholder(name)); }catch(err){}
            return false;
          }
          for(const url of urls){
            try{
              const img = await loadImageCompat(url);
              if(mapInstance.hasImage?.(name)) return true;
              const pixelRatio = pickPixelRatio(url, img);
              mapInstance.addImage(name, img, { sdf:false, pixelRatio });
              return true;
            }catch(err){}
          }
          try{ mapInstance.addImage(name, placeholder(name)); }catch(err){}
          return false;
        })().finally(() => pending.delete(name));
        pending.set(name, task);
        return task;
      }

      mapInstance.on('style.load', async () => {
        const markers = window.subcategoryMarkers || {};
        const preloadList = Array.from(new Set([...KNOWN, ...Object.keys(markers)]));
        if(!preloadList.length) return;
        const BATCH_SIZE = 4;
        const BATCH_DELAY = 60;
        for(let i = 0; i < preloadList.length; i += BATCH_SIZE){
          const slice = preloadList.slice(i, i + BATCH_SIZE);
          const tasks = slice.map(iconName => (
            addIcon(iconName).catch(() => false)
          ));
          try{
            await Promise.allSettled(tasks);
          }catch(err){}
          if(BATCH_DELAY && i + BATCH_SIZE < preloadList.length){
            await new Promise(resolve => setTimeout(resolve, BATCH_DELAY));
          }
        }
      });

      return addIcon;
    }

    const venueKey = (lng, lat) => toVenueCoordKey(lng, lat);

    function setSelectedVenueHighlight(lng, lat){
      if(Number.isFinite(lng) && Number.isFinite(lat)){
        const key = venueKey(lng, lat);
        if(selectedVenueKey !== key){
          selectedVenueKey = key;
          syncPostCardHighlights();
        }
      } else if(selectedVenueKey !== null){
        selectedVenueKey = null;
        syncPostCardHighlights();
      }
    }

    function ensureSvgDimensions(svg){
      try{
        const doc = new DOMParser().parseFromString(svg, 'image/svg+xml');
        const el = doc.documentElement;
        let w = parseFloat(el.getAttribute('width'));
        let h = parseFloat(el.getAttribute('height'));
        const viewBox = el.getAttribute('viewBox');
        if((!w || !h) && viewBox){
          const parts = viewBox.split(/[ ,]/).map(Number);
          if(parts.length === 4){
            w = w || parts[2];
            h = h || parts[3];
          }
        }
        if(!w) w = 40;
        if(!h) h = 40;
        el.setAttribute('width', w);
        el.setAttribute('height', h);
        return {svg: new XMLSerializer().serializeToString(el), width: w, height: h};
      }catch(e){
        return {svg, width:40, height:40};
      }
    }
// 0585: unique title generator (with location; no category prefix)
const __ADJ = ["Radiant","Indigo","Velvet","Silver","Crimson","Neon","Amber","Sapphire","Emerald","Electric","Roaring","Midnight","Sunlit","Ethereal","Urban","Astral","Analog","Digital","Windswept","Golden","Hidden","Avant","Cosmic","Garden","Quiet","Vivid","Obsidian","Scarlet","Cerulean","Lunar","Solar","Autumn","Verdant","Azure"];
const __NOUN = ["Symphony","Market","Carnival","Showcase","Assembly","Parade","Salon","Summit","Expo","Soire","Revue","Collective","Fair","Gathering","Series","Retrospective","Circuit","Sessions","Weekender","Festival","Bazaar","Program","Tableau","Odyssey","Forum","Mosaic","Canvas","Relay","Drift","Workshop","Lab"];
const __HOOK = ["at Dusk","of Ideas","in Motion","for Everyone","Remix","Live","Reborn","MKII","Redux","Infinite","Prime","Pulse","Wave","Future","Now","Unlocked","Extended","Panorama","Unbound","Edition","Run","Sequence"];
function __rng(seed){ let s = seed|0; return ()=> (s = (s*1664525 + 1013904223)>>>0); }
const __USED_BIGRAMS = new Set();
function uniqueTitle(seed, cityName, idx){
  // Deterministic RNG with attempt salt for conflict resolution
  const base = (seed||0) ^ ((idx||0)*99991);

  const normalize = (s)=> s
    .replace(/[^\p{L}\p{N}]+/gu,' ')
    .trim()
    .split(/\s+/)
    .filter(Boolean);

  const lower = (ws)=> ws.map(w=> w.toLowerCase());

  const bigrams = (words)=> {
    const out = [];
    for(let i=0;i<words.length-1;i++) out.push(words[i]+" "+words[i+1]);
    return out;
  };

  const violates = (title)=> {
    const ws = normalize(title);
    const lc = lower(ws);
    if(!ws.length) return true;

    // no duplicate adjacent words inside one title
    for(let i=0;i<lc.length-1;i++){
      if(lc[i]===lc[i+1]) return true;
    }
    // any bigram seen before globally?
    const b = bigrams(lc);
    for(const bg of b){ if(__USED_BIGRAMS.has(bg)) return true; }

    return false;
  };

  const pickFrom = (r, arr)=> arr[r()%arr.length];

  // Word banks
  const A = __ADJ, N = __NOUN, H = __HOOK;
  const ARTISTS = [
    "The Silver Comets","Neon Parade","Paper Lanterns","Velvet Echoes","Indigo Quartet",
    "The Jet Set","Crimson Tide","Midnight Radio","Electric Hearts","Golden Hour",
    "The Amber Rooms","Violet Skyline","Satellite City","The Night Owls","Ivory Street Band",
    "Bluebird Company","Marble Garden","Velvet Undergrounders","Echo Park Players","Lantern Light",
    "Harbor & Co.","The Carousel Club","Kite & Canvas","Saffron Society","The Prairie Dogs"
  ];
  const PLAY_FORMS = [
    "Picture Show","Live on Stage","In Concert","Experience","Cabaret","Showcase",
    "Festival","Gala","Residency","Matinee","After Dark","Revue","Workshop"
  ];
  const STORY_OPENERS = [
    "Once Upon a Time","Into the Unknown","A Night to Remember","Between Two Worlds",
    "The Last Carousel","Dreams of Summer","Echoes in the Hall","Velvet Midnight",
    "The Paper Moon","Lanterns at Dusk","The Long Goodbye","Morning After Dark","Before the Storm"
  ];
  const TOUR_TAGS = ["Greatest Hits","Unplugged","Anniversary Tour","Acoustic Sessions","Late Night Set"];
  const PROMOS = ["One Night Only!","Two Nights Only!","One Weekend Only!","2 weeks only!!","Limited Season","Encore Performance"];

  const makeTitle = (r)=>{
    const templates = [
      ()=> `${pickFrom(r, ARTISTS)} Live on Stage`,
      ()=> `${pickFrom(r, ARTISTS)}  ${pickFrom(r, TOUR_TAGS)}`,
      ()=> `An Evening with ${pickFrom(r, ARTISTS)}`,
      ()=> `The ${pickFrom(r, N)} ${pickFrom(r, PLAY_FORMS)}`,
      ()=> `The ${pickFrom(r, A)} ${pickFrom(r, N)}`,
      ()=> `${pickFrom(r, A)} ${pickFrom(r, N)} ${pickFrom(r, H)}`,
      ()=> `${pickFrom(r, STORY_OPENERS)}`,
      ()=> `${pickFrom(r, A)} ${pickFrom(r, N)}: ${pickFrom(r, H)}`,
      ()=> `${pickFrom(r, A)} ${pickFrom(r, N)} ${pickFrom(r, PLAY_FORMS)}`,
      ()=> `${pickFrom(r, N)} ${pickFrom(r, PLAY_FORMS)}`
    ];
    let t = templates[r()%templates.length]();
    if ((r()%4)===0) t += `  ${pickFrom(r, PROMOS)}`;
    return t.replace(/\s+/g,' ').trim();
  };

  // Try multiple deterministic attempts with salted RNG until constraints satisfied
  let attempt = 0, title = "";
  for(; attempt < 96; attempt++){
    const r = __rng(base ^ (attempt * 1315423911));
    const candidate = makeTitle(r);
    if(!violates(candidate)){
      title = candidate;
      break;
    }
  }
  if(!title){ title = makeTitle(__rng(base ^ 0x9e3779b9)); } // fallback

  // Commit global constraints
  const ws = lower(normalize(title));
  for(let i=0;i<ws.length-1;i++){ __USED_BIGRAMS.add(ws[i]+" "+ws[i+1]); }

  return title;
}function pick(arr){ return arr[Math.floor(rnd()*arr.length)]; }
    function jitter([lng,lat]){ return [lng + (rnd()-0.5)*8, clamp(lat + (rnd()-0.5)*8,-80,80)]; }

  function toISODate(d){
    const y = d.getFullYear();
    const m = String(d.getMonth()+1).padStart(2,'0');
    const day = String(d.getDate()).padStart(2,'0');
    return `${y}-${m}-${day}`;
  }

  function parseISODate(s){
    const [yy, mm, dd] = s.split('-').map(Number);
    return new Date(yy, mm - 1, dd);
  }

  const DAY_MS = 86400000;

  function generateEventBlocks(options={}){
    const {
      minBlocks = 1,
      maxBlocks = 3,
      allowPast = false,
      maxFutureDays = 180,
      upcomingBiasDays = 60,
      pastWindowDays = 60,
      maxSpanDays = 14
    } = options;
    const now = new Date();
    now.setHours(0,0,0,0);
    const normalizedMin = Math.max(1, Math.floor(minBlocks));
    const normalizedMax = Math.max(normalizedMin, Math.floor(maxBlocks));
    const blockTotal = normalizedMin + Math.floor(rnd() * (normalizedMax - normalizedMin + 1));
    const futureRange = Math.max(1, Math.floor(maxFutureDays));
    const biasRange = Math.max(1, Math.min(futureRange, Math.floor(upcomingBiasDays) || futureRange));
    const pastRange = Math.max(0, Math.floor(pastWindowDays));
    const blocks = [];
    for(let i=0;i<blockTotal;i++){
      let offsetDays = 0;
      if(allowPast && pastRange > 0 && rnd() < 0.22){
        offsetDays = -Math.floor(rnd() * pastRange);
      } else {
        const roll = rnd();
        if(roll < 0.7){
          offsetDays = Math.floor(rnd() * biasRange);
        } else if(roll < 0.9){
          const midRange = Math.max(biasRange, Math.floor(futureRange * 0.65));
          offsetDays = Math.floor(rnd() * Math.min(futureRange, midRange));
        } else {
          offsetDays = Math.floor(rnd() * futureRange);
        }
      }
      if(!allowPast && offsetDays < 0){
        offsetDays = 0;
      }
      const span = 1 + Math.floor(rnd() * Math.max(1, Math.floor(maxSpanDays)));
      const start = new Date(now.getTime() + offsetDays * DAY_MS);
      start.setHours(0,0,0,0);
      blocks.push({ start, spanDays: span });
    }
    blocks.sort((a,b)=> a.start - b.start);
    return blocks;
  }

  function pickBlockOffsets(spanDays){
    const totalDays = Math.max(1, Math.floor(spanDays));
    const offsets = new Set();
    if(totalDays <= 1){
      offsets.add(0);
      return Array.from(offsets);
    }
    const densityRoll = rnd();
    let target;
    if(densityRoll < 0.25){
      target = 1 + Math.floor(rnd() * Math.min(2, totalDays));
    } else if(densityRoll < 0.6){
      target = Math.min(totalDays, 2 + Math.floor(rnd() * Math.min(3, totalDays - 1)));
    } else if(densityRoll < 0.85){
      target = Math.min(totalDays, Math.max(2, Math.round(totalDays * (0.5 + rnd() * 0.4))));
    } else {
      target = Math.min(totalDays, Math.max(3, Math.round(totalDays * (0.75 + rnd() * 0.6))));
    }
    target = Math.max(1, Math.min(totalDays, target));
    while(offsets.size < target){
      offsets.add(Math.floor(rnd() * totalDays));
      if(offsets.size >= totalDays){
        break;
      }
    }
    return Array.from(offsets).sort((a,b)=> a - b);
  }

  function randomSessionTime(){
    const slot = rnd();
    let hour;
    if(slot < 0.15){
      hour = 10 + Math.floor(rnd() * 3); // late morning
    } else if(slot < 0.8){
      hour = 18 + Math.floor(rnd() * 4); // evening shows
    } else if(slot < 0.9){
      hour = 14 + Math.floor(rnd() * 4); // matinees
    } else {
      hour = 12 + Math.floor(rnd() * 6); // afternoon variety
    }
    const minute = Math.floor(rnd() * 4) * 15;
    return `${String(hour).padStart(2,'0')}:${String(minute).padStart(2,'0')}`;
  }

  function generateSessionsFromBlocks(blocks, options={}){
    const allowEmptyBlocks = options.allowEmptyBlocks !== false;
    const emptyBlockChance = typeof options.emptyBlockChance === 'number'
      ? Math.min(Math.max(options.emptyBlockChance, 0), 1)
      : 0.2;
    const ensureAtLeastOne = options.ensureAtLeastOne === true;
    const allowDoubleSessions = options.allowDoubleSessions !== false;
    const generator = typeof options.timeGenerator === 'function' ? options.timeGenerator : randomSessionTime;
    const sessions = [];
    blocks.forEach((block, blockIndex) => {
      if(!block || !(block.start instanceof Date)){
        return;
      }
      if(allowEmptyBlocks && rnd() < emptyBlockChance && blockIndex !== 0){
        return;
      }
      const offsets = pickBlockOffsets(block.spanDays);
      offsets.forEach(offset => {
        const sessionDate = new Date(block.start.getTime() + offset * DAY_MS);
        sessionDate.setHours(0,0,0,0);
        const full = toISODate(sessionDate);
        const dateLabel = sessionDate
          .toLocaleDateString('en-GB',{weekday:'short', day:'numeric', month:'short'})
          .replace(/,/g,'');
        const time = generator({ block, offset, date: sessionDate });
        sessions.push({ date: dateLabel, time, full });
        if(allowDoubleSessions && rnd() < 0.08){
          let extraTime = generator({ block, offset, date: sessionDate, variant: 'double' });
          if(extraTime === time){
            extraTime = randomSessionTime();
          }
          sessions.push({ date: dateLabel, time: extraTime, full });
        }
      });
    });
    if(ensureAtLeastOne && !sessions.length){
      const fallbackDate = new Date();
      fallbackDate.setHours(0,0,0,0);
      const full = toISODate(fallbackDate);
      const dateLabel = fallbackDate
        .toLocaleDateString('en-GB',{weekday:'short', day:'numeric', month:'short'})
        .replace(/,/g,'');
      const time = generator({ fallback: true, date: fallbackDate });
      sessions.push({ date: dateLabel, time, full });
    }
    sessions.sort((a,b)=> a.full.localeCompare(b.full) || a.time.localeCompare(b.time));
    return sessions;
  }

  function randomDates(){
    const blocks = generateEventBlocks({
      minBlocks: 1,
      maxBlocks: 3,
      allowPast: false,
      maxFutureDays: 180,
      upcomingBiasDays: 120,
      maxSpanDays: 14
    });
    const sessions = generateSessionsFromBlocks(blocks, {
      allowEmptyBlocks: false,
      ensureAtLeastOne: true,
      allowDoubleSessions: false
    });
    const isoSet = new Set();
    sessions.forEach(entry => {
      if(entry && entry.full){
        isoSet.add(entry.full);
      }
    });
    if(!isoSet.size){
      isoSet.add(toISODate(new Date()));
    }
    return Array.from(isoSet).sort();
  }

  function randomSchedule(){
    const blocks = generateEventBlocks({
      minBlocks: 1,
      maxBlocks: 3,
      allowPast: true,
      pastWindowDays: 75,
      maxFutureDays: 180,
      upcomingBiasDays: 60,
      maxSpanDays: 14
    });
    return generateSessionsFromBlocks(blocks, {
      allowEmptyBlocks: true,
      emptyBlockChance: 0.25,
      ensureAtLeastOne: true,
      allowDoubleSessions: true,
      timeGenerator: randomSessionTime
    });
  }

  function derivePostDatesFromLocations(locations){
    if(!Array.isArray(locations) || !locations.length){
      return [];
    }
    const seen = new Set();
    locations.forEach(loc => {
      if(!loc) return;
      const schedule = Array.isArray(loc.dates) ? loc.dates : [];
      schedule.forEach(entry => {
        if(!entry) return;
        if(typeof entry === 'string'){
          const trimmed = entry.trim();
          if(trimmed) seen.add(trimmed);
          return;
        }
        if(entry.full){
          const normalized = String(entry.full).trim();
          if(normalized) seen.add(normalized);
        }
      });
    });
    return Array.from(seen).sort();
  }

  function normalizeLongitude(value){
    if(!Number.isFinite(value)) value = 0;
    const normalized = ((value + 180) % 360 + 360) % 360 - 180;
    return Number.isFinite(normalized) ? normalized : 0;
  }

  function clampLatitude(value){
    if(!Number.isFinite(value)) return 0;
    return Math.max(-85, Math.min(85, value));
  }

  function safeCoordinate(city, baseLng=0, baseLat=0, radius=0){
    const centerLng = Number.isFinite(baseLng) ? baseLng : 0;
    const centerLat = Number.isFinite(baseLat) ? baseLat : 0;
    const spread = Math.max(Number.isFinite(radius) ? radius : 0, 0);

    let lng = centerLng;
    let lat = centerLat;

    if(spread > 0){
      const distance = Math.sqrt(rnd()) * spread;
      const angle = rnd() * Math.PI * 2;
      lng += Math.cos(angle) * distance;
      lat += Math.sin(angle) * distance;
    }

    return {
      lng: normalizeLongitude(lng),
      lat: clampLatitude(lat)
    };
  }

  function createRandomLocation(city, baseLng=0, baseLat=0, options={}){
    const defaultRadius = 0.05;
    const radius = Number.isFinite(options.radius) ? Math.max(options.radius, 0) : defaultRadius;
    const coord = safeCoordinate(city, baseLng, baseLat, radius);
    const venueName = options.name || city || 'Event Venue';
    const address = options.address || city || '';
    return {
      venue: venueName,
      address,
      lng: coord.lng,
      lat: coord.lat,
      dates: randomSchedule(),
      price: randomPriceRange()
    };
  }

  const LOCAL_GEOCODER_MAX_RESULTS = 10;
  const localVenueIndex = [];
  const localVenueKeySet = new Set();
  const LOCAL_VENUE_PLACE_TYPES = Object.freeze(['poi', 'venue']);
  const MULTI_VENUE_COORD_PRECISION = 6;
  window.postsAtVenue = window.postsAtVenue && typeof window.postsAtVenue === 'object'
    ? window.postsAtVenue
    : Object.create(null);

  function getPostsAtVenueStore(){
    if(!window.postsAtVenue || typeof window.postsAtVenue !== 'object'){
      window.postsAtVenue = Object.create(null);
    }
    return window.postsAtVenue;
  }

  function toVenueCoordKey(lng, lat){
    if(!Number.isFinite(lng) || !Number.isFinite(lat)) return '';
    const normalizedLng = Number(lng).toFixed(MULTI_VENUE_COORD_PRECISION);
    const normalizedLat = Number(lat).toFixed(MULTI_VENUE_COORD_PRECISION);
    return `${normalizedLng},${normalizedLat}`;
  }

  function clearPostsAtVenueIndex(){
    const store = getPostsAtVenueStore();
    Object.keys(store).forEach(key => { delete store[key]; });
  }

  function registerPostAtVenue(post, key){
    if(!key) return;
    const store = getPostsAtVenueStore();
    const bucket = store[key] || (store[key] = []);
    if(!bucket.some(item => item && item.id === post.id)){
      bucket.push(post);
    }
  }

  function getPostsAtVenueByCoords(lng, lat){
    const key = toVenueCoordKey(lng, lat);
    if(!key) return [];
    const store = getPostsAtVenueStore();
    const bucket = store[key];
    return Array.isArray(bucket) ? bucket.slice() : [];
  }

  window.getPostsAtVenueByCoords = getPostsAtVenueByCoords;

  function localVenueKey(name='', address='', lng, lat){
    const normName = (name || '').toLowerCase();
    const normAddr = (address || '').toLowerCase();
    const normLng = Number.isFinite(lng) ? lng.toFixed(6) : '';
    const normLat = Number.isFinite(lat) ? lat.toFixed(6) : '';
    return `${normName}|${normAddr}|${normLng}|${normLat}`;
  }

  function cloneGeocoderFeature(feature){
    return {
      ...feature,
      geometry: {
        ...feature.geometry,
        coordinates: Array.isArray(feature.geometry?.coordinates)
          ? feature.geometry.coordinates.slice()
          : []
      },
      center: Array.isArray(feature.center) ? feature.center.slice() : [],
      properties: {
        ...(feature.properties || {})
      }
    };
  }
  // Expose for forms.js usage
  if(typeof window !== 'undefined'){
    window.cloneGeocoderFeature = cloneGeocoderFeature;
  }

  function addVenueToLocalIndex({ name, address, lng, lat, city }){
    if(!name || !Number.isFinite(lng) || !Number.isFinite(lat)) return;
    const key = localVenueKey(name, address, lng, lat);
    if(localVenueKeySet.has(key)) return;
    localVenueKeySet.add(key);
    const contextParts = [address, city].filter(Boolean);
    const placeName = contextParts.length ? `${name}  ${contextParts.join(', ')}` : name;
    const searchText = [name, address, city].filter(Boolean).join(' ').toLowerCase();
    localVenueIndex.push({
      search: searchText,
      feature: {
        type:'Feature',
        geometry:{ type:'Point', coordinates:[lng, lat] },
        center:[lng, lat],
        place_name: placeName,
        text: name,
        place_type: LOCAL_VENUE_PLACE_TYPES.slice(),
        properties:{
          name,
          address: address || '',
          city: city || '',
          source:'local-venue'
        }
      }
    });
  }

  function rebuildVenueIndex(){
    localVenueIndex.length = 0;
    localVenueKeySet.clear();
    clearPostsAtVenueIndex();
    const postList = Array.isArray(posts) ? posts : [];
    const addFromPost = (post) => {
      if(!post) return;
      const city = post.city || '';
      const fallbackName = getPrimaryVenueName(post) || city;
      const fallbackAddress = city || post.city || '';
      const seenVenueKeys = new Set();
      const addVenue = (lng, lat, locName, locAddress) => {
        if(!Number.isFinite(lng) || !Number.isFinite(lat)) return;
        const nameValue = locName || fallbackName;
        const addressValue = locAddress || fallbackAddress;
        addVenueToLocalIndex({ name: nameValue, address: addressValue, lng, lat, city });
        const key = toVenueCoordKey(lng, lat);
        if(!key || seenVenueKeys.has(key)) return;
        seenVenueKeys.add(key);
        registerPostAtVenue(post, key);
      };
      if(Array.isArray(post.locations) && post.locations.length){
        post.locations.forEach(loc => {
          if(!loc) return;
          addVenue(loc.lng, loc.lat, loc.venue, loc.address);
        });
        return;
      }
      addVenue(post.lng, post.lat, fallbackName, fallbackAddress);
    };
    postList.forEach(addFromPost);
  }

  function searchLocalVenues(query){
    const normalized = (query || '').toLowerCase().trim();
    if(!normalized) return [];
    const terms = normalized.split(/\s+/).filter(Boolean);
    if(!terms.length) return [];
    const matches = [];
    for(const entry of localVenueIndex){
      const haystack = entry.search;
      let score = 0;
      let valid = true;
      for(const term of terms){
        const idx = haystack.indexOf(term);
        if(idx === -1){
          valid = false;
          break;
        }
        score += 1 / (1 + idx);
      }
      if(valid){
        matches.push({ entry, score });
      }
    }
    matches.sort((a,b)=> b.score - a.score);
    return matches.slice(0, LOCAL_GEOCODER_MAX_RESULTS).map(item => {
      const feature = cloneGeocoderFeature(item.entry.feature);
      feature.relevance = Math.min(1, item.score);
      return feature;
    });
  }

  const localVenueGeocoder = (query) => searchLocalVenues(query);
  // Expose to window for forms.js access
  if(typeof window !== 'undefined'){
    window.searchLocalVenues = searchLocalVenues;
    window.localVenueGeocoder = localVenueGeocoder;
  }

  const MAPBOX_VENUE_ENDPOINT = 'https://api.mapbox.com/geocoding/v5/mapbox.places/';
  const MAPBOX_VENUE_CACHE_LIMIT = 40;
  const MAPBOX_VENUE_MIN_QUERY = 2;
  const mapboxVenueCache = new Map();

  function mapboxVenueCacheKey(query, options={}){
    const normalized = (query || '').trim().toLowerCase();
    const limit = Number.isFinite(options.limit) ? options.limit : 0;
    const types = typeof options.types === 'string' ? options.types : '';
    const prox = options.proximity && Number.isFinite(options.proximity.longitude) && Number.isFinite(options.proximity.latitude)
      ? `${options.proximity.longitude.toFixed(3)},${options.proximity.latitude.toFixed(3)}`
      : '';
    const language = typeof options.language === 'string' ? options.language : '';
    const country = typeof options.country === 'string' ? options.country : '';
    const bbox = Array.isArray(options.bbox) ? options.bbox.join(',') : '';
    return [normalized, limit, types, prox, language, country, bbox].join('|');
  }

  function rememberMapboxVenueResult(key, features){
    if(!key) return;
    try{
      mapboxVenueCache.set(key, features);
      if(mapboxVenueCache.size > MAPBOX_VENUE_CACHE_LIMIT){
        const firstKey = mapboxVenueCache.keys().next().value;
        if(firstKey) mapboxVenueCache.delete(firstKey);
      }
    }catch(err){}
  }

  function getMapboxVenueFeatureCenter(feature){
    if(feature && Array.isArray(feature.center) && feature.center.length === 2){
      const [lng, lat] = feature.center;
      if(Number.isFinite(lng) && Number.isFinite(lat)) return [lng, lat];
    }
    const coords = feature && feature.geometry && Array.isArray(feature.geometry.coordinates)
      ? feature.geometry.coordinates
      : null;
    if(coords && coords.length >= 2){
      const [lng, lat] = coords;
      if(Number.isFinite(lng) && Number.isFinite(lat)) return [lng, lat];
    }
    return null;
  }
  // Expose for forms.js usage
  if(typeof window !== 'undefined'){
    window.getMapboxVenueFeatureCenter = getMapboxVenueFeatureCenter;
  }

  function normalizeMapboxVenueFeature(feature){
    if(!feature || typeof feature !== 'object') return null;
    const clone = cloneGeocoderFeature(feature);
    const center = getMapboxVenueFeatureCenter(clone);
    if(center){
      clone.center = center.slice();
      clone.geometry = clone.geometry || { type:'Point', coordinates:center.slice() };
      if(Array.isArray(clone.geometry.coordinates)){
        clone.geometry.coordinates[0] = center[0];
        clone.geometry.coordinates[1] = center[1];
      }
    }
    if(!Array.isArray(clone.place_type) || !clone.place_type.length){
      clone.place_type = Array.isArray(feature.place_type) && feature.place_type.length
        ? feature.place_type.slice()
        : ['poi'];
    }
    clone.properties = clone.properties || {};
    if(!clone.properties.name && typeof clone.text === 'string'){
      clone.properties.name = clone.text;
    }
    if(typeof feature.properties === 'object'){
      if(!clone.properties.address && typeof feature.properties.address === 'string'){
        clone.properties.address = feature.properties.address;
      }
      if(!clone.properties.category && typeof feature.properties.category === 'string'){
        clone.properties.category = feature.properties.category;
      }
    }
    if(!clone.properties.source){
      clone.properties.source = 'mapbox-places';
    }
    if(typeof clone.text !== 'string' && typeof feature.text === 'string'){
      clone.text = feature.text;
    }
    if(typeof clone.place_name !== 'string' && typeof feature.place_name === 'string'){
      clone.place_name = feature.place_name;
    }
    return clone;
  }

  const MAPBOX_SUPPORTED_VENUE_TYPES = ['poi','place','address'];

  const MAJOR_VENUE_PRIORITY_TYPES = [
    'country',
    'region',
    'district',
    'place',
    'locality',
    'neighborhood',
    'address'
  ];

  const MAJOR_VENUE_POI_KEYWORDS = [
    'airport',
    'international airport',
    'airfield',
    'railway station',
    'train station',
    'subway station',
    'metro station',
    'bus station',
    'bus terminal',
    'transit station',
    'ferry terminal',
    'cruise terminal',
    'harbor',
    'port',
    'stadium',
    'arena',
    'ballpark',
    'coliseum',
    'amphitheater',
    'amphitheatre',
    'convention center',
    'conference center',
    'exhibition center',
    'expo center',
    'landmark',
    'monument',
    'memorial',
    'tower',
    'bridge',
    'palace',
    'castle',
    'temple',
    'shrine',
    'cathedral',
    'church',
    'mosque',
    'synagogue',
    'basilica',
    'pagoda',
    'museum',
    'gallery',
    'art museum',
    'science museum',
    'science center',
    'observatory',
    'planetarium',
    'library',
    'university',
    'college',
    'campus',
    'school',
    'academy',
    'zoo',
    'aquarium',
    'botanical garden',
    'garden',
    'park',
    'national park',
    'state park',
    'theme park',
    'amusement park',
    'water park',
    'heritage site',
    'historic site',
    'world heritage',
    'city hall',
    'parliament',
    'government',
    'embassy',
    'consulate',
    'consulate general',
    'court',
    'plaza',
    'square',
    'cultural center',
    'performing arts',
    'concert hall',
    'opera house',
    'theatre',
    'theater',
    'music hall'
  ].map(keyword => keyword.toLowerCase());

  const MAJOR_VENUE_POI_MAKI = [
    'airport',
    'harbor',
    'harbour',
    'monument',
    'landmark',
    'castle',
    'town-hall',
    'museum',
    'park',
    'stadium',
    'rail',
    'college',
    'library',
    'zoo',
    'campsite'
  ];

  function isMajorVenuePoi(feature, placeTypes){
    const properties = (feature && feature.properties) ? feature.properties : {};
    if(properties.landmark === true) return true;
    if(placeTypes.includes('poi.landmark')) return true;
    const makiRaw = typeof properties.maki === 'string' ? properties.maki : '';
    const maki = makiRaw.toLowerCase();
    if(maki){
      if(MAJOR_VENUE_POI_MAKI.includes(maki) || maki.startsWith('religious')){
        return true;
      }
    }
    const category = typeof properties.category === 'string' ? properties.category.toLowerCase() : '';
    const name = typeof properties.name === 'string' ? properties.name.toLowerCase() : '';
    const text = typeof feature.text === 'string' ? feature.text.toLowerCase() : '';
    const placeName = typeof feature.place_name === 'string' ? feature.place_name.toLowerCase() : '';
    const haystack = [category, name, text, placeName].filter(Boolean).join(' ');
    if(!haystack) return false;
    return MAJOR_VENUE_POI_KEYWORDS.some(keyword => haystack.includes(keyword));
  }

  function majorVenueFilter(feature){
    if(!feature || typeof feature !== 'object') return false;
    const rawTypes = Array.isArray(feature.place_type) ? feature.place_type : [];
    const placeTypes = rawTypes.map(type => String(type || '').toLowerCase());
    if(placeTypes.some(type => MAJOR_VENUE_PRIORITY_TYPES.includes(type))){
      return true;
    }
    if(placeTypes.includes('poi') || placeTypes.includes('poi.landmark')){
      return isMajorVenuePoi(feature, placeTypes);
    }
    return false;
  }

  function normalizeMapboxVenueTypes(value, fallback='poi'){
    const rawList = Array.isArray(value)
      ? value
      : (typeof value === 'string' ? value.split(',') : []);
    const seen = new Set();
    const filtered = [];
    for(const entry of rawList){
      const trimmed = String(entry || '').trim();
      if(!trimmed) continue;
      if(MAPBOX_SUPPORTED_VENUE_TYPES.includes(trimmed) && !seen.has(trimmed)){
        seen.add(trimmed);
        filtered.push(trimmed);
      }
    }
    if(filtered.length > 0){
      return filtered.join(',');
    }
    if(typeof fallback === 'string' && fallback){
      return normalizeMapboxVenueTypes(fallback, '');
    }
    return '';
  }

  async function searchMapboxVenues(query, options={}){
    const normalized = (query || '').trim();
    if(!normalized || normalized.length < MAPBOX_VENUE_MIN_QUERY) return [];
    if(typeof MAPBOX_TOKEN !== 'string' || !MAPBOX_TOKEN){
      return [];
    }
    const limitRaw = Number.isFinite(options.limit) ? options.limit : 5;
    const limit = Math.max(1, Math.min(10, limitRaw));
    const types = normalizeMapboxVenueTypes(options.types, 'poi');
    const resolvedTypes = types || 'poi';
    const language = typeof options.language === 'string' && options.language ? options.language : '';
    const country = typeof options.country === 'string' && options.country ? options.country : '';
    const bbox = Array.isArray(options.bbox) ? options.bbox : null;
    const proximity = options.proximity && Number.isFinite(options.proximity.longitude) && Number.isFinite(options.proximity.latitude)
      ? { longitude: options.proximity.longitude, latitude: options.proximity.latitude }
      : null;
    const cacheKey = mapboxVenueCacheKey(normalized, { limit, types: resolvedTypes, proximity, language, country, bbox });
    if(mapboxVenueCache.has(cacheKey)){
      const cached = mapboxVenueCache.get(cacheKey);
      return Array.isArray(cached) ? cached.map(cloneGeocoderFeature) : [];
    }
    const params = new URLSearchParams({
      access_token: MAPBOX_TOKEN,
      autocomplete: 'true',
      types: resolvedTypes,
      limit: String(limit)
    });
    if(language) params.set('language', language);
    if(country) params.set('country', country);
    if(proximity){
      params.set('proximity', `${proximity.longitude},${proximity.latitude}`);
    }
    if(bbox && bbox.length === 4 && bbox.every(val => Number.isFinite(val))){
      params.set('bbox', bbox.join(','));
    }
    const url = `${MAPBOX_VENUE_ENDPOINT}${encodeURIComponent(normalized)}.json?${params.toString()}`;
    const fetchOptions = {};
    if(options.signal) fetchOptions.signal = options.signal;
    let data = null;
    try{
      const response = await fetch(url, fetchOptions);
      if(!response || !response.ok){
        return [];
      }
      data = await response.json();
    }catch(err){
      if(options.signal && options.signal.aborted){
        return [];
      }
      console.warn('Mapbox venue search failed', err);
      return [];
    }
    const features = Array.isArray(data && data.features) ? data.features : [];
    const normalizedResults = [];
    for(const feature of features){
      const normalizedFeature = normalizeMapboxVenueFeature(feature);
      const center = getMapboxVenueFeatureCenter(normalizedFeature);
      if(!normalizedFeature || !center) continue;
      normalizedResults.push(normalizedFeature);
    }
    rememberMapboxVenueResult(cacheKey, normalizedResults.map(cloneGeocoderFeature));
    return normalizedResults.map(cloneGeocoderFeature);
  }

  function externalMapboxVenueGeocoder(query){
    const contextOptions = (this && this.options) ? this.options : {};
    const limit = Number.isFinite(contextOptions.limit) ? contextOptions.limit : undefined;
    const proximity = contextOptions.proximity && typeof contextOptions.proximity === 'object'
      ? contextOptions.proximity
      : null;
    const language = contextOptions.language;
    const country = contextOptions.country;
    const bbox = contextOptions.bbox;
    const types = normalizeMapboxVenueTypes(contextOptions.types, 'poi');
    return searchMapboxVenues(query, { limit, proximity, language, country, bbox, types });
  }

  rebuildVenueIndex();

  function randomImages(id){
    const hero = heroUrl(id);
    const others = Array.from({length:9},(_,i)=>{
      const port = i % 2 === 0;
      return `https://picsum.photos/seed/${encodeURIComponent(id)}-${i}/${port?'800/1200':'1200/800'}`;
    });
    return [hero, ...others];
  }

  function randomText(min=50,max=200){
    const lorem = "lorem ipsum dolor sit amet consectetur adipiscing elit sed do eiusmod tempor incididunt ut labore et dolore magna aliqua".split(' ');
    const count = min + Math.floor(rnd()*(max-min+1));
    const words = [];
    for(let i=0;i<count;i++){ words.push(lorem[i%lorem.length]); }
    words[0] = words[0][0].toUpperCase() + words[0].slice(1);
    return words.join(' ') + '.';
  }

  function randomPriceRange(){
    const low = 10 + Math.floor(rnd()*90);
    const high = low + 10 + Math.floor(rnd()*90);
    return `$${low} - $${high}`;
  }

  function randomUsername(seed){
    const names = ['Aria','Blake','Casey','Drew','Evan','Finn','Gray','Harper','Indie','Jules'];
    let h = 0; for(let i=0;i<seed.length;i++){ h = (h<<5)-h+seed.charCodeAt(i); }
    const name = names[Math.abs(h)%names.length];
    const num = Math.abs(Math.floor(h/7))%1000;
    return name + num;
  }

  function randomAvatar(seed){
    return `https://picsum.photos/seed/${encodeURIComponent(seed)}-a/100/100`;
  }

  function slugify(str){
    return str.toLowerCase().replace(/[^a-z0-9]+/g,'-').replace(/^-|-$/g,'');
  }
  window.slugify = slugify;

  function postUrl(p){
    return `${BASE_URL}#/post/${p.slug}-${p.created}`;
  }

  async function showCopyMsg(btn){
    const cardHeader = btn && btn.closest('.post-card');
    if(!cardHeader) return;
    const msg = document.createElement('div');
    msg.className='copy-msg';
    const copyMsg = await getMessage('msg_link_copied', {}, false) || 'Link Copied';
    msg.textContent = copyMsg;
    cardHeader.appendChild(msg);
    const btnRect = btn.getBoundingClientRect();
    const headerRect = cardHeader.getBoundingClientRect();
    const msgRect = msg.getBoundingClientRect();
    msg.style.top = (btnRect.top - headerRect.top + (btnRect.height - msgRect.height)/2) + 'px';
    msg.style.left = (btnRect.left - headerRect.left - msgRect.width - 10) + 'px';
    requestAnimationFrame(()=>msg.classList.add('show'));
    setTimeout(()=>msg.remove(),1500);
  }

  function showCopyStyleMessage(text, target){
    if(!target || typeof target.getBoundingClientRect !== 'function') return null;
    const msg = document.createElement('div');
    msg.className = 'copy-msg';
    msg.textContent = text;
    document.body.appendChild(msg);

    let removed = false;
    const remove = ()=>{
      if(removed) return;
      removed = true;
      if(msg && msg.parentNode){
        msg.remove();
      }
    };

    const reposition = ()=>{
      if(!target || typeof target.getBoundingClientRect !== 'function'){
        remove();
        return;
      }
      if(document.body && !document.body.contains(target)){
        remove();
        return;
      }
      const rect = target.getBoundingClientRect();
      const msgRect = msg.getBoundingClientRect();
      const top = rect.top + window.scrollY + (rect.height - msgRect.height) / 2;
      const left = rect.left + window.scrollX + (rect.width - msgRect.width) / 2;
      msg.style.top = `${top}px`;
      msg.style.left = `${left}px`;
    };

    reposition();
    requestAnimationFrame(()=>{
      reposition();
      msg.classList.add('show');
    });

    return { element: msg, remove, reposition };
  }

function makePosts(){
  // OPTIMIZED: Reduced post counts for faster loading (was 1500+, now ~300)
  const out = [];
  const cityCounts = Object.create(null);
  const MAX_POSTS_PER_CITY = 200;
  const neighborhoodCache = new Map();
  const eligibleCategories = Array.isArray(categories)
    ? categories.filter(cat => cat && Array.isArray(cat.subs) && cat.subs.length)
    : [];

  const pickCategory = ()=> eligibleCategories.length ? pick(eligibleCategories) : null;
  const pickSubcategory = (cat)=> (cat && Array.isArray(cat.subs) && cat.subs.length)
    ? pick(cat.subs)
    : null;

  function pushPost(post){
    if(post && post.city){
      const key = String(post.city);
      cityCounts[key] = (cityCounts[key] || 0) + 1;
    }
    out.push(post);
  }

  function canAddCity(city){
    if(!city) return true;
    const key = String(city);
    return (cityCounts[key] || 0) < MAX_POSTS_PER_CITY;
  }

  function inlandShiftFor(lng){
    if(!Number.isFinite(lng)) return 0;
    if(lng < -90) return 0.012;
    if(lng < -30) return -0.012;
    if(lng >= 120) return -0.012;
    if(lng >= 60) return -0.009;
    if(lng >= 20) return -0.008;
    if(lng >= -10) return -0.006;
    return -0.01;
  }

  function buildNeighborhoods(city, baseLng, baseLat){
    const key = city || `${baseLng},${baseLat}`;
    if(neighborhoodCache.has(key)){
      return neighborhoodCache.get(key);
    }
    const latSign = Number.isFinite(baseLat) && baseLat < 0 ? -1 : 1;
    const lngShift = inlandShiftFor(baseLng);
    const neighborhoods = [
      { lng: normalizeLongitude(baseLng), lat: clampLatitude(baseLat) },
      { lng: normalizeLongitude(baseLng + lngShift), lat: clampLatitude(baseLat + 0.008 * latSign) },
      { lng: normalizeLongitude(baseLng + lngShift * 0.6), lat: clampLatitude(baseLat - 0.007 * latSign) },
      { lng: normalizeLongitude(baseLng + lngShift * -0.4), lat: clampLatitude(baseLat + 0.004 * latSign) }
    ];
    neighborhoodCache.set(key, neighborhoods);
    return neighborhoods;
  }

  function jitterNeighborhoodPoint(point){
    if(!point) return { lng: 0, lat: 0 };
    const jitterRange = 0.004;
    const lng = normalizeLongitude(point.lng + (rnd() - 0.5) * jitterRange * 2);
    const lat = clampLatitude(point.lat + (rnd() - 0.5) * jitterRange * 2);
    return { lng, lat };
  }
  // ---- OPTIMIZED: 30 posts at Federation Square (was 100) ----
  const fsLng = 144.9695, fsLat = -37.8178;
  const fsCity = "Federation Square, Melbourne";
  for(let i=0;i<30;i++){
    const cat = pickCategory();
    const sub = pickSubcategory(cat);
    if(!cat || !sub) continue;
    const id = 'FS'+i;
    const title = `${id} ${uniqueTitle(i*7777+13, fsCity, i)}`;
    const created = new Date().toISOString().replace(/[:.]/g,'-');
    const location = createRandomLocation(fsCity, fsLng, fsLat, {
      name: 'Federation Square',
      address: 'Swanston St & Flinders St, Melbourne VIC 3000, Australia',
      radius: 0.05
    });
    const locations = [location];
    pushPost({
      id,
      title,
      slug: slugify(title),
      created,
      city: fsCity,
      lng: location.lng, lat: location.lat,
      category: cat.name,
      subcategory: sub,
      dates: derivePostDatesFromLocations(locations),
      sponsored: true, // All posts are sponsored for development
      fav:false,
      desc: randomText(),
      images: randomImages(id),
      locations,
      member: { username: randomUsername(id), avatar: randomAvatar(id) },
    });
  }

  // ---- OPTIMIZED: 30 posts in Tasmania (was 100) ----
  const tasLng = 147.3272, tasLat = -42.8821;
  const tasCity = "Hobart, Tasmania";
  const todayTas = new Date(); todayTas.setHours(0,0,0,0);
  for(let i=0;i<30;i++){
    const cat = pickCategory();
    const sub = pickSubcategory(cat);
    if(!cat || !sub) continue;
    const id = 'TAS'+i;
    const title = `${id} ${uniqueTitle(i*5311+23, tasCity, i)}`;
    const created = new Date().toISOString().replace(/[:.]/g,'-');
    const offset = 1 + i%30;
    const date = new Date(todayTas);
    date.setDate(date.getDate() + (i<50 ? -offset : offset));
    const location = createRandomLocation(tasCity, tasLng, tasLat, { radius: 0.05 });
    const isoDate = toISODate(date);
    location.dates = [{
      date: date.toLocaleDateString('en-GB',{weekday:'short', day:'numeric', month:'short'}).replace(/,/g,''),
      time: '09:00',
      full: isoDate
    }];
    const locations = [location];
    pushPost({
      id,
      title,
      slug: slugify(title),
      created,
      city: tasCity,
      lng: location.lng,
      lat: location.lat,
      category: cat.name,
      subcategory: sub,
      dates: derivePostDatesFromLocations(locations),
      sponsored: true, // All posts are sponsored for development
      fav:false,
      desc: randomText(),
      images: randomImages(id),
      locations,
      member: { username: randomUsername(id), avatar: randomAvatar(id) },
    });
  }

  // ---- Restore world-wide posts ----
  // A light list of hub cities for better realism
  const hubs = [
    {c:"New York, USA",      lng:-73.9857, lat:40.7484},
    {c:"Los Angeles, USA",   lng:-118.2437, lat:34.0522},
    {c:"London, UK",         lng:-0.1276, lat:51.5074},
    {c:"Paris, France",      lng:2.3522, lat:48.8566},
    {c:"Berlin, Germany",    lng:13.4050, lat:52.5200},
    {c:"Madrid, Spain",      lng:-3.7038, lat:40.4168},
    {c:"Rome, Italy",        lng:12.4964, lat:41.9028},
    {c:"Amsterdam, NL",      lng:4.9041, lat:52.3676},
    {c:"Dublin, Ireland",    lng:-6.2603, lat:53.3498},
    {c:"Stockholm, Sweden",  lng:18.0686, lat:59.3293},
    {c:"Copenhagen, Denmark",lng:12.5683, lat:55.6761},
    {c:"Helsinki, Finland",  lng:24.9384, lat:60.1699},
    {c:"Oslo, Norway",       lng:10.7522, lat:59.9139},
    {c:"Reykjavk, Iceland", lng:-21.8277, lat:64.1265},
    {c:"Moscow, Russia",     lng:37.6173, lat:55.7558},
    {c:"Istanbul, Trkiye",  lng:28.9784, lat:41.0082},
    {c:"Athens, Greece",     lng:23.7275, lat:37.9838},
    {c:"Cairo, Egypt",       lng:31.2357, lat:30.0444},
    {c:"Nairobi, Kenya",     lng:36.8219, lat:-1.2921},
    {c:"Lagos, Nigeria",     lng:3.3792, lat:6.5244},
    {c:"Johannesburg, SA",   lng:28.0473, lat:-26.2041},
    {c:"Cape Town, SA",      lng:18.4241, lat:-33.9249},
    {c:"Dubai, UAE",         lng:55.2708, lat:25.2048},
    {c:"Mumbai, India",      lng:72.8777, lat:19.0760},
    {c:"Delhi, India",       lng:77.1025, lat:28.7041},
    {c:"Bangkok, Thailand",  lng:100.5018, lat:13.7563},
    {c:"Singapore",          lng:103.8198, lat:1.3521},
    {c:"Hong Kong, China",   lng:114.1694, lat:22.3193},
    {c:"Tokyo, Japan",       lng:139.6917, lat:35.6895},
    {c:"Seoul, South Korea", lng:126.9780, lat:37.5665},
    {c:"Sydney, Australia",  lng:151.2093, lat:-33.8688},
    {c:"Brisbane, Australia",lng:153.0251, lat:-27.4698},
    {c:"Auckland, New Zealand", lng:174.7633, lat:-36.8485},
    {c:"Toronto, Canada",    lng:-79.3832, lat:43.6532},
    {c:"Vancouver, Canada",  lng:-123.1207, lat:49.2827},
    {c:"Mexico City, Mexico",lng:-99.1332, lat:19.4326},
    {c:"So Paulo, Brazil",  lng:-46.6333, lat:-23.5505},
    {c:"Rio de Janeiro, Brazil", lng:-43.1729, lat:-22.9068},
    {c:"Buenos Aires, Argentina", lng:-58.3816, lat:-34.6037},
    {c:"Santiago, Chile",    lng:-70.6693, lat:-33.4489}
  ];

  // OPTIMIZED: Generate ~200 posts across hubs (was 900)
  const TOTAL_WORLD = 200;
  const worldCitySpecs = hubs.map(hub => ({
    city: hub.c,
    baseLng: hub.lng,
    baseLat: hub.lat,
    neighborhoods: buildNeighborhoods(hub.c, hub.lng, hub.lat),
    generated: 0
  }));
  const shufflePool = (pool)=>{
    if(!pool.length) return pool;
    const order = shuffledIndices(pool.length);
    return order.map(idx => pool[idx]);
  };
  let worldPool = shufflePool(worldCitySpecs.map((_, idx) => idx));
  let worldPoolIndex = 0;
  let worldProduced = 0;
  const WORLD_ATTEMPT_MAX = TOTAL_WORLD * 6;
  let worldAttempts = 0;
  while(worldProduced < TOTAL_WORLD && worldPool.length && worldAttempts < WORLD_ATTEMPT_MAX){
    if(worldPoolIndex >= worldPool.length){
      const available = worldPool.filter(idx => canAddCity(worldCitySpecs[idx].city));
      worldPool = shufflePool(available);
      worldPoolIndex = 0;
      if(!worldPool.length){
        break;
      }
    }
    const specIndex = worldPool[worldPoolIndex++];
    const spec = worldCitySpecs[specIndex];
    worldAttempts++;
    if(!spec || !canAddCity(spec.city)){
      continue;
    }
    const neighborhoods = spec.neighborhoods && spec.neighborhoods.length
      ? spec.neighborhoods
      : buildNeighborhoods(spec.city, spec.baseLng, spec.baseLat);
    const generation = spec.generated || 0;
    const basePoint = neighborhoods[generation % neighborhoods.length] || neighborhoods[0];
    spec.generated = generation + 1;
    const coords = jitterNeighborhoodPoint(basePoint);
    const cityLabel = typeof spec.city === 'string' ? spec.city.split(',')[0].trim() || spec.city : spec.city;
    const location = createRandomLocation(spec.city, coords.lng, coords.lat, {
      name: `${cityLabel} District ${((generation % neighborhoods.length) + 1)}`,
      address: spec.city,
      radius: 0
    });
    const locations = [location];
    const cat = pickCategory();
    const sub = pickSubcategory(cat);
    if(!cat || !sub) continue;
    const id = `WW${worldProduced}`;
    const title = `${id} ${uniqueTitle(worldProduced*9343+19, spec.city, worldProduced)}`;
    const created = new Date().toISOString().replace(/[:.]/g,'-');
    pushPost({
      id,
      title,
      slug: slugify(title),
      created,
      city: spec.city,
      lng: location.lng,
      lat: location.lat,
      category: cat.name,
      subcategory: sub,
      dates: derivePostDatesFromLocations(locations),
      sponsored: true, // All posts are sponsored for development
      fav:false,
      desc: randomText(),
      images: randomImages(id),
      locations,
      member: { username: randomUsername(id), avatar: randomAvatar(id) },
    });
    worldProduced++;
  }

  // ---- OPTIMIZED: 5 Sydney Opera House posts (was 10) ----
  const operaCity = 'Sydney, Australia';
  const operaVenueName = 'Sydney Opera House';
  const operaAddress = 'Bennelong Point, Sydney NSW 2000, Australia';
  const operaLng = 151.2153;
  const operaLat = -33.8568;
  for(let i=0;i<5;i++){
    const cat = pickCategory();
    const sub = pickSubcategory(cat);
    if(!cat || !sub) continue;
    const id = 'SOH'+i;
    const title = `${id} ${uniqueTitle(i*12007+7, operaCity, i)}`;
    const created = new Date().toISOString().replace(/[:.]/g,'-');
    const location = {
      venue: operaVenueName,
      address: operaAddress,
      lng: operaLng,
      lat: operaLat,
      dates: randomSchedule(),
      price: randomPriceRange()
    };
    const locations = [location];
    pushPost({
      id,
      title,
      slug: slugify(title),
      created,
      city: operaCity,
      lng: operaLng,
      lat: operaLat,
      category: cat.name,
      subcategory: sub,
      dates: derivePostDatesFromLocations(locations),
      sponsored: true, // All posts are sponsored for development
      fav:false,
      desc: randomText(),
      images: randomImages(id),
      locations,
      member: { username: randomUsername(id), avatar: randomAvatar(id) },
    });
  }

  // ---- OPTIMIZED: 100 single-venue posts (was 400) ----
  const coordKey = (lng, lat)=>{
    if(!Number.isFinite(lng) || !Number.isFinite(lat)) return '';
    return `${lng.toFixed(6)},${lat.toFixed(6)}`;
  };
  const existingCoordKeys = new Set(out.map(p => coordKey(p.lng, p.lat)).filter(Boolean));
  const singleVenueBases = [
    { city: "Anchorage, USA", lng: -149.9003, lat: 61.2181 },
    { city: "Honolulu, USA", lng: -157.8583, lat: 21.3069 },
    { city: "San Francisco, USA", lng: -122.4194, lat: 37.7749 },
    { city: "Seattle, USA", lng: -122.3321, lat: 47.6062 },
    { city: "Vancouver, Canada", lng: -123.1207, lat: 49.2827 },
    { city: "Calgary, Canada", lng: -114.0719, lat: 51.0447 },
    { city: "Toronto, Canada", lng: -79.3832, lat: 43.6532 },
    { city: "Montreal, Canada", lng: -73.5673, lat: 45.5017 },
    { city: "Boston, USA", lng: -71.0589, lat: 42.3601 },
    { city: "New Orleans, USA", lng: -90.0715, lat: 29.9511 },
    { city: "Chicago, USA", lng: -87.6298, lat: 41.8781 },
    { city: "Miami, USA", lng: -80.1918, lat: 25.7617 },
    { city: "Dallas, USA", lng: -96.7969, lat: 32.7767 },
    { city: "Denver, USA", lng: -104.9903, lat: 39.7392 },
    { city: "Phoenix, USA", lng: -112.0740, lat: 33.4484 },
    { city: "Los Angeles, USA", lng: -118.2437, lat: 34.0522 },
    { city: "Mexico City, Mexico", lng: -99.1332, lat: 19.4326 },
    { city: "Guadalajara, Mexico", lng: -103.3496, lat: 20.6597 },
    { city: "Bogot, Colombia", lng: -74.0721, lat: 4.7110 },
    { city: "Lima, Peru", lng: -77.0428, lat: -12.0464 },
    { city: "Quito, Ecuador", lng: -78.4678, lat: -0.1807 },
    { city: "Santiago, Chile", lng: -70.6693, lat: -33.4489 },
    { city: "Buenos Aires, Argentina", lng: -58.3816, lat: -34.6037 },
    { city: "Montevideo, Uruguay", lng: -56.1645, lat: -34.9011 },
    { city: "So Paulo, Brazil", lng: -46.6333, lat: -23.5505 },
    { city: "Rio de Janeiro, Brazil", lng: -43.1729, lat: -22.9068 },
    { city: "Braslia, Brazil", lng: -47.8825, lat: -15.7942 },
    { city: "Recife, Brazil", lng: -34.8770, lat: -8.0476 },
    { city: "Fortaleza, Brazil", lng: -38.5434, lat: -3.7319 },
    { city: "Caracas, Venezuela", lng: -66.9036, lat: 10.4806 },
    { city: "San Juan, Puerto Rico", lng: -66.1057, lat: 18.4655 },
    { city: "Reykjavk, Iceland", lng: -21.8277, lat: 64.1265 },
    { city: "Oslo, Norway", lng: 10.7522, lat: 59.9139 },
    { city: "Stockholm, Sweden", lng: 18.0686, lat: 59.3293 },
    { city: "Helsinki, Finland", lng: 24.9384, lat: 60.1699 },
    { city: "Copenhagen, Denmark", lng: 12.5683, lat: 55.6761 },
    { city: "Edinburgh, UK", lng: -3.1883, lat: 55.9533 },
    { city: "Dublin, Ireland", lng: -6.2603, lat: 53.3498 },
    { city: "Glasgow, UK", lng: -4.2518, lat: 55.8642 },
    { city: "London, UK", lng: -0.1276, lat: 51.5074 },
    { city: "Manchester, UK", lng: -2.2426, lat: 53.4808 },
    { city: "Paris, France", lng: 2.3522, lat: 48.8566 },
    { city: "Lyon, France", lng: 4.8357, lat: 45.7640 },
    { city: "Marseille, France", lng: 5.3698, lat: 43.2965 },
    { city: "Madrid, Spain", lng: -3.7038, lat: 40.4168 },
    { city: "Barcelona, Spain", lng: 2.1734, lat: 41.3851 },
    { city: "Valencia, Spain", lng: -0.3763, lat: 39.4699 },
    { city: "Lisbon, Portugal", lng: -9.1393, lat: 38.7223 },
    { city: "Porto, Portugal", lng: -8.6291, lat: 41.1579 },
    { city: "Brussels, Belgium", lng: 4.3517, lat: 50.8503 },
    { city: "Amsterdam, Netherlands", lng: 4.9041, lat: 52.3676 },
    { city: "Rotterdam, Netherlands", lng: 4.4792, lat: 51.9244 },
    { city: "Berlin, Germany", lng: 13.4050, lat: 52.5200 },
    { city: "Hamburg, Germany", lng: 9.9937, lat: 53.5511 },
    { city: "Munich, Germany", lng: 11.5820, lat: 48.1351 },
    { city: "Frankfurt, Germany", lng: 8.6821, lat: 50.1109 },
    { city: "Prague, Czechia", lng: 14.4378, lat: 50.0755 },
    { city: "Vienna, Austria", lng: 16.3738, lat: 48.2082 },
    { city: "Zurich, Switzerland", lng: 8.5417, lat: 47.3769 },
    { city: "Warsaw, Poland", lng: 21.0122, lat: 52.2297 },
    { city: "Krakw, Poland", lng: 19.9440, lat: 50.0647 },
    { city: "Budapest, Hungary", lng: 19.0402, lat: 47.4979 },
    { city: "Bucharest, Romania", lng: 26.1025, lat: 44.4268 },
    { city: "Athens, Greece", lng: 23.7275, lat: 37.9838 },
    { city: "Istanbul, Trkiye", lng: 28.9784, lat: 41.0082 },
    { city: "Ankara, Trkiye", lng: 32.8597, lat: 39.9334 },
    { city: "Cairo, Egypt", lng: 31.2357, lat: 30.0444 },
    { city: "Casablanca, Morocco", lng: -7.5898, lat: 33.5731 },
    { city: "Marrakesh, Morocco", lng: -7.9811, lat: 31.6295 },
    { city: "Algiers, Algeria", lng: 3.0588, lat: 36.7538 },
    { city: "Tunis, Tunisia", lng: 10.1815, lat: 36.8065 },
    { city: "Tripoli, Libya", lng: 13.1913, lat: 32.8872 },
    { city: "Khartoum, Sudan", lng: 32.5599, lat: 15.5007 },
    { city: "Addis Ababa, Ethiopia", lng: 38.7578, lat: 8.9806 },
    { city: "Nairobi, Kenya", lng: 36.8219, lat: -1.2921 },
    { city: "Kampala, Uganda", lng: 32.5825, lat: 0.3476 },
    { city: "Dar es Salaam, Tanzania", lng: 39.2083, lat: -6.7924 },
    { city: "Kigali, Rwanda", lng: 30.0588, lat: -1.9499 },
    { city: "Lagos, Nigeria", lng: 3.3792, lat: 6.5244 },
    { city: "Accra, Ghana", lng: -0.1869, lat: 5.6037 },
    { city: "Abidjan, Cte d'Ivoire", lng: -4.0083, lat: 5.3599 },
    { city: "Dakar, Senegal", lng: -17.4731, lat: 14.7167 },
    { city: "Kinshasa, DR Congo", lng: 15.2663, lat: -4.4419 },
    { city: "Luanda, Angola", lng: 13.2344, lat: -8.8383 },
    { city: "Johannesburg, South Africa", lng: 28.0473, lat: -26.2041 },
    { city: "Cape Town, South Africa", lng: 18.4241, lat: -33.9249 },
    { city: "Windhoek, Namibia", lng: 17.0832, lat: -22.5609 },
    { city: "Gaborone, Botswana", lng: 25.9089, lat: -24.6282 },
    { city: "Harare, Zimbabwe", lng: 31.0530, lat: -17.8249 },
    { city: "Maputo, Mozambique", lng: 32.5732, lat: -25.9692 },
    { city: "Riyadh, Saudi Arabia", lng: 46.6753, lat: 24.7136 },
    { city: "Jeddah, Saudi Arabia", lng: 39.1979, lat: 21.4858 },
    { city: "Doha, Qatar", lng: 51.5310, lat: 25.2854 },
    { city: "Dubai, UAE", lng: 55.2708, lat: 25.2048 },
    { city: "Muscat, Oman", lng: 58.4059, lat: 23.5859 },
    { city: "Kuwait City, Kuwait", lng: 47.9783, lat: 29.3759 },
    { city: "Manama, Bahrain", lng: 50.5861, lat: 26.2285 },
    { city: "Tehran, Iran", lng: 51.3890, lat: 35.6892 },
    { city: "Baghdad, Iraq", lng: 44.3661, lat: 33.3152 },
    { city: "Amman, Jordan", lng: 35.9239, lat: 31.9522 },
    { city: "Beirut, Lebanon", lng: 35.5018, lat: 33.8938 },
    { city: "Jerusalem", lng: 35.2137, lat: 31.7683 },
    { city: "Mumbai, India", lng: 72.8777, lat: 19.0760 },
    { city: "Delhi, India", lng: 77.1025, lat: 28.7041 },
    { city: "Bengaluru, India", lng: 77.5946, lat: 12.9716 },
    { city: "Hyderabad, India", lng: 78.4867, lat: 17.3850 },
    { city: "Chennai, India", lng: 80.2707, lat: 13.0827 },
    { city: "Kolkata, India", lng: 88.3639, lat: 22.5726 },
    { city: "Kathmandu, Nepal", lng: 85.3240, lat: 27.7172 },
    { city: "Dhaka, Bangladesh", lng: 90.4125, lat: 23.8103 },
    { city: "Colombo, Sri Lanka", lng: 79.8612, lat: 6.9271 },
    { city: "Bangkok, Thailand", lng: 100.5018, lat: 13.7563 },
    { city: "Chiang Mai, Thailand", lng: 98.9931, lat: 18.7883 },
    { city: "Vientiane, Laos", lng: 102.6341, lat: 17.9757 },
    { city: "Phnom Penh, Cambodia", lng: 104.9282, lat: 11.5564 },
    { city: "Ho Chi Minh City, Vietnam", lng: 106.6297, lat: 10.8231 },
    { city: "Hanoi, Vietnam", lng: 105.8342, lat: 21.0278 },
    { city: "Yangon, Myanmar", lng: 96.1951, lat: 16.8409 },
    { city: "Singapore", lng: 103.8198, lat: 1.3521 },
    { city: "Kuala Lumpur, Malaysia", lng: 101.6869, lat: 3.1390 },
    { city: "Jakarta, Indonesia", lng: 106.8456, lat: -6.2088 },
    { city: "Surabaya, Indonesia", lng: 112.7521, lat: -7.2575 },
    { city: "Manila, Philippines", lng: 120.9842, lat: 14.5995 },
    { city: "Cebu, Philippines", lng: 123.8854, lat: 10.3157 },
    { city: "Hong Kong", lng: 114.1694, lat: 22.3193 },
    { city: "Macau", lng: 113.5439, lat: 22.1987 },
    { city: "Taipei, Taiwan", lng: 121.5654, lat: 25.0330 },
    { city: "Seoul, South Korea", lng: 126.9780, lat: 37.5665 },
    { city: "Busan, South Korea", lng: 129.0756, lat: 35.1796 },
    { city: "Tokyo, Japan", lng: 139.6917, lat: 35.6895 },
    { city: "Osaka, Japan", lng: 135.5023, lat: 34.6937 },
    { city: "Nagoya, Japan", lng: 136.9066, lat: 35.1815 },
    { city: "Sapporo, Japan", lng: 141.3544, lat: 43.0618 },
    { city: "Beijing, China", lng: 116.4074, lat: 39.9042 },
    { city: "Shanghai, China", lng: 121.4737, lat: 31.2304 },
    { city: "Guangzhou, China", lng: 113.2644, lat: 23.1291 },
    { city: "Shenzhen, China", lng: 114.0579, lat: 22.5431 },
    { city: "Chengdu, China", lng: 104.0665, lat: 30.5728 },
    { city: "Xi'an, China", lng: 108.9398, lat: 34.3416 },
    { city: "Ulaanbaatar, Mongolia", lng: 106.9057, lat: 47.8864 },
    { city: "Almaty, Kazakhstan", lng: 76.8860, lat: 43.2389 },
    { city: "Bishkek, Kyrgyzstan", lng: 74.5698, lat: 42.8746 },
    { city: "Tashkent, Uzbekistan", lng: 69.2401, lat: 41.2995 },
    { city: "Astana, Kazakhstan", lng: 71.4704, lat: 51.1605 },
    { city: "Moscow, Russia", lng: 37.6173, lat: 55.7558 },
    { city: "Saint Petersburg, Russia", lng: 30.3351, lat: 59.9343 },
    { city: "Novosibirsk, Russia", lng: 82.9346, lat: 55.0084 },
    { city: "Yekaterinburg, Russia", lng: 60.5975, lat: 56.8389 },
    { city: "Perth, Australia", lng: 115.8575, lat: -31.9505 },
    { city: "Adelaide, Australia", lng: 138.6007, lat: -34.9285 },
    { city: "Melbourne, Australia", lng: 144.9631, lat: -37.8136 },
    { city: "Sydney, Australia", lng: 151.2093, lat: -33.8688 },
    { city: "Brisbane, Australia", lng: 153.0251, lat: -27.4698 },
    { city: "Hobart, Australia", lng: 147.3272, lat: -42.8821 },
    { city: "Auckland, New Zealand", lng: 174.7633, lat: -36.8485 },
    { city: "Wellington, New Zealand", lng: 174.7762, lat: -41.2865 },
    { city: "Christchurch, New Zealand", lng: 172.6362, lat: -43.5321 },
    { city: "Suva, Fiji", lng: 178.4419, lat: -18.1248 }
  ];
  const SINGLE_VENUE_POSTS = 100;
  const singleVenueSpecs = singleVenueBases.map(base => ({
    city: base.city,
    baseLng: base.lng,
    baseLat: base.lat,
    neighborhoods: buildNeighborhoods(base.city, base.lng, base.lat),
    generated: 0
  }));
  let singlePool = shufflePool(singleVenueSpecs.map((_, idx) => idx));
  let singlePoolIndex = 0;
  let singleProduced = 0;
  const SINGLE_ATTEMPT_MAX = SINGLE_VENUE_POSTS * 8;
  let singleAttempts = 0;
  while(singleProduced < SINGLE_VENUE_POSTS && singlePool.length && singleAttempts < SINGLE_ATTEMPT_MAX){
    if(singlePoolIndex >= singlePool.length){
      const available = singlePool.filter(idx => canAddCity(singleVenueSpecs[idx].city));
      singlePool = shufflePool(available);
      singlePoolIndex = 0;
      if(!singlePool.length){
        break;
      }
    }
    const specIndex = singlePool[singlePoolIndex++];
    const spec = singleVenueSpecs[specIndex];
    singleAttempts++;
    if(!spec || !canAddCity(spec.city)){
      continue;
    }
    const neighborhoods = spec.neighborhoods && spec.neighborhoods.length
      ? spec.neighborhoods
      : buildNeighborhoods(spec.city, spec.baseLng, spec.baseLat);
    const generation = spec.generated || 0;
    const venueIndex = generation % neighborhoods.length;
    const cycle = Math.floor(generation / neighborhoods.length) + 1;
    spec.generated = generation + 1;
    const basePoint = neighborhoods[venueIndex] || neighborhoods[0];
    let coords = jitterNeighborhoodPoint(basePoint);
    let key = coordKey(coords.lng, coords.lat);
    let coordAttempts = 0;
    while((!key || existingCoordKeys.has(key)) && coordAttempts < 20){
      coords = jitterNeighborhoodPoint(basePoint);
      key = coordKey(coords.lng, coords.lat);
      coordAttempts++;
    }
    if(!key || existingCoordKeys.has(key)){
      continue;
    }
    const venueName = `${spec.city} Solo Venue ${cycle}-${venueIndex + 1}`;
    const locationDetail = createRandomLocation(spec.city, coords.lng, coords.lat, {
      name: venueName,
      address: spec.city,
      radius: 0
    });
    const locations = [locationDetail];
    const finalKey = coordKey(locationDetail.lng, locationDetail.lat);
    if(finalKey){
      existingCoordKeys.add(finalKey);
    }
    const cat = pickCategory();
    const sub = pickSubcategory(cat);
    if(!cat || !sub) continue;
    const id = `SV${singleProduced}`;
    const title = `${id} ${uniqueTitle(singleProduced*48271+131, spec.city, singleProduced)}`;
    const created = new Date().toISOString().replace(/[:.]/g,'-');
    pushPost({
      id,
      title,
      slug: slugify(title),
      created,
      city: spec.city,
      lng: locationDetail.lng,
      lat: locationDetail.lat,
      category: cat.name,
      subcategory: sub,
      dates: derivePostDatesFromLocations(locations),
      sponsored: true, // All posts are sponsored for development
      fav:false,
      desc: randomText(),
      images: randomImages(id),
      locations,
      member: { username: randomUsername(id), avatar: randomAvatar(id) },
    });
    singleProduced++;
  }

  const MIN_MULTI_VENUE_DISTANCE_KM = 50;
  const MAX_MULTI_VENUE_DISTANCE_KM = 4000;
  const EARTH_RADIUS_KM = 6371;

  function toRadians(degrees){
    return (Number.isFinite(degrees) ? degrees : 0) * Math.PI / 180;
  }

  function haversineDistanceKm(a, b){
    if(!a || !b) return Infinity;
    const lat1 = toRadians(a.lat);
    const lat2 = toRadians(b.lat);
    const dLat = toRadians(b.lat - a.lat);
    const dLng = toRadians(b.lng - a.lng);
    const sinDLat = Math.sin(dLat / 2);
    const sinDLng = Math.sin(dLng / 2);
    const chord = sinDLat * sinDLat + Math.cos(lat1) * Math.cos(lat2) * sinDLng * sinDLng;
    const clampChord = Math.min(1, Math.max(0, chord));
    return 2 * EARTH_RADIUS_KM * Math.atan2(Math.sqrt(clampChord), Math.sqrt(1 - clampChord));
  }

  function buildMultiPostPool(){
    const cityLookup = singleVenueBases.reduce((acc, base)=>{
      if(!base || !base.city) return acc;
      if(Number.isFinite(base.lng) && Number.isFinite(base.lat)){
        acc[base.city] = { lng: base.lng, lat: base.lat };
      }
      return acc;
    }, Object.create(null));

    const MULTI_REGION_CITY_LISTS = [
      {
        region: 'North America',
        cityNames: [
          'Anchorage, USA',
          'Honolulu, USA',
          'San Francisco, USA',
          'Seattle, USA',
          'Vancouver, Canada',
          'Calgary, Canada',
          'Toronto, Canada',
          'Montreal, Canada',
          'Boston, USA',
          'New Orleans, USA',
          'Chicago, USA',
          'Miami, USA',
          'Dallas, USA',
          'Denver, USA',
          'Phoenix, USA',
          'Los Angeles, USA'
        ]
      },
      {
        region: 'Central & South America',
        cityNames: [
          'Mexico City, Mexico',
          'Guadalajara, Mexico',
          'Bogot, Colombia',
          'Lima, Peru',
          'Quito, Ecuador',
          'Santiago, Chile',
          'Buenos Aires, Argentina',
          'Montevideo, Uruguay',
          'So Paulo, Brazil',
          'Rio de Janeiro, Brazil',
          'Braslia, Brazil',
          'Recife, Brazil',
          'Fortaleza, Brazil',
          'Caracas, Venezuela',
          'San Juan, Puerto Rico'
        ]
      },
      {
        region: 'Europe',
        cityNames: [
          'Reykjavk, Iceland',
          'Oslo, Norway',
          'Stockholm, Sweden',
          'Helsinki, Finland',
          'Copenhagen, Denmark',
          'Edinburgh, UK',
          'Dublin, Ireland',
          'Glasgow, UK',
          'London, UK',
          'Manchester, UK',
          'Paris, France',
          'Lyon, France',
          'Marseille, France',
          'Madrid, Spain',
          'Barcelona, Spain',
          'Valencia, Spain',
          'Lisbon, Portugal',
          'Berlin, Germany',
          'Hamburg, Germany',
          'Munich, Germany',
          'Frankfurt, Germany',
          'Prague, Czechia',
          'Vienna, Austria',
          'Zurich, Switzerland',
          'Warsaw, Poland',
          'Krakw, Poland',
          'Budapest, Hungary',
          'Bucharest, Romania',
          'Athens, Greece'
        ]
      },
      {
        region: 'Africa',
        cityNames: [
          'Cairo, Egypt',
          'Casablanca, Morocco',
          'Marrakesh, Morocco',
          'Algiers, Algeria',
          'Tunis, Tunisia',
          'Tripoli, Libya',
          'Khartoum, Sudan',
          'Addis Ababa, Ethiopia',
          'Nairobi, Kenya',
          'Kampala, Uganda',
          'Dar es Salaam, Tanzania',
          'Kigali, Rwanda',
          'Lagos, Nigeria',
          'Accra, Ghana',
          "Abidjan, Cte d'Ivoire",
          'Dakar, Senegal',
          'Kinshasa, DR Congo',
          'Luanda, Angola',
          'Johannesburg, South Africa',
          'Cape Town, South Africa',
          'Windhoek, Namibia',
          'Gaborone, Botswana',
          'Harare, Zimbabwe',
          'Maputo, Mozambique'
        ]
      },
      {
        region: 'Middle East',
        cityNames: [
          'Riyadh, Saudi Arabia',
          'Jeddah, Saudi Arabia',
          'Doha, Qatar',
          'Dubai, UAE',
          'Muscat, Oman',
          'Kuwait City, Kuwait',
          'Manama, Bahrain',
          'Tehran, Iran',
          'Baghdad, Iraq',
          'Amman, Jordan',
          'Beirut, Lebanon',
          'Jerusalem'
        ]
      },
      {
        region: 'Asia',
        cityNames: [
          'Mumbai, India',
          'Delhi, India',
          'Bengaluru, India',
          'Hyderabad, India',
          'Chennai, India',
          'Kolkata, India',
          'Kathmandu, Nepal',
          'Dhaka, Bangladesh',
          'Colombo, Sri Lanka',
          'Bangkok, Thailand',
          'Chiang Mai, Thailand',
          'Vientiane, Laos',
          'Phnom Penh, Cambodia',
          'Ho Chi Minh City, Vietnam',
          'Hanoi, Vietnam',
          'Yangon, Myanmar',
          'Singapore',
          'Kuala Lumpur, Malaysia',
          'Jakarta, Indonesia',
          'Surabaya, Indonesia',
          'Manila, Philippines',
          'Cebu, Philippines',
          'Hong Kong',
          'Macau',
          'Taipei, Taiwan',
          'Seoul, South Korea',
          'Busan, South Korea',
          'Tokyo, Japan',
          'Osaka, Japan',
          'Nagoya, Japan',
          'Sapporo, Japan',
          'Beijing, China',
          'Shanghai, China',
          'Guangzhou, China',
          'Shenzhen, China',
          'Chengdu, China',
          "Xi'an, China",
          'Ulaanbaatar, Mongolia',
          'Almaty, Kazakhstan',
          'Bishkek, Kyrgyzstan',
          'Tashkent, Uzbekistan',
          'Astana, Kazakhstan',
          'Moscow, Russia',
          'Saint Petersburg, Russia',
          'Novosibirsk, Russia',
          'Yekaterinburg, Russia'
        ]
      },
      {
        region: 'Oceania',
        cityNames: [
          'Perth, Australia',
          'Adelaide, Australia',
          'Melbourne, Australia',
          'Sydney, Australia',
          'Brisbane, Australia',
          'Hobart, Australia',
          'Auckland, New Zealand',
          'Wellington, New Zealand',
          'Christchurch, New Zealand',
          'Suva, Fiji'
        ]
      }
    ];

    const deterministicOffset = (label, axis)=>{
      let hash = 0;
      for(let i = 0; i < label.length; i++){
        const charCode = label.charCodeAt(i);
        hash = (hash * 33 + charCode + (axis + 1) * 131) & 0xffffffff;
      }
      const normalized = ((hash % 2001) / 2000) - 0.5;
      return normalized * 0.002;
    };

    const pool = [];
    const seen = new Set();

    MULTI_REGION_CITY_LISTS.forEach(spec => {
      if(!spec || !spec.region || !Array.isArray(spec.cityNames)) return;
      spec.cityNames.forEach(cityName => {
        if(!cityName) return;
        const base = cityLookup[cityName];
        if(!base) return;
        const label = `${spec.region}:${cityName}`;
        let lng = normalizeLongitude(base.lng + deterministicOffset(label, 0));
        let lat = clampLatitude(base.lat + deterministicOffset(label, 1));
        let key = toVenueCoordKey(lng, lat);
        if(!key || seen.has(key)){
          let attempts = 0;
          let adjustment = 0.0003;
          while(attempts < 5 && key && seen.has(key)){
            const delta = adjustment * (attempts % 2 === 0 ? 1 : -1);
            lng = normalizeLongitude(base.lng + delta);
            lat = clampLatitude(base.lat + delta);
            key = toVenueCoordKey(lng, lat);
            attempts++;
            adjustment += 0.0001;
          }
          if((!key || seen.has(key)) && toVenueCoordKey(base.lng, base.lat) && !seen.has(toVenueCoordKey(base.lng, base.lat))){
            lng = normalizeLongitude(base.lng);
            lat = clampLatitude(base.lat);
            key = toVenueCoordKey(lng, lat);
          }
        }
        if(!key || seen.has(key)){
          return;
        }
        seen.add(key);
        pool.push({
          city: cityName,
          region: spec.region,
          lng,
          lat
        });
      });
    });
    return pool;
  }

  function shuffledIndices(length){
    const indices = Array.from({ length }, (_, idx) => idx);
    for(let i = indices.length - 1; i > 0; i--){
      const j = Math.floor(rnd() * (i + 1));
      const tmp = indices[i];
      indices[i] = indices[j];
      indices[j] = tmp;
    }
    return indices;
  }

  function assignMultiPosts(postList, targetCount){
    if(!Array.isArray(postList) || !postList.length || targetCount <= 0){
      return 0;
    }
    const pool = buildMultiPostPool();
    if(pool.length < 2){
      return 0;
    }
    const venuesByRegion = pool.reduce((acc, venue) => {
      if(!venue) return acc;
      const key = venue.region || 'Global';
      if(!acc[key]) acc[key] = [];
      acc[key].push(venue);
      return acc;
    }, Object.create(null));
    const regionKeys = Object.keys(venuesByRegion).filter(key => Array.isArray(venuesByRegion[key]) && venuesByRegion[key].length >= 2);
    if(!regionKeys.length){
      return 0;
    }
    const sampleVenueSet = (regionKey, desiredCount)=>{
      const candidates = venuesByRegion[regionKey];
      if(!Array.isArray(candidates) || candidates.length < desiredCount){
        return null;
      }
      const maxAttempts = Math.max(20, candidates.length);
      for(let attempt = 0; attempt < maxAttempts; attempt++){
        const order = shuffledIndices(candidates.length);
        const selection = [];
        const used = new Set();
        for(let i = 0; i < order.length && selection.length < desiredCount; i++){
          const candidate = candidates[order[i]];
          if(!candidate) continue;
          const key = toVenueCoordKey(candidate.lng, candidate.lat);
          if(!key || used.has(key)) continue;
          let ok = true;
          for(let s = 0; s < selection.length; s++){
            const existing = selection[s];
            const distance = haversineDistanceKm(existing, candidate);
            if(distance < MIN_MULTI_VENUE_DISTANCE_KM || distance > MAX_MULTI_VENUE_DISTANCE_KM){
              ok = false;
              break;
            }
          }
          if(ok){
            selection.push(candidate);
            used.add(key);
          }
        }
        if(selection.length === desiredCount){
          return selection;
        }
      }
      return null;
    };
    const indices = shuffledIndices(postList.length);
    let assigned = 0;
    for(let idx = 0; idx < indices.length && assigned < targetCount; idx++){
      const post = postList[indices[idx]];
      if(!post){
        continue;
      }
      const desiredBase = 2 + Math.floor(rnd() * 3);
      let desired = desiredBase;
      let venues = null;
      let attempts = 0;
      while(attempts < 60 && !venues){
        const regionKey = regionKeys[Math.floor(rnd() * regionKeys.length)];
        venues = sampleVenueSet(regionKey, desired);
        if(!venues){
          attempts++;
          if(attempts % 10 === 0 && desired > 2){
            desired--;
          }
        }
      }
      if(!venues || venues.length < 2){
        for(let r = 0; r < regionKeys.length && (!venues || venues.length < 2); r++){
          venues = sampleVenueSet(regionKeys[r], 2);
        }
      }
      if(!venues || venues.length < 2){
        continue;
      }
      const nextLocations = venues.map((venue, venueIdx) => {
        const cityLabel = venue.city;
        const venueLabel = `${cityLabel}  Spot ${venueIdx + 1}`;
        return {
          venue: venueLabel,
          address: cityLabel,
          lng: venue.lng,
          lat: venue.lat,
          dates: randomSchedule(),
          price: randomPriceRange()
        };
      });
      post.locations = nextLocations;
      post.dates = derivePostDatesFromLocations(nextLocations);
      const primary = nextLocations[0];
      if(primary){
        post.lng = primary.lng;
        post.lat = primary.lat;
        post.city = primary.address || primary.venue || post.city;
      }
      assigned++;
    }
    return assigned;
  }

  // OPTIMIZED: Reduced multi-post assignment target (was 1000, now 200 to match reduced post count)
  assignMultiPosts(out, 200);

  out.forEach(post => {
    if(!post) return;
    if(Array.isArray(post.locations) && post.locations.length){
      post.dates = derivePostDatesFromLocations(post.locations);
    } else if(Array.isArray(post.dates)){
      post.dates = post.dates.slice().sort();
    } else {
      post.dates = [];
    }
  });

  return out;
}

    // Posts cache is REQUIRED for performance - posts are generated once and reused
    let ALL_POSTS_CACHE = null;
    let ALL_POSTS_BY_ID = null;
    function rebuildAllPostsIndex(cache){
      if(!Array.isArray(cache)){
        ALL_POSTS_BY_ID = null;
        return;
      }
      const map = new Map();
      cache.forEach(item => {
        if(!item || item.id === undefined || item.id === null) return;
        map.set(String(item.id), item);
      });
      ALL_POSTS_BY_ID = map;
    }
    function getAllPostsCache(options = {}){
      const { allowInitialize = true } = options;
      if(Array.isArray(ALL_POSTS_CACHE)){
        return ALL_POSTS_CACHE;
      }
      if(!allowInitialize){
        return null;
      }
      // Track if posts were built with empty categories (for race condition detection)
      const hadCategories = Array.isArray(window.categories) && window.categories.length > 0;
      ALL_POSTS_CACHE = makePosts();
      if(!hadCategories && ALL_POSTS_CACHE.length === 0){
        window.__postsBuiltWithEmptyCategories = true;
      }
      rebuildAllPostsIndex(ALL_POSTS_CACHE);
      return ALL_POSTS_CACHE;
    }
    // Clear posts cache to force regeneration when categories change
    function invalidateAllPostsCache(){
      ALL_POSTS_CACHE = null;
      ALL_POSTS_BY_ID = null;
      // Also clear loaded posts state so posts are actually reloaded
      if(typeof clearLoadedPosts === 'function'){
        clearLoadedPosts();
      }
    }
    window.invalidateAllPostsCache = invalidateAllPostsCache;
    function getPostByIdAnywhere(id){
      if(id === undefined || id === null) return null;
      const normalizedId = String(id);
      const checkList = (list) => {
        if(!Array.isArray(list)) return null;
        return list.find(entry => entry && String(entry.id) === normalizedId) || null;
      };
      const loaded = checkList(posts);
      if(loaded) return loaded;
      if(!ALL_POSTS_BY_ID || !(ALL_POSTS_BY_ID instanceof Map)){
        const cache = getAllPostsCache({ allowInitialize: true });
        if(Array.isArray(cache)){
          rebuildAllPostsIndex(cache);
        }
      }
      return ALL_POSTS_BY_ID instanceof Map ? (ALL_POSTS_BY_ID.get(normalizedId) || null) : null;
    }
    const EMPTY_FEATURE_COLLECTION = { type:'FeatureCollection', features: [] };

    // Marker data cache is REQUIRED for performance - prevents recalculating GeoJSON on every interaction
    const markerDataCache = {
      signature: null,
      postsData: EMPTY_FEATURE_COLLECTION,
      featureIndex: new Map()
    };

    function invalidateMarkerDataCache(){
      markerDataCache.signature = null;
      markerDataCache.postsData = EMPTY_FEATURE_COLLECTION;
      markerDataCache.featureIndex = new Map();
    }

    function markerSignatureForList(list){
      if(!Array.isArray(list) || !list.length){
        return 'empty';
      }
      const parts = [];
      list.forEach(post => {
        if(!post) return;
        const baseId = post.id || '';
        let added = false;
        if(Array.isArray(post.locations) && post.locations.length){
          post.locations.forEach((loc, idx) => {
            if(!loc) return;
            const key = toVenueCoordKey(loc.lng, loc.lat);
            if(!key) return;
            parts.push(`${baseId}#${idx}:${key}`);
            added = true;
          });
        }
        if(!added){
          const key = toVenueCoordKey(post.lng, post.lat);
          if(key){
            parts.push(`${baseId}:${key}`);
          } else {
            parts.push(String(baseId));
          }
        }
      });
      parts.sort();
      return parts.join('|');
    }

    function buildMarkerFeatureIndex(postsData){
      const index = new Map();
      const features = Array.isArray(postsData?.features) ? postsData.features : [];
      features.forEach(feature => {
        if(!feature || !feature.properties) return;
        const props = feature.properties;
        const baseId = props.id;
        if(baseId === undefined || baseId === null) return;
        const fid = feature.id ?? props.featureId;
        if(fid === undefined || fid === null) return;
        let venueKey = '';
        if(props.venueKey !== undefined && props.venueKey !== null){
          const venueString = String(props.venueKey).trim();
          venueKey = venueString;
        } else if(typeof fid === 'string'){
          const parts = fid.split('::');
          if(parts.length >= 3){
            venueKey = String(parts[1] || '');
          }
        }
        const rawSpriteId = props.spriteId ?? '';
        const spriteId = rawSpriteId !== undefined && rawSpriteId !== null ? String(rawSpriteId) : '';
        const ids = new Set();
        ids.add(String(baseId));
        if(Array.isArray(props.multiPostIds)){
          props.multiPostIds.forEach(postId => {
            if(postId === undefined || postId === null) return;
            const strId = String(postId);
            if(strId) ids.add(strId);
          });
        }
        ids.forEach(idValue => {
          if(!index.has(idValue)){
            index.set(idValue, []);
          }
          index.get(idValue).push({ source: 'posts', id: fid, venueKey, spriteId });
        });
      });
      return index;
    }

    function getMarkerCollections(list){
      const signature = markerSignatureForList(list);
      if(markerDataCache.signature === signature && markerDataCache.postsData){
        return {
          postsData: markerDataCache.postsData,
          signature,
          changed: false,
          featureIndex: markerDataCache.featureIndex
        };
      }
      if(!Array.isArray(list) || !list.length){
        markerDataCache.signature = signature;
        markerDataCache.postsData = EMPTY_FEATURE_COLLECTION;
        markerDataCache.featureIndex = new Map();
        return {
          postsData: EMPTY_FEATURE_COLLECTION,
          signature,
          changed: true,
          featureIndex: markerDataCache.featureIndex
        };
      }
      const postsData = postsToGeoJSON(list);
      markerDataCache.signature = signature;
      markerDataCache.postsData = postsData;
      markerDataCache.featureIndex = buildMarkerFeatureIndex(postsData);
      return { postsData, signature, changed: true, featureIndex: markerDataCache.featureIndex };
    }


    async function syncMarkerSources(list, options = {}){
      const { force = false } = options;
      const collections = getMarkerCollections(list);
      const { postsData, signature, featureIndex } = collections;
      markerFeatureIndex = featureIndex instanceof Map ? featureIndex : new Map();
      let updated = false;
      if(map && typeof map.getSource === 'function'){
        const postsSource = map.getSource('posts');
        if(postsSource && (force || postsSource.__markerSignature !== signature)){
          try{ postsSource.setData(postsData); }catch(err){ console.error(err); }
          postsSource.__markerSignature = signature;
          updated = true;
        }
      }
      if(updated || force){
        updateMapFeatureHighlights(lastHighlightedPostIds);
      }
      return { updated, signature };
    }

    let postsLoaded = false;
    window.postsLoaded = postsLoaded;
    let waitForInitialZoom = window.waitForInitialZoom ?? (firstVisit ? true : false);
    let initialZoomStarted = false;
    let postLoadRequested = false;
    let lastLoadedBoundsKey = null;
    window.waitForInitialZoom = waitForInitialZoom;
    let updatePostsButtonState = () => {};

    function boundsToKey(bounds, precision = 2){
      if(!bounds) return '';
      const west = typeof bounds.getWest === 'function' ? bounds.getWest() : bounds.west;
      const east = typeof bounds.getEast === 'function' ? bounds.getEast() : bounds.east;
      const south = typeof bounds.getSouth === 'function' ? bounds.getSouth() : bounds.south;
      const north = typeof bounds.getNorth === 'function' ? bounds.getNorth() : bounds.north;
      const fmt = (val) => Number.isFinite(val) ? val.toFixed(precision) : 'nan';
      return [west, south, east, north].map(fmt).join('|');
    }

    function normalizeBounds(bounds){
      if(!bounds) return null;
      if(typeof bounds.getWest === 'function'){
        return {
          west: bounds.getWest(),
          east: bounds.getEast(),
          south: bounds.getSouth(),
          north: bounds.getNorth()
        };
      }
      const { west, east, south, north } = bounds;
      if(!Number.isFinite(west) || !Number.isFinite(east) || !Number.isFinite(south) || !Number.isFinite(north)){
        return null;
      }
      return { west, east, south, north };
    }

    function expandBounds(bounds, padding = {}){
      const normalized = normalizeBounds(bounds);
      if(!normalized) return null;
      let latPad;
      let lngPad;
      if(typeof padding === 'number'){
        latPad = lngPad = padding;
      } else {
        const latCandidate = padding.lat ?? padding.latitude ?? padding.y ?? padding.vertical;
        const lngCandidate = padding.lng ?? padding.longitude ?? padding.x ?? padding.horizontal;
        latPad = Number.isFinite(latCandidate) ? latCandidate : 0.25;
        lngPad = Number.isFinite(lngCandidate) ? lngCandidate : 0.25;
      }
      latPad = Math.max(0, latPad);
      lngPad = Math.max(0, lngPad);
      let { west, east, south, north } = normalized;
      west = Math.max(-180, west - lngPad);
      east = Math.min(180, east + lngPad);
      const clampLat = (value) => Math.max(-85, Math.min(85, value));
      south = clampLat(south - latPad);
      north = clampLat(north + latPad);
      return { west, east, south, north };
    }

    function pointWithinBounds(lng, lat, bounds){
      if(!Number.isFinite(lng) || !Number.isFinite(lat) || !bounds){
        return false;
      }
      const { west, east, south, north } = bounds;
      if(!Number.isFinite(west) || !Number.isFinite(east) || !Number.isFinite(south) || !Number.isFinite(north)){
        return false;
      }
      const withinLat = lat >= Math.min(south, north) && lat <= Math.max(south, north);
      if(!withinLat) return false;
      if(west <= east){
        return lng >= west && lng <= east;
      }
      return lng >= west || lng <= east;
    }

    function clearLoadedPosts(){
      invalidateMarkerDataCache();
      if(postsLoaded){
        postsLoaded = false;
        window.postsLoaded = postsLoaded;
      }
      lastLoadedBoundsKey = null;
      posts = [];
      filtered = [];
      if(typeof sortedPostList !== 'undefined'){ sortedPostList = []; }
      if(typeof renderedPostCount !== 'undefined'){ renderedPostCount = 0; }
      if(typeof postBatchObserver !== 'undefined' && postBatchObserver){
        try{ postBatchObserver.disconnect(); }catch(err){}
        postBatchObserver = null;
      }
      if(typeof postSentinel !== 'undefined' && postSentinel && postSentinel.remove){
        postSentinel.remove();
        postSentinel = null;
      }
      if(typeof adTimer !== 'undefined' && adTimer){
        clearInterval(adTimer);
        adTimer = null;
      }
      if(typeof adPosts !== 'undefined'){ adPosts = []; }
      if(typeof adIdsKey !== 'undefined'){ adIdsKey = ''; }
      const adPanelEl = typeof document !== 'undefined' ? document.querySelector('.ad-panel') : null;
      if(adPanelEl){ adPanelEl.innerHTML = ''; }
      const resultsElLocal = $('#results');
      if(resultsElLocal){ resultsElLocal.innerHTML = ''; }
      const postsBoardEl = $('.post-board');
      if(postsBoardEl){ postsBoardEl.innerHTML = ''; }
      hideResultIndicators();
      if(typeof updateResetBtn === 'function'){ updateResetBtn(); }
      if(map){
        const postsSource = map.getSource && map.getSource('posts');
        if(postsSource && typeof postsSource.setData === 'function'){
          postsSource.setData(EMPTY_FEATURE_COLLECTION);
          postsSource.__markerSignature = null;
        }
      }
      updateLayerVisibility(lastKnownZoom);
    }

    function loadPosts(bounds){
      if(spinning){
        pendingPostLoad = true;
        return;
      }
      const normalized = normalizeBounds(bounds);
      if(!normalized){
        postLoadRequested = true;
        hideResultIndicators();
        return;
      }
      const key = boundsToKey(normalized);
      if(postsLoaded && lastLoadedBoundsKey === key){
        applyFilters();
        return;
      }
      const cache = getAllPostsCache();
      const nextPosts = Array.isArray(cache)
        ? cache.filter(p => pointWithinBounds(p.lng, p.lat, normalized))
        : [];
      posts = nextPosts;
      postsLoaded = true;
      window.postsLoaded = postsLoaded;
      lastLoadedBoundsKey = key;
      rebuildVenueIndex();
      invalidateMarkerDataCache();
      resetClusterSourceState();
      if(markersLoaded && map && Object.keys(subcategoryMarkers).length){ addPostSource(); }
      initAdBoard();
      applyFilters();
      updateLayerVisibility(lastKnownZoom);
    }

    let markerLayersVisible = false;
    let pendingZoomCheckToken = null;
    let pendingZoomEvent = null;

    function getZoomFromEvent(event){
      if(event){
        if(typeof event.zoom === 'number'){ return event.zoom; }
        const target = event.target && typeof event.target.getZoom === 'function' ? event.target : null;
        if(target){
          try{ return target.getZoom(); }catch(err){ return NaN; }
        }
      }
      if(map && typeof map.getZoom === 'function'){
        try{ return map.getZoom(); }catch(err){ return NaN; }
      }
      return NaN;
    }

    function setLayerVisibility(id, visible){
      if(!map || typeof map.getLayer !== 'function') return;
      let layer = null;
      try{ layer = map.getLayer(id); }catch(err){ layer = null; }
      if(!layer) return;
      const desired = visible ? 'visible' : 'none';
      try{
        const current = map.getLayoutProperty(id, 'visibility');
        if(current !== desired){
          map.setLayoutProperty(id, 'visibility', desired);
        }
      }catch(err){
        try{ map.setLayoutProperty(id, 'visibility', desired); }catch(e){}
      }
    }

    function updateMarkerZoomClasses(zoom){
      if(!map || typeof map.getContainer !== 'function') return;
      const container = map.getContainer();
      if(!container || !container.classList) return;
      const zoomValue = Number.isFinite(zoom) ? zoom : getZoomFromEvent();
      const isMidZoom = Number.isFinite(zoomValue) && zoomValue >= MARKER_ZOOM_THRESHOLD && zoomValue < MARKER_SPRITE_ZOOM;
      const isSpriteZoom = Number.isFinite(zoomValue) && zoomValue >= MARKER_SPRITE_ZOOM;
      container.classList.toggle(MID_ZOOM_MARKER_CLASS, isMidZoom);
      container.classList.toggle(SPRITE_MARKER_CLASS, isSpriteZoom);
    }

    function updateLayerVisibility(zoom){
      const zoomValue = Number.isFinite(zoom) ? zoom : getZoomFromEvent();
      const zoomBucket = Number.isFinite(zoomValue)
        ? Math.floor((zoomValue + 1e-6) * ZOOM_VISIBILITY_PRECISION)
        : NaN;
      const hasBucket = Number.isFinite(zoomBucket);
      const shouldShowMarkers = hasBucket ? zoomBucket >= MARKER_VISIBILITY_BUCKET : markerLayersVisible;
      const shouldShowClusters = hasBucket ? zoomBucket < MARKER_VISIBILITY_BUCKET : clusterLayersVisible;
      if(markerLayersVisible !== shouldShowMarkers){
        MARKER_LAYER_IDS.forEach(id => {
          setLayerVisibility(id, shouldShowMarkers);
        });
        markerLayersVisible = shouldShowMarkers;
      }
      if(clusterLayersVisible !== shouldShowClusters){
        CLUSTER_LAYER_IDS.forEach(id => setLayerVisibility(id, shouldShowClusters));
        clusterLayersVisible = shouldShowClusters;
      }
      if(shouldShowClusters && Number.isFinite(zoomValue)){
        updateClusterSourceForZoom(zoomValue);
      }
    }

    function updateZoomState(zoom){
      if(Number.isFinite(zoom)){
        lastKnownZoom = zoom;
      } else {
        const current = getZoomFromEvent();
        if(Number.isFinite(current)){
          lastKnownZoom = current;
        }
      }
      updatePostsButtonState(lastKnownZoom);
      updateLayerVisibility(lastKnownZoom);
      updateMarkerZoomClasses(lastKnownZoom);
      updateClusterSourceForZoom(lastKnownZoom);
      if(map && Number.isFinite(lastKnownZoom) && lastKnownZoom >= MARKER_SPRITE_ZOOM){
        map.__retainAllMarkerSprites = true;
      }
      if(!markersLoaded){
        const preloadCandidate = Number.isFinite(lastKnownZoom) ? lastKnownZoom : getZoomFromEvent();
        if(Number.isFinite(preloadCandidate) && preloadCandidate >= MARKER_PRELOAD_ZOOM){
          try{ loadPostMarkers(); }catch(err){ console.error(err); }
          markersLoaded = true;
          window.__markersLoaded = true;
        }
      }
    }

    function scheduleCheckLoadPosts(event){
      pendingZoomEvent = event || { zoom: lastKnownZoom, target: map };
      if(pendingZoomCheckToken !== null) return;
      const scheduler = typeof requestAnimationFrame === 'function' ? requestAnimationFrame : (cb)=> setTimeout(cb, 0);
      pendingZoomCheckToken = scheduler(()=>{
        pendingZoomCheckToken = null;
        const evt = pendingZoomEvent;
        pendingZoomEvent = null;
        checkLoadPosts(evt);
      });
    }
    window.scheduleCheckLoadPosts = scheduleCheckLoadPosts;

    function checkLoadPosts(event){
      if(!map) return;
      const zoomCandidate = getZoomFromEvent(event);
      updateZoomState(zoomCandidate);
      let zoomLevel = Number.isFinite(zoomCandidate) ? zoomCandidate : lastKnownZoom;
      if(!Number.isFinite(zoomLevel)){
        zoomLevel = getZoomFromEvent();
      }
      if(waitForInitialZoom){
        if(Number.isFinite(zoomLevel) && zoomLevel >= MARKER_PRELOAD_ZOOM){
          waitForInitialZoom = false;
          window.waitForInitialZoom = waitForInitialZoom;
          initialZoomStarted = false;
        } else {
          postLoadRequested = true;
          hideResultIndicators();
          return;
        }
      }
      if(!Number.isFinite(zoomLevel)){
        postLoadRequested = true;
        hideResultIndicators();
        return;
      }
      updatePostsButtonState(zoomLevel);
      if(Number.isFinite(zoomLevel) && zoomLevel < MARKER_PRELOAD_ZOOM){
        postLoadRequested = true;
        if(postsLoaded || (Array.isArray(posts) && posts.length)){ clearLoadedPosts(); }
        hideResultIndicators();
        return;
      }
      if(spinning){
        pendingPostLoad = true;
        hideResultIndicators();
        return;
      }
      postLoadRequested = false;
      const bounds = typeof map.getBounds === 'function' ? map.getBounds() : null;
      if(!bounds){
        postLoadRequested = true;
        hideResultIndicators();
        return;
      }
      loadPosts(bounds);
    }

    const resultsEl = $('#results');
    const postsWideEl = $('.post-board');
    const postsModeEl = $('.post-board');

    let sortedPostList = [];
    let renderedPostCount = 0;
    let postBatchObserver = null;
    let postSentinel = null;
    let postBoardScrollOptions = null;
    const INITIAL_RENDER_COUNT = 50;
    const POST_BATCH_SIZE = 25;

    function appendPostBatch(count = POST_BATCH_SIZE){
      const slice = sortedPostList.slice(renderedPostCount, renderedPostCount + count);
      slice.forEach(p => {
        if(resultsEl){
          const rCard = card(p);
          if(activePostId && p.id === activePostId) rCard.setAttribute('aria-selected','true');
          resultsEl.appendChild(rCard);
        }
        const wCard = card(p, true);
        postsWideEl.insertBefore(wCard, postSentinel);
      });
      renderedPostCount += slice.length;
      if(renderedPostCount >= sortedPostList.length){
        if(postBatchObserver) postBatchObserver.disconnect();
        removeScrollListener(postsWideEl, onPostBoardScroll, postBoardScrollOptions);
        postBoardScrollOptions = null;
      }
      prioritizeVisibleImages();
    }

    function onPostBoardScroll(){
      if(postsWideEl.scrollTop + postsWideEl.clientHeight >= postsWideEl.scrollHeight - 200){
        appendPostBatch();
      }
    }

    // Image helpers (reuse shared utilities)

    function memberAvatarUrl(p){
      if(p.member && p.member.avatar){
        return p.member.avatar;
      }
      return 'assets/balloons/birthday-party-png-45917-100.png';
    }


    // Categories UI
    const categoryControllers = {};
    const allSubcategoryKeys = [];
    const resetCategoriesBtn = $('#resetCategoriesBtn');
    const catsEl = $('#cats');
    const formbuilderCats = document.getElementById('formbuilderCats');
    const formbuilderAddCategoryBtn = document.getElementById('formbuilderAddCategory');
    const FORM_BUILDER_ADD_CATEGORY_HANDLER_PROP = '__formbuilderAddCategoryHandler';
    let formbuilderConfirmOverlay = null;
    let categoryDragContainerInitialized = false;
    let draggedCategoryMenu = null;
    let categoryDropIndicatorTarget = null;
    let categoryDropIndicatorClass = '';
    let categoryDropIndicatorBefore = null;
    let categoryDropCommitted = false;
    let draggedSubcategoryMenu = null;
    let draggedSubcategoryContainer = null;
    const subcategoryContainerState = new WeakMap();
    let draggedFieldRow = null;
    let draggedFieldContainer = null;
    const fieldContainerState = new WeakMap();
    const dropIndicatorMap = new WeakMap();

    function getDropIndicator(container){
      if(!container) return null;
      let indicator = dropIndicatorMap.get(container);
      if(indicator && indicator.parentElement !== container){
        dropIndicatorMap.delete(container);
        indicator = null;
      }
      if(!indicator){
        indicator = document.createElement('div');
        indicator.className = 'formbuilder-drop-indicator';
        container.appendChild(indicator);
        dropIndicatorMap.set(container, indicator);
      }
      return indicator;
    }

    function hideDropIndicator(container){
      if(!container) return;
      const indicator = dropIndicatorMap.get(container);
      if(indicator){
        indicator.classList.remove('visible');
      }
    }

    function positionDropIndicator(container, target, before, selector, draggedEl){
      if(!container) return;
      const indicator = getDropIndicator(container);
      if(!indicator) return;
      let top = 0;
      if(target && target !== draggedEl){
        top = before ? target.offsetTop : target.offsetTop + target.offsetHeight;
      } else {
        const items = Array.from(container.querySelectorAll(selector)).filter(el => el !== draggedEl);
        if(items.length > 0){
          const ref = before ? items[0] : items[items.length - 1];
          top = before ? ref.offsetTop : ref.offsetTop + ref.offsetHeight;
        } else {
          top = 0;
        }
      }
      indicator.style.top = `${top}px`;
      indicator.classList.add('visible');
    }

    function sanitizeInsertionReference(node){
      while(node && node.nodeType === 1 && node.classList.contains('formbuilder-drop-indicator')){
        node = node.nextSibling;
      }
      while(node && node.nodeType === 3){
        node = node.nextSibling;
      }
      return node;
    }

    function clearCategoryDropIndicator(){
      if(categoryDropIndicatorTarget){
        categoryDropIndicatorTarget.classList.remove('drag-target-before','drag-target-after');
        categoryDropIndicatorTarget = null;
        categoryDropIndicatorClass = '';
      }
      categoryDropIndicatorBefore = null;
      hideDropIndicator(formbuilderCats);
    }

    function updateCategoryDropIndicator(target, before){
      const cls = target ? (before ? 'drag-target-before' : 'drag-target-after') : '';
      if(categoryDropIndicatorTarget && categoryDropIndicatorTarget !== target){
        categoryDropIndicatorTarget.classList.remove('drag-target-before','drag-target-after');
      }
      if(target){
        if(categoryDropIndicatorTarget !== target || categoryDropIndicatorClass !== cls){
          target.classList.remove('drag-target-before','drag-target-after');
          target.classList.add(cls);
          categoryDropIndicatorTarget = target;
          categoryDropIndicatorClass = cls;
        }
      } else {
        categoryDropIndicatorTarget = null;
        categoryDropIndicatorClass = '';
      }
      categoryDropIndicatorBefore = before;
      positionDropIndicator(formbuilderCats, target, before, '.category-form-menu', draggedCategoryMenu);
    }

    function captureChildPositions(container, selector){
      const map = new Map();
      if(!container) return map;
      container.querySelectorAll(selector).forEach(el=>{
        map.set(el, el.getBoundingClientRect());
      });
      return map;
    }

    function animateListReorder(container, selector, previousRects, exclude){
      if(!container || !previousRects || previousRects.size === 0) return;
      requestAnimationFrame(()=>{
        container.querySelectorAll(selector).forEach(el=>{
          if(el === exclude) return;
          const prevRect = previousRects.get(el);
          if(!prevRect) return;
          const nextRect = el.getBoundingClientRect();
          const dx = prevRect.left - nextRect.left;
          const dy = prevRect.top - nextRect.top;
          if(Math.abs(dx) < 0.5 && Math.abs(dy) < 0.5) return;
          el.style.transition = 'none';
          el.style.transform = `translate(${dx}px, ${dy}px)`;
          void el.offsetWidth;
          el.style.transition = 'transform 150ms ease';
          el.style.transform = '';
          const cleanup = ()=>{
            el.style.transition = '';
            el.style.transform = '';
            el.removeEventListener('transitionend', cleanup);
          };
          el.addEventListener('transitionend', cleanup);
        });
      });
    }

    function createFormbuilderDragHandle(label, extraClass){
      const handle = document.createElement('button');
      handle.type = 'button';
      handle.className = extraClass ? `formbuilder-drag-handle ${extraClass}` : 'formbuilder-drag-handle';
      handle.setAttribute('aria-label', label);
      handle.title = label;
      handle.draggable = true;
      handle.setAttribute('draggable', 'true');
      handle.innerHTML = '<svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor" aria-hidden="true"><path d="M8 1.25a.75.75 0 0 1 .53.22l2.5 2.5a.75.75 0 1 1-1.06 1.06L8.75 3.38v3.12a.75.75 0 0 1-1.5 0V3.38L6.03 5.03a.75.75 0 0 1-1.06-1.06l2.5-2.5A.75.75 0 0 1 8 1.25zm0 13.5a.75.75 0 0 0 .53-.22l2.5-2.5a.75.75 0 0 0-1.06-1.06L8.75 12.62V9.5a.75.75 0 0 0-1.5 0v3.12l-1.72-1.66a.75.75 0 1 0-1.06 1.06l2.5 2.5c.14.14.33.22.53.22z"/></svg>';
      handle.addEventListener('keydown', event=>{
        if(event.key === ' ' || event.key === 'Spacebar'){
          event.preventDefault();
        }
      });
      return handle;
    }

    function updateDragHandleLabel(handle, label){
      if(!handle) return;
      handle.setAttribute('aria-label', label);
      handle.title = label;
    }

    let formbuilderAutoSaveTimer = null;
    
    // Auto-save toggle - stored in localStorage
    function isAutoSaveEnabled(){
      return localStorage.getItem('adminAutoSave') === 'true';
    }
    function setAutoSaveEnabled(enabled){
      localStorage.setItem('adminAutoSave', enabled ? 'true' : 'false');
    }
    
    // Initialize auto-save toggle checkbox
    function initAutoSaveToggle(){
      const toggle = document.getElementById('adminAutosaveToggle');
      if(toggle){
        toggle.checked = isAutoSaveEnabled();
        toggle.addEventListener('change', ()=>{
          setAutoSaveEnabled(toggle.checked);
        });
      }
    }
    
    // Initialize when DOM is ready
    if(document.readyState === 'loading'){
      document.addEventListener('DOMContentLoaded', initAutoSaveToggle);
    } else {
      initAutoSaveToggle();
    }
    
    function notifyFormbuilderChange(){
      if(!formbuilderCats) return;
      // Don't trigger save if interaction is inside a sandbox (form preview)
      const activeEl = document.activeElement;
      if(activeEl && activeEl.closest && activeEl.closest('[data-sandbox="true"]')){
        return;
      }
      try{
        formbuilderCats.dispatchEvent(new Event('change', { bubbles: true }));
      }catch(err){
        const evt = document.createEvent('Event');
        evt.initEvent('change', true, true);
        formbuilderCats.dispatchEvent(evt);
      }
      // Directly mark admin panel as dirty since formbuilder state isn't tracked via form inputs
      // Only after formbuilder is fully loaded to avoid marking dirty during initialization
      if(window.formbuilderStateManager && window.formbuilderStateManager._loaded){
        if(window.adminPanelModule && typeof window.adminPanelModule.markDirty === 'function'){
          window.adminPanelModule.markDirty();
        }
        // Auto-save with debounce (only if enabled)
        if(isAutoSaveEnabled()){
          if(formbuilderAutoSaveTimer){
            clearTimeout(formbuilderAutoSaveTimer);
          }
          formbuilderAutoSaveTimer = setTimeout(()=>{
            if(typeof window.adminPanelModule?.runSave === 'function'){
              window.adminPanelModule.runSave({ closeAfter: false });
            }
          }, 800);
        }
      }
    }

    function syncCategoriesFromDom(){
      if(!formbuilderCats) return;
      const menuEls = Array.from(formbuilderCats.querySelectorAll('.category-form-menu'));
      if(menuEls.length !== categories.length) return;
      const used = new Set();
      const newOrder = [];
      menuEls.forEach(menu=>{
        const idx = Number.parseInt(menu.dataset.categoryIndex, 10);
        if(Number.isInteger(idx) && idx >= 0 && idx < categories.length && !used.has(idx)){
          newOrder.push(categories[idx]);
          used.add(idx);
          return;
        }
        const name = menu.dataset.category || '';
        const fallback = categories.findIndex((cat, index)=> cat && !used.has(index) && cat.name === name);
        if(fallback !== -1){
          newOrder.push(categories[fallback]);
          used.add(fallback);
        }
      });
      let changed = false;
      if(newOrder.length === categories.length){
        for(let i = 0; i < newOrder.length; i++){
          if(newOrder[i] !== categories[i]){
            changed = true;
            break;
          }
        }
        if(changed){
          categories.splice(0, categories.length, ...newOrder);
        }
      }
      menuEls.forEach((menu, index)=>{
        menu.dataset.categoryIndex = String(index);
      });
      if(changed){
        notifyFormbuilderChange();
      }
    }

    function ensureCategoryDragContainer(){
      if(categoryDragContainerInitialized || !formbuilderCats) return;
      categoryDragContainerInitialized = true;
      formbuilderCats.addEventListener('dragover', event=>{
        if(!draggedCategoryMenu || draggedSubcategoryMenu || draggedFieldRow){
          return;
        }
        event.preventDefault();
        if(event.dataTransfer){
          event.dataTransfer.dropEffect = 'move';
        }
        const target = event.target.closest('.category-form-menu');
        const menus = Array.from(formbuilderCats.querySelectorAll('.category-form-menu')).filter(menu => menu !== draggedCategoryMenu);
        const containerRect = formbuilderCats.getBoundingClientRect();
        if(!target || target === draggedCategoryMenu){
          if(menus.length === 0){
            updateCategoryDropIndicator(null, true);
            return;
          }
          if(event.clientY <= containerRect.top + 8){
            updateCategoryDropIndicator(menus[0], true);
          } else {
            updateCategoryDropIndicator(menus[menus.length - 1], false);
          }
          return;
        }
        const rect = target.getBoundingClientRect();
        const before = event.clientY < rect.top + rect.height / 2;
        updateCategoryDropIndicator(target, before);
      });
      formbuilderCats.addEventListener('drop', event=>{
        if(!draggedCategoryMenu || draggedSubcategoryMenu || draggedFieldRow){
          return;
        }
        event.preventDefault();
        categoryDropCommitted = true;
        const target = categoryDropIndicatorTarget;
        const before = categoryDropIndicatorBefore;
        let reference = null;
        if(formbuilderCats){
          if(target && target !== draggedCategoryMenu){
            reference = before ? target : target.nextSibling;
          } else if(!target && before){
            reference = formbuilderCats.firstChild;
          }
        }
        reference = sanitizeInsertionReference(reference);
        const currentNext = draggedCategoryMenu.nextSibling;
        if(formbuilderCats){
          const beforeRects = captureChildPositions(formbuilderCats, '.category-form-menu');
          if(reference !== draggedCategoryMenu && reference !== currentNext){
            formbuilderCats.insertBefore(draggedCategoryMenu, reference || null);
            animateListReorder(formbuilderCats, '.category-form-menu', beforeRects, draggedCategoryMenu);
          }
        }
        clearCategoryDropIndicator();
        syncCategoriesFromDom();
      });
      formbuilderCats.addEventListener('dragleave', event=>{
        if(!draggedCategoryMenu || draggedSubcategoryMenu || draggedFieldRow) return;
        if(event.target === formbuilderCats){
          clearCategoryDropIndicator();
        }
      });
    }

    function clearSubDropIndicator(state){
      if(!state) return;
      if(state.dropIndicatorTarget){
        state.dropIndicatorTarget.classList.remove('drag-target-before','drag-target-after');
        state.dropIndicatorTarget = null;
        state.dropIndicatorClass = '';
      }
      state.dropIndicatorBefore = null;
      hideDropIndicator(state.container);
    }

    function updateSubDropIndicator(state, target, before){
      if(!state) return;
      const cls = target ? (before ? 'drag-target-before' : 'drag-target-after') : '';
      if(state.dropIndicatorTarget && state.dropIndicatorTarget !== target){
        state.dropIndicatorTarget.classList.remove('drag-target-before','drag-target-after');
      }
      if(target){
        if(state.dropIndicatorTarget !== target || state.dropIndicatorClass !== cls){
          target.classList.remove('drag-target-before','drag-target-after');
          target.classList.add(cls);
          state.dropIndicatorTarget = target;
          state.dropIndicatorClass = cls;
        }
      } else {
        state.dropIndicatorTarget = null;
        state.dropIndicatorClass = '';
      }
      state.dropIndicatorBefore = before;
      positionDropIndicator(state.container, target, before, '.subcategory-form-menu', draggedSubcategoryMenu);
    }

    function syncSubcategoryOrderFromDom(container, categoryObj){
      if(!container || !categoryObj) return;
      const subEls = Array.from(container.querySelectorAll('.subcategory-form-menu'));
      const original = Array.isArray(categoryObj.subs) ? categoryObj.subs.slice() : [];
      const used = new Set();
      const reordered = [];
      subEls.forEach(subMenu=>{
        const idx = Number.parseInt(subMenu.dataset.subIndex, 10);
        if(Number.isInteger(idx) && idx >= 0 && idx < original.length && !used.has(idx)){
          reordered.push(original[idx]);
          used.add(idx);
          return;
        }
        const name = subMenu.dataset.subcategory || '';
        const fallback = original.findIndex((subName, index)=> subName === name && !used.has(index));
        if(fallback !== -1){
          reordered.push(original[fallback]);
          used.add(fallback);
        }
      });
      let changed = false;
      if(reordered.length === original.length){
        for(let i = 0; i < reordered.length; i++){
          if(reordered[i] !== original[i]){
            changed = true;
            break;
          }
        }
        if(changed){
          categoryObj.subs = reordered;
        }
      }
      subEls.forEach((subMenu, index)=>{
        subMenu.dataset.subIndex = String(index);
      });
      if(changed){
        notifyFormbuilderChange();
      }
    }

    function setupSubcategoryContainer(container, categoryObj, addButton){
      if(!container) return null;
      let state = subcategoryContainerState.get(container);
      if(!state){
        state = {
          dropIndicatorTarget: null,
          dropIndicatorClass: '',
          dropIndicatorBefore: null,
          dropCommitted: false,
          addButton: addButton,
          category: categoryObj,
          container
        };
        subcategoryContainerState.set(container, state);
        container.addEventListener('dragover', event=>{
          if(!draggedSubcategoryMenu || draggedSubcategoryContainer !== container) return;
          event.preventDefault();
          event.stopPropagation();
          if(event.dataTransfer){
            event.dataTransfer.dropEffect = 'move';
          }
          const target = event.target.closest('.subcategory-form-menu');
          const subMenus = Array.from(container.querySelectorAll('.subcategory-form-menu')).filter(menu => menu !== draggedSubcategoryMenu);
          const containerRect = container.getBoundingClientRect();
          if(!target || target === draggedSubcategoryMenu){
            if(subMenus.length === 0){
              updateSubDropIndicator(state, null, true);
            } else if(event.clientY <= containerRect.top + 8){
              updateSubDropIndicator(state, subMenus[0], true);
            } else {
              updateSubDropIndicator(state, subMenus[subMenus.length - 1], false);
            }
            return;
          }
          const rect = target.getBoundingClientRect();
          const before = event.clientY < rect.top + rect.height / 2;
          updateSubDropIndicator(state, target, before);
        });
        container.addEventListener('drop', event=>{
          if(!draggedSubcategoryMenu || draggedSubcategoryContainer !== container) return;
          event.preventDefault();
          event.stopPropagation();
          state.dropCommitted = true;
          const target = state.dropIndicatorTarget;
          const before = state.dropIndicatorBefore;
          let reference = null;
          if(container){
            if(target && target !== draggedSubcategoryMenu){
              reference = before ? target : target.nextSibling;
            } else if(!target && before){
              reference = container.firstChild;
            } else if(state.addButton){
              reference = state.addButton;
            }
          }
          if(reference === state.addButton && state.addButton && state.addButton.previousSibling === draggedSubcategoryMenu){
            reference = draggedSubcategoryMenu.nextSibling;
          }
          reference = sanitizeInsertionReference(reference);
          if(reference === state.addButton && reference === draggedSubcategoryMenu.nextSibling){
            reference = reference.nextSibling;
          }
          const beforeRects = captureChildPositions(container, '.subcategory-form-menu');
          const currentNext = draggedSubcategoryMenu.nextSibling;
          if(reference !== draggedSubcategoryMenu && reference !== currentNext){
            container.insertBefore(draggedSubcategoryMenu, reference || state.addButton || null);
            animateListReorder(container, '.subcategory-form-menu', beforeRects, draggedSubcategoryMenu);
          }
          clearSubDropIndicator(state);
          syncSubcategoryOrderFromDom(container, state.category);
        });
        container.addEventListener('dragleave', event=>{
          if(!draggedSubcategoryMenu || draggedSubcategoryContainer !== container) return;
          if(event.target === container){
            clearSubDropIndicator(state);
          }
        });
      }
      state.addButton = addButton;
      state.category = categoryObj;
      state.container = container;
      return state;
    }

    function enableCategoryDrag(menu, header, handle){
      if(!menu || !header || !handle) return;
      ensureCategoryDragContainer();
      menu.draggable = false;
      header.draggable = false;
      handle.draggable = true;
      handle.setAttribute('draggable', 'true');
      handle.addEventListener('dragstart', event=>{
        const origin = event.target;
        if(origin !== handle){
          event.preventDefault();
          return;
        }
        event.stopPropagation();
        draggedCategoryMenu = menu;
        categoryDropCommitted = false;
        menu.classList.add('is-dragging');
        header.classList.add('is-dragging');
        handle.classList.add('is-dragging');
        if(event.dataTransfer){
          event.dataTransfer.effectAllowed = 'move';
          try{ event.dataTransfer.setData('text/plain', menu.dataset.category || ''); }catch(err){}
          try{
            const rect = menu.getBoundingClientRect();
            event.dataTransfer.setDragImage(menu, rect.width / 2, rect.height / 2);
          }catch(err){}
        }
      });
      handle.addEventListener('dragend', event=>{
        event.stopPropagation();
        if(draggedCategoryMenu === menu){
          menu.classList.remove('is-dragging');
          header.classList.remove('is-dragging');
          handle.classList.remove('is-dragging');
          draggedCategoryMenu = null;
        }
        clearCategoryDropIndicator();
        if(!categoryDropCommitted){
          syncCategoriesFromDom();
        }
        categoryDropCommitted = false;
      });
    }

    function enableSubcategoryDrag(subMenu, container, categoryObj, header, addButton, handle){
      if(!subMenu || !container || !header || !handle) return;
      const state = setupSubcategoryContainer(container, categoryObj, addButton);
      subMenu.draggable = false;
      header.draggable = false;
      handle.draggable = true;
      handle.setAttribute('draggable', 'true');
      handle.addEventListener('dragstart', event=>{
        const origin = event.target;
        if(origin !== handle){
          event.preventDefault();
          return;
        }
        event.stopPropagation();
        draggedSubcategoryMenu = subMenu;
        draggedSubcategoryContainer = container;
        if(state) state.dropCommitted = false;
        subMenu.classList.add('is-dragging');
        header.classList.add('is-dragging');
        handle.classList.add('is-dragging');
        if(event.dataTransfer){
          event.dataTransfer.effectAllowed = 'move';
          try{ event.dataTransfer.setData('text/plain', subMenu.dataset.subcategory || ''); }catch(err){}
          try{
            const rect = subMenu.getBoundingClientRect();
            event.dataTransfer.setDragImage(subMenu, rect.width / 2, rect.height / 2);
          }catch(err){}
        }
      });
      handle.addEventListener('dragend', event=>{
        event.stopPropagation();
        if(draggedSubcategoryMenu === subMenu){
          subMenu.classList.remove('is-dragging');
          header.classList.remove('is-dragging');
          handle.classList.remove('is-dragging');
          draggedSubcategoryMenu = null;
          draggedSubcategoryContainer = null;
        }
        if(state){
          clearSubDropIndicator(state);
          if(!state.dropCommitted){
            syncSubcategoryOrderFromDom(container, state.category);
          }
          state.dropCommitted = false;
        }
      });
    }

    function clearFieldDropIndicator(state){
      if(!state) return;
      if(state.dropIndicatorTarget){
        state.dropIndicatorTarget.classList.remove('drag-target-before','drag-target-after');
        state.dropIndicatorTarget = null;
        state.dropIndicatorClass = '';
      }
      state.dropIndicatorBefore = null;
      hideDropIndicator(state.container);
    }

    function updateFieldDropIndicator(state, target, before){
      if(!state) return;
      const cls = target ? (before ? 'drag-target-before' : 'drag-target-after') : '';
      if(state.dropIndicatorTarget && state.dropIndicatorTarget !== target){
        state.dropIndicatorTarget.classList.remove('drag-target-before','drag-target-after');
      }
      if(target){
        if(state.dropIndicatorTarget !== target || state.dropIndicatorClass !== cls){
          target.classList.remove('drag-target-before','drag-target-after');
          target.classList.add(cls);
          state.dropIndicatorTarget = target;
          state.dropIndicatorClass = cls;
        }
      } else {
        state.dropIndicatorTarget = null;
        state.dropIndicatorClass = '';
      }
      state.dropIndicatorBefore = before;
      positionDropIndicator(state.container, target, before, '.subcategory-field-row', draggedFieldRow);
    }

    function syncFieldOrderFromDom(container, fields){
      if(!container || !Array.isArray(fields)) return;
      const rows = Array.from(container.querySelectorAll('.subcategory-field-row'));
      const original = fields.slice();
      const reordered = [];
      rows.forEach(row=>{
        const ref = row && row.__fieldRef;
        if(ref && original.includes(ref) && !reordered.includes(ref)){
          reordered.push(ref);
        }
      });
      let changed = false;
      if(reordered.length === original.length){
        for(let i = 0; i < reordered.length; i++){
          if(reordered[i] !== original[i]){
            changed = true;
            break;
          }
        }
        if(changed){
          fields.splice(0, fields.length, ...reordered);
          notifyFormbuilderChange();
          const state = fieldContainerState.get(container);
          if(state && typeof state.onFieldsReordered === 'function'){
            try{
              state.onFieldsReordered();
            }catch(err){}
          }
        }
      }
      rows.forEach((row, index)=>{
        if(!row || !(row instanceof Element) || !row.dataset) return;
        row.dataset.fieldIndex = String(index);
      });
    }

    function setupFieldContainer(container, fields){
      if(!container) return null;
      let state = fieldContainerState.get(container);
      if(!state){
        state = {
          dropIndicatorTarget: null,
          dropIndicatorClass: '',
          dropIndicatorBefore: null,
          dropCommitted: false,
          fields,
          container
        };
        fieldContainerState.set(container, state);
        container.addEventListener('dragover', event=>{
          if(!draggedFieldRow || draggedFieldContainer !== container) return;
          event.preventDefault();
          event.stopPropagation();
          if(event.dataTransfer){
            event.dataTransfer.dropEffect = 'move';
          }
          const target = event.target.closest('.subcategory-field-row');
          const rows = Array.from(container.querySelectorAll('.subcategory-field-row')).filter(row => row !== draggedFieldRow);
          const containerRect = container.getBoundingClientRect();
          if(!target || target === draggedFieldRow){
            if(rows.length === 0){
              updateFieldDropIndicator(state, null, true);
            } else if(event.clientY <= containerRect.top + 8){
              updateFieldDropIndicator(state, rows[0], true);
            } else {
              updateFieldDropIndicator(state, rows[rows.length - 1], false);
            }
            return;
          }
          const rect = target.getBoundingClientRect();
          const before = event.clientY < rect.top + rect.height / 2;
          updateFieldDropIndicator(state, target, before);
        });
        container.addEventListener('drop', event=>{
          if(!draggedFieldRow || draggedFieldContainer !== container) return;
          event.preventDefault();
          event.stopPropagation();
          state.dropCommitted = true;
          const target = state.dropIndicatorTarget;
          const before = state.dropIndicatorBefore;
          let reference = null;
          if(container){
            if(target && target !== draggedFieldRow){
              reference = before ? target : target.nextSibling;
            } else if(!target && before){
              reference = container.firstChild;
            }
          }
          reference = sanitizeInsertionReference(reference);
          const beforeRects = captureChildPositions(container, '.subcategory-field-row');
          const currentNext = draggedFieldRow.nextSibling;
          if(reference !== draggedFieldRow && reference !== currentNext){
            container.insertBefore(draggedFieldRow, reference || null);
            animateListReorder(container, '.subcategory-field-row', beforeRects, draggedFieldRow);
          }
          clearFieldDropIndicator(state);
          syncFieldOrderFromDom(container, state.fields || fields);
        });
        container.addEventListener('dragleave', event=>{
          if(!draggedFieldRow || draggedFieldContainer !== container) return;
          if(event.target === container){
            clearFieldDropIndicator(state);
          }
        });
      }
      state.fields = fields;
      state.container = container;
      return state;
    }

    function enableFieldDrag(row, container, fields, handle){
      if(!row || !container || !handle) return;
      const state = setupFieldContainer(container, fields);
      row.draggable = false;
      handle.draggable = true;
      handle.setAttribute('draggable', 'true');
      handle.addEventListener('dragstart', event=>{
        const origin = event.target;
        if(origin !== handle){
          event.preventDefault();
          return;
        }
        event.stopPropagation();
        draggedFieldRow = row;
        draggedFieldContainer = container;
        if(state) state.dropCommitted = false;
        row.classList.add('is-dragging');
        if(row._header){
          row._header.classList.add('is-dragging');
        }
        handle.classList.add('is-dragging');
        if(event.dataTransfer){
          event.dataTransfer.effectAllowed = 'move';
          try{ 
            const summaryLabel = row.querySelector('.field-summary-label');
            const labelText = summaryLabel ? summaryLabel.textContent.trim() : 'Field';
            event.dataTransfer.setData('text/plain', labelText);
          }catch(err){}
          try{
            const rect = row.getBoundingClientRect();
            event.dataTransfer.setDragImage(row, rect.width / 2, rect.height / 2);
          }catch(err){}
        }
      });
      handle.addEventListener('dragend', event=>{
        event.stopPropagation();
        if(draggedFieldRow === row){
          row.classList.remove('is-dragging');
          if(row._header){
            row._header.classList.remove('is-dragging');
          }
          handle.classList.remove('is-dragging');
          draggedFieldRow = null;
          draggedFieldContainer = null;
        }
        if(state){
          clearFieldDropIndicator(state);
          if(!state.dropCommitted){
            syncFieldOrderFromDom(container, state.fields || fields);
          }
          state.dropCommitted = false;
        }
      });
    }

    async function ensureFormbuilderConfirmOverlay(){
      if(formbuilderConfirmOverlay) return formbuilderConfirmOverlay;
      const overlay = document.createElement('div');
      overlay.id = 'formbuilderConfirmOverlay';
      overlay.className = 'formbuilder-confirm-overlay';
      overlay.setAttribute('aria-hidden', 'true');
      overlay.setAttribute('tabindex', '-1');

      const dialog = document.createElement('div');
      dialog.className = 'formbuilder-confirm-dialog';
      dialog.setAttribute('role', 'alertdialog');
      dialog.setAttribute('aria-modal', 'true');
      dialog.setAttribute('aria-labelledby', 'formbuilderConfirmTitle');
      dialog.setAttribute('aria-describedby', 'formbuilderConfirmMessage');

      const title = document.createElement('h2');
      title.id = 'formbuilderConfirmTitle';
      // Title will be set from DB message

      const message = document.createElement('p');
      message.id = 'formbuilderConfirmMessage';
      // Message will be set from DB message

      const actions = document.createElement('div');
      actions.className = 'formbuilder-confirm-actions';

      const cancelBtn = document.createElement('button');
      cancelBtn.type = 'button';
      cancelBtn.className = 'formbuilder-confirm-cancel';
      cancelBtn.dataset.role = 'cancel';
      cancelBtn.dataset.messageKey = 'msg_button_cancel';
      const cancelText = await getMessage('msg_button_cancel', {}, true) || 'Cancel';
      cancelBtn.textContent = cancelText;

      const deleteBtn = document.createElement('button');
      deleteBtn.type = 'button';
      deleteBtn.className = 'formbuilder-confirm-button formbuilder-confirm-delete button--delete';
      deleteBtn.dataset.role = 'confirm';
      deleteBtn.dataset.messageKey = 'msg_button_delete';
      const deleteText = await getMessage('msg_button_delete', {}, true) || 'Delete';
      deleteBtn.textContent = deleteText;

      actions.append(cancelBtn, deleteBtn);
      dialog.append(title, message, actions);
      overlay.append(dialog);
      document.body.appendChild(overlay);
      formbuilderConfirmOverlay = overlay;
      return overlay;
    }

    async function confirmFormbuilderAction({
      messageText = 'Are you sure you want to continue?',
      titleText = 'Confirm action',
      confirmLabel = 'Confirm',
      confirmClassName = 'formbuilder-confirm-delete',
      focusCancel = true,
      messageKey = null,
      titleKey = null,
      placeholders = {}
    } = {}){
      const overlay = await ensureFormbuilderConfirmOverlay();
      const dialog = overlay.querySelector('.formbuilder-confirm-dialog');
      const title = dialog.querySelector('#formbuilderConfirmTitle');
      const message = dialog.querySelector('#formbuilderConfirmMessage');
      let cancelBtn = overlay.querySelector('[data-role="cancel"]');
      let confirmBtn = overlay.querySelector('[data-role="confirm"]');
      if(!cancelBtn || !confirmBtn) return Promise.resolve(false);
      const previousClassName = confirmBtn.className;
      const previousLabel = confirmBtn.textContent;
      const previousFocused = document.activeElement;

      // Clone both buttons to ensure clean event listeners
      if(cancelBtn && cancelBtn.parentNode){
        const replacement = cancelBtn.cloneNode(true);
        cancelBtn.parentNode.replaceChild(replacement, cancelBtn);
        cancelBtn = replacement;
      }
      if(confirmBtn && confirmBtn.parentNode){
        const replacement = confirmBtn.cloneNode(true);
        // Clear the message key so it doesn't override our explicit label
        if(confirmLabel && confirmLabel.trim() !== ''){
          replacement.removeAttribute('data-message-key');
        }
        confirmBtn.parentNode.replaceChild(replacement, confirmBtn);
        confirmBtn = replacement;
      }

      // Load messages from DB if keys provided
      // Use sync version first (from cache) to avoid delays, fallback to async if needed
      let finalTitle = titleText || 'Confirm action';
      let finalMessage = messageText || 'Are you sure you want to continue?';
      
      if(titleKey){
        // Try sync first (fast, from cache), fallback to async if not in cache
        const syncTitle = getMessageSync(titleKey, placeholders, true);
        if(syncTitle){
          finalTitle = syncTitle;
        } else {
          // Only wait for async if sync didn't find it (with timeout to prevent long delays)
          try {
            const dbTitle = await Promise.race([
              getMessage(titleKey, placeholders, true),
              new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), 500))
            ]);
            if(dbTitle) finalTitle = dbTitle;
          } catch(err){
            // Use fallback text if message load times out
            console.warn('Message load timeout for:', titleKey);
          }
        }
      }
      if(messageKey){
        // Try sync first (fast, from cache), fallback to async if not in cache
        const syncMessage = getMessageSync(messageKey, placeholders, true);
        if(syncMessage){
          finalMessage = syncMessage;
        } else {
          // Only wait for async if sync didn't find it (with timeout to prevent long delays)
          try {
            const dbMessage = await Promise.race([
              getMessage(messageKey, placeholders, true),
              new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), 500))
            ]);
            if(dbMessage) finalMessage = dbMessage;
          } catch(err){
            // Use fallback text if message load times out
            console.warn('Message load timeout for:', messageKey);
          }
        }
      }

      title.textContent = finalTitle;
      message.textContent = finalMessage;

      const normalizedConfirmClass = typeof confirmClassName === 'string' && confirmClassName.trim()
        ? `formbuilder-confirm-button ${confirmClassName.trim()}`
        : previousClassName || 'formbuilder-confirm-button';
      confirmBtn.className = normalizedConfirmClass;
      
      // Set button label - use provided confirmLabel, don't load from DB message key
      // If confirmLabel is provided, use it directly and ignore the button's data-message-key
      let finalConfirmLabel = confirmLabel;
      if(!finalConfirmLabel || (typeof finalConfirmLabel === 'string' && finalConfirmLabel.trim() === '')){
        // Only fallback to DB message if no label provided
        const confirmKey = confirmBtn.dataset.messageKey || 'msg_button_confirm';
        finalConfirmLabel = await getMessage(confirmKey, placeholders, true) || previousLabel || 'Confirm';
      }
      // Always set the text content explicitly - this happens AFTER all async operations
      confirmBtn.textContent = finalConfirmLabel || 'Confirm';

      overlay.setAttribute('aria-hidden', 'false');
      overlay.classList.add('visible');

      return new Promise(resolve => {
        const cleanup = (result)=>{
          overlay.classList.remove('visible');
          overlay.setAttribute('aria-hidden', 'true');
          window.removeEventListener('keydown', onKeyDown, true);
          overlay.removeEventListener('click', onOverlayClick);
          confirmBtn.className = previousClassName || 'formbuilder-confirm-button formbuilder-confirm-delete';
          // Restore previous label (which was already loaded from DB when overlay was created)
          confirmBtn.textContent = previousLabel || 'Delete';
          if(previousFocused && typeof previousFocused.focus === 'function'){
            try{
              previousFocused.focus({ preventScroll: true });
            }catch(err){
              try{ previousFocused.focus(); }catch(e){}
            }
          }
          resolve(result);
        };
        const onCancel = (event)=> {
          event.preventDefault();
          event.stopPropagation();
          cleanup(false);
        };
        const onConfirm = (event)=> {
          event.preventDefault();
          event.stopPropagation();
          cleanup(true);
        };
        const onOverlayClick = event => {
          if(event.target === overlay){
            cleanup(false);
          }
        };
        const onKeyDown = event => {
          if(event.key === 'Escape'){
            event.preventDefault();
            cleanup(false);
          }
        };

        cancelBtn.addEventListener('click', onCancel);
        confirmBtn.addEventListener('click', onConfirm);
        overlay.addEventListener('click', onOverlayClick);
        window.addEventListener('keydown', onKeyDown, true);

        requestAnimationFrame(()=>{
          const targetBtn = focusCancel ? cancelBtn : confirmBtn;
          try{
            targetBtn.focus({ preventScroll: true });
          }catch(err){
            try{ targetBtn.focus(); }catch(e){}
          }
        });
      });
    }

    async function confirmFormbuilderDeletion(messageText, titleText){
      const result = await confirmFormbuilderAction({
        messageText: messageText,
        titleText: titleText,
        messageKey: !messageText ? 'msg_confirm_delete_item' : null,
        titleKey: !titleText ? 'msg_confirm_delete_title' : null,
        confirmLabel: 'Delete',
        confirmClassName: 'formbuilder-confirm-delete',
        focusCancel: true
      });
      return result;
    }
    
    // Expose confirm dialog globally for use across admin panel
    window.showConfirmDialog = confirmFormbuilderAction;
    let subcategoryFieldOverlayEl = null;
    let subcategoryFieldOverlayContent = null;
    let subcategoryFieldOverlayKeyHandler = null;
    let subcategoryFieldOverlayPointerDownHandler = null;
    let subcategoryFieldOverlayScrollHandler = null;
    let subcategoryFieldOverlayResizeHandler = null;
    let subcategoryFieldOverlayTrigger = null;
    function ensureSubcategoryFieldOverlay(){
      if(subcategoryFieldOverlayEl && subcategoryFieldOverlayContent) return subcategoryFieldOverlayEl;
      if(!document || !document.body) return null;
      const overlay = document.createElement('div');
      overlay.id = 'subcategoryFieldOverlay';
      overlay.className = 'subcategory-field-overlay';
      const content = document.createElement('div');
      content.className = 'subcategory-field-overlay-content';
      content.setAttribute('role', 'dialog');
      content.setAttribute('tabindex', '-1');
      overlay.appendChild(content);
      document.body.appendChild(overlay);
      subcategoryFieldOverlayEl = overlay;
      subcategoryFieldOverlayContent = content;
      if(!subcategoryFieldOverlayKeyHandler){
        subcategoryFieldOverlayKeyHandler = event=>{
          if(event.key === 'Escape' && overlay.classList.contains('visible')){
            event.preventDefault();
            closeSubcategoryFieldOverlay();
          }
        };
        document.addEventListener('keydown', subcategoryFieldOverlayKeyHandler);
      }
      return overlay;
    }
    function closeSubcategoryFieldOverlay(){
      const overlay = subcategoryFieldOverlayEl;
      const content = subcategoryFieldOverlayContent;
      if(!overlay || !content) return;
      const activeRow = content.querySelector('.subcategory-field-row');
      if(activeRow){
        const placeholder = activeRow.__overlayPlaceholder;
        if(placeholder && placeholder.parentNode){
          placeholder.replaceWith(activeRow);
        } else if(activeRow.__overlayParent && activeRow.__overlayParent.isConnected){
          activeRow.__overlayParent.appendChild(activeRow);
        }
        if(placeholder && placeholder.parentNode){
          // already replaced
        } else if(placeholder){
          placeholder.remove();
        }
        delete activeRow.__overlayPlaceholder;
        delete activeRow.__overlayParent;
        delete activeRow.__overlayOverlay;
      }
      content.innerHTML = '';
      content.style.top = '';
      content.style.left = '';
      content.style.width = '';
      overlay.classList.remove('visible');
      overlay.removeAttribute('data-active-label');
      content.removeAttribute('aria-label');
      if(subcategoryFieldOverlayPointerDownHandler){
        document.removeEventListener('pointerdown', subcategoryFieldOverlayPointerDownHandler, true);
        subcategoryFieldOverlayPointerDownHandler = null;
      }
      if(subcategoryFieldOverlayScrollHandler){
        window.removeEventListener('scroll', subcategoryFieldOverlayScrollHandler, true);
        subcategoryFieldOverlayScrollHandler = null;
      }
      if(subcategoryFieldOverlayResizeHandler){
        window.removeEventListener('resize', subcategoryFieldOverlayResizeHandler);
        subcategoryFieldOverlayResizeHandler = null;
      }
      subcategoryFieldOverlayTrigger = null;
    }
    function openSubcategoryFieldOverlay(row, labelText, triggerEl){
      if(!row) return;
      const overlay = ensureSubcategoryFieldOverlay();
      const content = subcategoryFieldOverlayContent;
      if(!overlay || !content) return;
      const currentRow = content.querySelector('.subcategory-field-row');
      if(currentRow === row){
        closeSubcategoryFieldOverlay();
        return;
      }
      closeSubcategoryFieldOverlay();
      if(!row.parentNode) return;
      const placeholder = document.createElement('div');
      placeholder.className = 'subcategory-field-placeholder';
      const rowRect = row.getBoundingClientRect();
      if(rowRect && rowRect.width){
        const storedWidth = Math.round(rowRect.width);
        if(storedWidth > 0){
          placeholder.__overlayWidth = storedWidth;
          placeholder.style.width = storedWidth + 'px';
        }
      }
      const parentContent = row.closest('.subcategory-form-content');
      if(parentContent && typeof parentContent.getBoundingClientRect === 'function'){
        const parentRect = parentContent.getBoundingClientRect();
        const containerWidth = Math.round(parentRect?.width || 0);
        if(containerWidth > 0){
          placeholder.__overlayContainerWidth = containerWidth;
        }
      }
      row.__overlayPlaceholder = placeholder;
      row.__overlayParent = row.parentNode;
      row.__overlayOverlay = overlay;
      row.parentNode.insertBefore(placeholder, row);
      content.innerHTML = '';
      content.appendChild(row);
      const overlayWidth = placeholder.__overlayContainerWidth || placeholder.__overlayWidth;
      if(overlayWidth){
        content.style.width = overlayWidth + 'px';
      } else {
        content.style.width = '';
      }
      if(labelText){
        content.setAttribute('aria-label', labelText);
        overlay.setAttribute('data-active-label', labelText);
      } else {
        content.removeAttribute('aria-label');
        overlay.removeAttribute('data-active-label');
      }
      const triggerButton = (triggerEl instanceof Element)
        ? triggerEl.closest('.subcategory-form-button')
        : null;
      subcategoryFieldOverlayTrigger = triggerButton || (triggerEl instanceof Element ? triggerEl : null);
      overlay.classList.add('visible');
      const alignOverlay = ()=>{
        const buffer = 10;
        const triggerNode = subcategoryFieldOverlayTrigger;
        const scrollY = (typeof window !== 'undefined' && typeof window.pageYOffset === 'number')
          ? window.pageYOffset
          : (document.documentElement?.scrollTop || document.body?.scrollTop || 0);
        const scrollX = (typeof window !== 'undefined' && typeof window.pageXOffset === 'number')
          ? window.pageXOffset
          : (document.documentElement?.scrollLeft || document.body?.scrollLeft || 0);
        const viewportHeight = (typeof window !== 'undefined' && typeof window.innerHeight === 'number')
          ? window.innerHeight
          : (document.documentElement?.clientHeight || 0);
        const viewportWidth = (typeof window !== 'undefined' && typeof window.innerWidth === 'number')
          ? window.innerWidth
          : (document.documentElement?.clientWidth || 0);
        const contentRect = content.getBoundingClientRect();
        const contentHeight = contentRect?.height || 0;
        const contentWidth = contentRect?.width || 0;
        let top = scrollY + buffer;
        let left = scrollX + buffer;
        if(triggerNode && typeof triggerNode.getBoundingClientRect === 'function'){
          const triggerRect = triggerNode.getBoundingClientRect();
          const minTop = scrollY + buffer;
          let maxTop = scrollY + viewportHeight - contentHeight - buffer;
          if(!Number.isFinite(maxTop) || maxTop < minTop){
            maxTop = minTop;
          }
          let preferredTop = scrollY + triggerRect.top - buffer - contentHeight;
          if(preferredTop < minTop){
            preferredTop = scrollY + triggerRect.bottom + buffer;
          }
          if(preferredTop > maxTop){
            preferredTop = Math.max(minTop, Math.min(preferredTop, maxTop));
          }
          top = preferredTop;
          const minLeft = scrollX + buffer;
          let maxLeft = scrollX + viewportWidth - contentWidth - buffer;
          if(!Number.isFinite(maxLeft) || maxLeft < minLeft){
            maxLeft = minLeft;
          }
          let preferredLeft = scrollX + triggerRect.left;
          if(preferredLeft > maxLeft){
            preferredLeft = maxLeft;
          }
          if(preferredLeft < minLeft){
            preferredLeft = minLeft;
          }
          left = preferredLeft;
        }
        content.style.top = Math.round(top) + 'px';
        content.style.left = Math.round(left) + 'px';
      };
      const scheduleAlign = ()=>{
        if(!overlay.classList.contains('visible')) return;
        const run = ()=>{
          if(!overlay.classList.contains('visible')) return;
          alignOverlay();
        };
        if(typeof window !== 'undefined' && typeof window.requestAnimationFrame === 'function'){
          window.requestAnimationFrame(run);
        } else {
          setTimeout(run, 16);
        }
      };
      const pointerDownHandler = event=>{
        if(!overlay.classList.contains('visible')) return;
        const target = event.target;
        if(!target) return;
        if(content.contains(target)) return;
        const triggerNode = subcategoryFieldOverlayTrigger;
        if(triggerNode && typeof triggerNode.contains === 'function' && triggerNode.contains(target)) return;
        closeSubcategoryFieldOverlay();
      };
      document.addEventListener('pointerdown', pointerDownHandler, true);
      subcategoryFieldOverlayPointerDownHandler = pointerDownHandler;
      const onScroll = ()=> scheduleAlign();
      const onResize = ()=> scheduleAlign();
      window.addEventListener('scroll', onScroll, true);
      window.addEventListener('resize', onResize);
      subcategoryFieldOverlayScrollHandler = onScroll;
      subcategoryFieldOverlayResizeHandler = onResize;
      requestAnimationFrame(()=>{
        alignOverlay();
        const focusSelectors = [
          'input:not([disabled]):not([tabindex="-1"])',
          'select:not([disabled]):not([tabindex="-1"])',
          'textarea:not([disabled]):not([tabindex="-1"])',
          'button:not([disabled]):not([tabindex="-1"])',
          '[href]:not([tabindex="-1"])',
          '[tabindex]:not([tabindex="-1"])',
          '[contenteditable="true"]'
        ].join(', ');
        const focusTarget = row.querySelector(focusSelectors);
        if(focusTarget && typeof focusTarget.focus === 'function'){
          try{ focusTarget.focus({ preventScroll: true }); }
          catch(err){
            try{ focusTarget.focus(); }catch(e){}
          }
        } else if(typeof content.focus === 'function'){
          try{ content.focus({ preventScroll: true }); }
          catch(err){
            try{ content.focus(); }catch(e){}
          }
        }
      });
      scheduleAlign();
    }
    const refreshFormbuilderSubcategoryLogos = ()=>{
      if(!formbuilderCats) return;
      formbuilderCats.querySelectorAll('.subcategory-form-menu').forEach(menu=>{
        const logoSpan = menu.querySelector('.subcategory-logo');
        if(!logoSpan) return;
        const subName = menu.dataset.subcategory || '';
        const iconLookup = lookupIconPath(subcategoryIconPaths, null, subName);
        const path = iconLookup.found ? (iconLookup.path || '') : '';
        const iconHtml = subcategoryIcons[subName] || '';
        const normalizedPath = applyNormalizeIconPath(path);
        logoSpan.innerHTML = '';
        if(normalizedPath){
          const img = document.createElement('img');
          img.src = normalizedPath;
          img.alt = '';
          logoSpan.appendChild(img);
          logoSpan.classList.add('has-icon');
        } else if(iconHtml){
          logoSpan.innerHTML = iconHtml;
          logoSpan.classList.add('has-icon');
        } else {
          logoSpan.textContent = subName ? subName.charAt(0) : '';
          logoSpan.classList.remove('has-icon');
        }
      });
    };
    
    function ensureFieldDefaults(field){
      const safeField = field && typeof field === 'object' ? field : {};
      if(typeof safeField.name !== 'string'){
        safeField.name = '';
      } else if(!safeField.name.trim()){
        safeField.name = '';
      }
      if(typeof safeField.type !== 'string'){
        safeField.type = '';
      } else {
        // Preserve description and text-area types BEFORE normalization
        const originalType = safeField.type;
        const isDescriptionType = originalType === 'description' || originalType === 'text-area' ||
                                 (typeof originalType === 'string' && (originalType.includes('description') || originalType.includes('text-area')));
        
        if(isDescriptionType){
          // Normalize but preserve description/text-area
          const normalizedType = getBaseFieldset(originalType);
          if(normalizedType === 'description' || normalizedType === 'text-area'){
            safeField.type = normalizedType;
          } else if(originalType === 'description' || originalType === 'text-area'){
            safeField.type = originalType;
          } else {
            // Extract description/text-area from the type string
            safeField.type = originalType.includes('description') ? 'description' : 'text-area';
          }
        } else {
          // Normalize field type to extract base type (e.g., "description [field=2]" -> "description")
          const normalizedType = getBaseFieldset(safeField.type);
          if(normalizedType){
            safeField.type = normalizedType;
          }
        }
      }
      // Ensure key and fieldsetKey sync with each other if one is missing
      if(!safeField.key && safeField.fieldsetKey){
        safeField.key = safeField.fieldsetKey;
      }
      if(!safeField.fieldsetKey && safeField.key){
        safeField.fieldsetKey = safeField.key;
      }
      // For brand new fields, don't default - let user select from dropdown
      if(!safeField.key && !safeField.fieldsetKey){
        // Leave unset - user must select from dropdown
      } else if(safeField.fieldsetKey && !safeField.key){
        safeField.key = safeField.fieldsetKey;
      } else if(safeField.key && !safeField.fieldsetKey){
        safeField.fieldsetKey = safeField.key;
      }
      
      // Only auto-name if field type is explicitly set (not defaulted)
        if(!safeField.name){
          safeField.name = '';
        }
        if(typeof safeField.placeholder !== 'string') safeField.placeholder = '';
        const fieldsetKey = safeField.fieldsetKey || safeField.key;
        const existingFieldsetName = typeof safeField.fieldset_name === 'string' ? safeField.fieldset_name.trim() : '';
        const existingFieldsetNameCamel = typeof safeField.fieldsetName === 'string' ? safeField.fieldsetName.trim() : '';
        let resolvedFieldsetName = existingFieldsetName || existingFieldsetNameCamel;
        if(!resolvedFieldsetName && fieldsetKey){
          const matchingFieldset = FORM_FIELDSETS.find(opt => opt.value === fieldsetKey);
          if(matchingFieldset){
            resolvedFieldsetName = resolveFieldsetDisplayName(matchingFieldset);
          }
        }
        resolvedFieldsetName = resolvedFieldsetName || '';
        safeField.fieldset_name = resolvedFieldsetName;
        safeField.fieldsetName = resolvedFieldsetName;
      // Only auto-name if fieldset is set AND field doesn't already have a custom name
      // For editable fields, preserve existing custom names
      if(fieldsetKey && resolvedFieldsetName){
        const matchingFieldset = FORM_FIELDSETS.find(ft => ft.value === fieldsetKey);
        const isEditable = matchingFieldset && matchingFieldset.formbuilder_editable === true;
        // Only auto-name if not editable OR if name is empty
        if(!isEditable || !safeField.name || safeField.name.trim() === ''){
          safeField.name = resolvedFieldsetName;
        }
      }
      
      if(fieldsetKey === 'location'){
          if(!safeField.placeholder || !safeField.placeholder.trim()){
            safeField.placeholder = 'Search for a location';
          }
          const loc = safeField.location && typeof safeField.location === 'object' ? safeField.location : {};
          const address = typeof loc.address === 'string' ? loc.address : '';
          const latitude = typeof loc.latitude === 'string' ? loc.latitude : '';
          const longitude = typeof loc.longitude === 'string' ? loc.longitude : '';
          safeField.location = { address, latitude, longitude };
        } else if(Object.prototype.hasOwnProperty.call(safeField, 'location')){
          delete safeField.location;
        }
        const hasRequiredProp = Object.prototype.hasOwnProperty.call(safeField, 'required');
        safeField.required = hasRequiredProp ? !!safeField.required : true;
        if(!Array.isArray(safeField.options)){
          safeField.options = [];
        }
        if(fieldsetKey === 'venue-ticketing'){
          safeField.options = normalizeVenueSessionOptions(safeField.options);
        } else if(fieldsetKey === 'item-pricing'){
          safeField.options = safeField.options.map(opt => {
            if(opt && typeof opt === 'object'){
              return {
                item_name: typeof opt.item_name === 'string' ? opt.item_name : '',
                item_currency: typeof opt.item_currency === 'string' ? opt.item_currency : '',
                item_price: typeof opt.item_price === 'string' ? opt.item_price : ''
              };
            }
            const str = typeof opt === 'string' ? opt : String(opt ?? '');
            return { item_name: str, item_currency: 'USD', item_price: '' };
          });
          if(safeField.options.length === 0){
            safeField.options.push({ item_name: '', item_currency: 'USD', item_price: '' });
          }
        } else {
          safeField.options = safeField.options.map(opt => {
            if(typeof opt === 'string') return opt;
            if(opt && typeof opt === 'object' && typeof opt.item_name === 'string'){
              return opt.item_name;
            }
            return String(opt ?? '');
          });
          if((safeField.type === 'dropdown' || safeField.type === 'radio') && safeField.options.length === 0){
            safeField.options.push('', '', '');
          }
        }
        if(safeField.type !== 'venue-ticketing'){
          resetVenueAutofillState(safeField);
        }
        return safeField;
    }

    function renderForm(options = {}){
      if (!options.formFields || !options.formId || !options.fields) {
        console.error('renderForm: Missing required options (formFields, formId, fields)');
        return;
      }
      
      const formFields = options.formFields;
      const formId = options.formId;
      const fields = options.fields;
      const categoryName = options.categoryName || '';
      const subcategoryName = options.subcategoryName || '';
      const fieldIdCounter = options.fieldIdCounter !== undefined ? options.fieldIdCounter : 0;
      const formLabel = options.formLabel || 'Form';
      
      const isUserFormContext = options.isUserForm === true;
      const ensureDefaults = (isUserFormContext && typeof window.ensureFieldDefaultsForMember === 'function')
        ? window.ensureFieldDefaultsForMember
        : ensureFieldDefaults;
      
      let currentFieldIdCounter = fieldIdCounter;
      
      // Clear checkout price updaters from previous render
      if(window._checkoutPriceUpdaters){
        window._checkoutPriceUpdaters = [];
      }
      
      formFields.innerHTML = '';
      
      const categorySubcategoryLabel = document.createElement('div');
      categorySubcategoryLabel.className = 'form-category-label';
      const labelText = categoryName && subcategoryName ? `${categoryName} > ${subcategoryName}` : formLabel;
      categorySubcategoryLabel.textContent = labelText;
      categorySubcategoryLabel.style.marginBottom = '12px';
      categorySubcategoryLabel.style.fontSize = '14px';
      categorySubcategoryLabel.style.fontWeight = '600';
      categorySubcategoryLabel.style.color = 'var(--button-text)';
      formFields.appendChild(categorySubcategoryLabel);
      
      if(!fields.length){
        const empty = document.createElement('p');
        empty.className = 'form-empty';
        empty.textContent = 'No fields added yet.';
        formFields.appendChild(empty);
        return;
      }
      fields.forEach((fieldData, fieldIndex)=>{
        const field = ensureDefaults(fieldData);
        const wrapper = document.createElement('div');
        wrapper.className = 'panel-field form-field';
        const baseId = `${formId}-field-${++currentFieldIdCounter}`;
        const labelText = field.name.trim() || `Field ${fieldIndex + 1}`;
        const labelEl = document.createElement('span');
        labelEl.className = 'subcategory-form-label';
        labelEl.textContent = labelText;
        const labelId = `${baseId}-label`;
        labelEl.id = labelId;
        let control = null;
        
        const fieldsetKey = field.fieldsetKey || field.key || '';
        let baseType = '';
        if (isUserFormContext) {
          if (fieldsetKey === 'radio' || fieldsetKey === 'dropdown') {
            baseType = fieldsetKey;
          } else {
            baseType = fieldsetKey || field.type;
            if(!baseType) throw new Error('Fieldset is required. Missing fieldsetKey and type for field: ' + JSON.stringify(field));
          }
        } else {
          baseType = getBaseFieldset(field.type);
          if(!baseType) throw new Error('Field type is required. Cannot determine baseType from field.type: ' + JSON.stringify(field));
        }
        
        // Get field limits for character counting
        const fieldLimits = getFieldLimits(baseType);
        const minLength = fieldLimits.min_length;
        const maxLength = fieldLimits.max_length;
        const showLimit = fieldLimits.show_limit !== false;
        // Get custom tooltip from fieldset - match by value, key, fieldset_key, or fieldsetKey
        const matchingFieldset = FORM_FIELDSETS.find(fs => 
          (fs.value === baseType || fs.key === baseType || fs.fieldset_key === baseType || fs.fieldsetKey === baseType)
        );
        const customTooltip = matchingFieldset?.fieldset_tooltip || null;
        let charCounter = null;
        
        // Helper to notify formbuilder of changes (no-op in sandbox/preview mode)
        const safeNotifyFormbuilderChange = (options.isSandbox === true)
          ? (()=>{})
          : (typeof window !== 'undefined' && typeof window.notifyFormbuilderChange === 'function'
            ? window.notifyFormbuilderChange
            : (()=>{}));
        
        if(baseType === 'text-area' || baseType === 'description'){
          const textarea = document.createElement('textarea');
          textarea.rows = 5;
          textarea.readOnly = false;
          textarea.tabIndex = 0;
          textarea.addEventListener('change', (e) => {
            e.stopPropagation();
          });
          textarea.addEventListener('input', (e) => {
            e.stopPropagation();
          });
          textarea.placeholder = field.placeholder || '';
          textarea.className = 'form-textarea';
          textarea.style.resize = 'vertical';
          const textareaId = `${baseId}-input`;
          textarea.id = textareaId;
          if(baseType === 'description'){
            textarea.classList.add('form-description');
          }
          if(field.required) textarea.required = true;
          // Add character counter for textarea if max_length is set
          if(maxLength !== null){
            charCounter = createCharCounter(textarea, maxLength, minLength);
          }
          // Add blur/input validation for textareas with red border
          const validateTextarea = function(){
            const val = (this.value || '');
            const len = val.length;
            let isValid = true;
            // Only validate if there's content
            if(len > 0){
              if(minLength !== null && len < minLength){
                isValid = false;
              }
              if(maxLength !== null && len > maxLength){
                isValid = false;
              }
            }
            this.classList.toggle('input-invalid', !isValid);
          };
          textarea.addEventListener('blur', validateTextarea);
          // Clear invalid state when user starts typing again
          textarea.addEventListener('input', function(){
            if(this.classList.contains('input-invalid')){
              this.classList.remove('input-invalid');
            }
          });
          control = textarea;
        } else if(field.type === 'dropdown' || baseType === 'dropdown'){
          wrapper.classList.add('form-field--dropdown');
          const dropdownWrapper = document.createElement('div');
          dropdownWrapper.className = 'options-dropdown';
          const menuBtn = document.createElement('button');
          menuBtn.type = 'button';
          menuBtn.className = 'form-select';
          menuBtn.setAttribute('aria-haspopup', 'true');
          menuBtn.setAttribute('aria-expanded', 'false');
          const selectId = `${baseId}-input`;
          menuBtn.id = selectId;
          if(field.required) menuBtn.setAttribute('data-required', 'true');
          const menuId = `${selectId}-menu`;
          menuBtn.setAttribute('aria-controls', menuId);
          const options = Array.isArray(field.options) ? field.options : [];
          const defaultText = options.length > 0 ? options[0].trim() || 'Select an option' : 'Select an option';
          menuBtn.textContent = defaultText;
          const arrow = document.createElement('span');
          arrow.className = 'dropdown-arrow';
          arrow.setAttribute('aria-hidden', 'true');
          menuBtn.appendChild(arrow);
          const optionsMenu = document.createElement('div');
          optionsMenu.className = 'options-menu';
          optionsMenu.id = menuId;
          optionsMenu.hidden = true;
          if(options.length){
            options.forEach((optionValue, optionIndex)=>{
              const optionBtn = document.createElement('button');
              optionBtn.type = 'button';
              optionBtn.className = 'menu-option';
              const stringValue = typeof optionValue === 'string' ? optionValue : String(optionValue ?? '');
              optionBtn.textContent = stringValue.trim() || '';
              optionBtn.dataset.value = stringValue;
              optionBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                const arrow = menuBtn.querySelector('.dropdown-arrow');
                menuBtn.textContent = stringValue.trim() || 'Select an option';
                if(arrow) menuBtn.appendChild(arrow);
                optionsMenu.hidden = true;
                menuBtn.setAttribute('aria-expanded', 'false');
                if(typeof window.updatePostButtonState === 'function'){
                  window.updatePostButtonState();
                }
              });
              optionsMenu.appendChild(optionBtn);
            });
          } else {
            const placeholderBtn = document.createElement('button');
            placeholderBtn.type = 'button';
            placeholderBtn.className = 'menu-option';
            placeholderBtn.textContent = 'Select an option';
            placeholderBtn.disabled = true;
            optionsMenu.appendChild(placeholderBtn);
          }
          menuBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            const open = !optionsMenu.hasAttribute('hidden');
            if(open){
              optionsMenu.hidden = true;
              menuBtn.setAttribute('aria-expanded', 'false');
            } else {
              optionsMenu.hidden = false;
              menuBtn.setAttribute('aria-expanded', 'true');
              const outsideHandler = (ev) => {
                if(!dropdownWrapper.contains(ev.target)){
                  optionsMenu.hidden = true;
                  menuBtn.setAttribute('aria-expanded', 'false');
                  document.removeEventListener('click', outsideHandler);
                  document.removeEventListener('pointerdown', outsideHandler);
                }
              };
              setTimeout(() => {
                document.addEventListener('click', outsideHandler);
                document.addEventListener('pointerdown', outsideHandler);
              }, 0);
            }
          });
          optionsMenu.addEventListener('click', (e) => e.stopPropagation());
          dropdownWrapper.appendChild(menuBtn);
          dropdownWrapper.appendChild(optionsMenu);
          control = dropdownWrapper;
        } else if(field.type === 'radio' || baseType === 'radio'){
          const options = Array.isArray(field.options) ? field.options : [];
          const radioGroup = document.createElement('div');
          radioGroup.className = 'form-radio-group';
          wrapper.classList.add('form-field--radio-toggle');
          const groupName = `${baseId}-radio`;
          if(options.length){
            options.forEach((optionValue, optionIndex)=>{
              const radioLabel = document.createElement('label');
              radioLabel.className = 'form-radio-option';
              const radio = document.createElement('input');
              radio.type = 'radio';
              radio.name = groupName;
              const stringValue = typeof optionValue === 'string' ? optionValue : String(optionValue ?? '');
              radio.value = stringValue;
              radio.tabIndex = 0;
              radio.disabled = false;
              if(field.required && optionIndex === 0) radio.required = true;
              if(!isUserFormContext){
                radio.addEventListener('change', (e) => {
                  e.stopPropagation();
                  e.preventDefault();
                });
                radio.addEventListener('click', (e) => {
                  e.stopPropagation();
                });
                radio.addEventListener('mousedown', (e) => {
                  e.stopPropagation();
                });
                radioLabel.addEventListener('click', (e) => {
                  e.stopPropagation();
                });
                radioLabel.addEventListener('mousedown', (e) => {
                  e.stopPropagation();
                });
              }
              const radioText = document.createElement('span');
              radioText.textContent = stringValue.trim() || '';
              radioLabel.append(radio, radioText);
              radioGroup.appendChild(radioLabel);
            });
          } else {
            const placeholderOption = document.createElement('label');
            placeholderOption.className = 'form-radio-option';
            const radio = document.createElement('input');
            radio.type = 'radio';
            radio.tabIndex = -1;
            radio.disabled = true;
            placeholderOption.append(radio, document.createTextNode('Option'));
            radioGroup.appendChild(placeholderOption);
          }
          control = radioGroup;
        } else if(field.type === 'venue-ticketing'){
          wrapper.classList.add('form-field--venues-sessions-pricing');
          if(typeof window.buildVenueSessionPreview === 'function'){
            control = window.buildVenueSessionPreview(field, baseId, { isSandbox: options.isSandbox === true });
          } else {
            control = document.createElement('div');
            control.textContent = 'Event session details field';
          }
          if(control && field.required){
            control.setAttribute('aria-required','true');
          }
        } else if(field.type === 'item-pricing'){
          wrapper.classList.add('form-field--item-pricing');
          const editor = document.createElement('div');
          editor.className = 'form-item-pricing item-pricing-options-editor';
          const itemList = document.createElement('div');
          itemList.className = 'item-pricing-options-list';
          editor.appendChild(itemList);

          const createEmptyOption = ()=>({ item_name: '', item_currency: 'USD', item_price: '' });

          const normalizeOptions = ()=>{
            if(!Array.isArray(field.options)){
              field.options = [];
            }
            field.options = field.options.map(opt => {
              if(opt && typeof opt === 'object'){
                return {
                  item_name: typeof opt.item_name === 'string' ? opt.item_name : '',
                  item_currency: typeof opt.item_currency === 'string' ? opt.item_currency : '',
                  item_price: typeof opt.item_price === 'string' ? opt.item_price : ''
                };
              }
              const str = typeof opt === 'string' ? opt : String(opt ?? '');
              return { item_name: str, item_currency: 'USD', item_price: '' };
            });
            if(field.options.length === 0){
              field.options.push(createEmptyOption());
            }
          };

          const renderItemEditor = (focusIndex = null, focusTarget = 'item_name')=>{
            normalizeOptions();
            itemList.innerHTML = '';
            let firstId = null;
            const currencyAlertMessage = 'Please select a currency before entering a price.';
            let lastCurrencyAlertAt = 0;
            let currencyAlertHandle = null;
            let currencyAlertTimeout = 0;
            const showCurrencyAlert = target => {
              const candidate = (target && typeof target.getBoundingClientRect === 'function')
                ? target
                : ((document && document.activeElement && typeof document.activeElement.getBoundingClientRect === 'function')
                  ? document.activeElement
                  : null);
              const inputEl = candidate && document.body && document.body.contains(candidate) ? candidate : null;
              if(!inputEl) return;
              const now = Date.now();
              if(now - lastCurrencyAlertAt < 400){
                if(currencyAlertHandle && typeof currencyAlertHandle.reposition === 'function'){
                  currencyAlertHandle.reposition();
                }
                return;
              }
              lastCurrencyAlertAt = now;
              if(currencyAlertTimeout){
                clearTimeout(currencyAlertTimeout);
                currencyAlertTimeout = 0;
              }
              if(currencyAlertHandle && typeof currencyAlertHandle.remove === 'function'){
                currencyAlertHandle.remove();
                currencyAlertHandle = null;
              }
              const showCopyStyleMessageFn = typeof window !== 'undefined' && typeof window.showCopyStyleMessage === 'function' ? window.showCopyStyleMessage : (() => null);
              const handle = showCopyStyleMessageFn(currencyAlertMessage, inputEl);
              if(!handle) return;
              currencyAlertHandle = handle;
              currencyAlertTimeout = window.setTimeout(()=>{
                handle.remove();
                if(currencyAlertHandle === handle){
                  currencyAlertHandle = null;
                }
                currencyAlertTimeout = 0;
              }, 1500);
            };
            field.options.forEach((optionValue, optionIndex)=>{
              const optionRow = document.createElement('div');
              optionRow.className = 'item-pricing-option';
              optionRow.dataset.optionIndex = String(optionIndex);

              const topRow = document.createElement('div');
              topRow.className = 'item-pricing-row item-pricing-row--top';

              const itemNameInput = document.createElement('input');
              itemNameInput.type = 'text';
              itemNameInput.className = 'item-pricing-name';
              itemNameInput.placeholder = 'Item Name';
              const itemNameInputId = `${baseId}-item-${optionIndex}`;
              itemNameInput.id = itemNameInputId;
              if(optionIndex === 0){
                firstId = itemNameInputId;
              }
              itemNameInput.value = optionValue.item_name || '';
              protectInputMaxLength(itemNameInput, getFieldLimitsByKey('item-name').max_length);
              itemNameInput.addEventListener('input', ()=>{
                field.options[optionIndex].item_name = itemNameInput.value;
                safeNotifyFormbuilderChange();
              });
              topRow.appendChild(itemNameInput);

              const bottomRow = document.createElement('div');
              bottomRow.className = 'item-pricing-row item-pricing-row--bottom';

              const currencyWrapper = document.createElement('div');
              currencyWrapper.className = 'options-dropdown';
              const currencyMenuBtn = document.createElement('button');
              currencyMenuBtn.type = 'button';
              currencyMenuBtn.className = 'item-pricing-currency';
              currencyMenuBtn.setAttribute('aria-haspopup', 'true');
              currencyMenuBtn.setAttribute('aria-expanded', 'false');
              const currencyMenuId = `item-currency-${baseId}-${optionIndex}`;
              currencyMenuBtn.setAttribute('aria-controls', currencyMenuId);
              const existingCurrency = optionValue.item_currency || 'USD';
              const existingCountryCode = findCurrencyCountryCode(existingCurrency);
              currencyMenuBtn.innerHTML = getCurrencyButtonHTML(existingCountryCode, existingCurrency);
              currencyMenuBtn.dataset.value = existingCurrency;
              // Set default currency in data model if not already set
              if (!optionValue.item_currency) {
                optionValue.item_currency = 'USD';
              }
              const currencyArrow = document.createElement('span');
              currencyArrow.className = 'dropdown-arrow';
              currencyArrow.setAttribute('aria-hidden', 'true');
              currencyMenuBtn.appendChild(currencyArrow);
              const currencyMenu = document.createElement('div');
              currencyMenu.className = 'options-menu';
              currencyMenu.id = currencyMenuId;
              currencyMenu.hidden = true;
              // No placeholder needed - USD is always the default
              // Populate currency options with full labels
              getCurrencyOptions().forEach(opt => {
                const { countryCode, currencyCode } = parseCurrencyValue(opt.value);
                const optionBtn = document.createElement('button');
                optionBtn.type = 'button';
                optionBtn.className = 'menu-option';
                optionBtn.innerHTML = getCurrencyDisplayText(opt);
                optionBtn.dataset.value = currencyCode;
                optionBtn.dataset.countryCode = countryCode || '';
                optionBtn.dataset.label = opt.label || '';
                optionBtn.addEventListener('click', (e) => {
                  e.stopPropagation();
                  const arrow = currencyMenuBtn.querySelector('.dropdown-arrow');
                  currencyMenuBtn.innerHTML = getCurrencyButtonHTML(countryCode, currencyCode);
                  if(arrow) currencyMenuBtn.appendChild(arrow);
                  currencyMenuBtn.dataset.value = currencyCode;
                  currencyMenu.hidden = true;
                  currencyMenuBtn.setAttribute('aria-expanded', 'false');
                  const previousCurrency = field.options[optionIndex].item_currency || '';
                  field.options[optionIndex].item_currency = currencyCode;
                  const priceCleared = updatePriceState();
                  if(isCurrencySelected()){
                    commitPriceValue();
                  }
                  if(previousCurrency !== currencyCode || priceCleared){
                    safeNotifyFormbuilderChange();
                  }
                });
                currencyMenu.appendChild(optionBtn);
              });
              currencyMenuBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                const open = !currencyMenu.hasAttribute('hidden');
                if(open){
                  currencyMenu.hidden = true;
                  currencyMenuBtn.setAttribute('aria-expanded', 'false');
                } else {
                  // Ensure currency options are populated when menu opens
                  const existingOptions = currencyMenu.querySelectorAll('.menu-option[data-value]:not([data-value=""])');
                  if(existingOptions.length === 0){
                    getCurrencyOptions().forEach(opt => {
                      const { countryCode, currencyCode } = parseCurrencyValue(opt.value);
                      // Check if option already exists
                      const existing = currencyMenu.querySelector(`.menu-option[data-value="${currencyCode}"]`);
                      if(!existing){
                        const optionBtn = document.createElement('button');
                        optionBtn.type = 'button';
                        optionBtn.className = 'menu-option';
                        optionBtn.innerHTML = getCurrencyDisplayText(opt);
                        optionBtn.dataset.value = currencyCode;
                        optionBtn.dataset.countryCode = countryCode || '';
                        optionBtn.dataset.label = opt.label || '';
                        optionBtn.addEventListener('click', (e) => {
                          e.stopPropagation();
                          const arrow = currencyMenuBtn.querySelector('.dropdown-arrow');
                          currencyMenuBtn.innerHTML = getCurrencyButtonHTML(countryCode, currencyCode);
                          if(arrow) currencyMenuBtn.appendChild(arrow);
                          currencyMenuBtn.dataset.value = currencyCode;
                          currencyMenu.hidden = true;
                          currencyMenuBtn.setAttribute('aria-expanded', 'false');
                          const previousCurrency = field.options[optionIndex].item_currency || '';
                          field.options[optionIndex].item_currency = currencyCode;
                          const priceCleared = updatePriceState();
                          if(isCurrencySelected()){
                            commitPriceValue();
                          }
                          if(previousCurrency !== currencyCode || priceCleared){
                            safeNotifyFormbuilderChange();
                          }
                        });
                        currencyMenu.appendChild(optionBtn);
                      }
                    });
                  }
                  currencyMenu.hidden = false;
                  currencyMenuBtn.setAttribute('aria-expanded', 'true');
                  
                  // Setup keyboard navigation for currency dropdown
                  const cleanupKeyboardNav = setupCurrencyMenuKeyboardNav(currencyMenu, () => {
                    currencyMenu.hidden = true;
                    currencyMenuBtn.setAttribute('aria-expanded', 'false');
                  });
                  
                  const outsideHandler = (ev) => {
                    if(!currencyWrapper.contains(ev.target)){
                      currencyMenu.hidden = true;
                      currencyMenuBtn.setAttribute('aria-expanded', 'false');
                      cleanupKeyboardNav();
                      document.removeEventListener('click', outsideHandler);
                      document.removeEventListener('pointerdown', outsideHandler);
                    }
                  };
                  setTimeout(() => {
                    document.addEventListener('click', outsideHandler);
                    document.addEventListener('pointerdown', outsideHandler);
                  }, 0);
                }
              });
              currencyMenu.addEventListener('click', (e) => e.stopPropagation());
              currencyWrapper.appendChild(currencyMenuBtn);
              currencyWrapper.appendChild(currencyMenu);
              const currencySelect = currencyMenuBtn;
              const isCurrencySelected = ()=> (currencyMenuBtn.dataset.value || '').trim() !== '';

              const priceInput = document.createElement('input');
              priceInput.type = 'text';
              priceInput.inputMode = 'decimal';
              priceInput.pattern = '[0-9]+([\.,][0-9]{0,2})?';
              priceInput.className = 'item-pricing-price';
              priceInput.placeholder = '0.00';
              const sanitizePriceValue = value => (value || '').replace(/[^0-9.,]/g, '');
              const formatPriceValue = value => {
                const trimmed = (value || '').trim();
                if(trimmed === '') return '';
                let normalized = trimmed.replace(/,/g, '.');
                if(normalized === '.') return '0.00';
                if(normalized.startsWith('.')){
                  normalized = `0${normalized}`;
                }
                const dotIndex = normalized.indexOf('.');
                if(dotIndex === -1){
                  return `${normalized}.00`;
                }
                let integerPart = normalized.slice(0, dotIndex).replace(/\./g, '');
                if(integerPart === ''){
                  integerPart = '0';
                }
                let decimalPart = normalized.slice(dotIndex + 1).replace(/\./g, '');
                if(decimalPart.length === 0){
                  decimalPart = '00';
                } else if(decimalPart.length === 1){
                  decimalPart = `${decimalPart}0`;
                } else {
                  decimalPart = decimalPart.slice(0, 2);
                }
                return `${integerPart}.${decimalPart}`;
              };
              const initialPriceValue = sanitizePriceValue(optionValue.price || optionValue.item_price || '');
              const formattedInitialPrice = formatPriceValue(initialPriceValue);
              priceInput.value = formattedInitialPrice;
              const currentPrice = field.options[optionIndex].item_price || '';
              if(formattedInitialPrice !== currentPrice){
                field.options[optionIndex].item_price = formattedInitialPrice;
              }
              const clearPriceValue = ()=>{
                let changed = false;
                if(priceInput.value !== ''){
                  priceInput.value = '';
                  changed = true;
                }
                const currentPrice = field.options[optionIndex].item_price || '';
                if(currentPrice !== ''){
                  field.options[optionIndex].item_price = '';
                  changed = true;
                } else if(typeof field.options[optionIndex].item_price !== 'string'){
                  field.options[optionIndex].item_price = '';
                }
                return changed;
              };
              const updatePriceState = ()=>{
                if(isCurrencySelected()){
                  priceInput.readOnly = false;
                  priceInput.classList.remove('is-awaiting-currency');
                  priceInput.removeAttribute('aria-disabled');
                  return false;
                }
                priceInput.readOnly = true;
                priceInput.classList.add('is-awaiting-currency');
                priceInput.setAttribute('aria-disabled', 'true');
                return clearPriceValue();
              };
              const blockPriceAccess = event => {
                if(isCurrencySelected()) return false;
                if(event && event.type === 'pointerdown' && event.button !== 0) return false;
                if(event && typeof event.preventDefault === 'function'){
                  event.preventDefault();
                }
                if(event && typeof event.stopPropagation === 'function'){
                  event.stopPropagation();
                }
                if(typeof priceInput.blur === 'function'){
                  requestAnimationFrame(()=>{
                    try{ priceInput.blur(); }catch(err){}
                  });
                }
                showCurrencyAlert(priceInput);
                return true;
              };

              const commitPriceValue = event => {
                if(!isCurrencySelected()){
                  if(clearPriceValue()){
                    safeNotifyFormbuilderChange();
                  }
                  return;
                }
                const rawValue = priceInput.value;
                const sanitized = sanitizePriceValue(rawValue);
                if(rawValue !== sanitized){
                  priceInput.value = sanitized;
                }
                const formatted = formatPriceValue(sanitized);
                if(priceInput.value !== formatted){
                  priceInput.value = formatted;
                }
                if(event && document.activeElement === priceInput && typeof priceInput.setSelectionRange === 'function'){
                  if(formatted === ''){
                    priceInput.setSelectionRange(0, 0);
                  } else if(!/[.,]/.test(sanitized)){ 
                    const dotIndex = formatted.indexOf('.');
                    const caretPos = dotIndex === -1 ? formatted.length : Math.min(sanitized.length, dotIndex);
                    priceInput.setSelectionRange(caretPos, caretPos);
                  } else {
                    const dotIndex = formatted.indexOf('.');
                    if(dotIndex === -1){
                      priceInput.setSelectionRange(formatted.length, formatted.length);
                    } else {
                      const decimals = sanitized.split(/[.,]/)[1] || '';
                      if(decimals.length === 0){
                        priceInput.setSelectionRange(dotIndex + 1, formatted.length);
                      } else {
                        const caretPos = Math.min(dotIndex + 1 + decimals.length, formatted.length);
                        priceInput.setSelectionRange(caretPos, caretPos);
                      }
                    }
                  }
                }
                const previous = field.options[optionIndex].item_price || '';
                if(previous !== formatted){
                  field.options[optionIndex].item_price = formatted;
                  safeNotifyFormbuilderChange();
                }
              };
              priceInput.addEventListener('beforeinput', event => {
                if(event && typeof event.data === 'string' && /[^0-9.,]/.test(event.data)){
                  event.preventDefault();
                }
              });
              priceInput.addEventListener('pointerdown', event => {
                blockPriceAccess(event);
              });
              priceInput.addEventListener('focus', event => {
                blockPriceAccess(event);
              });
              priceInput.addEventListener('keydown', event => {
                if(event.key === 'Tab' || event.key === 'Shift') return;
                if(blockPriceAccess(event)) return;
              });
              priceInput.addEventListener('input', commitPriceValue);
              priceInput.addEventListener('change', commitPriceValue);
              const initialCleared = updatePriceState();
              if(isCurrencySelected()){
                commitPriceValue();
              } else if(initialCleared){
                safeNotifyFormbuilderChange();
              }

              const actions = document.createElement('div');
              actions.className = 'dropdown-option-actions item-pricing-option-actions';

              const addBtn = document.createElement('button');
              addBtn.type = 'button';
              addBtn.className = 'dropdown-option-add';
              addBtn.textContent = '+';
              addBtn.setAttribute('aria-label', `Add item after Item ${optionIndex + 1}`);
              addBtn.addEventListener('click', ()=>{
                field.options.splice(optionIndex + 1, 0, createEmptyOption());
                safeNotifyFormbuilderChange();
                renderItemEditor(optionIndex + 1);
              });

              const removeBtn = document.createElement('button');
              removeBtn.type = 'button';
              removeBtn.className = 'dropdown-option-remove';
              removeBtn.textContent = '-';
              removeBtn.setAttribute('aria-label', `Remove Item ${optionIndex + 1}`);
              removeBtn.disabled = field.options.length <= 1;
              removeBtn.addEventListener('click', ()=>{
                if(field.options.length <= 1){
                  field.options[0] = createEmptyOption();
                } else {
                  field.options.splice(optionIndex, 1);
                }
                safeNotifyFormbuilderChange();
                const nextFocus = Math.min(optionIndex, Math.max(field.options.length - 1, 0));
                renderItemEditor(nextFocus);
              });

              actions.append(addBtn, removeBtn);
              bottomRow.append(currencyWrapper, priceInput, actions);

              optionRow.append(topRow, bottomRow);
              itemList.appendChild(optionRow);
            });

            if(focusIndex !== null){
              requestAnimationFrame(()=>{
                const targetRow = itemList.querySelector(`.item-pricing-option[data-option-index="${focusIndex}"]`);
                if(!targetRow) return;
                let focusEl = null;
                if(focusTarget === 'price'){
                  focusEl = targetRow.querySelector('.item-pricing-price');
                } else if(focusTarget === 'currency'){
                  focusEl = targetRow.querySelector('button.item-pricing-currency');
                }
                if(!focusEl){
                  focusEl = targetRow.querySelector('.item-pricing-name');
                }
                if(focusEl && typeof focusEl.focus === 'function'){
                  try{ focusEl.focus({ preventScroll: true }); }
                  catch(err){
                    try{ focusEl.focus(); }catch(e){}
                  }
                }
              });
            }
          };

          renderItemEditor();
          editor.setAttribute('aria-required', field.required ? 'true' : 'false');
          control = editor;
        } else if(field.type === 'website-url' || field.type === 'tickets-url'){
          wrapper.classList.add('form-field--url');
          const urlWrapper = document.createElement('div');
          urlWrapper.className = 'form-url-wrapper';
          const urlInput = document.createElement('input');
          urlInput.type = 'text';
          urlInput.className = 'form-url-input';
          const urlInputId = `${baseId}-input`;
          urlInput.id = urlInputId;
          const placeholderValue = field.placeholder && /\.[A-Za-z]{2,}/.test(field.placeholder)
            ? field.placeholder
            : 'https://example.com';
          urlInput.placeholder = placeholderValue;
          urlInput.dataset.urlType = field.type === 'website-url' ? 'website' : 'tickets';
          urlInput.dataset.urlMessage = 'Please enter a valid URL with a dot and letters after it.';
          const linkId = `${baseId}-link`;
          urlInput.dataset.urlLinkId = linkId;
          urlInput.autocomplete = 'url';
          urlInput.inputMode = 'url';
          // Protect URL input with field limit from 'website' field
          const urlFieldLimits = getFieldLimitsByKey('website');
          const urlMinLength = urlFieldLimits.min_length;
          const urlMaxLength = urlFieldLimits.max_length;
          protectInputMaxLength(urlInput, urlMaxLength);
          // Add blur validation with red border
          const validateUrlInput = function(){
            const val = (this.value || '').trim();
            const len = val.length;
            let isValid = true;
            if(val){
              let candidate = val;
              if(!candidate.includes('://')){
                candidate = 'https://' + candidate;
              }
              try {
                new URL(candidate);
                isValid = true;
              } catch(_e){
                isValid = false;
              }
              // Character length validation
              if(isValid){
                if(urlMinLength !== null && len < urlMinLength){
                  isValid = false;
                }
                if(urlMaxLength !== null && len > urlMaxLength){
                  isValid = false;
                }
              }
            } else {
              isValid = true; // Empty is valid if not required
            }
            this.classList.toggle('input-invalid', !isValid);
          };
          urlInput.addEventListener('blur', validateUrlInput);
          // Clear invalid state when user starts typing again
          urlInput.addEventListener('input', function(){
            if(this.classList.contains('input-invalid')){
              this.classList.remove('input-invalid');
            }
          });
          const urlLink = document.createElement('a');
          urlLink.id = linkId;
          urlLink.href = '#';
          urlLink.target = '_blank';
          urlLink.rel = 'noopener noreferrer';
          urlLink.className = 'form-url-link';
          urlLink.textContent = 'Open link';
          urlLink.setAttribute('aria-disabled','true');
          urlLink.tabIndex = -1;
          const urlMessage = document.createElement('div');
          urlMessage.className = 'form-url-message';
          urlMessage.textContent = 'Link disabled until a valid URL is entered.';
          urlWrapper.append(urlInput, urlLink, urlMessage);
          control = urlWrapper;
        } else if(field.type === 'images'){
          wrapper.classList.add('form-field--images');
          const imageWrapper = document.createElement('div');
          imageWrapper.className = 'form-images';
          const fileInput = document.createElement('input');
          fileInput.type = 'file';
          const fileInputId = `${baseId}-input`;
          fileInput.id = fileInputId;
          fileInput.accept = 'image/*';
          fileInput.multiple = true;
          fileInput.dataset.imagesField = 'true';
          fileInput.dataset.maxImages = '10';
          const previewId = `${baseId}-previews`;
          const messageId = `${baseId}-message`;
          fileInput.dataset.imagePreviewTarget = previewId;
          fileInput.dataset.imageMessageTarget = messageId;
          const hint = document.createElement('div');
          hint.className = 'form-image-hint';
          hint.textContent = 'Upload up to 10 images.';
          const message = document.createElement('div');
          message.className = 'form-image-message';
          message.id = messageId;
          message.hidden = true;
          const previewGrid = document.createElement('div');
          previewGrid.className = 'form-image-previews';
          previewGrid.id = previewId;
          imageWrapper.append(fileInput, hint, message, previewGrid);
          control = imageWrapper;
        } else if(field.type === 'location'){
          wrapper.classList.add('form-field--location');
          const ensureLocationState = ()=>{
            if(!field.location || typeof field.location !== 'object'){
              field.location = { address: '', latitude: '', longitude: '' };
            } else {
              if(typeof field.location.address !== 'string') field.location.address = '';
              if(typeof field.location.latitude !== 'string') field.location.latitude = '';
              if(typeof field.location.longitude !== 'string') field.location.longitude = '';
            }
            return field.location;
          };
          const locationState = ensureLocationState();
          const locationWrapper = document.createElement('div');
          locationWrapper.className = 'location-field-wrapper';
          locationWrapper.setAttribute('role', 'group');
          const addressRow = document.createElement('div');
          addressRow.className = 'address_line-line';
          const geocoderContainer = document.createElement('div');
          geocoderContainer.className = 'address_line-geocoder-container';
          const addressInputId = `${baseId}-location-address`;
          geocoderContainer.id = `${baseId}-location-geocoder`;
          // Display element shown when not editing
          const addressDisplay = document.createElement('div');
          addressDisplay.className = 'address_line-display';
          addressDisplay.tabIndex = 0;
          addressDisplay.setAttribute('role', 'button');
          addressDisplay.setAttribute('aria-label', 'Click to edit address');
          const showInput = () => {
            geocoderContainer.hidden = false;
            addressDisplay.hidden = true;
            const input = geocoderContainer.querySelector('input');
            if(input) input.focus();
          };
          const showDisplay = () => {
            const addr = locationState.address || '';
            if(addr.trim()){
              addressDisplay.textContent = addr;
              geocoderContainer.hidden = true;
              addressDisplay.hidden = false;
            } else {
              geocoderContainer.hidden = false;
              addressDisplay.hidden = true;
            }
          };
          addressDisplay.addEventListener('click', showInput);
          addressDisplay.addEventListener('keydown', (e) => {
            if(e.key === 'Enter' || e.key === ' '){
              e.preventDefault();
              showInput();
            }
          });
          addressRow.appendChild(geocoderContainer);
          addressRow.appendChild(addressDisplay);
          // Initialize: show display if address exists, otherwise show input
          if(locationState.address && locationState.address.trim()){
            addressDisplay.textContent = locationState.address;
            geocoderContainer.hidden = true;
            addressDisplay.hidden = false;
          } else {
            geocoderContainer.hidden = false;
            addressDisplay.hidden = true;
          }
          locationWrapper.appendChild(addressRow);
          const latitudeInput = document.createElement('input');
          latitudeInput.type = 'hidden';
          latitudeInput.dataset.locationLatitude = 'true';
          latitudeInput.value = locationState.latitude || '';
          const longitudeInput = document.createElement('input');
          longitudeInput.type = 'hidden';
          longitudeInput.dataset.locationLongitude = 'true';
          longitudeInput.value = locationState.longitude || '';
          locationWrapper.append(latitudeInput, longitudeInput);
          const placeholderValue = (field.placeholder && field.placeholder.trim())
            ? field.placeholder
            : 'Search for a location';
          const syncCoordinateInputs = ()=>{
            latitudeInput.value = locationState.latitude || '';
            longitudeInput.value = locationState.longitude || '';
          };
          syncCoordinateInputs();
          const formatCoord = value => {
            const num = Number(value);
            return Number.isFinite(num) ? num.toFixed(6) : '';
          };
          const applyAddressLabel = input => {
            if(input){
              input.setAttribute('aria-labelledby', labelId);
            }
            return input;
          };
          const createFallbackAddressInput = ()=>{
            geocoderContainer.innerHTML = '';
            geocoderContainer.classList.remove('is-geocoder-active');
            const fallback = document.createElement('input');
            fallback.type = 'text';
            fallback.id = addressInputId;
            fallback.className = 'address_line-fallback';
            fallback.placeholder = placeholderValue;
            fallback.setAttribute('aria-label', placeholderValue);
            fallback.dataset.locationAddress = 'true';
            fallback.value = locationState.address || '';
            if(field.required) fallback.required = true;
            protectInputMaxLength(fallback, getFieldLimitsByKey('address-line').max_length);
            fallback.addEventListener('input', ()=>{
              locationState.address = fallback.value;
              safeNotifyFormbuilderChange();
            });
            geocoderContainer.appendChild(fallback);
            addressInput = fallback;
            applyAddressLabel(fallback);
            return fallback;
          };
          const mapboxReady = window.mapboxgl && window.MapboxGeocoder && window.mapboxgl.accessToken;
          let addressInput = null;
          if(mapboxReady){
            const geocoderOptions = {
              accessToken: window.mapboxgl.accessToken,
              mapboxgl: window.mapboxgl,
              marker: false,
              placeholder: placeholderValue,
              geocodingUrl: MAPBOX_VENUE_ENDPOINT,
              types: 'address,poi',
              reverseGeocode: true,
              localGeocoder: localVenueGeocoder,
              externalGeocoder: externalMapboxVenueGeocoder,
              filter: majorVenueFilter,
              limit: 7,
              language: (typeof navigator !== 'undefined' && navigator.language) ? navigator.language : undefined
            };
            const geocoder = new MapboxGeocoder(geocoderOptions);
            const schedule = (typeof window !== 'undefined' && typeof window.requestAnimationFrame === 'function')
              ? window.requestAnimationFrame.bind(window)
              : (cb)=> setTimeout(cb, 16);
            let attempts = 0;
            const maxAttempts = 20;
            let geocoderMounted = false;
            let fallbackActivated = false;
            const attachGeocoder = ()=>{
              if(fallbackActivated){
                return;
              }
              const scheduleRetry = ()=>{
                attempts += 1;
                if(attempts > maxAttempts){
                  addressInput = createFallbackAddressInput();
                  fallbackActivated = true;
                  return false;
                }
                schedule(attachGeocoder);
                return true;
              };
              if(!geocoderContainer.isConnected){
                scheduleRetry();
                return;
              }
              if(!geocoderMounted){
                try{
                  geocoder.addTo(geocoderContainer);
                  geocoderMounted = true;
                }catch(err){
                  addressInput = createFallbackAddressInput();
                  fallbackActivated = true;
                  return;
                }
              }
              const setGeocoderActive = isActive => {
                const active = !!isActive;
                geocoderContainer.classList.toggle('is-geocoder-active', active);
                const subMenu = geocoderContainer.closest('.subcategory-form-menu');
                if(subMenu){
                  subMenu.classList.toggle('has-floating-overlay', active);
                }
                const categoryMenu = subMenu
                  ? subMenu.closest('.category-form-menu')
                  : geocoderContainer.closest('.category-form-menu');
                if(categoryMenu){
                  categoryMenu.classList.toggle('has-floating-overlay', active);
                }
              };
              setGeocoderActive(false);
              const geocoderRoot = geocoderContainer.querySelector('.mapboxgl-ctrl-geocoder');
              if(geocoderRoot && !geocoderRoot.__formGeocoderBound){
                geocoderRoot.__formGeocoderBound = true;
                const handleFocusIn = ()=> setGeocoderActive(true);
                const handleFocusOut = event => {
                  const nextTarget = event && event.relatedTarget;
                  if(!nextTarget || !geocoderRoot.contains(nextTarget)){
                    setGeocoderActive(false);
                  }
                };
                const handlePointerDown = ()=> setGeocoderActive(true);
                geocoderRoot.addEventListener('focusin', handleFocusIn);
                geocoderRoot.addEventListener('focusout', handleFocusOut);
                geocoderRoot.addEventListener('pointerdown', handlePointerDown);
              }
              const geocoderInput = geocoderContainer.querySelector('.mapboxgl-ctrl-geocoder--input');
              if(!geocoderInput){
                scheduleRetry();
                return;
              }
              if(geocoderInput.__formLocationBound){
                addressInput = geocoderInput;
                applyAddressLabel(geocoderInput);
                return;
              }
              geocoderInput.__formLocationBound = true;
              geocoderInput.placeholder = placeholderValue;
              geocoderInput.setAttribute('aria-label', placeholderValue);
              geocoderInput.id = addressInputId;
              geocoderInput.dataset.locationAddress = 'true';
              geocoderInput.value = locationState.address || '';
              if(field.required) geocoderInput.required = true;
              addressInput = geocoderInput;
              applyAddressLabel(geocoderInput);
              geocoderInput.addEventListener('blur', ()=>{
                const nextValue = geocoderInput.value || '';
                if(locationState.address !== nextValue){
                  locationState.address = nextValue;
                  safeNotifyFormbuilderChange();
                }
              });
              geocoderInput.addEventListener('keydown', (e)=>{
                if(e.key === 'Enter'){
                  e.stopPropagation();
                }
              });
              geocoder.on('results', ()=> setGeocoderActive(true));
              geocoder.on('result', event => {
                const result = event && event.result;
                if(result){
                  const clone = cloneGeocoderFeature(result);
                  const placeName = typeof clone.place_name === 'string' ? clone.place_name : '';
                  if(placeName){
                    locationState.address = placeName;
                    geocoderInput.value = placeName;
                  } else {
                    locationState.address = geocoderInput.value || '';
                  }
                  const center = getMapboxVenueFeatureCenter(clone);
                  if(center && center.length >= 2){
                    const [lng, lat] = center;
                    locationState.longitude = formatCoord(lng);
                    locationState.latitude = formatCoord(lat);
                  }
                  syncCoordinateInputs();
                  safeNotifyFormbuilderChange();
                  showDisplay();
                }
                setGeocoderActive(false);
              });
              geocoder.on('clear', ()=>{
                locationState.address = '';
                locationState.latitude = '';
                locationState.longitude = '';
                geocoderInput.value = '';
                syncCoordinateInputs();
                safeNotifyFormbuilderChange();
                setGeocoderActive(false);
              });
              // Switch to display when clicking outside
              geocoderInput.addEventListener('blur', () => {
                setTimeout(showDisplay, 150);
              });
              geocoder.on('error', ()=> setGeocoderActive(false));
              return geocoderInput;
            };
            attachGeocoder();
          } else {
            addressInput = createFallbackAddressInput();
          }
          if(addressInput){
            addressInput.setAttribute('aria-labelledby', labelId);
          }
          control = locationWrapper;
        } else if(field.type === 'checkout' || baseType === 'checkout'){
          wrapper.classList.add('form-field--checkout');
          const checkoutGroup = document.createElement('div');
          checkoutGroup.className = 'form-checkout-group';
          const groupName = `${baseId}-checkout`;
          
          // Calculate days from submission to final session date for events
          function calculateDaysToFinalSession(){
            try {
              // Find venue-ticketing field in the form fields
              const venueTicketingField = fields.find(f => f && (f.type === 'venue-ticketing' || f.fieldsetKey === 'venue-ticketing'));
              if(!venueTicketingField || !venueTicketingField.options || !Array.isArray(venueTicketingField.options)) return null;
              
              let latestDate = null;
              
              // Iterate through all venues
              venueTicketingField.options.forEach(venue => {
                if(!venue || !Array.isArray(venue.sessions)) return;
                
                // Iterate through all sessions in this venue
                venue.sessions.forEach(session => {
                  if(!session || typeof session.date !== 'string' || !session.date.trim()) return;
                  
                  // Parse session date - could be ISO format or other
                  const dateStr = session.date.trim();
                  let date = null;
                  
                  // Try ISO format first (YYYY-MM-DD)
                  if(dateStr.match(/^\d{4}-\d{2}-\d{2}/)){
                    date = new Date(dateStr.split(' ')[0] + 'T00:00:00');
                  } else {
                    date = new Date(dateStr);
                  }
                  
                  if(date && !isNaN(date.getTime())){
                    date.setHours(0, 0, 0, 0);
                    if(!latestDate || date > latestDate){
                      latestDate = date;
                    }
                  }
                });
              });
              
              if(!latestDate) return null;
              
              // Calculate days from today (submission date) to final session
              const today = new Date();
              today.setHours(0, 0, 0, 0);
              
              const diffTime = latestDate.getTime() - today.getTime();
              const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
              
              return diffDays > 0 ? diffDays : null;
            } catch(err){
              console.warn('Failed to calculate days to final session:', err);
              return null;
            }
          }
          
          const calculatedDays = calculateDaysToFinalSession();
          
          // Get selected checkout options from field.checkoutOptions (array of IDs)
          let selectedOptionIds = [];
          if(Array.isArray(field.checkoutOptions)){
            // Filter out invalid values and convert to numbers
            selectedOptionIds = field.checkoutOptions
              .filter(opt => opt !== '' && opt !== null && opt !== 0)
              .map(opt => typeof opt === 'number' ? opt : parseInt(opt, 10))
              .filter(id => !isNaN(id) && id > 0);
          }
          
          // Get all checkout options from global
          const allCheckoutOptions = window.CHECKOUT_OPTIONS || [];
          
          // Filter to only show selected options (by ID), preserving order
          let optionsToShow = [];
          if(selectedOptionIds.length > 0){
            selectedOptionIds.forEach(id => {
              const found = allCheckoutOptions.find(opt => opt.id === id);
              if(found) optionsToShow.push(found);
            });
          }
          // Fallback to first 3 if nothing selected
          if(optionsToShow.length === 0){
            optionsToShow = allCheckoutOptions.slice(0, 3);
          }
          
          if(optionsToShow.length){
            optionsToShow.forEach((option, optionIndex) => {
              const radioLabel = document.createElement('label');
              radioLabel.className = 'form-checkout-option';
              
              const radio = document.createElement('input');
              radio.type = 'radio';
              radio.name = groupName;
              radio.value = String(option.id || '');
              radio.id = `${baseId}-checkout-${optionIndex}`;
              if(optionIndex === 0) radio.checked = true;
              if(field.required && optionIndex === 0) radio.required = true;
              
              const optionContent = document.createElement('div');
              optionContent.className = 'form-checkout-option-content';
              
              const titleRow = document.createElement('div');
              titleRow.className = 'form-checkout-option-title';
              
              const titleText = document.createElement('span');
              titleText.className = 'form-checkout-option-name';
              titleText.textContent = option.checkout_title || 'Untitled';
              
              const priceText = document.createElement('span');
              priceText.className = 'form-checkout-option-price';
              
              // Calculate prices for 30 and 365 day options, or use calculated days for events
              const flagfallPrice = parseFloat(option.checkout_flagfall_price) || 0;
              const basicDayRate = option.checkout_basic_day_rate !== undefined && option.checkout_basic_day_rate !== null ? parseFloat(option.checkout_basic_day_rate) : null;
              const discountDayRate = option.checkout_discount_day_rate !== undefined && option.checkout_discount_day_rate !== null ? parseFloat(option.checkout_discount_day_rate) : null;
              const currency = option.checkout_currency || 'USD';
              
              const price30Days = basicDayRate !== null ? flagfallPrice + (basicDayRate * 30) : flagfallPrice;
              const price365Days = discountDayRate !== null ? flagfallPrice + (discountDayRate * 365) : (basicDayRate !== null ? flagfallPrice + (basicDayRate * 365) : flagfallPrice);
              
              // If calculated days available (event with sessions), show calculated price
              if(calculatedDays !== null && calculatedDays > 0){
                const dayRate = calculatedDays >= 365 && discountDayRate !== null ? discountDayRate : (basicDayRate !== null ? basicDayRate : null);
                const calculatedPrice = dayRate !== null ? flagfallPrice + (dayRate * calculatedDays) : flagfallPrice;
                priceText.textContent = `(${calculatedDays} days)  ${calculatedPrice > 0 ? `${currency} ${calculatedPrice.toFixed(2)}` : 'Free'}`;
              } else {
                // Show both duration options for standard posts
                const durationWrapper = document.createElement('div');
                durationWrapper.className = 'form-checkout-duration-wrapper';
                
                const duration30 = document.createElement('span');
                duration30.className = 'form-checkout-duration-option';
                duration30.textContent = `(30 days)  ${price30Days > 0 ? `${currency} ${price30Days.toFixed(2)}` : 'Free'}`;
                
                const duration365 = document.createElement('span');
                duration365.className = 'form-checkout-duration-option';
                duration365.textContent = `(365 days)  ${price365Days > 0 ? `${currency} ${price365Days.toFixed(2)}` : 'Free'}`;
                
                durationWrapper.appendChild(duration30);
                durationWrapper.appendChild(duration365);
                
                priceText.appendChild(durationWrapper);
              }
              
              titleRow.appendChild(titleText);
              titleRow.appendChild(priceText);
              optionContent.appendChild(titleRow);
              
              if(option.checkout_description){
                const descText = document.createElement('div');
                descText.className = 'form-checkout-option-description';
                descText.textContent = option.checkout_description;
                optionContent.appendChild(descText);
              }
              
              radioLabel.appendChild(radio);
              radioLabel.appendChild(optionContent);
              checkoutGroup.appendChild(radioLabel);
            });
          } else {
            const placeholder = document.createElement('div');
            placeholder.className = 'form-checkout-placeholder';
            placeholder.textContent = 'No checkout options configured.';
            checkoutGroup.appendChild(placeholder);
          }
          control = checkoutGroup;
        } else {
          const input = document.createElement('input');
          // Set input type based on fieldset for proper validation
          if(baseType === 'email' || field.type === 'email'){
            input.type = 'email';
            input.autocomplete = 'email';
            input.inputMode = 'email';
          } else if(baseType === 'phone' || field.type === 'phone'){
            // Phone field with prefix dropdown + input (same pattern as currency dropdown)
            const phoneWrapper = document.createElement('div');
            phoneWrapper.className = 'form-phone-wrapper';
            phoneWrapper.style.display = 'flex';
            phoneWrapper.style.gap = '8px';
            phoneWrapper.style.alignItems = 'stretch';
            
            // Phone prefix dropdown (same structure as item-pricing currency)
            const prefixWrapper = document.createElement('div');
            prefixWrapper.className = 'options-dropdown';
            prefixWrapper.style.flexShrink = '0';
            
            const prefixMenuId = `phone-prefix-${baseId}`;
            const prefixBtn = document.createElement('button');
            prefixBtn.type = 'button';
            prefixBtn.className = 'item-pricing-currency';
            prefixBtn.setAttribute('aria-haspopup', 'true');
            prefixBtn.setAttribute('aria-expanded', 'false');
            prefixBtn.setAttribute('aria-controls', prefixMenuId);
            
            const phonePrefixOptions = getPhonePrefixOptions();
            // Use USA as default (same pattern as currency uses 'USD')
            const usaOpt = phonePrefixOptions.find(opt => opt.value && opt.value.startsWith('us ')) 
                        || { value: 'us +1', label: 'United States' };
            const { countryCode: defaultCountry, prefix: defaultPrefix } = parsePhonePrefixValue(usaOpt.value);
            prefixBtn.innerHTML = getPhonePrefixButtonHTML(defaultCountry, defaultPrefix);
            prefixBtn.dataset.value = defaultPrefix;
            prefixBtn.dataset.countryCode = defaultCountry || '';
            
            const prefixArrow = document.createElement('span');
            prefixArrow.className = 'dropdown-arrow';
            prefixArrow.setAttribute('aria-hidden', 'true');
            prefixBtn.appendChild(prefixArrow);
            
            const prefixMenu = document.createElement('div');
            prefixMenu.className = 'options-menu';
            prefixMenu.id = prefixMenuId;
            prefixMenu.hidden = true;
            
            // Populate phone prefix options with flags (same as currency)
            phonePrefixOptions.forEach(opt => {
              const { countryCode, prefix } = parsePhonePrefixValue(opt.value);
              const optionBtn = document.createElement('button');
              optionBtn.type = 'button';
              optionBtn.className = 'menu-option';
              optionBtn.innerHTML = getPhonePrefixDisplayText(opt);
              optionBtn.dataset.value = prefix;
              optionBtn.dataset.countryCode = countryCode || '';
              optionBtn.dataset.label = opt.label || '';
              optionBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                const arrow = prefixBtn.querySelector('.dropdown-arrow');
                prefixBtn.innerHTML = getPhonePrefixButtonHTML(countryCode, prefix);
                if(arrow) prefixBtn.appendChild(arrow);
                prefixBtn.dataset.value = prefix;
                prefixBtn.dataset.countryCode = countryCode || '';
                prefixMenu.hidden = true;
                prefixBtn.setAttribute('aria-expanded', 'false');
              });
              prefixMenu.appendChild(optionBtn);
            });
            
            prefixBtn.addEventListener('click', (e) => {
              e.stopPropagation();
              const open = !prefixMenu.hasAttribute('hidden');
              if(open){
                prefixMenu.hidden = true;
                prefixBtn.setAttribute('aria-expanded', 'false');
              } else {
                prefixMenu.hidden = false;
                prefixBtn.setAttribute('aria-expanded', 'true');
                
                // Setup keyboard navigation for phone prefix dropdown
                const cleanupKeyboardNav = setupDropdownKeyboardNav(prefixMenu, () => {
                  prefixMenu.hidden = true;
                  prefixBtn.setAttribute('aria-expanded', 'false');
                });
                
                const outsideHandler = (ev) => {
                  if(!prefixWrapper.contains(ev.target)){
                    prefixMenu.hidden = true;
                    prefixBtn.setAttribute('aria-expanded', 'false');
                    cleanupKeyboardNav();
                    document.removeEventListener('click', outsideHandler);
                    document.removeEventListener('pointerdown', outsideHandler);
                  }
                };
                setTimeout(() => {
                  document.addEventListener('click', outsideHandler);
                  document.addEventListener('pointerdown', outsideHandler);
                }, 0);
              }
            });
            prefixMenu.addEventListener('click', (e) => e.stopPropagation());
            
            prefixWrapper.appendChild(prefixBtn);
            prefixWrapper.appendChild(prefixMenu);
            phoneWrapper.appendChild(prefixWrapper);
            
            // Phone number input
            input.type = 'tel';
            input.autocomplete = 'tel';
            input.inputMode = 'tel';
            input.style.flex = '1';
            input.style.minWidth = '0';
            // Prevent non-digit characters (except allowed formatting: spaces, +, (), -)
            input.addEventListener('beforeinput', function(e){
              if(e.data && !/^[0-9 +()-]+$/.test(e.data)){
                e.preventDefault();
              }
            });
            phoneWrapper.appendChild(input);
            control = phoneWrapper;
          } else {
            input.type = 'text';
          }
          input.placeholder = field.placeholder || '';
          input.readOnly = false;
          input.tabIndex = 0;
          const inputId = `${baseId}-input`;
          input.id = inputId;
          if(field.type === 'title'){
            input.classList.add('form-title-input');
          }
          if(field.required) input.required = true;
          if(!isUserFormContext){
            input.addEventListener('change', (e) => {
              e.stopPropagation();
            });
            input.addEventListener('input', (e) => {
              e.stopPropagation();
            });
          }
          // Add character counter for text input if max_length is set
          if(maxLength !== null){
            charCounter = createCharCounter(input, maxLength, minLength);
          }
          // Add blur/input validation for ALL text inputs with red border
          // Validates: email format, phone format, URL format, and character limits
          const validateInput = function(){
            const val = (this.value || '').trim();
            const len = val.length;
            let isValid = true;
            
            // Only validate if there's content
            if(len > 0){
              // Format validation for special input types
              if(this.type === 'email' || baseType === 'email'){
                isValid = /^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$/.test(val);
              } else if(this.dataset && this.dataset.urlType){
                let candidate = val;
                if(!candidate.includes('://')){
                  candidate = 'https://' + candidate;
                }
                try {
                  new URL(candidate);
                  isValid = true;
                } catch(_e){
                  isValid = false;
                }
              } else if(this.type === 'url' || this.inputMode === 'url' || baseType === 'website-url' || baseType === 'tickets-url'){
                try {
                  new URL(val.includes('://') ? val : 'https://' + val);
                  isValid = true;
                } catch(_e){
                  isValid = false;
                }
              } else if(this.type === 'tel' || this.inputMode === 'tel' || baseType === 'phone'){
                const digits = val.replace(/\D+/g,'');
                isValid = digits.length >= 7 && /^[-+() 0-9]+$/.test(val);
              }
              
              // Character length validation
              if(isValid){
                if(minLength !== null && len < minLength){
                  isValid = false;
                }
                if(maxLength !== null && len > maxLength){
                  isValid = false;
                }
              }
            }
            
            this.classList.toggle('input-invalid', !isValid);
          };
          input.addEventListener('blur', validateInput);
          // Clear invalid state when user starts typing again
          input.addEventListener('input', function(){
            if(this.classList.contains('input-invalid')){
              this.classList.remove('input-invalid');
            }
          });
          // Only set control to input if it wasn't already set (e.g., phone fieldset sets control to phoneWrapper)
          if(!control){
            control = input;
          }
        }
        if(control){
          if(control instanceof HTMLElement){
            control.setAttribute('aria-required', field.required ? 'true' : 'false');
            if(labelId){
              control.setAttribute('aria-labelledby', labelId);
            }
          }
        }
        if(field.required){
          wrapper.classList.add('form-field--required');
          labelEl.appendChild(document.createTextNode(' '));
          const asterisk = document.createElement('span');
          asterisk.className = 'required-asterisk';
          asterisk.textContent = '*';
          labelEl.appendChild(asterisk);
        }
        // Add limit hint after label (when limits are set AND show_limit is true, or custom tooltip exists)
        if(showLimit && (minLength !== null || maxLength !== null || customTooltip)){
          const limitHint = createLimitHint(minLength, maxLength, customTooltip);
          labelEl.appendChild(limitHint);
        }
        const header = document.createElement('div');
        header.className = 'form-field-header';
        header.style.position = 'relative';
        header.appendChild(labelEl);

        if(!isUserFormContext && typeof createFieldEditUI === 'function'){
          const fieldEditUI = createFieldEditUI(field, {
            hostElement: wrapper
          });

          if(fieldEditUI && typeof fieldEditUI.setDeleteHandler === 'function'){
            const sourceRow = field.__rowEl instanceof Element ? field.__rowEl : null;
            const rowDeleteHandler = sourceRow && typeof sourceRow.__deleteHandler === 'function'
              ? sourceRow.__deleteHandler
              : null;
            const deleteHandler = rowDeleteHandler || (typeof field.__handleDeleteField === 'function'
              ? field.__handleDeleteField
              : null);
            fieldEditUI.setDeleteHandler(deleteHandler);
          }

          fieldEditUI.setSummaryUpdater(()=>{
            const displayName = (typeof field.name === 'string' && field.name.trim())
              ? field.name.trim()
              : labelText;
            fieldEditUI.editBtn.setAttribute('aria-label', `Edit ${displayName || 'field'} settings`);
          });
          fieldEditUI.runSummaryUpdater();

          header.append(fieldEditUI.editBtn, fieldEditUI.editPanel);

          // Edit panel only opens via the edit button click (handled in createFieldEditUI)
          // No automatic opening on header click
        }

        wrapper.append(header, control);
        // Add character counter after control (for user forms)
        if(charCounter){
          const counterWrapper = document.createElement('div');
          counterWrapper.className = 'char-counter-wrapper';
          counterWrapper.style.cssText = 'text-align: right; margin-top: 4px;';
          counterWrapper.appendChild(charCounter);
          wrapper.appendChild(counterWrapper);
        }
        formFields.appendChild(wrapper);
        
        if(options.onFieldRendered && typeof options.onFieldRendered === 'function'){
          options.onFieldRendered(wrapper, field);
        }
      });
      
      // Render checkout options (integrated system) - appears at bottom of form
      // All subcategories show the same checkout options from Admin Settings
      // Subcategory-specific surcharge is applied to displayed prices
      if(categoryName && subcategoryName){
        const allCheckoutOptions = (window.CHECKOUT_OPTIONS || []).filter(opt => opt.is_active !== false && opt.is_active !== 0);
        
        if(allCheckoutOptions.length > 0){
          // Get subcategory data
          let surcharge = 0;
          let subcategoryType = 'General';
          if(window.categories && Array.isArray(window.categories)){
            const category = window.categories.find(c => c && c.name === categoryName);
            if(category && category.subFees && category.subFees[subcategoryName]){
              const subData = category.subFees[subcategoryName];
              const rawSurcharge = subData.checkout_surcharge;
              if(rawSurcharge !== null && rawSurcharge !== undefined){
                surcharge = parseFloat(rawSurcharge) || 0;
              }
              if(subData.subcategory_type){
                subcategoryType = subData.subcategory_type;
              }
            }
          }
          
          const isEvent = subcategoryType === 'Events';
          
          // Calculate days from submission to final session date for events
          let calculatedDays = null;
          if(isEvent){
            try {
              const venueTicketingField = fields.find(f => f && (f.type === 'venue-ticketing' || f.fieldsetKey === 'venue-ticketing'));
              if(venueTicketingField && venueTicketingField.options && Array.isArray(venueTicketingField.options)){
                let latestDate = null;
                venueTicketingField.options.forEach(venue => {
                  if(!venue || !Array.isArray(venue.sessions)) return;
                  venue.sessions.forEach(session => {
                    if(!session || typeof session.date !== 'string' || !session.date.trim()) return;
                    const dateStr = session.date.trim();
                    let date = dateStr.match(/^\d{4}-\d{2}-\d{2}/) 
                      ? new Date(dateStr.split(' ')[0] + 'T00:00:00')
                      : new Date(dateStr);
                    if(date && !isNaN(date.getTime())){
                      date.setHours(0, 0, 0, 0);
                      if(!latestDate || date > latestDate) latestDate = date;
                    }
                  });
                });
                if(latestDate){
                  const today = new Date();
                  today.setHours(0, 0, 0, 0);
                  const diffDays = Math.ceil((latestDate.getTime() - today.getTime()) / (1000 * 60 * 60 * 24));
                  calculatedDays = diffDays > 0 ? diffDays : 1;
                }
              }
            } catch(err){
              console.warn('Failed to calculate days to final session:', err);
            }
          }
          
          const wrapper = document.createElement('div');
          wrapper.className = 'panel-field form-field form-field--checkout';
          const baseId = `${formId}-subcategory-checkout`;
          const labelEl = document.createElement('span');
          labelEl.className = 'subcategory-form-label';
          labelEl.textContent = surcharge > 0 ? `Checkout Options (+${surcharge.toFixed(2)} surcharge)` : 'Checkout Options';
          const labelId = `${baseId}-label`;
          labelEl.id = labelId;
          
          const checkoutGroup = document.createElement('div');
          checkoutGroup.className = 'form-checkout-group';
          checkoutGroup.dataset.subcategoryType = subcategoryType;
          const groupName = `${baseId}-checkout`;
          const durationGroupName = `${baseId}-duration`;
          
          // Build checkout option cards (always show for events, with disabled state if no dates)
          const hasDates = isEvent ? calculatedDays !== null : true;
          
          allCheckoutOptions.forEach((option, optionIndex) => {
            const flagfallPrice = (parseFloat(option.checkout_flagfall_price) || 0) + surcharge;
            const basicDayRate = option.checkout_basic_day_rate !== undefined && option.checkout_basic_day_rate !== null ? parseFloat(option.checkout_basic_day_rate) : null;
            const discountDayRate = option.checkout_discount_day_rate !== undefined && option.checkout_discount_day_rate !== null ? parseFloat(option.checkout_discount_day_rate) : null;
            const currency = option.checkout_currency || 'USD';
            const title = option.checkout_title || 'Untitled';
            const description = option.checkout_description || '';
            
            const card = document.createElement('label');
            card.className = 'form-checkout-option' + (hasDates ? '' : ' disabled');
            card.dataset.optionId = String(option.id || '');
            card.dataset.flagfall = String(flagfallPrice);
            card.dataset.basicRate = String(basicDayRate !== null ? basicDayRate : '');
            card.dataset.discountRate = String(discountDayRate !== null ? discountDayRate : '');
            card.dataset.currency = currency;
            
            const radio = document.createElement('input');
            radio.type = 'radio';
            radio.name = groupName;
            radio.value = String(option.id || '');
            radio.id = `${baseId}-checkout-${optionIndex}`;
            radio.dataset.optionId = String(option.id || '');
            if(optionIndex === 0 && hasDates) radio.checked = true;
            radio.required = true;
            radio.disabled = !hasDates;
            
            const optionContent = document.createElement('div');
            optionContent.className = 'form-checkout-option-content';
            
            const titleRow = document.createElement('div');
            titleRow.className = 'form-checkout-option-title';
            
            const titleText = document.createElement('span');
            titleText.className = 'form-checkout-option-name';
            titleText.textContent = title;
            
            titleRow.appendChild(titleText);
            optionContent.appendChild(titleRow);
            
            if(description){
              const descText = document.createElement('div');
              descText.className = 'form-checkout-option-description';
              descText.textContent = description;
              optionContent.appendChild(descText);
            }
            
            // Price/duration section
            const priceSection = document.createElement('div');
            priceSection.className = 'form-checkout-price-section';
            
            if(isEvent){
              // Events: Single calculated price display (shows -- when no dates)
              const priceText = document.createElement('span');
              priceText.className = 'form-checkout-price-display';
              if(hasDates){
                const dayRate = calculatedDays >= 365 && discountDayRate !== null ? discountDayRate : basicDayRate;
                const price = dayRate !== null ? flagfallPrice + (dayRate * calculatedDays) : flagfallPrice;
                priceText.textContent = `(${calculatedDays} days)  ${price > 0 ? `${currency} ${price.toFixed(2)}` : 'Free'}`;
              } else {
                priceText.textContent = 'Select session dates for price';
              }
              priceSection.appendChild(priceText);
            } else {
              // General: Two duration radio options inside card
              const durationBtns = document.createElement('div');
              durationBtns.className = 'form-checkout-duration-buttons';
              
              const price30 = basicDayRate !== null ? flagfallPrice + (basicDayRate * 30) : flagfallPrice;
              const price365 = discountDayRate !== null ? flagfallPrice + (discountDayRate * 365) : (basicDayRate !== null ? flagfallPrice + (basicDayRate * 365) : flagfallPrice);
              
              // Create radio option for 30 days
              const label30 = document.createElement('label');
              label30.className = 'form-checkout-duration-option';
              const radio30 = document.createElement('input');
              radio30.type = 'radio';
              radio30.name = groupName;
              radio30.value = `${option.id || ''}-30`;
              radio30.dataset.optionId = String(option.id || '');
              radio30.dataset.days = '30';
              radio30.dataset.price = price30.toFixed(2);
              radio30.required = true;
              if(optionIndex === 0) radio30.checked = true;
              const text30 = document.createElement('span');
              text30.textContent = `30 days  ${price30 > 0 ? `${currency} ${price30.toFixed(2)}` : 'Free'}`;
              label30.appendChild(radio30);
              label30.appendChild(text30);
              
              // Create radio option for 365 days
              const label365 = document.createElement('label');
              label365.className = 'form-checkout-duration-option';
              const radio365 = document.createElement('input');
              radio365.type = 'radio';
              radio365.name = groupName;
              radio365.value = `${option.id || ''}-365`;
              radio365.dataset.optionId = String(option.id || '');
              radio365.dataset.days = '365';
              radio365.dataset.price = price365.toFixed(2);
              radio365.required = true;
              const text365 = document.createElement('span');
              text365.textContent = `365 days  ${price365 > 0 ? `${currency} ${price365.toFixed(2)}` : 'Free'}`;
              label365.appendChild(radio365);
              label365.appendChild(text365);
              
              durationBtns.appendChild(label30);
              durationBtns.appendChild(label365);
              priceSection.appendChild(durationBtns);
            }
            
            optionContent.appendChild(priceSection);
            // Only add card-level radio for Events (General has radios on each duration)
            if(isEvent){
              card.appendChild(radio);
            }
            card.appendChild(optionContent);
            checkoutGroup.appendChild(card);
          });
          
          // For events, set up reactive price updates when venue sessions change
          if(isEvent){
            checkoutGroup.dataset.isEvent = 'true';
            const updateCheckoutPrices = ()=>{
              // Recalculate days from current venue-ticketing data
              let newCalculatedDays = null;
              try {
                const venueEditor = formFields.querySelector('.venue-session-editor');
                if(venueEditor && venueEditor._fieldRef && venueEditor._fieldRef.options){
                  const venueOptions = venueEditor._fieldRef.options;
                  let latestDate = null;
                  venueOptions.forEach(venue => {
                    if(!venue || !Array.isArray(venue.sessions)) return;
                    venue.sessions.forEach(session => {
                      if(!session || typeof session.date !== 'string' || !session.date.trim()) return;
                      const dateStr = session.date.trim();
                      let date = dateStr.match(/^\d{4}-\d{2}-\d{2}/) 
                        ? new Date(dateStr.split(' ')[0] + 'T00:00:00')
                        : new Date(dateStr);
                      if(date && !isNaN(date.getTime())){
                        date.setHours(0, 0, 0, 0);
                        if(!latestDate || date > latestDate) latestDate = date;
                      }
                    });
                  });
                  if(latestDate){
                    const today = new Date();
                    today.setHours(0, 0, 0, 0);
                    const diffDays = Math.ceil((latestDate.getTime() - today.getTime()) / (1000 * 60 * 60 * 24));
                    newCalculatedDays = diffDays > 0 ? diffDays : 1;
                  }
                }
              } catch(err){
                console.warn('Failed to recalculate checkout days:', err);
              }
              
              const nowHasDates = newCalculatedDays !== null;
              
              // Update all checkout option cards
              checkoutGroup.querySelectorAll('.form-checkout-option').forEach((card, idx) => {
                const radio = card.querySelector('input[type="radio"]');
                const priceDisplay = card.querySelector('.form-checkout-price-display');
                
                if(nowHasDates){
                  card.classList.remove('disabled');
                  if(radio){
                    radio.disabled = false;
                    if(idx === 0 && !checkoutGroup.querySelector('input[type="radio"]:checked')){
                      radio.checked = true;
                    }
                  }
                  if(priceDisplay){
                    const flagfall = parseFloat(card.dataset.flagfall) || 0;
                    const basicRate = card.dataset.basicRate !== '' ? parseFloat(card.dataset.basicRate) : null;
                    const discountRate = card.dataset.discountRate !== '' ? parseFloat(card.dataset.discountRate) : null;
                    const curr = card.dataset.currency || 'USD';
                    const dayRate = newCalculatedDays >= 365 && discountRate !== null ? discountRate : basicRate;
                    const price = dayRate !== null ? flagfall + (dayRate * newCalculatedDays) : flagfall;
                    priceDisplay.textContent = `(${newCalculatedDays} days)  ${price > 0 ? `${curr} ${price.toFixed(2)}` : 'Free'}`;
                  }
                } else {
                  card.classList.add('disabled');
                  if(radio){
                    radio.disabled = true;
                    radio.checked = false;
                  }
                  if(priceDisplay){
                    priceDisplay.textContent = 'Select session dates for price';
                  }
                }
              });
            };
            
            // Store update function on the checkout group for external access
            checkoutGroup._updatePrices = updateCheckoutPrices;
            
            // Also expose globally for venue-ticketing to call
            if(!window._checkoutPriceUpdaters) window._checkoutPriceUpdaters = [];
            window._checkoutPriceUpdaters.push(updateCheckoutPrices);
          }
          
          const header = document.createElement('div');
          header.className = 'form-field-header';
          header.style.position = 'relative';
          header.appendChild(labelEl);
          
          wrapper.append(header, checkoutGroup);
          formFields.appendChild(wrapper);
          
          if(options.onFieldRendered && typeof options.onFieldRendered === 'function'){
            options.onFieldRendered(wrapper, { type: 'checkout', name: 'Checkout Options', required: true });
          }
        }
      }
    }
    window.renderForm = renderForm;
    
    const renderFormbuilderCats = ()=>{
      if(!formbuilderCats) return;
      // Skip re-rendering if already rendered (prevents visible refresh when tab opens)
      if(formbuilderCats.querySelector('.category-form-menu')){
        return;
      }
      if(typeof closeSubcategoryFieldOverlay === 'function'){
        closeSubcategoryFieldOverlay();
      }
      closeAllIconPickers();
      
      // Icon cache for instant loading
      const iconCache = new Map();
      
      // Function to load available icons from a folder (with caching)
      const loadIconsFromFolder = async (folderPath) => {
        if(!folderPath) return [];
        // Return cached result if available
        if(iconCache.has(folderPath)){
          return iconCache.get(folderPath);
        }
        try {
          const response = await fetch(`/gateway.php?action=list-icons&folder=${encodeURIComponent(folderPath)}`);
          if(!response.ok) return [];
          const data = await response.json();
          if(data.success && Array.isArray(data.icons)){
            const icons = data.icons.map(icon => `${folderPath}/${icon}`);
            iconCache.set(folderPath, icons);
            return icons;
          }
        } catch(err){
          console.warn('Failed to load icons from folder:', err);
        }
        return [];
      };
      
      // Preload icons when formbuilder loads
      if(window.iconFolder){
        loadIconsFromFolder(window.iconFolder);
      }
      
      const attachIconPicker = (trigger, container, options = {})=>{
        const opts = options || {};
        const getCurrentPath = typeof opts.getCurrentPath === 'function' ? opts.getCurrentPath : (()=> '');
        const onSelect = typeof opts.onSelect === 'function' ? opts.onSelect : (()=>{});
        const label = typeof opts.label === 'string' && opts.label.trim() ? opts.label.trim() : 'Choose Icon';
        const parentMenu = opts.parentMenu || null;
        const parentCategoryMenu = opts.parentCategoryMenu || null;
        const useIconFolder = opts.useIconFolder !== false;
        const customIconFolder = typeof opts.iconFolder === 'string' ? opts.iconFolder : null;
        let popup = null;
        let alignFrame = 0;
        let resizeObserver = null;

        const alignPopup = ()=>{
          if(!popup) return;
          let triggerRect;
          let containerRect;
          try {
            triggerRect = trigger.getBoundingClientRect();
            containerRect = container.getBoundingClientRect();
          } catch(err){
            return;
          }
          const viewportWidth = window.innerWidth || document.documentElement.clientWidth || 0;
          const viewportHeight = window.innerHeight || document.documentElement.clientHeight || 0;
          let left = triggerRect.left - containerRect.left;
          // Use 10px spacing for map tab, 4px for others (matches .options-menu)
          const isMapTab = container.closest('#tab-map') !== null;
          const spacing = isMapTab ? 10 : 4;
          let top = triggerRect.bottom - containerRect.top + spacing;
          popup.style.left = '0px';
          popup.style.top = '0px';
          const popupRect = popup.getBoundingClientRect();
          const overflowRight = triggerRect.left + popupRect.width - viewportWidth + 12;
          if(overflowRight > 0){
            left -= overflowRight;
          }
          const overflowLeft = containerRect.left + left;
          if(overflowLeft < 8){
            left += 8 - overflowLeft;
          }
          const desiredBottom = triggerRect.bottom + spacing + popupRect.height;
          if(desiredBottom > viewportHeight - 12){
            const altTop = triggerRect.top - containerRect.top - popupRect.height - spacing;
            if(altTop + containerRect.top >= 12 || desiredBottom >= viewportHeight){
              top = Math.max(0, altTop);
            }
          }
          if(containerRect.left + left < 0){
            left = -containerRect.left;
          }
          popup.style.left = `${Math.round(left)}px`;
          popup.style.top = `${Math.round(Math.max(0, top))}px`;
        };

        const scheduleAlign = ()=>{
          if(!popup) return;
          if(alignFrame){
            cancelAnimationFrame(alignFrame);
          }
          alignFrame = requestAnimationFrame(()=>{
            alignFrame = 0;
            alignPopup();
          });
        };

        const closePicker = ()=>{
          if(!popup) return;
          popup.remove();
          popup = null;
          if(alignFrame){
            cancelAnimationFrame(alignFrame);
            alignFrame = 0;
          }
          container.classList.remove('menu-open');
          trigger.setAttribute('aria-expanded', 'false');
          if(parentMenu) parentMenu.classList.remove('has-floating-overlay');
          if(parentCategoryMenu) parentCategoryMenu.classList.remove('has-floating-overlay');
          document.removeEventListener('pointerdown', handlePointerDown, true);
          document.removeEventListener('keydown', handleKeyDown, true);
          window.removeEventListener('scroll', handleScroll, true);
          window.removeEventListener('resize', handleResize);
          if(resizeObserver){
            try{ resizeObserver.disconnect(); }catch(err){}
            resizeObserver = null;
          }
          OPEN_ICON_PICKERS.delete(closePicker);
        };

        const handlePointerDown = event => {
          if(!popup) return;
          const target = event.target;
          if(!target) return;
          if(target === trigger || (typeof trigger.contains === 'function' && trigger.contains(target))) return;
          if(popup.contains(target)) return;
          closePicker();
        };
        const handleKeyDown = event => {
          if(event.key === 'Escape'){
            closePicker();
          }
        };
        const handleScroll = ()=> scheduleAlign();
        const handleResize = ()=> scheduleAlign();

        const openPicker = async ()=>{
          if(popup) return;
          closeAllIconPickers();
          trigger.setAttribute('aria-expanded', 'true');
          
          // Load icons from folder if configured
          let iconsToShow = [];
          const folderToUse = customIconFolder || window.iconFolder;
          if(useIconFolder && folderToUse){
            try {
              iconsToShow = await loadIconsFromFolder(folderToUse);
            } catch(err){
              console.warn('Failed to load from icon folder', err);
            }
          }
          
          // Check if this is a system image picker or regular icon picker
          const isSystemImagePicker = container.classList.contains('menu--system-image-picker');
          
          popup = document.createElement('div');
          popup.className = isSystemImagePicker ? 'menu-options--system-image-picker' : 'menu-options--icon-picker';
          popup.setAttribute('role', 'dialog');
          popup.setAttribute('aria-label', label);
          popup.tabIndex = -1;
          popup.style.position = 'absolute';
          const grid = document.createElement('div');
          grid.className = isSystemImagePicker ? 'menu-grid--system-image-picker' : 'menu-grid--icon-picker';
          
          if(!iconsToShow.length){
            console.warn('No icons available to display in picker');
            const errorMsg = document.createElement('div');
            errorMsg.className = isSystemImagePicker ? 'menu-error--system-image-picker' : 'menu-error--icon-picker';
            errorMsg.innerHTML = 'No icons found.<br><br>Please select the icon folder in the Admin Settings Tab.<br><br>Example: <code>assets/icons</code>';
            grid.appendChild(errorMsg);
            // Load error message from DB
            (async () => {
              const msg = await getMessage('msg_error_no_icons', {}, true) || errorMsg.innerHTML;
              if(msg) errorMsg.innerHTML = msg;
            })();
          } else {
          const currentPath = applyNormalizeIconPath(getCurrentPath());
          // Load "No Icon" label from DB
          const noIconLabel = await getMessage('msg_label_no_icon', {}, true) || 'No Icon';
          const optionsList = [{ value: '', label: noIconLabel }];
            iconsToShow.forEach(path => {
            if(typeof path === 'string' && path.trim()){
              optionsList.push({ value: applyNormalizeIconPath(path) });
            }
          });
          // Check if we're in map, messages, forms, or settings tab for vertical layout with filenames
          const isMapMessagesOrFormsTab = container.closest('#tab-map, #tab-messages, #tab-forms, #tab-settings') !== null;
          const optionClass = isSystemImagePicker ? 'menu-option--system-image-picker' : 'menu-option--icon-picker';
          
          for(const entry of optionsList){
            const btn = document.createElement('button');
            btn.type = 'button';
            btn.className = optionClass;
            const value = entry.value || '';
            if(!value){
              btn.classList.add(optionClass + '--clear');
              // Use entry.label (which is already loaded from DB) or fallback
              btn.textContent = entry.label || noIconLabel;
            } else {
              const img = document.createElement('img');
              img.src = value;
              img.alt = '';
              btn.appendChild(img);
              
              // Add filename for map, messages, and forms tabs
              if(isMapMessagesOrFormsTab){
                const filename = document.createElement('div');
                filename.className = isSystemImagePicker ? 'menu-filename--system-image-picker' : 'menu-filename--icon-picker';
                // Extract filename from path
                const pathParts = value.split('/');
                const fullFilename = pathParts[pathParts.length - 1] || value;
                filename.textContent = fullFilename;
                btn.appendChild(filename);
              }
            }
            if(value === currentPath){
              btn.classList.add('selected');
            }
            btn.addEventListener('click', ()=>{
              onSelect(value);
              closePicker();
            });
            grid.appendChild(btn);
          }
          }
          popup.appendChild(grid);
          container.appendChild(popup);
          container.classList.add('menu-open');
          if(parentMenu) parentMenu.classList.add('has-floating-overlay');
          if(parentCategoryMenu) parentCategoryMenu.classList.add('has-floating-overlay');
          scheduleAlign();
          document.addEventListener('pointerdown', handlePointerDown, true);
          document.addEventListener('keydown', handleKeyDown, true);
          window.addEventListener('scroll', handleScroll, true);
          window.addEventListener('resize', handleResize);
          if(typeof ResizeObserver === 'function'){
            resizeObserver = new ResizeObserver(()=> scheduleAlign());
            try{ resizeObserver.observe(container); }catch(err){ resizeObserver = null; }
          }
          OPEN_ICON_PICKERS.add(closePicker);
          requestAnimationFrame(()=>{
            try{ popup.focus({ preventScroll: true }); }
            catch(err){ try{ popup.focus(); }catch(e){} }
          });
        };
        trigger.addEventListener('click', event => {
          event.preventDefault();
          event.stopPropagation();
          if(popup){
            closePicker();
          } else {
            openPicker();
          }
        });
        trigger.addEventListener('keydown', event => {
          if(event.key === 'Enter' || event.key === ' ' || event.key === 'Spacebar'){
            event.preventDefault();
            if(popup){
              closePicker();
            } else {
              openPicker();
            }
          }
        });
        // Enable picker if we have icon folder (or custom folder specified)
        const folderAvailable = customIconFolder || window.iconFolder || window.adminIconFolder;
        if(!folderAvailable){
          trigger.disabled = true;
          trigger.setAttribute('aria-disabled','true');
        } else {
          trigger.disabled = false;
          trigger.removeAttribute('aria-disabled');
        }
        return { open: openPicker, close: closePicker };
      };
      
      // System Image Picker - for system images (map tab pills, messages tab category logos)
      // Uses system-images folder by default (not category-icons folder)
      const attachSystemImagePicker = (trigger, container, options = {})=>{
        const opts = options || {};
        // Default to system-images folder unless explicitly overridden
        const defaultSystemImagesFolder = window.systemImagesFolder || 'assets/system-images';
        const systemImageOptions = {
          ...opts,
          iconFolder: opts.iconFolder !== undefined ? opts.iconFolder : defaultSystemImagesFolder,
          useIconFolder: opts.useIconFolder !== false
        };
        return attachIconPicker(trigger, container, systemImageOptions);
      };
      
      // Make icon picker functions globally available
      window.loadIconsFromFolder = loadIconsFromFolder;
      window.attachIconPicker = attachIconPicker; // For formbuilder (uses category-icons folder)
      window.attachSystemImagePicker = attachSystemImagePicker; // For system images (uses system-images folder)
      
      const frag = document.createDocumentFragment();
      const sortedCategoryEntries = getSortedCategoryEntries(categories);
      sortedCategoryEntries.forEach(({ category: c, index: sourceIndex }, viewIndex)=>{
        const baseId = slugify(c.name) || `category-${viewIndex + 1}`;
        const contentId = `category-form-content-${baseId}-${viewIndex}`;
        const editPanelId = `category-edit-panel-${baseId}-${viewIndex}`;

        const menu = document.createElement('div');
        menu.className = 'category-form-menu filter-category-menu';
        menu.dataset.category = c.name;
        menu.dataset.categoryIndex = String(sourceIndex);
        menu.setAttribute('role','group');
        menu.setAttribute('aria-expanded','true');

        const header = document.createElement('div');
        header.className = 'formbuilder-category-header';

        const triggerWrap = document.createElement('div');
        triggerWrap.className = 'options-dropdown filter-category-trigger-wrap';

        const menuBtn = document.createElement('button');
        menuBtn.type = 'button';
        menuBtn.className = 'filter-category-trigger';
        menuBtn.setAttribute('aria-haspopup','true');
        menuBtn.setAttribute('aria-expanded','true');
        menuBtn.setAttribute('aria-controls', contentId);

        const categoryLogo = document.createElement('span');
        categoryLogo.className = 'category-logo';
        const categoryIconHtml = categoryIcons[c.name] || '';
        const categoryIconLookup = lookupIconPath(categoryIconPaths, c.id, c.name);
        const initialCategoryIconSrc = categoryIconLookup.found
          ? (categoryIconLookup.path || '')
          : extractIconSrc(categoryIconHtml);
        if(initialCategoryIconSrc){
          const normalizedInitial = applyNormalizeIconPath(initialCategoryIconSrc);
          if(normalizedInitial){
            categoryIcons[c.name] = `<img src="${normalizedInitial}" alt="">`;
            if(!categoryIconLookup.found){
              writeIconPath(categoryIconPaths, c.id, c.name, normalizedInitial);
            }
          }
          const img = document.createElement('img');
          img.src = applyNormalizeIconPath(initialCategoryIconSrc);
          img.alt = '';
          categoryLogo.appendChild(img);
          categoryLogo.classList.add('has-icon');
        } else if(categoryIconHtml){
          categoryLogo.innerHTML = categoryIconHtml;
          categoryLogo.classList.add('has-icon');
        } else {
          categoryLogo.textContent = c.name.charAt(0) || '';
        }

        const label = document.createElement('span');
        label.className = 'label';
        label.textContent = c.name;

        const arrow = document.createElement('span');
        arrow.className = 'dropdown-arrow';
        arrow.setAttribute('aria-hidden','true');

        menuBtn.append(categoryLogo, label, arrow);
        triggerWrap.append(menuBtn);

        const editBtn = document.createElement('button');
        editBtn.type = 'button';
        editBtn.className = 'category-edit-btn';
        editBtn.innerHTML = '<svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor" aria-hidden="true"><path d="M12.854 1.146a.5.5 0 0 1 .707 0l1.293 1.293a.5.5 0 0 1 0 .707l-8.939 8.939a.5.5 0 0 1-.233.131l-3.5.875a.5.5 0 0 1-.606-.606l.875-3.5a.5.5 0 0 1 .131-.233l8.939-8.939z"/><path d="M2.5 12.5V14h1.5l9-9-1.5-1.5-9 9z"/></svg>';
        editBtn.setAttribute('aria-label', `Edit ${c.name} category`);
        editBtn.setAttribute('aria-expanded','false');

        const categoryDragHandle = createFormbuilderDragHandle(`Reorder ${c.name || 'Category'} category`, 'category-drag-handle');

        const toggleInput = document.createElement('input');
        toggleInput.type = 'checkbox';
        toggleInput.checked = true;
        toggleInput.setAttribute('aria-label', `Toggle ${c.name} category`);
        toggleInput.hidden = true;

        header.append(triggerWrap, categoryDragHandle, editBtn, toggleInput);
        menu.append(header);

        const content = document.createElement('div');
        content.className = 'category-form-content';
        content.id = contentId;
        content.hidden = false;

        const editMenu = document.createElement('div');
        editMenu.className = 'category-edit-menu';

        const editPanel = document.createElement('div');
        editPanel.className = 'category-edit-panel';
        editPanel.id = editPanelId;

        // Name row with input and 3-dot overflow menu
        const nameRow = document.createElement('div');
        nameRow.className = 'edit-panel-name-row';

        const nameInput = document.createElement('input');
        nameInput.type = 'text';
        nameInput.className = 'category-name-input';
        nameInput.placeholder = 'Category Name';
        nameInput.value = c.name || '';

        // 3-dot overflow button
        const overflowBtn = document.createElement('button');
        overflowBtn.type = 'button';
        overflowBtn.className = 'edit-panel-overflow-btn';
        overflowBtn.innerHTML = '<svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor"><circle cx="8" cy="3" r="1.5"/><circle cx="8" cy="8" r="1.5"/><circle cx="8" cy="13" r="1.5"/></svg>';
        overflowBtn.setAttribute('aria-label', 'More options');
        overflowBtn.setAttribute('aria-haspopup', 'true');
        overflowBtn.setAttribute('aria-expanded', 'false');

        const overflowMenu = document.createElement('div');
        overflowMenu.className = 'edit-panel-overflow-menu';
        overflowMenu.hidden = true;

        const iconPicker = document.createElement('div');
        iconPicker.className = 'options-dropdown menu--icon-picker';

        const iconPickerButton = document.createElement('button');
        iconPickerButton.type = 'button';
        iconPickerButton.className = 'menu-button--icon-picker';
        iconPickerButton.setAttribute('aria-haspopup', 'true');
        iconPickerButton.setAttribute('aria-expanded', 'false');

        const iconPickerImg = document.createElement('img');
        iconPickerImg.className = 'menu-button-img--icon-picker';
        iconPickerImg.alt = '';
        const iconPickerLabel = document.createElement('span');
        iconPickerLabel.className = 'menu-button-label--icon-picker';
        iconPickerLabel.textContent = 'Choose Icon';
        const iconPickerArrow = document.createElement('span');
        iconPickerArrow.className = 'dropdown-arrow';
        iconPickerArrow.setAttribute('aria-hidden', 'true');
        iconPickerButton.append(iconPickerImg, iconPickerLabel, iconPickerArrow);

        const normalizedCategoryIconPath = applyNormalizeIconPath(initialCategoryIconSrc);
        if(normalizedCategoryIconPath){
          iconPickerImg.src = normalizedCategoryIconPath;
          iconPickerButton.classList.add('has-icon');
          // Extract filename from path
          const filename = normalizedCategoryIconPath.split('/').pop();
          iconPickerLabel.textContent = filename;
          if(!categoryIconLookup.found){
            writeIconPath(categoryIconPaths, c.id, c.name, normalizedCategoryIconPath);
          }
        }
        iconPicker.append(iconPickerButton);
        // Use icon picker for formbuilder (uses category-icons folder, not system-images)
        if(typeof window.attachIconPicker === 'function'){
          window.attachIconPicker(iconPickerButton, iconPicker, {
            getCurrentPath: ()=> applyNormalizeIconPath(getCategoryIconPath(c)),
            onSelect: value => {
              updateCategoryIconDisplay(value);
              notifyFormbuilderChange();
            },
            label: `Choose icon for ${c.name}`,
            parentMenu: content,
            parentCategoryMenu: menu
          });
        }

        let addSubBtn = document.createElement('button');
        addSubBtn.type = 'button';
        addSubBtn.className = 'add-subcategory-btn';
        addSubBtn.dataset.messageKey = 'msg_button_add_subcategory';
        // Set fallback text in case messages don't load immediately
        addSubBtn.textContent = 'Add Subcategory';
        // Text will be updated from DB when messages are available (via MutationObserver)
        addSubBtn.setAttribute('aria-label', `Add subcategory to ${c.name}`);

        // Hide toggle inside overflow menu
        const hideToggleRow = document.createElement('div');
        hideToggleRow.className = 'overflow-menu-item overflow-menu-toggle';
        const hideToggleLabel = document.createElement('span');
        hideToggleLabel.dataset.messageKey = 'msg_label_hide_category';
        hideToggleLabel.textContent = 'Hide Category';
        const hideToggle = document.createElement('label');
        hideToggle.className = 'switch';
        const hideToggleInput = document.createElement('input');
        hideToggleInput.type = 'checkbox';
        hideToggleInput.checked = typeof c.hidden === 'boolean' ? c.hidden : !toggleInput.checked;
        const hideToggleSlider = document.createElement('span');
        hideToggleSlider.className = 'slider';
        hideToggle.append(hideToggleInput, hideToggleSlider);
        hideToggleRow.append(hideToggleLabel, hideToggle);
        
        hideToggleInput.addEventListener('change', ()=>{
          c.hidden = hideToggleInput.checked;
          toggleInput.checked = !hideToggleInput.checked;
          toggleInput.dispatchEvent(new Event('change', {bubbles: true}));
          notifyFormbuilderChange();
        });
        
        toggleInput.addEventListener('change', ()=>{
          hideToggleInput.checked = !toggleInput.checked;
          c.hidden = hideToggleInput.checked;
          notifyFormbuilderChange();
        });

        // Delete button inside overflow menu
        const deleteCategoryBtn = document.createElement('button');
        deleteCategoryBtn.type = 'button';
        deleteCategoryBtn.className = 'overflow-menu-item overflow-menu-item--danger';
        deleteCategoryBtn.innerHTML = '<svg width="14" height="14" viewBox="0 0 16 16" fill="currentColor"><path d="M5.5 5.5A.5.5 0 0 1 6 6v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm2.5 0a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm3 .5a.5.5 0 0 0-1 0v6a.5.5 0 0 0 1 0V6z"/><path fill-rule="evenodd" d="M14.5 3a1 1 0 0 1-1 1H13v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V4h-.5a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1H6a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1h3.5a1 1 0 0 1 1 1v1zM4.118 4 4 4.059V13a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V4.059L11.882 4H4.118zM2.5 3V2h11v1h-11z"/></svg><span>Delete Category</span>';
        deleteCategoryBtn.setAttribute('aria-label', `Delete ${c.name} category`);

        overflowMenu.append(hideToggleRow, deleteCategoryBtn);
        nameRow.append(nameInput, overflowBtn, overflowMenu);

        // Overflow button toggle
        overflowBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          const isOpen = !overflowMenu.hidden;
          document.querySelectorAll('.edit-panel-overflow-menu').forEach(m => {
            if(m !== overflowMenu) m.hidden = true;
          });
          document.querySelectorAll('.edit-panel-overflow-btn').forEach(b => {
            if(b !== overflowBtn) b.setAttribute('aria-expanded', 'false');
          });
          overflowMenu.hidden = isOpen;
          overflowBtn.setAttribute('aria-expanded', isOpen ? 'false' : 'true');
        });

        // Close overflow menu when clicking outside
        document.addEventListener('pointerdown', (e) => {
          if(!overflowMenu.hidden && !overflowBtn.contains(e.target) && !overflowMenu.contains(e.target)){
            overflowMenu.hidden = true;
            overflowBtn.setAttribute('aria-expanded', 'false');
          }
        }, true);

        editPanel.append(nameRow, iconPicker);
        editPanel.hidden = true;
        
        editBtn.addEventListener('click', (e)=>{
          e.stopPropagation();
          document.querySelectorAll('.category-edit-panel, .subcategory-edit-panel').forEach(panel => {
            if(panel === editPanel) return;
            panel.hidden = true;
            const relatedButton = panel.parentElement
              ? panel.parentElement.querySelector('.category-edit-btn, .subcategory-edit-btn')
              : null;
            if(relatedButton){
              relatedButton.setAttribute('aria-expanded','false');
            }
          });
          closeFieldEditPanels();
          const willShow = editPanel.hidden;
          editPanel.hidden = !willShow;
          editBtn.setAttribute('aria-expanded', willShow ? 'true' : 'false');
          // Also expand the category content if showing edit panel
          if(willShow && content.hidden){
            content.hidden = false;
            menu.setAttribute('aria-expanded', 'true');
            menuBtn.setAttribute('aria-expanded', 'true');
          }
        });

        const handleCategoryEditPointerDown = event => {
          if(editPanel.hidden){
            return;
          }
          const target = event.target;
          if(editPanel.contains(target)){
            return;
          }
          const clickedEditBtn = target.closest('.category-edit-btn, .subcategory-edit-btn, .field-edit-btn');
          if(clickedEditBtn){
            return;
          }
          editPanel.hidden = true;
          editBtn.setAttribute('aria-expanded', 'false');
        };
        document.addEventListener('pointerdown', handleCategoryEditPointerDown, true);
        editMenu.appendChild(addSubBtn);
        const cleanAddSubBtn = addSubBtn.cloneNode(true);
        editMenu.replaceChild(cleanAddSubBtn, addSubBtn);
        addSubBtn = cleanAddSubBtn;

        const subMenusContainer = document.createElement('div');
        subMenusContainer.className = 'subcategory-form-menus';
        const addSubAnchor = document.createElement('div');
        addSubAnchor.className = 'subcategory-drop-anchor';
        subMenusContainer.append(addSubAnchor);

        const subNameUpdaters = [];
        const subFieldsMap = (c.subFields && typeof c.subFields === 'object' && !Array.isArray(c.subFields)) ? c.subFields : (c.subFields = {});
        const getCategoryNameValue = ()=> nameInput.value.trim();
        let lastCategoryName = c.name || 'Category';
        let currentCategoryName = c.name || 'Category';
        const getCategoryDisplayName = ()=> getCategoryNameValue() || lastCategoryName || 'Category';
        const updateCategoryIconDisplay = (src)=>{
          const displayName = getCategoryDisplayName();
          categoryLogo.innerHTML = '';
          const normalizedSrc = applyNormalizeIconPath(src);
          if(normalizedSrc){
            const img = document.createElement('img');
            img.src = normalizedSrc;
            img.alt = '';
            categoryLogo.appendChild(img);
            categoryLogo.classList.add('has-icon');
            categoryIcons[currentCategoryName] = `<img src="${normalizedSrc}" alt="">`;
            writeIconPath(categoryIconPaths, c.id, currentCategoryName, normalizedSrc);
          } else {
            categoryLogo.textContent = displayName.charAt(0) || '';
            categoryLogo.classList.remove('has-icon');
            delete categoryIcons[currentCategoryName];
            writeIconPath(categoryIconPaths, c.id, currentCategoryName, '');
          }
          // Update iconpicker button display
          if(normalizedSrc){
            iconPickerImg.src = normalizedSrc;
            iconPickerButton.classList.add('has-icon');
            const filename = normalizedSrc.split('/').pop();
            iconPickerLabel.textContent = filename;
          } else {
            iconPickerImg.removeAttribute('src');
            iconPickerButton.classList.remove('has-icon');
            iconPickerLabel.textContent = 'Choose Icon';
          }
        };
        const applyCategoryNameChange = ()=>{
          const nameValue = getCategoryNameValue();
          if(nameValue){
            lastCategoryName = nameValue;
          }
          const displayName = getCategoryDisplayName();
          const datasetValue = displayName;
          const previousName = currentCategoryName;
          if(previousName !== datasetValue){
            if(categoryIcons[previousName] !== undefined){
              if(categoryIcons[datasetValue] === undefined){
                categoryIcons[datasetValue] = categoryIcons[previousName];
              }
              delete categoryIcons[previousName];
            }
            renameIconNameKey(categoryIconPaths, previousName, datasetValue);
          }
          currentCategoryName = datasetValue;
          c.name = datasetValue;
          if(Array.isArray(categories) && categories[sourceIndex] && typeof categories[sourceIndex] === 'object'){
            categories[sourceIndex].name = datasetValue;
          }
          menu.dataset.category = datasetValue;
          label.textContent = displayName;
          toggleInput.setAttribute('aria-label', `Toggle ${displayName} category`);
          updateDragHandleLabel(categoryDragHandle, `Reorder ${displayName} category`);
          iconPickerButton.setAttribute('aria-label', `Choose icon for ${displayName}`);
          deleteCategoryBtn.setAttribute('aria-label', `Delete ${displayName} category`);
          addSubBtn.setAttribute('aria-label', `Add subcategory to ${displayName}`);
          subMenusContainer.querySelectorAll('.subcategory-form-menu').forEach(subEl=>{
            subEl.dataset.category = datasetValue;
          });
          if(categoryLogo.querySelector('img')){
            categoryLogo.classList.add('has-icon');
          } else {
            updateCategoryIconDisplay('');
          }
          subNameUpdaters.forEach(fn=>{
            try{ fn(); }catch(err){}
          });
        };
        nameInput.addEventListener('input', applyCategoryNameChange);
        deleteCategoryBtn.addEventListener('click', async ()=>{
          const displayName = getCategoryDisplayName();
          const confirmed = await confirmFormbuilderDeletion(`Delete the "${displayName}" category?`, 'Delete Category');
          if(!confirmed) return;
          if(subcategoryFieldOverlayContent && typeof closeSubcategoryFieldOverlay === 'function'){
            const activeRow = subcategoryFieldOverlayContent.querySelector('.subcategory-field-row');
            if(activeRow && menu.contains(activeRow)){
              closeSubcategoryFieldOverlay();
            }
          }
          delete categoryIcons[currentCategoryName];
          deleteIconKeys(categoryIconPaths, c.id, currentCategoryName);
          if(c.subs && Array.isArray(c.subs)){
            c.subs.forEach(subName => {
              const subId = c.subIds && Object.prototype.hasOwnProperty.call(c.subIds, subName) ? c.subIds[subName] : null;
              deleteIconKeys(subcategoryIconPaths, subId, subName);
            });
          }
          const categoryIndex = categories.indexOf(c);
          if(categoryIndex !== -1){
            categories.splice(categoryIndex, 1);
          }
          menu.remove();
          notifyFormbuilderChange();
          
          // Update formbuilder state manager snapshot first
          if(window.formbuilderStateManager && typeof window.formbuilderStateManager.save === 'function'){
            try {
              window.formbuilderStateManager.save();
            } catch(err) {
              console.error('[Formbuilder] Failed to update state manager:', err);
            }
          }
          
          // Trigger auto-save after deletion
          if(typeof window.adminPanelModule?.runSave === 'function'){
            setTimeout(() => {
              window.adminPanelModule.runSave({ closeAfter: false });
            }, 100);
          }
        });

        c.subs.forEach((sub, subIndex)=>{
          const subMenu = document.createElement('div');
          subMenu.className = 'subcategory-form-menu';
          subMenu.dataset.category = c.name;
          subMenu.dataset.subcategory = sub;
          subMenu.dataset.subIndex = String(subIndex);
          subMenu.setAttribute('aria-expanded','false');

          const subHeader = document.createElement('div');
          subHeader.className = 'formbuilder-subcategory-header';

          const subTriggerWrap = document.createElement('div');
          subTriggerWrap.className = 'options-dropdown subcategory-trigger-wrap';

          const subContentId = `subcategory-form-content-${baseId}-${subIndex}`;
          const subBtn = document.createElement('button');
          subBtn.type = 'button';
          subBtn.className = 'subcategory-form-trigger';
          subBtn.setAttribute('aria-expanded','false');
          subBtn.setAttribute('aria-controls', subContentId);

          const subLabelWrap = document.createElement('span');
          subLabelWrap.className = 'subcategory-label-wrap';

          const subLogo = document.createElement('span');
          subLogo.className = 'subcategory-logo';
          const subIconHtml = subcategoryIcons[sub] || '';
          const subIconLookup = lookupIconPath(subcategoryIconPaths, c.subIds && Object.prototype.hasOwnProperty.call(c.subIds, sub) ? c.subIds[sub] : null, sub);
          const initialSubIconPath = subIconLookup.found ? (subIconLookup.path || '') : extractIconSrc(subIconHtml);
          if(initialSubIconPath){
            const normalizedInitialSub = applyNormalizeIconPath(initialSubIconPath);
            if(normalizedInitialSub){
              subcategoryIcons[sub] = `<img src="${normalizedInitialSub}" alt="">`;
            }
          }
          if(initialSubIconPath){
            const img = document.createElement('img');
            img.src = applyNormalizeIconPath(initialSubIconPath);
            img.alt = '';
            subLogo.appendChild(img);
            subLogo.classList.add('has-icon');
            if(!subIconLookup.found){
              writeIconPath(subcategoryIconPaths, c.subIds && Object.prototype.hasOwnProperty.call(c.subIds, sub) ? c.subIds[sub] : null, sub, applyNormalizeIconPath(initialSubIconPath));
            }
          } else if(subIconHtml){
            subLogo.innerHTML = subIconHtml;
            subLogo.classList.add('has-icon');
          } else {
            subLogo.textContent = sub.charAt(0) || '';
          }

          const subLabel = document.createElement('span');
          subLabel.className = 'subcategory-label';
          subLabel.textContent = sub;

          subLabelWrap.append(subLogo, subLabel);

          const subArrow = document.createElement('span');
          subArrow.className = 'dropdown-arrow';
          subArrow.setAttribute('aria-hidden','true');

          subBtn.append(subLabelWrap, subArrow);
          subTriggerWrap.append(subBtn);

          const subEditBtn = document.createElement('button');
          subEditBtn.type = 'button';
          subEditBtn.className = 'subcategory-edit-btn';
          subEditBtn.innerHTML = '<svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor" aria-hidden="true"><path d="M12.854 1.146a.5.5 0 0 1 .707 0l1.293 1.293a.5.5 0 0 1 0 .707l-8.939 8.939a.5.5 0 0 1-.233.131l-3.5.875a.5.5 0 0 1-.606-.606l.875-3.5a.5.5 0 0 1 .131-.233l8.939-8.939z"/><path d="M2.5 12.5V14h1.5l9-9-1.5-1.5-9 9z"/></svg>';
          subEditBtn.setAttribute('aria-label', `Edit ${sub} subcategory`);
          subEditBtn.setAttribute('aria-expanded','false');

          const subDragHandle = createFormbuilderDragHandle(`Reorder ${sub || 'Subcategory'} subcategory`, 'subcategory-drag-handle');

          const subInput = document.createElement('input');
          subInput.type = 'checkbox';
          subInput.checked = true;
          subInput.setAttribute('aria-label', `Toggle ${sub} subcategory`);
          subInput.hidden = true;

          subHeader.append(subTriggerWrap, subDragHandle, subEditBtn, subInput);
          subMenu.append(subHeader);

          const subContent = document.createElement('div');
          subContent.className = 'subcategory-form-content';
          subContent.id = subContentId;
          subContent.hidden = true;

          const subNameInput = document.createElement('input');
          subNameInput.type = 'text';
          subNameInput.className = 'subcategory-name-input';
          subNameInput.placeholder = 'Subcategory Name';
          subNameInput.value = sub || '';

          const subIconPicker = document.createElement('div');
          subIconPicker.className = 'options-dropdown menu--icon-picker';

          const subIconButton = document.createElement('button');
          subIconButton.type = 'button';
          subIconButton.className = 'menu-button--icon-picker';
          subIconButton.setAttribute('aria-haspopup', 'true');
          subIconButton.setAttribute('aria-expanded', 'false');

          const subIconImg = document.createElement('img');
          subIconImg.className = 'menu-button-img--icon-picker';
          subIconImg.alt = '';
          const subIconLabel = document.createElement('span');
          subIconLabel.className = 'menu-button-label--icon-picker';
          subIconLabel.textContent = 'Choose Icon';
          const subIconArrow = document.createElement('span');
          subIconArrow.className = 'dropdown-arrow';
          subIconArrow.setAttribute('aria-hidden', 'true');
          subIconButton.append(subIconImg, subIconLabel, subIconArrow);

          if(initialSubIconPath){
            const normalizedSubIconPath = applyNormalizeIconPath(initialSubIconPath);
            if(normalizedSubIconPath){
              subIconImg.src = normalizedSubIconPath;
              subIconButton.classList.add('has-icon');
              const filename = normalizedSubIconPath.split('/').pop();
              subIconLabel.textContent = filename;
            }
          }

          subIconPicker.append(subIconButton);
          // Use icon picker for formbuilder (uses category-icons folder, not system-images)
          if(typeof window.attachIconPicker === 'function'){
            window.attachIconPicker(subIconButton, subIconPicker, {
              getCurrentPath: ()=> applyNormalizeIconPath(getSubcategoryIconPath(c, currentSubName)),
              onSelect: value => {
                updateSubIconDisplay(value);
                notifyFormbuilderChange();
              },
              label: `Choose icon for ${sub}`,
              parentMenu: subContent,
              parentCategoryMenu: menu
            });
          }

          const deleteSubBtn = document.createElement('button');
          deleteSubBtn.type = 'button';
          deleteSubBtn.className = 'delete-subcategory-btn button--delete';
          deleteSubBtn.dataset.messageKey = 'msg_button_delete_subcategory';
          // Text will be loaded from DB
          deleteSubBtn.setAttribute('aria-label', `Delete ${sub} subcategory from ${c.name}`);

          const fieldsSection = document.createElement('div');
          fieldsSection.className = 'subcategory-fields-section';

          const fieldsList = document.createElement('div');
          fieldsList.className = 'subcategory-fields-list';
          fieldsSection.appendChild(fieldsList);

          const addFieldBtnWrapper = document.createElement('div');
          addFieldBtnWrapper.className = 'field-type-select-wrapper options-dropdown add-field-btn-wrapper';
          
          const addFieldBtn = document.createElement('button');
          addFieldBtn.type = 'button';
          addFieldBtn.className = 'add-field-btn';
          addFieldBtn.dataset.messageKey = 'msg_button_add_field';
          // Text will be loaded from DB
          addFieldBtn.setAttribute('aria-label', `Add field to ${sub}`);
          
          addFieldBtnWrapper.appendChild(addFieldBtn);

          // ensureFieldDefaults is now defined at module scope, use it directly
          const buildVenueSessionPreview = (previewField, baseId, buildOptions = {})=>{
            // CRITICAL: Clone options to prevent sharing state between form preview and member forms
            // Each instance needs its own independent copy of the options
            const clonedOptions = Array.isArray(previewField.options) 
              ? previewField.options.map(venue => cloneVenueSessionVenue(venue))
              : [];
            // Create a local field copy to work with, so we don't mutate the original
            const localField = {
              ...previewField,
              options: clonedOptions.length > 0 ? clonedOptions : [venueSessionCreateVenue()]
            };
            
            const editor = document.createElement('div');
            editor.className = 'venue-session-editor';
            editor.setAttribute('aria-required', previewField.required ? 'true' : 'false');
            
            // Store reference to localField for external access (e.g., checkout price updates)
            editor._fieldRef = localField;
            
            // Detect if we're in member form context (needs stopPropagation to prevent form closure)
            const isMemberForm = baseId && (baseId.includes('memberForm') || baseId.includes('memberCreate'));
            // Detect if we're in formbuilder (needs to sync back to previewField.options)
            const isFormbuilder = !isMemberForm && baseId && (baseId.includes('formPreview') || baseId.includes('formbuilder'));
            // In sandbox mode, don't trigger save state changes
            const isSandbox = buildOptions.isSandbox === true;
            const safeNotifyChange = isSandbox ? (()=>{}) : notifyFormbuilderChange;
            
            // For member forms, prevent clicks from bubbling up to prevent form closure
            // BUT allow buttons and geocoder events to propagate so they work
            if(isMemberForm){
              const shouldStopPropagation = (e) => {
                const target = e.target;
                // Don't stop propagation for geocoder elements - they need events to work
                if(target.closest('.mapboxgl-ctrl-geocoder') || target.closest('.google-places-geocoder')) return false;
                // Don't stop propagation for buttons - they need clicks to work
                if(target.tagName === 'BUTTON' || target.closest('button')) return false;
                // Don't stop propagation for action button containers
                if(target.closest('.venue-line-actions') || target.closest('.session-date-actions') || target.closest('.session-time-actions')) return false;
                // Don't stop propagation for calendar picker elements
                if(target.closest('.session-date-picker') || target.closest('.calendar-actions')) return false;
                return true;
              };
              
              editor.addEventListener('click', (e)=>{
                if(shouldStopPropagation(e)){
                  e.stopPropagation();
                }
              }, true);
              editor.addEventListener('pointerdown', (e)=>{
                if(shouldStopPropagation(e)){
                  e.stopPropagation();
                }
              }, true);
              editor.addEventListener('mousedown', (e)=>{
                if(shouldStopPropagation(e)){
                  e.stopPropagation();
                }
              }, true);
              editor.addEventListener('change', (e)=>{
                if(shouldStopPropagation(e)){
                  e.stopPropagation();
                }
              }, true);
              editor.addEventListener('focusin', (e)=>{
                if(shouldStopPropagation(e)){
                  e.stopPropagation();
                }
              }, true);
              // CRITICAL: Add input event handler to prevent form closure when typing
              editor.addEventListener('input', (e)=>{
                if(shouldStopPropagation(e)){
                  e.stopPropagation();
                  e.stopImmediatePropagation();
                }
              }, true);
            }
            
            const venueList = document.createElement('div');
            venueList.className = 'venue-session-venues';
            
            // Also stop propagation on venue list for member forms (but allow buttons)
            if(isMemberForm){
              venueList.addEventListener('click', (e)=>{
                const target = e.target;
                if(!target.closest('.mapboxgl-ctrl-geocoder') && !target.closest('.google-places-geocoder') && !(target.tagName === 'BUTTON' || target.closest('button'))){
                  e.stopPropagation();
                }
              }, true);
              venueList.addEventListener('pointerdown', (e)=>{
                const target = e.target;
                if(!target.closest('.mapboxgl-ctrl-geocoder') && !target.closest('.google-places-geocoder') && !(target.tagName === 'BUTTON' || target.closest('button'))){
                  e.stopPropagation();
                }
              }, true);
              venueList.addEventListener('change', (e)=>{
                const target = e.target;
                if(!target.closest('.mapboxgl-ctrl-geocoder') && !target.closest('.google-places-geocoder') && !(target.tagName === 'BUTTON' || target.closest('button'))){
                  e.stopPropagation();
                }
              }, true);
              // CRITICAL: Add input event handler to prevent form closure when typing
              venueList.addEventListener('input', (e)=>{
                const target = e.target;
                if(!target.closest('.mapboxgl-ctrl-geocoder') && !target.closest('.google-places-geocoder') && !(target.tagName === 'BUTTON' || target.closest('button'))){
                  e.stopPropagation();
                  e.stopImmediatePropagation();
                }
              }, true);
            }
            
            editor.appendChild(venueList);

            const ensureOptions = ()=>{
              // Work with localField.options, not previewField.options
              localField.options = normalizeVenueSessionOptions(localField.options);
              if(!Array.isArray(localField.options) || localField.options.length === 0){
                localField.options = [venueSessionCreateVenue()];
              }
              // Only sync back to previewField.options if we're in formbuilder (not member forms)
              if(isFormbuilder){
                previewField.options = localField.options.map(venue => cloneVenueSessionVenue(venue));
              }
            };
            
            // Sync function to update previewField.options from localField.options (only for formbuilder)
            const syncToPreviewField = ()=>{
              if(isFormbuilder){
                previewField.options = localField.options.map(venue => cloneVenueSessionVenue(venue));
              }
            };

            const today = new Date();
            today.setHours(0, 0, 0, 0);
            const currentYear = today.getFullYear();
            const minPickerDate = new Date(today);
            minPickerDate.setMonth(minPickerDate.getMonth() - 12);
            const maxPickerDate = new Date(today);
            maxPickerDate.setFullYear(maxPickerDate.getFullYear() + 2);

            const openPickers = new Set();
            const openSessions = new Set();
            const closeAllPickers = ()=>{
              openPickers.forEach(close => {
                try{ close(); }catch(err){}
              });
              openPickers.clear();
            };

            const createTransientInputAlert = message => {
              let lastTimestamp = 0;
              let activeAlert = null;
              let activeAlertTimeout = 0;
              return target => {
                const candidate = (target && typeof target.getBoundingClientRect === 'function')
                  ? target
                  : ((document && document.activeElement && typeof document.activeElement.getBoundingClientRect === 'function')
                    ? document.activeElement
                    : null);
                const inputEl = candidate && document.body && document.body.contains(candidate) ? candidate : null;
                if(!inputEl) return;
                const now = Date.now();
                if(now - lastTimestamp < 400){
                  if(activeAlert && typeof activeAlert.reposition === 'function'){
                    activeAlert.reposition();
                  }
                  return;
                }
                lastTimestamp = now;
                if(activeAlertTimeout){
                  clearTimeout(activeAlertTimeout);
                  activeAlertTimeout = 0;
                }
                if(activeAlert && typeof activeAlert.remove === 'function'){
                  activeAlert.remove();
                  activeAlert = null;
                }
                const handle = showCopyStyleMessage(message, inputEl);
                if(!handle) return;
                activeAlert = handle;
                activeAlertTimeout = window.setTimeout(()=>{
                  handle.remove();
                  if(activeAlert === handle){
                    activeAlert = null;
                  }
                  activeAlertTimeout = 0;
                }, 1500);
              };
            };

            const currencyAlertMessage = 'Please select a currency before entering a price.';
            const showCurrencyAlert = createTransientInputAlert(currencyAlertMessage);
            const sessionTimeAlertMessage = 'There is already a session for that time.';
            const showSessionTimeAlert = createTransientInputAlert(sessionTimeAlertMessage);

            const sanitizeSessionPriceValue = value => {
              const raw = typeof value === 'string' ? value : String(value ?? '');
              const cleaned = raw.replace(/[^0-9.,]/g, '');
              if(cleaned === '') return '';
              let integerPart = '';
              let fractionPart = '';
              let separator = '';
              for(let i = 0; i < cleaned.length; i++){
                const ch = cleaned[i];
                if(ch >= '0' && ch <= '9'){
                  if(separator){
                    if(fractionPart.length < 2){
                      fractionPart += ch;
                    }
                  } else {
                    integerPart += ch;
                  }
                } else if((ch === '.' || ch === ',') && !separator){
                  separator = ch;
                }
              }
              if(separator){
                if(integerPart === '') integerPart = '0';
                return fractionPart.length > 0 ? `${integerPart}${separator}${fractionPart}` : `${integerPart}${separator}`;
              }
              return integerPart;
            };

            const formatSessionPriceValue = value => {
              const sanitized = sanitizeSessionPriceValue(value);
              if(sanitized === '') return '';
              let normalized = sanitized.replace(',', '.');
              if(normalized === '') return '';
              if(normalized.startsWith('.')){
                normalized = `0${normalized}`;
              }
              const parts = normalized.split('.');
              let integerPart = parts[0].replace(/\D/g, '');
              if(integerPart === ''){
                integerPart = '0';
              }
              let fractionPart = parts[1] || '';
              fractionPart = fractionPart.replace(/\D/g, '');
              if(fractionPart.length === 0){
                fractionPart = '00';
              } else if(fractionPart.length === 1){
                fractionPart = `${fractionPart}0`;
              } else if(fractionPart.length > 2){
                fractionPart = fractionPart.slice(0, 2);
              }
              return `${integerPart}.${fractionPart}`;
            };

            const ensureVenueCurrencyState = venue => {
              let state = VENUE_CURRENCY_STATE.get(venue);
              if(!state){
                state = { currency: 'USD' };
                VENUE_CURRENCY_STATE.set(venue, state);
              }
              if(typeof state.currency !== 'string'){
                state.currency = '';
              }
              return state;
            };

            const findFirstVenueCurrency = venue => {
              if(!venue || !Array.isArray(venue.sessions)) return '';
              for(const session of venue.sessions){
                if(!session || !Array.isArray(session.session_times)) continue;
                for(const time of session.session_times){
                  if(!time || !Array.isArray(time.seating_areas)) continue;
                  for(const seatingArea of time.seating_areas){
                    if(!seatingArea || !Array.isArray(seatingArea.pricing_tiers)) continue;
                    for(const pricingTier of seatingArea.pricing_tiers){
                      if(pricingTier && typeof pricingTier.currency === 'string'){
                        const trimmed = pricingTier.currency.trim();
                        if(trimmed) return trimmed;
                      }
                    }
                  }
                }
              }
              return '';
            };

            const getVenueCurrencyValue = venue => {
              const state = ensureVenueCurrencyState(venue);
              if(state.currency){
                return state.currency;
              }
              const detected = findFirstVenueCurrency(venue);
              if(detected){
                state.currency = detected;
                LAST_SELECTED_VENUE_CURRENCY = detected;
                return detected;
              }
              return '';
            };

            const setVenueCurrencyState = (venue, currency)=>{
              const state = ensureVenueCurrencyState(venue);
              const normalized = typeof currency === 'string' ? currency.trim() : '';
              state.currency = normalized;
              if(normalized){
                LAST_SELECTED_VENUE_CURRENCY = normalized;
              }
            };

            const applyCurrencyToVenueData = (venue, currency, options = {})=>{
              const normalized = typeof currency === 'string' ? currency.trim() : '';
              const onlyUnset = options && options.onlyUnset === true;
              const sourceTier = options ? options.sourceTier : null;
              const clearPrices = options && options.clearPrices === true;
              let changed = false;
              if(!venue || !Array.isArray(venue.sessions)) return changed;
              venue.sessions.forEach(session => {
                if(!session || !Array.isArray(session.session_times)) return;
                session.session_times.forEach(time => {
                  if(!time || !Array.isArray(time.seating_areas)) return;
                  time.seating_areas.forEach(seatingArea => {
                    if(!seatingArea || !Array.isArray(seatingArea.pricing_tiers)) return;
                    seatingArea.pricing_tiers.forEach(tierItem => {
                      if(!tierItem || typeof tierItem !== 'object') return;
                      if(sourceTier && tierItem === sourceTier) return;
                      const current = typeof tierItem.currency === 'string' ? tierItem.currency : '';
                      if(normalized){
                        if((!onlyUnset || !current) && current !== normalized){
                          tierItem.currency = normalized;
                          changed = true;
                        }
                      } else if(!onlyUnset && current){
                        tierItem.currency = '';
                        changed = true;
                      }
                      if(clearPrices && (!normalized || !current)){
                        if(typeof tierItem.price === 'string' && tierItem.price !== ''){
                          tierItem.price = '';
                          changed = true;
                        }
                      }
                    });
                  });
                });
              });
              return changed;
            };

            const sanitizeTimeInput = value => {
              const digits = String(value || '').replace(/\D/g, '').slice(0, 4);
              if(digits.length <= 2){
                return digits;
              }
              return `${digits.slice(0, 2)}:${digits.slice(2, 4)}`;
            };

            const formatSessionDate = iso => {
              if(!iso) return '';
              try{
                const parsed = parseISODate(iso);
                const options = {
                  weekday: 'short',
                  day: 'numeric',
                  month: 'short'
                };
                if(parsed.getFullYear() !== currentYear){
                  options.year = 'numeric';
                }
                return parsed.toLocaleDateString('en-GB', options).replace(/,/g, '');
              }catch(err){
                return '';
              }
            };

            const getSessionPrimaryTime = session => {
              if(!session || !Array.isArray(session.session_times)) return '';
              for(let i = 0; i < session.session_times.length; i++){
                const candidate = session.session_times[i];
                if(candidate && typeof candidate.time === 'string' && candidate.time.trim() !== ''){
                  return candidate.time.trim();
                }
              }
              const first = session.session_times[0];
              return first && typeof first.time === 'string' ? first.time.trim() : '';
            };

            const formatSessionDateWithTime = (session, overrideTime) => {
              const dateLabel = formatSessionDate(session && session.date);
              const override = typeof overrideTime === 'string' ? overrideTime.trim() : '';
              const timeLabel = override || getSessionPrimaryTime(session);
              if(dateLabel && timeLabel){
                return `${dateLabel} ${timeLabel}`;
              }
              return dateLabel || timeLabel;
            };

            const setSessionDateInputValue = (input, session, overrideTime) => {
              if(!input) return;
              input.value = formatSessionDateWithTime(session, overrideTime);
            };

            const updateSessionDateInputDisplay = (venueIndex, sessionIndex, overrideTime) => {
              if(!localField || !Array.isArray(localField.options)) return;
              const venue = localField.options[venueIndex];
              if(!venue || !Array.isArray(venue.sessions)) return;
              const session = venue.sessions[sessionIndex];
              if(!session) return;
              const selector = `.session-date-input[data-venue-index="${venueIndex}"][data-session-index="${sessionIndex}"]`;
              const input = editor.querySelector(selector);
              if(!input) return;
              setSessionDateInputValue(input, session, overrideTime);
            };

            const ensureSlot = (venue, index)=>{
              const state = getVenueAutofillState(previewField, venue);
              if(!Array.isArray(state.slots)){
                state.slots = [];
              }
              while(state.slots.length <= index){
                state.slots.push({ value: '', locked: false, source: null });
              }
              const slot = state.slots[index];
              if(!slot || typeof slot !== 'object'){
                state.slots[index] = { value: '', locked: false, source: null };
                return state.slots[index];
              }
              if(typeof slot.value !== 'string') slot.value = '';
              if(typeof slot.locked !== 'boolean') slot.locked = false;
              if(!Object.prototype.hasOwnProperty.call(slot, 'source')) slot.source = null;
              return slot;
            };

            const resetSlotIfEmpty = (venue, index)=>{
              const state = getVenueAutofillState(previewField, venue);
              if(!state || !Array.isArray(state.slots) || !state.slots[index]) return;
              const allEmpty = venue.sessions.every(sess => {
                const t = sess.session_times[index];
                return !t || !t.time || !t.time.trim();
              });
              if(allEmpty){
                state.slots[index].value = '';
                state.slots[index].locked = false;
                state.slots[index].source = null;
              }
            };

            const isSessionMirrorLocked = venue => {
              const state = getVenueAutofillState(previewField, venue);
              if(typeof state.sessionMirrorLocked !== 'boolean'){
                state.sessionMirrorLocked = false;
              }
              return state.sessionMirrorLocked;
            };

            const lockSessionMirror = venue => {
              const state = getVenueAutofillState(previewField, venue);
              if(state.sessionMirrorLocked === true) return;
              state.sessionMirrorLocked = true;
              if(Array.isArray(state.slots)){
                state.slots.forEach(slot => {
                  if(slot && typeof slot === 'object'){
                    slot.locked = true;
                  }
                });
              }
            };

            const forEachOtherSession = (venue, callback)=>{
              if(!venue || !Array.isArray(venue.sessions)) return;
              venue.sessions.forEach((sess, idx)=>{
                if(idx === 0 || !sess) return;
                callback(sess, idx);
              });
            };

            const cloneSeatingAreasFromTime = sourceTime => {
              const seatingAreas = sourceTime && Array.isArray(sourceTime.seating_areas) ? sourceTime.seating_areas : [];
              return seatingAreas.length ? seatingAreas.map(cloneVenueSessionSeatingArea) : [venueSessionCreateSeatingArea()];
            };

            const cloneSessionTimesFromFirst = (venue, targetSession)=>{
              if(!venue || !targetSession) return;
              if(isSessionMirrorLocked(venue)) return;
              const sessions = Array.isArray(venue.sessions) ? venue.sessions : [];
              if(sessions.length === 0) return;
              const template = sessions[0];
              if(!template || template === targetSession) return;
              const preservedDate = typeof targetSession.date === 'string' ? targetSession.date : '';
              const preservedTimes = Array.isArray(targetSession.session_times)
                ? targetSession.session_times.map(time => (time && typeof time.time === 'string') ? time.time : '')
                : [];
              const times = Array.isArray(template.session_times) ? template.session_times : [];
              targetSession.session_times = times.length ? times.map(cloneVenueSessionSessionTime) : [venueSessionCreateSessionTime()];
              targetSession.date = preservedDate;
              const referenceTimes = times;
              const referenceFirstTime = referenceTimes[0];
              if(targetSession.session_times.length === 0){
                targetSession.session_times.push(venueSessionCreateSessionTime());
              }
              if(targetSession !== template){
                targetSession.session_times.forEach((time, index)=>{
                  time.samePricingSourceIndex = 0;
                  if(index === 0){
                    if(referenceFirstTime){
                      time.samePricingAsAbove = true;
                      time.seating_areas = cloneSeatingAreasFromTime(referenceFirstTime);
                      time.tierAutofillLocked = true;
                    } else {
                      time.samePricingAsAbove = false;
                      time.tierAutofillLocked = false;
                    }
                  }
                  if(preservedTimes[index]){
                    time.time = preservedTimes[index];
                  }
                });
                const targetFirstTime = targetSession.session_times[0];
                targetSession.session_times.forEach((time, index)=>{
                  if(index > 0){
                    time.samePricingAsAbove = true;
                    if(targetFirstTime && targetFirstTime !== time){
                      time.seating_areas = cloneSeatingAreasFromTime(targetFirstTime);
                    }
                    time.tierAutofillLocked = true;
                  }
                });
              }
            };

            const flattenSessionTimes = venue => {
              if(!venue || !Array.isArray(venue.sessions)) return;
              const pendingInsertions = [];
              let requiresLock = false;
              venue.sessions.forEach((session, index)=>{
                if(!session) return;
                if(!Array.isArray(session.session_times) || session.session_times.length === 0){
                  session.session_times = [venueSessionCreateSessionTime()];
                }
                const sanitizedTimes = session.session_times.filter(Boolean);
                if(sanitizedTimes.length <= 1){
                  session.session_times = sanitizedTimes.length ? [sanitizedTimes[0]] : [venueSessionCreateSessionTime()];
                  const firstTime = session.session_times[0];
                  if(firstTime){
                    if(typeof firstTime.samePricingAsAbove !== 'boolean'){
                      firstTime.samePricingAsAbove = false;
                    }
                    if(!Number.isInteger(firstTime.samePricingSourceIndex) || firstTime.samePricingSourceIndex < 0){
                      firstTime.samePricingSourceIndex = 0;
                    }
                  }
                  return;
                }
                requiresLock = true;
                const primaryTime = cloneVenueSessionSessionTime(sanitizedTimes[0]);
                primaryTime.samePricingSourceIndex = 0;
                primaryTime.tierAutofillLocked = !!primaryTime.tierAutofillLocked;
                session.session_times = [primaryTime];
                const clones = [];
                for(let i = 1; i < sanitizedTimes.length; i++){
                  const cloneSession = cloneVenueSessionSession(session);
                  cloneSession.session_times = [cloneVenueSessionSessionTime(sanitizedTimes[i])];
                  const firstCloneTime = cloneSession.session_times[0];
                  if(firstCloneTime){
                    firstCloneTime.samePricingSourceIndex = 0;
                    firstCloneTime.tierAutofillLocked = !!firstCloneTime.tierAutofillLocked;
                  }
                  clones.push(cloneSession);
                }
                if(clones.length){
                  pendingInsertions.push({ index, clones });
                }
              });
              if(requiresLock){
                lockSessionMirror(venue);
              }
              if(!pendingInsertions.length) return;
              let offset = 0;
              pendingInsertions.forEach(entry => {
                const insertIndex = entry.index + 1 + offset;
                venue.sessions.splice(insertIndex, 0, ...entry.clones);
                offset += entry.clones.length;
              });
            };

            const applyAutofillToSession = (venue, session)=>{
              if(!session) return;
              cloneSessionTimesFromFirst(venue, session);
              if(isSessionMirrorLocked(venue)) return;
              const state = getVenueAutofillState(previewField, venue);
              const slots = Array.isArray(state.slots) ? state.slots : [];
              for(let i = 0; i < slots.length; i++){
                const slot = slots[i];
                if(!slot || typeof slot !== 'object' || !slot.value || slot.locked) continue;
                const target = session.session_times[i] || (session.session_times[i] = venueSessionCreateSessionTime());
                if(!target.time){
                  target.time = slot.value;
                }
              }
            };

            const ensureSessionStructure = (venue)=>{
              if(!Array.isArray(venue.sessions)){
                venue.sessions = [venueSessionCreateSession()];
              }
              if(venue.sessions.length === 0){
                venue.sessions.push(venueSessionCreateSession());
              }
              flattenSessionTimes(venue);
              if(!isSessionMirrorLocked(venue)){
                venue.sessions.forEach((session, index)=>{
                  if(index === 0) return;
                  cloneSessionTimesFromFirst(venue, session);
                });
              }
              let maxTimes = 0;
              venue.sessions.forEach(session => {
                if(!Array.isArray(session.session_times)){
                  session.session_times = [venueSessionCreateSessionTime()];
                }
                if(session.session_times.length === 0){
                  session.session_times.push(venueSessionCreateSessionTime());
                }
                session.session_times.forEach((time, timeIndex) => {
                  if(!Array.isArray(time.seating_areas)){
                    time.seating_areas = [venueSessionCreateSeatingArea()];
                  }
                  if(time.seating_areas.length === 0){
                    time.seating_areas.push(venueSessionCreateSeatingArea());
                  }
                  if(typeof time.samePricingAsAbove !== 'boolean'){
                    time.samePricingAsAbove = timeIndex > 0;
                  }
                  const sourceIndex = Number(time.samePricingSourceIndex);
                  if(!Number.isInteger(sourceIndex) || sourceIndex < 0){
                    time.samePricingSourceIndex = 0;
                  }
                  if(typeof time.tierAutofillLocked !== 'boolean'){
                    time.tierAutofillLocked = false;
                  }
                  time.seating_areas.forEach(seatingArea => {
                    if(!Array.isArray(seatingArea.pricing_tiers)){
                      seatingArea.pricing_tiers = [venueSessionCreatePricingTier()];
                    }
                    if(seatingArea.pricing_tiers.length === 0){
                      seatingArea.pricing_tiers.push(venueSessionCreatePricingTier());
                    }
                  });
                });
                maxTimes = Math.max(maxTimes, session.session_times.length);
              });
              const state = getVenueAutofillState(previewField, venue);
              if(!Array.isArray(state.slots)) state.slots = [];
              while(state.slots.length < maxTimes){
                state.slots.push({ value: '', locked: false, source: null });
              }
              while(state.slots.length > maxTimes){
                state.slots.pop();
              }
              for(let i = 0; i < maxTimes; i++){
                ensureSlot(venue, i);
              }
              venue.sessions.forEach(session => {
                while(session.session_times.length < maxTimes){
                  session.session_times.push(venueSessionCreateSessionTime());
                }
              });
              if(!isSessionMirrorLocked(venue)){
                const template = venue.sessions[0];
                if(template && Array.isArray(template.session_times)){
                  template.session_times.forEach((time, index)=>{
                    const slot = ensureSlot(venue, index);
                    slot.value = typeof time.time === 'string' ? time.time : '';
                    slot.source = time;
                    slot.locked = false;
                  });
                }
              }
            };

            const addVenue = (afterIndex)=>{
              ensureOptions();
              const venues = localField.options;
              const newVenue = venueSessionCreateVenue();
              let defaultCurrency = '';
              if(Array.isArray(venues) && venues.length > 0){
                const referenceIndex = Math.min(Math.max(afterIndex, 0), venues.length - 1);
                const referenceVenue = venues[referenceIndex];
                if(referenceVenue){
                  defaultCurrency = getVenueCurrencyValue(referenceVenue) || defaultCurrency;
                }
              }
              if(!defaultCurrency && LAST_SELECTED_VENUE_CURRENCY){
                defaultCurrency = LAST_SELECTED_VENUE_CURRENCY;
              }
              if(defaultCurrency){
                applyCurrencyToVenueData(newVenue, defaultCurrency);
                setVenueCurrencyState(newVenue, defaultCurrency);
              }
              venues.splice(afterIndex + 1, 0, newVenue);
              // Sync to previewField if in formbuilder
              if(isFormbuilder){
                previewField.options = localField.options.map(venue => cloneVenueSessionVenue(venue));
              }
              openSessions.clear();
              safeNotifyChange();
              renderVenues({ type: 'venue-name', venueIndex: afterIndex + 1 });
            };

            const removeVenue = (index)=>{
              ensureOptions();
              if(localField.options.length <= 1) return;
              const removed = localField.options.splice(index, 1)[0];
              // Sync back to previewField if in formbuilder
              if(isFormbuilder){
                previewField.options = localField.options.map(venue => cloneVenueSessionVenue(venue));
              }
              const state = VENUE_TIME_AUTOFILL_STATE.get(previewField);
              if(state && removed){
                try{ state.delete(removed); }catch(err){}
              }
              openSessions.clear();
              safeNotifyChange();
              const nextIndex = Math.max(0, index - 1);
              renderVenues({ type: 'venue-name', venueIndex: nextIndex });
            };

            const requestVenueRemoval = (index)=>{
              ensureOptions();
              if(localField.options.length <= 1) return;
              if(window.confirm('Are you sure you want to remove this venue?')){
                removeVenue(index);
              }
            };

            const addSession = (venue, venueIndex, afterIndex)=>{
              const sessions = venue.sessions;
              const newSession = venueSessionCreateSession();
              const maxTimes = Math.max(...sessions.map(sess => Array.isArray(sess.session_times) ? sess.session_times.length : 1), 1);
              while(newSession.session_times.length < maxTimes){
                newSession.session_times.push(venueSessionCreateSessionTime());
              }
              const primarySession = sessions[0];
              const primaryTimes = Array.isArray(primarySession?.session_times) ? primarySession.session_times : [];
              const primaryFirstTime = primaryTimes[0];
              newSession.session_times.forEach((time, index)=>{
                time.samePricingSourceIndex = 0;
                if(index === 0){
                  if(primaryFirstTime){
                    time.samePricingAsAbove = true;
                    time.seating_areas = cloneSeatingAreasFromTime(primaryFirstTime);
                    time.tierAutofillLocked = true;
                  } else {
                    time.samePricingAsAbove = false;
                    time.tierAutofillLocked = false;
                  }
                } else {
                  time.samePricingAsAbove = true;
                  const baseTime = newSession.session_times[0];
                  if(primaryTimes[index]){
                    const referenceTime = primaryTimes[index];
                    time.seating_areas = cloneSeatingAreasFromTime(referenceTime);
                  } else if(baseTime && baseTime !== time){
                    time.seating_areas = cloneSeatingAreasFromTime(baseTime);
                  }
                  time.tierAutofillLocked = true;
                }
              });
              const venueCurrency = getVenueCurrencyValue(venue);
              if(venueCurrency){
                newSession.session_times.forEach(time => {
                  if(!time || !Array.isArray(time.seating_areas)) return;
                  time.seating_areas.forEach(seatingArea => {
                    if(!seatingArea || !Array.isArray(seatingArea.pricing_tiers)) return;
                    seatingArea.pricing_tiers.forEach(tier => {
                      if(tier && !tier.currency){
                        tier.currency = venueCurrency;
                      }
                    });
                  });
                });
              }
              sessions.splice(afterIndex + 1, 0, newSession);
              applyAutofillToSession(venue, newSession);
              openSessions.clear();
              safeNotifyChange();
              renderVenues();
            };

            const removeSession = (venue, venueIndex, sessionIndex)=>{
              if(venue.sessions.length <= 1) return;
              venue.sessions.splice(sessionIndex, 1);
              openSessions.clear();
              safeNotifyChange();
              renderVenues();
            };

            const addTimeSlot = (venue, venueIndex, sessionIndex, timeIndex)=>{
              if(!venue || !Array.isArray(venue.sessions)) return;
              const previouslyOpenSessions = new Set(openSessions);
              flattenSessionTimes(venue);
              const sessions = venue.sessions;
              if(sessionIndex < 0 || sessionIndex >= sessions.length) return;
              const baseSession = sessions[sessionIndex];
              if(!baseSession) return;
              const existingTimes = Array.isArray(baseSession.session_times) ? baseSession.session_times : [];
              const baseTime = existingTimes[timeIndex] || existingTimes[0] || venueSessionCreateSessionTime();
              baseSession.session_times = [existingTimes[0] || cloneVenueSessionSessionTime(baseTime) || venueSessionCreateSessionTime()];
              const primaryTime = baseSession.session_times[0];
              if(primaryTime){
                primaryTime.samePricingAsAbove = false;
                primaryTime.samePricingSourceIndex = 0;
                primaryTime.tierAutofillLocked = !!primaryTime.tierAutofillLocked;
                primaryTime.displayOrder = 1;
              }
              const newSession = cloneVenueSessionSession(baseSession);
              newSession.date = baseSession.date;
              newSession.session_times = [cloneVenueSessionSessionTime(baseTime)];
              const newTime = newSession.session_times[0];
              newTime.time = '';
              newTime.samePricingAsAbove = true;
              newTime.samePricingSourceIndex = 0;
              newTime.tierAutofillLocked = true;
              newTime.displayOrder = Number.isFinite(Number(timeIndex)) ? Number(timeIndex) + 2 : 2;
              lockSessionMirror(venue);
              sessions.splice(sessionIndex + 1, 0, newSession);
              const state = getVenueAutofillState(previewField, venue);
              if(Array.isArray(state.slots) && state.slots.length > 1){
                state.slots.length = 1;
              }
              const sessionExistsInOptions = sessionObj => previewField.options.some(v => Array.isArray(v?.sessions) && v.sessions.includes(sessionObj));
              openSessions.clear();
              previouslyOpenSessions.forEach(sessionObj => {
                if(sessionExistsInOptions(sessionObj)){
                  openSessions.add(sessionObj);
                }
              });
              openSessions.add(newSession);
              safeNotifyChange();
              renderVenues({ type: 'session-time', venueIndex, sessionIndex: sessionIndex + 1, timeIndex: 0 });
            };

            const removeTimeSlot = (venue, venueIndex, sessionIndex, timeIndex)=>{
              if(!venue || !Array.isArray(venue.sessions) || venue.sessions.length === 0) return;
              flattenSessionTimes(venue);
              const session = venue.sessions[sessionIndex];
              if(!session) return;
              const times = Array.isArray(session.session_times) ? session.session_times : [];
              if(times.length <= 1){
                const state = getVenueAutofillState(previewField, venue);
                if(Array.isArray(state.slots) && state.slots.length > 1){
                  state.slots.length = 1;
                }
                lockSessionMirror(venue);
                removeSession(venue, venueIndex, sessionIndex);
                return;
              }
              const mirrorLocked = isSessionMirrorLocked(venue);
              const referenceSession = mirrorLocked ? venue.sessions[sessionIndex] : venue.sessions[0];
              if(!referenceSession) return;
              const totalSlots = Array.isArray(referenceSession.session_times) ? referenceSession.session_times.length : 0;
              if(totalSlots <= 1) return;
              if(mirrorLocked){
                const sess = venue.sessions[sessionIndex];
                if(sess && sess.session_times.length > timeIndex){
                  sess.session_times.splice(timeIndex, 1);
                }
                if(sess && sess.session_times.length === 0){
                  sess.session_times.push(venueSessionCreateSessionTime());
                }
                lockSessionMirror(venue);
              } else {
                venue.sessions.forEach(sess => {
                  if(sess.session_times.length > timeIndex){
                    sess.session_times.splice(timeIndex, 1);
                  }
                  if(sess.session_times.length === 0){
                    sess.session_times.push(venueSessionCreateSessionTime());
                  }
                });
              }
              const state = getVenueAutofillState(previewField, venue);
              if(Array.isArray(state.slots) && state.slots.length > timeIndex){
                state.slots.splice(timeIndex, 1);
              }
              safeNotifyChange();
              const nextTime = Math.max(0, Math.min(timeIndex, venue.sessions[sessionIndex]?.session_times.length - 1));
              renderVenues({ type: 'session-time', venueIndex, sessionIndex, timeIndex: nextTime });
            };

            const copyTemplateTiersToSeatingArea = (time, targetSeatingArea)=>{
              if(!time || !targetSeatingArea) return;
              if(time.tierAutofillLocked) return;
              const template = Array.isArray(time.seating_areas) ? time.seating_areas[0] : null;
              if(!template || template === targetSeatingArea) return;
              if(!Array.isArray(template.pricing_tiers) || template.pricing_tiers.length === 0) return;
              targetSeatingArea.pricing_tiers = template.pricing_tiers.map(cloneVenueSessionPricingTier);
            };

            const addSeatingArea = (venue, venueIndex, sessionIndex, timeIndex, afterIndex)=>{
              const time = venue.sessions[sessionIndex].session_times[timeIndex];
              const timeSeatingAreasRef = time.seating_areas;
              const newSeatingArea = venueSessionCreateSeatingArea();
              const venueCurrency = getVenueCurrencyValue(venue);
              if(venueCurrency && Array.isArray(newSeatingArea.pricing_tiers)){
                newSeatingArea.pricing_tiers.forEach(tier => {
                  if(tier && !tier.currency){
                    tier.currency = venueCurrency;
                  }
                });
              }
              copyTemplateTiersToSeatingArea(time, newSeatingArea);
              time.seating_areas.splice(afterIndex + 1, 0, newSeatingArea);
              if(sessionIndex === 0 && !isSessionMirrorLocked(venue)){
                forEachOtherSession(venue, otherSess => {
                  const otherTime = otherSess.session_times[timeIndex] || (otherSess.session_times[timeIndex] = venueSessionCreateSessionTime());
                  if(!Array.isArray(otherTime.seating_areas)){
                    otherTime.seating_areas = [venueSessionCreateSeatingArea()];
                  }
                  if(otherTime.seating_areas === timeSeatingAreasRef){
                    return;
                  }
                  const clone = cloneVenueSessionSeatingArea(newSeatingArea);
                  otherTime.seating_areas.splice(afterIndex + 1, 0, clone);
                });
              } else if(sessionIndex > 0){
                lockSessionMirror(venue);
              }
              safeNotifyChange();
              renderVenues({ type: 'seating_area', venueIndex, sessionIndex, timeIndex, seatingAreaIndex: afterIndex + 1 });
            };

            const removeSeatingArea = (venue, venueIndex, sessionIndex, timeIndex, seatingAreaIndex, expectedSeatingArea = null)=>{
              const time = venue.sessions[sessionIndex].session_times[timeIndex];
              const seatingAreas = Array.isArray(time.seating_areas) ? time.seating_areas : [];
              if(seatingAreas.length <= 1) return;
              let targetSeatingArea = expectedSeatingArea ?? null;
              let targetIndex = targetSeatingArea ? seatingAreas.indexOf(targetSeatingArea) : -1;
              if(targetIndex === -1){
                targetIndex = typeof seatingAreaIndex === 'number' ? seatingAreaIndex : -1;
                if(targetIndex < 0 || targetIndex >= seatingAreas.length) return;
                targetSeatingArea = seatingAreas[targetIndex];
              }
              if(!targetSeatingArea) return;
              if(sessionIndex === 0 && !isSessionMirrorLocked(venue)){
                forEachOtherSession(venue, otherSess => {
                  const otherTime = otherSess.session_times[timeIndex];
                  if(!otherTime || !Array.isArray(otherTime.seating_areas)) return;
                  if(otherTime.seating_areas === seatingAreas){
                    otherTime.seating_areas = otherTime.seating_areas.map(cloneVenueSessionSeatingArea);
                  }
                });
              } else if(sessionIndex > 0){
                lockSessionMirror(venue);
              }
              seatingAreas.splice(targetIndex, 1);
              safeNotifyChange();
              const focusSeatingArea = Math.max(0, Math.min(targetIndex, seatingAreas.length - 1));
              renderVenues({ type: 'seating_area', venueIndex, sessionIndex, timeIndex, seatingAreaIndex: focusSeatingArea });
            };

            const addTier = (venue, venueIndex, sessionIndex, timeIndex, seatingAreaIndex, afterIndex)=>{
              const time = venue.sessions[sessionIndex].session_times[timeIndex];
              if(seatingAreaIndex > 0){
                lockTierAutofillIfNeeded(time, seatingAreaIndex);
              }
              const seatingArea = time.seating_areas[seatingAreaIndex];
              const seatingAreaTiersRef = seatingArea.pricing_tiers;
              const newTier = venueSessionCreatePricingTier();
              const venueCurrency = getVenueCurrencyValue(venue);
              if(venueCurrency){
                newTier.currency = venueCurrency;
              }
              seatingArea.pricing_tiers.splice(afterIndex + 1, 0, newTier);
              if(seatingAreaIndex === 0){
                syncTiersFromTemplate(time);
              }
              if(sessionIndex === 0 && !isSessionMirrorLocked(venue)){
                forEachOtherSession(venue, otherSess => {
                  const otherTime = otherSess.session_times[timeIndex] || (otherSess.session_times[timeIndex] = venueSessionCreateSessionTime());
                  const otherSeatingAreas = Array.isArray(otherTime.seating_areas) ? otherTime.seating_areas : (otherTime.seating_areas = [venueSessionCreateSeatingArea()]);
                  while(otherSeatingAreas.length <= seatingAreaIndex){
                    otherSeatingAreas.push(venueSessionCreateSeatingArea());
                  }
                  const otherSeatingArea = otherSeatingAreas[seatingAreaIndex];
                  if(!otherSeatingArea) return;
                  if(otherSeatingArea === seatingArea || otherSeatingArea.pricing_tiers === seatingAreaTiersRef){
                    return;
                  }
                  const clone = cloneVenueSessionPricingTier(newTier);
                  otherSeatingArea.pricing_tiers.splice(afterIndex + 1, 0, clone);
                });
              } else if(sessionIndex > 0){
                lockSessionMirror(venue);
              }
              safeNotifyChange();
              renderVenues({ type: 'tier', venueIndex, sessionIndex, timeIndex, seatingAreaIndex, tierIndex: afterIndex + 1 });
            };

            const removeTier = (venue, venueIndex, sessionIndex, timeIndex, seatingAreaIndex, tierIndex, expectedSeatingArea = null, expectedTier = null)=>{
              const time = venue.sessions[sessionIndex].session_times[timeIndex];
              const seatingAreas = Array.isArray(time.seating_areas) ? time.seating_areas : [];
              if(seatingAreas.length === 0) return;
              let targetSeatingArea = expectedSeatingArea ?? null;
              let targetSeatingAreaIndex = targetSeatingArea ? seatingAreas.indexOf(targetSeatingArea) : -1;
              if(targetSeatingAreaIndex === -1){
                targetSeatingAreaIndex = typeof seatingAreaIndex === 'number' ? seatingAreaIndex : -1;
                if(targetSeatingAreaIndex < 0 || targetSeatingAreaIndex >= seatingAreas.length) return;
                targetSeatingArea = seatingAreas[targetSeatingAreaIndex];
              }
              if(!targetSeatingArea) return;
              if(targetSeatingAreaIndex > 0){
                lockTierAutofillIfNeeded(time, targetSeatingAreaIndex);
              }
              const seatingArea = seatingAreas[targetSeatingAreaIndex];
              const tiers = seatingArea && Array.isArray(seatingArea.pricing_tiers) ? seatingArea.pricing_tiers : [];
              if(tiers.length <= 1) return;
              let targetTier = expectedTier ?? null;
              let targetTierIndex = targetTier ? tiers.indexOf(targetTier) : -1;
              if(targetTierIndex === -1){
                targetTierIndex = typeof tierIndex === 'number' ? tierIndex : -1;
                if(targetTierIndex < 0 || targetTierIndex >= tiers.length) return;
                targetTier = tiers[targetTierIndex];
              }
              if(!targetTier) return;
              const templateRemoval = targetSeatingAreaIndex === 0;
              if(sessionIndex === 0 && !isSessionMirrorLocked(venue)){
                forEachOtherSession(venue, otherSess => {
                  const otherTime = otherSess.session_times[timeIndex];
                  if(!otherTime || !Array.isArray(otherTime.seating_areas)) return;
                  if(otherTime.seating_areas === seatingAreas){
                    otherTime.seating_areas = otherTime.seating_areas.map(cloneVenueSessionSeatingArea);
                    return;
                  }
                  const otherSeatingArea = otherTime.seating_areas[targetSeatingAreaIndex];
                  if(!otherSeatingArea || !Array.isArray(otherSeatingArea.pricing_tiers)) return;
                  if(otherSeatingArea.pricing_tiers === tiers){
                    otherSeatingArea.pricing_tiers = otherSeatingArea.pricing_tiers.map(cloneVenueSessionPricingTier);
                  }
                });
              } else if(sessionIndex > 0){
                lockSessionMirror(venue);
              }
              tiers.splice(targetTierIndex, 1);
              if(templateRemoval){
                syncTiersFromTemplate(time);
              }
              safeNotifyChange();
              const focusTier = Math.max(0, Math.min(targetTierIndex, tiers.length - 1));
              renderVenues({ type: 'tier', venueIndex, sessionIndex, timeIndex, seatingAreaIndex: targetSeatingAreaIndex, tierIndex: focusTier });
            };

            const focusRequest = { current: null };
            const setFocus = spec => { focusRequest.current = spec; };

            const applyFocus = ()=>{
              const spec = focusRequest.current;
              if(!spec) return;
              focusRequest.current = null;
              let selector = '';
              if(spec.type === 'venue-name'){
                selector = `.venue-name-input[data-venue-index="${spec.venueIndex}"]`;
              } else if(spec.type === 'session-date'){
                selector = `.session-date-input[data-venue-index="${spec.venueIndex}"][data-session-index="${spec.sessionIndex}"]`;
              } else if(spec.type === 'session-time'){
                selector = `.session-time-input[data-venue-index="${spec.venueIndex}"][data-session-index="${spec.sessionIndex}"][data-time-index="${spec.timeIndex}"]`;
              } else if(spec.type === 'seating_area'){
                selector = `.seating_area-input[data-venue-index="${spec.venueIndex}"][data-session-index="${spec.sessionIndex}"][data-time-index="${spec.timeIndex}"][data-seating-area-index="${spec.seatingAreaIndex}"]`;
              } else if(spec.type === 'tier'){
                selector = `.pricing_tier-input[data-venue-index="${spec.venueIndex}"][data-session-index="${spec.sessionIndex}"][data-time-index="${spec.timeIndex}"][data-seating-area-index="${spec.seatingAreaIndex}"][data-tier-index="${spec.tierIndex}"]`;
              } else if(spec.type === 'price'){
                selector = `.session-price-input[data-venue-index="${spec.venueIndex}"][data-session-index="${spec.sessionIndex}"][data-time-index="${spec.timeIndex}"][data-seating-area-index="${spec.seatingAreaIndex}"][data-tier-index="${spec.tierIndex}"]`;
              }
              if(!selector) return;
              const target = editor.querySelector(selector);
              if(!target) return;
              requestAnimationFrame(()=>{
                try{
                  target.focus();
                  if(typeof target.select === 'function'){
                    target.select();
                  }
                }catch(err){}
              });
            };

            const createActionButton = (symbol, ariaLabel, onClick)=>{
              const btn = document.createElement('button');
              btn.type = 'button';
              btn.className = 'tiny';
              btn.textContent = symbol;
              btn.setAttribute('aria-label', ariaLabel);
              btn.addEventListener('click', event => {
                event.preventDefault();
                onClick();
              });
              return btn;
            };

            const lockTierAutofillIfNeeded = (time, seatingAreaIndex)=>{
              if(!time || time.tierAutofillLocked) return false;
              if(typeof seatingAreaIndex !== 'number' || seatingAreaIndex <= 0) return false;
              const seatingAreaCount = Array.isArray(time.seating_areas) ? time.seating_areas.length : 0;
              if(seatingAreaCount <= 1) return false;
              time.tierAutofillLocked = true;
              return true;
            };

            const syncTiersFromTemplate = time => {
              if(!time || time.tierAutofillLocked) return false;
              const seatingAreas = Array.isArray(time.seating_areas) ? time.seating_areas : [];
              if(seatingAreas.length <= 1) return false;
              const template = seatingAreas[0];
              if(!template || !Array.isArray(template.pricing_tiers)) return false;
              const templateTiers = template.pricing_tiers;
              let changed = false;
              for(let index = 1; index < seatingAreas.length; index++){
                const seatingArea = seatingAreas[index];
                if(!seatingArea) continue;
                let tiers = Array.isArray(seatingArea.pricing_tiers) ? seatingArea.pricing_tiers : (seatingArea.pricing_tiers = []);
                if(tiers.length > templateTiers.length){
                  tiers.length = templateTiers.length;
                  changed = true;
                }
                for(let tierIndex = 0; tierIndex < templateTiers.length; tierIndex++){
                  const templateTier = templateTiers[tierIndex];
                  let targetTier = tiers[tierIndex];
                  if(!targetTier){
                    targetTier = venueSessionCreatePricingTier();
                    tiers[tierIndex] = targetTier;
                    changed = true;
                  }
                  const templateName = typeof templateTier?.name === 'string' ? templateTier.name : '';
                  if(targetTier.name !== templateName){
                    targetTier.name = templateName;
                    changed = true;
                  }
                }
              }
              return changed;
            };

            const commitTimeValue = ({ venue, venueIndex, sessionIndex, timeIndex, timeObj, input })=>{
              const session = Array.isArray(venue.sessions) ? venue.sessions[sessionIndex] : null;
              const isMaster = sessionIndex === 0;
              if(!isMaster){
                lockSessionMirror(venue);
              }
              const mirrorLocked = isSessionMirrorLocked(venue);

              const clearTimeValue = ()=>{
                const previous = typeof timeObj.time === 'string' ? timeObj.time : '';
                if(input.value !== ''){
                  input.value = '';
                }
                if(previous){
                  timeObj.time = '';
                  safeNotifyChange();
                }
                const slot = ensureSlot(venue, timeIndex);
                if(isMaster && !mirrorLocked){
                  slot.value = '';
                  slot.source = timeObj;
                  slot.locked = false;
                  forEachOtherSession(venue, (sess, idx)=>{
                    const targetTime = sess.session_times[timeIndex] || (sess.session_times[timeIndex] = venueSessionCreateSessionTime());
                    if(targetTime.time){
                      targetTime.time = '';
                    }
                    const selector = `.session-time-input[data-venue-index="${venueIndex}"][data-session-index="${idx}"][data-time-index="${timeIndex}"]`;
                    const sibling = editor.querySelector(selector);
                    if(sibling){
                      sibling.value = '';
                      sibling.classList.remove('is-invalid');
                    }
                    updateSessionDateInputDisplay(venueIndex, idx);
                  });
                } else {
                  if(slot.source === timeObj){
                    slot.source = null;
                  }
                  slot.value = '';
                  slot.locked = true;
                }
                resetSlotIfEmpty(venue, timeIndex);
                input.classList.remove('is-invalid');
                updateSessionDateInputDisplay(venueIndex, sessionIndex);
                return previous;
              };

              const raw = input.value.trim();
              if(raw === ''){
                clearTimeValue();
                return;
              }
              if(!/^([01]\d|2[0-3]):[0-5]\d$/.test(raw)){
                input.classList.add('is-invalid');
                input.value = timeObj.time || '';
                return;
              }
              input.classList.remove('is-invalid');
              if(timeObj.time === raw){
                return;
              }

              let hasDuplicateTime = false;
              const currentDate = typeof session?.date === 'string' ? session.date : '';
              const sessionsToCheck = Array.isArray(venue.sessions) ? venue.sessions : [];
              for(let idx = 0; idx < sessionsToCheck.length && !hasDuplicateTime; idx++){
                const compareSession = sessionsToCheck[idx];
                if(!compareSession) continue;
                if(currentDate){
                  if(typeof compareSession.date !== 'string' || compareSession.date !== currentDate) continue;
                } else if(compareSession !== session){
                  continue;
                }
                const compareTimes = Array.isArray(compareSession.session_times) ? compareSession.session_times : [];
                for(let tIdx = 0; tIdx < compareTimes.length; tIdx++){
                  const compareTime = compareTimes[tIdx];
                  if(!compareTime || compareTime === timeObj) continue;
                  if(typeof compareTime.time !== 'string') continue;
                  if(compareTime.time === raw){
                    hasDuplicateTime = true;
                    break;
                  }
                }
              }
              if(hasDuplicateTime){
                clearTimeValue();
                showSessionTimeAlert(input);
                return;
              }

              const slot = ensureSlot(venue, timeIndex);
              timeObj.time = raw;
              updateSessionDateInputDisplay(venueIndex, sessionIndex);
              if(isMaster && !mirrorLocked){
                slot.value = raw;
                slot.source = timeObj;
                slot.locked = false;
                forEachOtherSession(venue, (sess, idx)=>{
                  const targetTime = sess.session_times[timeIndex] || (sess.session_times[timeIndex] = venueSessionCreateSessionTime());
                  targetTime.time = raw;
                  const selector = `.session-time-input[data-venue-index="${venueIndex}"][data-session-index="${idx}"][data-time-index="${timeIndex}"]`;
                  const sibling = editor.querySelector(selector);
                  if(sibling){
                    sibling.value = raw;
                    sibling.classList.remove('is-invalid');
                  }
                  updateSessionDateInputDisplay(venueIndex, idx);
                });
              } else {
                slot.value = raw;
                slot.source = timeObj;
                slot.locked = true;
              }
              safeNotifyChange();
            };

            const setupDatePicker = (input, venue, session, venueIndex, sessionIndex, options = {})=>{
              const trigger = options && options.trigger ? options.trigger : input;
              let picker = null;
              let todayMonthNode = null;
              let todayMarker = null;
              let markerScrollTarget = null;
              let markerScrollListener = null;
              let markerScrollOptions = null;

              const cleanupMarker = ()=>{
                if(todayMarker){
                  todayMarker.remove();
                  todayMarker = null;
                }
                if(markerScrollTarget && markerScrollListener){
                  removeScrollListener(markerScrollTarget, markerScrollListener, markerScrollOptions);
                }
                markerScrollTarget = null;
                markerScrollListener = null;
                markerScrollOptions = null;
                todayMonthNode = null;
              };

              const scrollToMonth = (scrollEl, monthEl, behavior = 'auto')=>{
                if(!scrollEl || !monthEl) return 0;
                const left = monthEl.offsetLeft;
                scrollEl.scrollTo({ left, behavior });
                return left;
              };

              const scrollToTodayMonth = (behavior = 'auto')=>{
                if(!picker || !todayMonthNode) return;
                const scrollEl = picker.querySelector('.calendar-scroll');
                if(!scrollEl) return;
                const left = scrollToMonth(scrollEl, todayMonthNode, behavior);
                if(todayMarker){
                  const base = parseFloat(todayMarker.dataset.pos || '0');
                  todayMarker.style.left = `${base + left}px`;
                }
              };

              const selectedDates = new Set(
                Array.isArray(venue.sessions)
                  ? venue.sessions
                      .map(sess => (sess && typeof sess.date === 'string') ? sess.date : '')
                      .filter(Boolean)
                  : []
              );
              if(session && typeof session.date === 'string' && session.date){
                selectedDates.add(session.date);
              }
              const isoCells = new Map();
              const pickerHostRow = input.closest('.session-date-row');
              const parentSubMenu = input.closest('.subcategory-form-menu');
              const parentCategoryMenu = input.closest('.category-form-menu');
              let activePickerHost = null;
              const closePicker = ()=>{
                if(activePickerHost){
                  activePickerHost.classList.remove('has-open-session-picker');
                  activePickerHost = null;
                }
                if(parentSubMenu){
                  parentSubMenu.classList.remove('has-floating-overlay');
                }
                if(parentCategoryMenu){
                  parentCategoryMenu.classList.remove('has-floating-overlay');
                }
                if(!picker) return;
                cleanupMarker();
                picker.remove();
                picker = null;
                document.removeEventListener('pointerdown', onPointerDown, true);
                document.removeEventListener('keydown', onKeydown, true);
                openPickers.delete(closePicker);
              };
              const isTriggerElement = element => {
                if(!trigger || !(trigger instanceof Element)) return false;
                return trigger === element || trigger.contains(element);
              };
              const onPointerDown = event => {
                if(!picker) return;
                const target = event.target;
                if(target === input || (input && typeof input.contains === 'function' && input.contains(target))) return;
                if(isTriggerElement(target)) return;
                if(picker.contains(target)) return;
                closePicker();
              };
              const onKeydown = event => {
                if(event.key === 'Escape'){
                  event.preventDefault();
                  closePicker();
                  const focusTarget = trigger || input;
                  if(focusTarget && typeof focusTarget.focus === 'function'){
                    try{ focusTarget.focus(); }catch(err){}
                  }
                }
              };
              const updateCellSelection = iso => {
                const cell = isoCells.get(iso);
                if(!cell) return;
                if(selectedDates.has(iso)){
                  cell.classList.add('selected');
                } else {
                  cell.classList.remove('selected');
                }
              };
              const toggleDate = iso => {
                if(!iso) return;
                if(selectedDates.has(iso)){
                  selectedDates.delete(iso);
                } else {
                  selectedDates.add(iso);
                }
                updateCellSelection(iso);
              };
              const applySelection = ()=>{
                try {
                if(selectedDates.size === 0){
                  closePicker();
                  return;
                }
                const sorted = Array.from(selectedDates).sort();
                const existingSessions = Array.isArray(venue.sessions) ? [...venue.sessions] : [];
                const maxTimes = Math.max(
                  ...existingSessions.map(sess => Array.isArray(sess?.times) ? sess.times.length : 1),
                  1
                );
                const sessionsByIso = new Map();
                existingSessions.forEach(sess => {
                  if(sess && typeof sess.date === 'string' && sess.date){
                    if(!sessionsByIso.has(sess.date)){
                      sessionsByIso.set(sess.date, []);
                    }
                    sessionsByIso.get(sess.date).push(sess);
                  }
                });
                const usedSessions = new Set();
                const takeUnused = ()=>{
                  for(const candidate of existingSessions){
                    if(!candidate || usedSessions.has(candidate)) continue;
                    if(typeof candidate.date === 'string' && candidate.date && sorted.includes(candidate.date)){
                      continue;
                    }
                    usedSessions.add(candidate);
                    return candidate;
                  }
                  return null;
                };
                const newSessions = [];
                sorted.forEach(iso => {
                  let active = null;
                  const pool = sessionsByIso.get(iso);
                  if(pool && pool.length){
                    active = pool.shift();
                  }
                  if(active && usedSessions.has(active)){
                    active = null;
                  }
                  if(active){
                    usedSessions.add(active);
                  } else {
                    active = takeUnused();
                  }
                  if(!active){
                    active = venueSessionCreateSession();
                    while(active.times.length < maxTimes){
                      active.times.push(venueSessionCreateSessionTime());
                    }
                    applyAutofillToSession(venue, active);
                  }
                  active.date = iso;
                  newSessions.push(active);
                });
                if(newSessions.length === 0){
                  closePicker();
                  return;
                }
                venue.sessions.splice(0, venue.sessions.length, ...newSessions);
                openSessions.clear();
                safeNotifyChange();
                closePicker();
                renderVenues();
                } catch(err) {
                  console.error('[DatePicker] Error in applySelection:', err);
                }
              };
              const buildCalendar = ()=>{
                isoCells.clear();
                cleanupMarker();
                const container = document.createElement('div');
                container.className = 'session-date-picker';
                const instructions = document.createElement('p');
                instructions.className = 'session-date-picker-instructions';
                instructions.textContent = 'Select all the dates for this venue.';
                container.appendChild(instructions);
                const scroll = document.createElement('div');
                scroll.className = 'calendar-scroll';
                setupHorizontalWheel(scroll);
                const calendar = document.createElement('div');
                calendar.className = 'calendar';
                const weekdays = ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'];
                const todayIso = toISODate(today);
                let current = new Date(minPickerDate.getFullYear(), minPickerDate.getMonth(), 1);
                const end = new Date(maxPickerDate.getFullYear(), maxPickerDate.getMonth(), 1);
                while(current <= end){
                  const monthDate = new Date(current.getFullYear(), current.getMonth(), 1);
                  const monthEl = document.createElement('div');
                  monthEl.className = 'month';
                  const header = document.createElement('div');
                  header.className = 'calendar-header';
                  header.textContent = monthDate.toLocaleDateString('en-GB', { month: 'long', year: 'numeric' });
                  monthEl.appendChild(header);
                  const grid = document.createElement('div');
                  grid.className = 'grid';
                  weekdays.forEach(day => {
                    const wd = document.createElement('div');
                    wd.className = 'weekday';
                    wd.textContent = day;
                    grid.appendChild(wd);
                  });
                  const firstDay = new Date(monthDate.getFullYear(), monthDate.getMonth(), 1);
                  const startDow = firstDay.getDay();
                  const daysInMonth = new Date(monthDate.getFullYear(), monthDate.getMonth() + 1, 0).getDate();
                  const totalCells = 42;
                  for(let i = 0; i < totalCells; i++){
                    const cell = document.createElement('div');
                    cell.className = 'day';
                    const dayNum = i - startDow + 1;
                    if(i < startDow || dayNum > daysInMonth){
                      cell.classList.add('empty');
                    } else {
                      cell.textContent = dayNum;
                      const dateObj = new Date(monthDate.getFullYear(), monthDate.getMonth(), dayNum);
                      dateObj.setHours(0,0,0,0);
                      const iso = toISODate(dateObj);
                      cell.dataset.iso = iso;
                      isoCells.set(iso, cell);
                      if(dateObj < today){
                        cell.classList.add('past');
                      } else {
                        cell.classList.add('future');
                      }
                      if(iso === todayIso){
                        cell.classList.add('today');
                        if(!todayMonthNode){
                          todayMonthNode = monthEl;
                        }
                      }
                      if(selectedDates.has(iso)){
                        cell.classList.add('selected');
                      }
                      cell.addEventListener('click', ()=>{
                        toggleDate(iso);
                      });
                    }
                    grid.appendChild(cell);
                  }
                  monthEl.appendChild(grid);
                  calendar.appendChild(monthEl);
                  current.setMonth(current.getMonth() + 1);
                }
                scroll.appendChild(calendar);
                container.appendChild(scroll);
                const actions = document.createElement('div');
                actions.className = 'calendar-actions';
                const cancelBtn = document.createElement('button');
                cancelBtn.type = 'button';
                cancelBtn.className = 'calendar-action cancel';
                cancelBtn.textContent = 'Cancel';
                cancelBtn.addEventListener('click', ()=> closePicker());
                actions.appendChild(cancelBtn);
                const okBtn = document.createElement('button');
                okBtn.type = 'button';
                okBtn.className = 'calendar-action ok primary';
                okBtn.textContent = 'OK';
                okBtn.addEventListener('click', ()=> applySelection());
                actions.appendChild(okBtn);
                container.appendChild(actions);
                container.addEventListener('keydown', event => {
                  if(event.key !== 'Enter' || event.repeat){
                    return;
                  }
                  const target = event.target;
                  if(target instanceof HTMLButtonElement){
                    return;
                  }
                  event.preventDefault();
                  applySelection();
                });
                queueMicrotask(() => okBtn.focus());
                return container;
              };
              const initializePicker = pickerEl => {
                if(!pickerEl) return;
                const scrollEl = pickerEl.querySelector('.calendar-scroll');
                if(!scrollEl) return;
                scrollEl.setAttribute('tabindex', '0');
                const calendarEl = scrollEl.querySelector('.calendar');
                if(!calendarEl){
                  return;
                }
                const targetMonth = todayMonthNode || calendarEl.querySelector('.month');
                if(targetMonth){
                  scrollEl.scrollLeft = targetMonth.offsetLeft;
                }
                if(todayMonthNode){
                  const maxScroll = Math.max(0, scrollEl.scrollWidth - scrollEl.clientWidth);
                  const track = scrollEl.clientWidth - 20;
                  const scrollPos = todayMonthNode.offsetLeft;
                  todayMarker = document.createElement('div');
                  todayMarker.className = 'today-marker';
                  const basePos = maxScroll > 0 ? (scrollPos / maxScroll) * track + 10 : 10;
                  todayMarker.dataset.pos = String(basePos);
                  todayMarker.style.left = `${basePos + scrollEl.scrollLeft}px`;
                  todayMarker.addEventListener('click', ()=> scrollToTodayMonth('smooth'));
                  scrollEl.appendChild(todayMarker);
                  const onScroll = ()=>{
                    if(!todayMarker) return;
                    const base = parseFloat(todayMarker.dataset.pos || '0');
                    todayMarker.style.left = `${base + scrollEl.scrollLeft}px`;
                  };
                  markerScrollListener = onScroll;
                  markerScrollTarget = scrollEl;
                  markerScrollOptions = addPassiveScrollListener(scrollEl, onScroll);
                  onScroll();
                }
                scrollToTodayMonth('auto');
              };
              const openPicker = ()=>{
                if(picker) return;
                closeAllPickers();
                picker = buildCalendar();
                const appendTarget = pickerHostRow || input.parentElement;
                if(pickerHostRow instanceof Element){
                  activePickerHost = pickerHostRow;
                } else if(appendTarget instanceof Element){
                  activePickerHost = appendTarget;
                } else {
                  activePickerHost = null;
                }
                if(activePickerHost){
                  activePickerHost.classList.add('has-open-session-picker');
                }
                if(appendTarget instanceof Element){
                  appendTarget.appendChild(picker);
                } else if(input.parentElement instanceof Element){
                  input.parentElement.appendChild(picker);
                }
                if(parentSubMenu){
                  parentSubMenu.classList.add('has-floating-overlay');
                }
                if(parentCategoryMenu){
                  parentCategoryMenu.classList.add('has-floating-overlay');
                }
                if(picker){
                  initializePicker(picker);
                  const pickerEl = picker;
                  const showPicker = ()=> pickerEl && pickerEl.classList.add('is-visible');
                  if(typeof requestAnimationFrame === 'function'){
                    requestAnimationFrame(showPicker);
                  } else {
                    showPicker();
                  }
                }
                document.addEventListener('pointerdown', onPointerDown, true);
                document.addEventListener('keydown', onKeydown, true);
                openPickers.add(closePicker);
              };
              if(trigger === input){
                input.addEventListener('focus', ()=> openPicker());
                input.addEventListener('click', ()=> openPicker());
              } else if(trigger){
                const handleTriggerClick = event => {
                  event.preventDefault();
                  event.stopPropagation();
                  openPicker();
                };
                const handleTriggerKeydown = event => {
                  if(event.key === 'Enter' || event.key === ' ' || event.key === 'Spacebar'){
                    event.preventDefault();
                    openPicker();
                  }
                };
                trigger.addEventListener('click', handleTriggerClick);
                trigger.addEventListener('keydown', handleTriggerKeydown);
              }
              return { open: openPicker, close: closePicker };
            };

            const renderVenues = (nextFocus = null)=>{
              closeAllPickers();
              ensureOptions();
              let shouldNotifyAfterRender = false;
              const markAutoChange = ()=>{ shouldNotifyAfterRender = true; };
              if(nextFocus) setFocus(nextFocus);
              venueList.innerHTML = '';
              const datalistSeed = Date.now();
              localField.options.forEach((venue, venueIndex)=>{
                ensureSessionStructure(venue);
                const venueCard = document.createElement('div');
                venueCard.className = 'venue-card';
                venueList.appendChild(venueCard);

                const venueLine = document.createElement('div');
                venueLine.className = 'venue-line';
                let geocoderInputRef = null;
                let nameResultsByKey = Object.create(null);
                let nameSearchTimeout = null;
                let nameSearchAbort = null;
                const NAME_AUTOCOMPLETE_DELAY = 220;
                const nameDatalistId = `venue-name-options-${datalistSeed}-${venueIndex}`;
                const venueNameDatalist = document.createElement('datalist');
                venueNameDatalist.id = nameDatalistId;
                venueCard.appendChild(venueNameDatalist);

                const clearNameSuggestions = ()=>{
                  nameResultsByKey = Object.create(null);
                  venueNameDatalist.innerHTML = '';
                };

                const getFeatureKey = (feature)=>{
                  if(!feature || typeof feature !== 'object') return '';
                  return feature.id
                    || (feature.properties && feature.properties.mapbox_id)
                    || feature.place_name
                    || feature.text
                    || '';
                };

                const updateNameSuggestions = (features)=>{
                  clearNameSuggestions();
                  if(!Array.isArray(features) || !features.length) return;
                  const seenKeys = new Set();
                  for(const feature of features){
                    if(!feature) continue;
                    const key = getFeatureKey(feature);
                    if(!key || seenKeys.has(key)) continue;
                    seenKeys.add(key);
                    const featureClone = cloneGeocoderFeature(feature);
                    nameResultsByKey[key] = featureClone;
                    const option = document.createElement('option');
                    const optionLabel = featureClone.place_name || featureClone.text || '';
                    option.value = featureClone.text || optionLabel;
                    if(optionLabel && optionLabel !== option.value){
                      option.label = optionLabel;
                      option.textContent = optionLabel;
                    } else if(optionLabel){
                      option.textContent = optionLabel;
                    }
                    option.dataset.featureKey = key;
                    venueNameDatalist.appendChild(option);
                  }
                };

                const applyFeatureToVenue = (feature, { updateName=false }={})=>{
                  if(!feature || typeof feature !== 'object') return;
                  const clone = cloneGeocoderFeature(feature);
                  const center = getMapboxVenueFeatureCenter(clone);
                  const placeName = typeof clone.place_name === 'string' ? clone.place_name : '';
                  const featureName = (typeof clone.text === 'string' && clone.text.trim())
                    ? clone.text.trim()
                    : (typeof clone.properties?.name === 'string' ? clone.properties.name.trim() : '');
                  if(updateName && featureName){
                    venue.name = featureName;
                    venueNameInput.value = featureName;
                    syncToPreviewField();
                  }
                  if(placeName){
                    venue.address = placeName;
                    if(geocoderInputRef){
                      geocoderInputRef.value = placeName;
                    }
                    showVenueDisplay();
                    syncToPreviewField();
                  }
                  if(center){
                    venue.location = {
                      lng: Number(center[0]),
                      lat: Number(center[1])
                    };
                  }
                  safeNotifyChange();
                };

                const venueNamePlaceholder = `Venue Name ${venueIndex + 1}`;
                const venueNameInput = document.createElement('input');
                venueNameInput.type = 'text';
                venueNameInput.className = 'venue-name-input';
                venueNameInput.placeholder = venueNamePlaceholder;
                venueNameInput.setAttribute('aria-label', venueNamePlaceholder);
                venueNameInput.value = venue.name || '';
                venueNameInput.dataset.venueIndex = String(venueIndex);
                venueNameInput.setAttribute('list', nameDatalistId);
                protectInputMaxLength(venueNameInput, getFieldLimitsByKey('venue-name').max_length);
                venueNameInput.addEventListener('input', ()=>{
                  const value = venueNameInput.value || '';
                  venue.name = value;
                  syncToPreviewField();
                  safeNotifyChange();
                  if(nameSearchTimeout){
                    clearTimeout(nameSearchTimeout);
                    nameSearchTimeout = null;
                  }
                  if(nameSearchAbort && typeof nameSearchAbort.abort === 'function'){
                    nameSearchAbort.abort();
                    nameSearchAbort = null;
                  }
                  const trimmed = value.trim();
                  if(trimmed.length < MAPBOX_VENUE_MIN_QUERY){
                    clearNameSuggestions();
                    return;
                  }
                  nameSearchTimeout = setTimeout(async ()=>{
                    nameSearchTimeout = null;
                    const controller = (typeof AbortController === 'function') ? new AbortController() : null;
                    if(controller) nameSearchAbort = controller;
                    const signal = controller ? controller.signal : undefined;
                    try{
                      const normalizedQuery = venueNameInput.value.trim();
                      if(normalizedQuery.length < MAPBOX_VENUE_MIN_QUERY){
                        clearNameSuggestions();
                        if(controller) controller.abort();
                        return;
                      }
                      const localResults = searchLocalVenues(normalizedQuery) || [];
                      const remoteResults = await searchMapboxVenues(normalizedQuery, { limit: 6, signal });
                      if(signal && signal.aborted) return;
                      if((venueNameInput.value || '').trim() !== normalizedQuery){
                        return;
                      }
                      updateNameSuggestions([...localResults, ...remoteResults]);
                    } catch(err){
                      if(signal && signal.aborted) return;
                      console.warn('Venue name lookup failed', err);
                      clearNameSuggestions();
                    } finally {
                      if(nameSearchAbort === controller){
                        nameSearchAbort = null;
                      }
                    }
                  }, NAME_AUTOCOMPLETE_DELAY);
                });

                const commitNameSelection = ()=>{
                  const value = (venueNameInput.value || '').trim();
                  if(!value){
                    return;
                  }
                  let selectedFeature = null;
                  const options = venueNameDatalist.querySelectorAll('option');
                  for(const option of options){
                    if(option.value === value && option.dataset && option.dataset.featureKey){
                      const stored = nameResultsByKey[option.dataset.featureKey];
                      if(stored){
                        selectedFeature = stored;
                        break;
                      }
                    }
                  }
                  if(!selectedFeature){
                    const lower = value.toLowerCase();
                    for(const key of Object.keys(nameResultsByKey)){
                      const candidate = nameResultsByKey[key];
                      const candidateName = (candidate.text || candidate.place_name || '').toLowerCase();
                      if(candidateName === lower){
                        selectedFeature = candidate;
                        break;
                      }
                    }
                  }
                  if(selectedFeature){
                    applyFeatureToVenue(selectedFeature, { updateName:true });
                    updateNameSuggestions([selectedFeature]);
                  }
                };

                venueNameInput.addEventListener('change', commitNameSelection);
                venueNameInput.addEventListener('blur', commitNameSelection);
                venueNameInput.addEventListener('keydown', (event)=>{
                  if(event.key === 'Enter'){
                    commitNameSelection();
                  }
                });
                venueLine.appendChild(venueNameInput);
                const venueActions = document.createElement('div');
                venueActions.className = 'venue-line-actions';
                venueActions.appendChild(createActionButton('+', 'Add Venue', ()=> addVenue(venueIndex)));
                const removeVenueBtn = createActionButton('-', 'Remove Venue', ()=> requestVenueRemoval(venueIndex));
                removeVenueBtn.classList.add('danger');
                if(localField.options.length <= 1){
                  removeVenueBtn.disabled = true;
                  removeVenueBtn.setAttribute('aria-disabled', 'true');
                } else {
                  removeVenueBtn.disabled = false;
                  removeVenueBtn.removeAttribute('aria-disabled');
                }
                venueActions.appendChild(removeVenueBtn);
                venueLine.appendChild(venueActions);
                venueCard.appendChild(venueLine);

                const addressLine = document.createElement('div');
                addressLine.className = 'address_line-line';
                const geocoderContainer = document.createElement('div');
                geocoderContainer.className = 'address_line-geocoder-container';
                // Display element shown when not editing
                const addressDisplay = document.createElement('div');
                addressDisplay.className = 'address_line-display';
                addressDisplay.tabIndex = 0;
                addressDisplay.setAttribute('role', 'button');
                addressDisplay.setAttribute('aria-label', 'Click to edit address');
                const showVenueInput = () => {
                  geocoderContainer.hidden = false;
                  addressDisplay.hidden = true;
                  const input = geocoderContainer.querySelector('input');
                  if(input) input.focus();
                };
                const showVenueDisplay = () => {
                  const addr = venue.address || '';
                  if(addr.trim()){
                    addressDisplay.textContent = addr;
                    geocoderContainer.hidden = true;
                    addressDisplay.hidden = false;
                  } else {
                    geocoderContainer.hidden = false;
                    addressDisplay.hidden = true;
                  }
                };
                addressDisplay.addEventListener('click', showVenueInput);
                addressDisplay.addEventListener('keydown', (e) => {
                  if(e.key === 'Enter' || e.key === ' '){
                    e.preventDefault();
                    showVenueInput();
                  }
                });
                addressLine.appendChild(geocoderContainer);
                addressLine.appendChild(addressDisplay);
                // Initialize: show display if address exists, otherwise show input
                if(venue.address && venue.address.trim()){
                  addressDisplay.textContent = venue.address;
                  geocoderContainer.hidden = true;
                  addressDisplay.hidden = false;
                } else {
                  geocoderContainer.hidden = false;
                  addressDisplay.hidden = true;
                }
                venueCard.appendChild(addressLine);
                const addressPlaceholder = `Venue Address ${venueIndex + 1}`;
                const createFallbackAddressInput = ()=>{
                  geocoderContainer.innerHTML = '';
                  geocoderContainer.classList.remove('is-geocoder-active');
                  const fallback = document.createElement('input');
                  fallback.type = 'text';
                  fallback.className = 'address_line-fallback';
                  fallback.placeholder = addressPlaceholder;
                  fallback.setAttribute('aria-label', addressPlaceholder);
                  fallback.value = venue.address || '';
                  fallback.dataset.venueIndex = String(venueIndex);
                  protectInputMaxLength(fallback, getFieldLimitsByKey('address-line').max_length);
                  fallback.addEventListener('input', ()=>{
                    venue.address = fallback.value;
                    safeNotifyChange();
                  });
                  geocoderContainer.appendChild(fallback);
                  geocoderInputRef = fallback;
                  return fallback;
                };
                const mapboxReady = window.mapboxgl && window.MapboxGeocoder && window.mapboxgl.accessToken;
                if(mapboxReady){
                  const geocoderOptions = {
                    accessToken: window.mapboxgl.accessToken,
                    mapboxgl: window.mapboxgl,
                    marker: false,
                    placeholder: addressPlaceholder,
                    geocodingUrl: MAPBOX_VENUE_ENDPOINT,
                    // NOTE: types: 'poi,place,address' retained for reference while testing broader results.
                    types: 'address,poi',
                    reverseGeocode: true,
                    localGeocoder: localVenueGeocoder,
                    externalGeocoder: externalMapboxVenueGeocoder,
                    filter: majorVenueFilter,
                    limit: 7,
                    language: (typeof navigator !== 'undefined' && navigator.language) ? navigator.language : undefined
                  };
                  const geocoder = new MapboxGeocoder(geocoderOptions);
                  const schedule = (typeof window !== 'undefined' && typeof window.requestAnimationFrame === 'function')
                    ? window.requestAnimationFrame.bind(window)
                    : (cb)=> setTimeout(cb, 16);
                  let attempts = 0;
                  const maxAttempts = 20;
                  const attachGeocoder = ()=>{
                    if(!geocoderContainer.isConnected){
                      attempts += 1;
                      if(attempts > maxAttempts){
                        createFallbackAddressInput();
                        return;
                      }
                      schedule(attachGeocoder);
                      return;
                    }
                    try {
                      geocoder.addTo(geocoderContainer);
                    } catch(err){
                      createFallbackAddressInput();
                      return;
                    }
                    const setGeocoderActive = (isActive)=>{
                      const active = !!isActive;
                      geocoderContainer.classList.toggle('is-geocoder-active', active);
                      const subMenu = geocoderContainer.closest('.subcategory-form-menu');
                      if(subMenu){
                        subMenu.classList.toggle('has-floating-overlay', active);
                      }
                      const categoryMenu = subMenu
                        ? subMenu.closest('.category-form-menu')
                        : geocoderContainer.closest('.category-form-menu');
                      if(categoryMenu){
                        categoryMenu.classList.toggle('has-floating-overlay', active);
                      }
                    };
                    setGeocoderActive(false);
                    const geocoderRoot = geocoderContainer.querySelector('.mapboxgl-ctrl-geocoder');
                    if(geocoderRoot && !geocoderRoot.__formPreviewGeocoderBound){
                      geocoderRoot.__formPreviewGeocoderBound = true;
                      // For member forms, set high z-index to ensure geocoder is visible above other elements
                      if(isMemberForm){
                        geocoderRoot.style.zIndex = '1000001';
                        geocoderRoot.style.position = 'relative';
                        const suggestions = geocoderRoot.querySelector('.suggestions');
                        if(suggestions){
                          suggestions.style.zIndex = '1000002';
                        }
                        // Also ensure container has proper positioning
                        geocoderContainer.style.position = 'relative';
                        geocoderContainer.style.zIndex = '1000000';
                      }
                      const handleFocusIn = ()=> setGeocoderActive(true);
                      const handleFocusOut = event => {
                        const nextTarget = event && event.relatedTarget;
                        if(!nextTarget || !geocoderRoot.contains(nextTarget)){
                          setGeocoderActive(false);
                        }
                      };
                      const handlePointerDown = (e) => {
                        setGeocoderActive(true);
                        // For member forms, prevent form closure
                        if(isMemberForm && e){
                          e.stopPropagation();
                          e.stopImmediatePropagation();
                        }
                      };
                      geocoderRoot.addEventListener('focusin', handleFocusIn);
                      geocoderRoot.addEventListener('focusout', handleFocusOut);
                      geocoderRoot.addEventListener('pointerdown', handlePointerDown);
                      // For member forms, prevent form closure when clicking geocoder suggestions
                      if(isMemberForm){
                        geocoderRoot.addEventListener('click', (e) => {
                          e.stopPropagation();
                          e.stopImmediatePropagation();
                        }, true);
                        const suggestionsWrapper = geocoderRoot.querySelector('.suggestions-wrapper');
                        if(suggestionsWrapper){
                          suggestionsWrapper.addEventListener('click', (e) => {
                            e.stopPropagation();
                            e.stopImmediatePropagation();
                          }, true);
                          suggestionsWrapper.addEventListener('pointerdown', (e) => {
                            e.stopPropagation();
                            e.stopImmediatePropagation();
                          }, true);
                          // Also handle individual suggestion items to prevent form closure
                          const handleSuggestionEvents = (e) => {
                            e.stopPropagation();
                            e.stopImmediatePropagation();
                          };
                          // Use MutationObserver to catch dynamically added suggestions
                          const suggestionObserver = new MutationObserver(() => {
                            const suggestionItems = suggestionsWrapper.querySelectorAll('.suggestions > li, .suggestions > div, li[role="option"]');
                            suggestionItems.forEach(item => {
                              if(!item.__venueGeocoderBound){
                                item.__venueGeocoderBound = true;
                                item.addEventListener('click', handleSuggestionEvents, true);
                                item.addEventListener('pointerdown', handleSuggestionEvents, true);
                                item.addEventListener('mousedown', handleSuggestionEvents, true);
                              }
                            });
                          });
                          suggestionObserver.observe(suggestionsWrapper, { childList: true, subtree: true });
                          // Also handle existing items
                          const existingItems = suggestionsWrapper.querySelectorAll('.suggestions > li, .suggestions > div, li[role="option"]');
                          existingItems.forEach(item => {
                            item.__venueGeocoderBound = true;
                            item.addEventListener('click', handleSuggestionEvents, true);
                            item.addEventListener('pointerdown', handleSuggestionEvents, true);
                            item.addEventListener('mousedown', handleSuggestionEvents, true);
                          });
                        }
                      }
                    }
                    const geocoderInput = geocoderContainer.querySelector('input[type="text"]');
                    if(!geocoderInput){
                      createFallbackAddressInput();
                      return;
                    }
                    geocoderInput.placeholder = addressPlaceholder;
                    geocoderInput.setAttribute('aria-label', addressPlaceholder);
                    geocoderInput.dataset.venueIndex = String(venueIndex);
                    geocoderInput.value = venue.address || '';
                    geocoderInputRef = geocoderInput;
                    geocoderInput.addEventListener('blur', ()=>{
                      const nextValue = geocoderInput.value || '';
                      if(venue.address !== nextValue){
                        venue.address = nextValue;
                        syncToPreviewField();
                        safeNotifyChange();
                      }
                    });
                    // For member forms, prevent form closure when interacting with geocoder input
                    if(isMemberForm){
                      geocoderInput.addEventListener('click', (e) => {
                        e.stopPropagation();
                        e.stopImmediatePropagation();
                      }, true);
                      geocoderInput.addEventListener('pointerdown', (e) => {
                        e.stopPropagation();
                        e.stopImmediatePropagation();
                      }, true);
                      geocoderInput.addEventListener('input', (e) => {
                        e.stopPropagation();
                        e.stopImmediatePropagation();
                      }, true);
                    }
                    geocoder.on('results', ()=> setGeocoderActive(true));
                    geocoder.on('result', event => {
                      // For member forms, stop propagation to prevent form closure
                      if(isMemberForm && event && event.originalEvent){
                        event.originalEvent.stopPropagation();
                        event.originalEvent.stopImmediatePropagation();
                      }
                      const result = event && event.result;
                      if(result){
                        const shouldUpdateName = !(venue.name && venue.name.trim());
                        applyFeatureToVenue(result, { updateName: shouldUpdateName });
                        updateNameSuggestions([result]);
                      }
                      setGeocoderActive(false);
                    });
                    geocoder.on('clear', ()=>{
                      venue.address = '';
                      venue.location = null;
                      clearNameSuggestions();
                      safeNotifyChange();
                      setGeocoderActive(false);
                    });
                    // Switch to display when clicking outside
                    geocoderInput.addEventListener('blur', () => {
                      setTimeout(showVenueDisplay, 150);
                    });
                    geocoder.on('error', ()=> setGeocoderActive(false));
                  };
                  attachGeocoder();
                } else {
                  createFallbackAddressInput();
                }

                const sessionContainer = document.createElement('div');
                sessionContainer.className = 'session-list';
                venue.sessions.forEach((session, sessionIndex)=>{
                  const sessionCard = document.createElement('div');
                  sessionCard.className = 'session-card';

                  const dateRow = document.createElement('div');
                  dateRow.className = 'session-date-row';
                  const datePlaceholder = `Session Date ${sessionIndex + 1}`;
                  const dateInput = document.createElement('input');
                  dateInput.type = 'text';
                  dateInput.readOnly = true;
                  dateInput.className = 'session-date-input';
                  dateInput.placeholder = datePlaceholder;
                  dateInput.setAttribute('aria-label', datePlaceholder);
                  setSessionDateInputValue(dateInput, session);
                  dateInput.dataset.venueIndex = String(venueIndex);
                  dateInput.dataset.sessionIndex = String(sessionIndex);
                  dateInput.setAttribute('role', 'button');
                  dateInput.setAttribute('aria-haspopup', 'region');
                  const dateInputWrapper = document.createElement('div');
                  dateInputWrapper.className = 'session-date-input-wrapper';
                  dateInputWrapper.appendChild(dateInput);
                  const dropdownIndicator = document.createElement('span');
                  dropdownIndicator.className = 'session-date-dropdown-indicator';
                  dropdownIndicator.setAttribute('aria-hidden', 'true');
                  dropdownIndicator.textContent = '';
                  dateInputWrapper.appendChild(dropdownIndicator);
                  dateRow.appendChild(dateInputWrapper);

                  const dateActions = document.createElement('div');
                  dateActions.className = 'session-date-actions';
                  const openDatePickerBtn = document.createElement('button');
                  openDatePickerBtn.type = 'button';
                  openDatePickerBtn.className = 'tiny';
                  openDatePickerBtn.textContent = '+';
                  openDatePickerBtn.setAttribute('aria-label', 'Select Session Dates');
                  openDatePickerBtn.setAttribute('aria-haspopup', 'dialog');
                  dateActions.appendChild(openDatePickerBtn);
                  const removeDateBtn = createActionButton('-', 'Remove Session Date', ()=> removeSession(venue, venueIndex, sessionIndex));
                  if(venue.sessions.length <= 1){
                    removeDateBtn.disabled = true;
                    removeDateBtn.setAttribute('aria-disabled', 'true');
                  } else {
                    removeDateBtn.disabled = false;
                    removeDateBtn.removeAttribute('aria-disabled');
                  }
                  dateActions.appendChild(removeDateBtn);
                  dateRow.appendChild(dateActions);
                  sessionCard.appendChild(dateRow);
                  const datePickerControls = setupDatePicker(dateInput, venue, session, venueIndex, sessionIndex, { trigger: openDatePickerBtn });

                  const sessionDetails = document.createElement('div');
                  sessionDetails.className = 'session-details';
                  const detailsId = `session-details-${venueIndex}-${sessionIndex}`;
                  sessionDetails.id = detailsId;
                  // Automatically expand session date 1 (first session) by default
                  if(sessionIndex === 0 && !openSessions.has(session)){
                    openSessions.add(session);
                  }
                  const isOpen = openSessions.has(session);
                  sessionDetails.hidden = !isOpen;
                  dateInputWrapper.classList.toggle('is-open', isOpen);
                  dateInput.setAttribute('aria-expanded', isOpen ? 'true' : 'false');
                  dateInput.setAttribute('aria-controls', detailsId);

                  const syncSessionVisibility = (targetDetails, shouldOpen)=>{
                    if(!targetDetails) return;
                    const parentCard = targetDetails.closest('.session-card');
                    const wrapperNode = parentCard ? parentCard.querySelector('.session-date-input-wrapper') : null;
                    const inputNode = parentCard ? parentCard.querySelector('.session-date-input') : null;
                    targetDetails.hidden = !shouldOpen;
                    if(wrapperNode){
                      wrapperNode.classList.toggle('is-open', shouldOpen);
                    }
                    if(inputNode){
                      inputNode.setAttribute('aria-expanded', shouldOpen ? 'true' : 'false');
                    }
                  };

                  dateInput.addEventListener('click', event => {
                    const isFirstSessionBlank = sessionIndex === 0 && (!session || typeof session.date !== 'string' || session.date.trim() === '');
                    if(isFirstSessionBlank && datePickerControls && typeof datePickerControls.open === 'function'){
                      event.preventDefault();
                      event.stopPropagation();
                      datePickerControls.open();
                      return;
                    }
                    closeAllPickers();
                    const currentlyOpen = openSessions.has(session);
                    const nextShouldOpen = !currentlyOpen;
                    if(nextShouldOpen){
                      openSessions.add(session);
                    } else {
                      openSessions.delete(session);
                    }
                    syncSessionVisibility(sessionDetails, nextShouldOpen);
                  });
                  dateInput.addEventListener('keydown', event => {
                    if(event.key === 'Enter' || event.key === ' ' || event.key === 'Spacebar'){
                      const isFirstSessionBlank = sessionIndex === 0 && (!session || typeof session.date !== 'string' || session.date.trim() === '');
                      if(isFirstSessionBlank && datePickerControls && typeof datePickerControls.open === 'function'){
                        event.preventDefault();
                        datePickerControls.open();
                        return;
                      }
                      event.preventDefault();
                      closeAllPickers();
                      const currentlyOpen = openSessions.has(session);
                      const nextShouldOpen = !currentlyOpen;
                      if(nextShouldOpen){
                        openSessions.add(session);
                      } else {
                        openSessions.delete(session);
                      }
                      syncSessionVisibility(sessionDetails, nextShouldOpen);
                    }
                  });
                  sessionCard.appendChild(sessionDetails);

                  const timesList = document.createElement('div');
                  timesList.className = 'session-times';
                  sessionDetails.appendChild(timesList);

                  session.session_times.forEach((timeObj, timeIndex)=>{
                    const isFirstSession = sessionIndex === 0;
                    const isFirstTimeSlot = timeIndex === 0;
                    if(isFirstTimeSlot){
                      timeObj.samePricingSourceIndex = 0;
                      if(isFirstSession){
                        timeObj.samePricingAsAbove = false;
                      } else if(typeof timeObj.samePricingAsAbove !== 'boolean'){
                        timeObj.samePricingAsAbove = true;
                      }
                    } else {
                      if(typeof timeObj.samePricingAsAbove !== 'boolean'){
                        timeObj.samePricingAsAbove = true;
                      }
                      if(!Number.isInteger(timeObj.samePricingSourceIndex) || timeObj.samePricingSourceIndex < 0){
                        timeObj.samePricingSourceIndex = 0;
                      }
                    }
                    const timeRow = document.createElement('div');
                    timeRow.className = 'session-time-row';

                    const computeTimeOrdinal = ()=>{
                      let ordinal = timeIndex + 1;
                      const currentDate = typeof session.date === 'string' ? session.date : '';
                      if(Array.isArray(venue.sessions) && currentDate){
                        for(let i = 0; i < sessionIndex; i++){
                          const compareSession = venue.sessions[i];
                          if(!compareSession || typeof compareSession.date !== 'string') continue;
                          if(compareSession.date !== currentDate) continue;
                          const compareTimes = Array.isArray(compareSession.session_times) ? compareSession.session_times.filter(Boolean) : [];
                          ordinal += Math.max(compareTimes.length, 1);
                        }
                      }
                      return ordinal;
                    };
                    const timeOrdinal = computeTimeOrdinal();
                    const timePlaceholder = `Session Time ${timeOrdinal} (24 hr clock)`;
                    const timeInput = document.createElement('input');
                    timeInput.type = 'text';
                    timeInput.className = 'session-time-input';
                    timeInput.placeholder = timePlaceholder;
                    timeInput.setAttribute('aria-label', timePlaceholder);
                    timeInput.inputMode = 'numeric';
                    timeInput.pattern = '([01]\\d|2[0-3]):[0-5]\\d';
                    timeInput.value = timeObj.time || '';
                    timeInput.dataset.venueIndex = String(venueIndex);
                    timeInput.dataset.sessionIndex = String(sessionIndex);
                    timeInput.dataset.timeIndex = String(timeIndex);
                    timeInput.addEventListener('input', ()=>{
                      const sanitized = sanitizeTimeInput(timeInput.value);
                      if(timeInput.value !== sanitized){
                        timeInput.value = sanitized;
                      }
                      timeInput.classList.remove('is-invalid');
                      setSessionDateInputValue(dateInput, session, sanitized);
                    });
                    timeInput.addEventListener('blur', ()=>{
                      commitTimeValue({ venue, venueIndex, sessionIndex, timeIndex, timeObj, input: timeInput });
                      resetSlotIfEmpty(venue, timeIndex);
                      updateSessionDateInputDisplay(venueIndex, sessionIndex);
                    });
                    timeRow.appendChild(timeInput);

                    const timeActions = document.createElement('div');
                    timeActions.className = 'session-time-actions';
                    timeActions.appendChild(createActionButton('+', 'Add Session Time', ()=> addTimeSlot(venue, venueIndex, sessionIndex, timeIndex)));
                    const removeTimeBtn = createActionButton('-', 'Remove Session Time', ()=> removeTimeSlot(venue, venueIndex, sessionIndex, timeIndex));
                    const timesForSession = Array.isArray(session.session_times) ? session.session_times.filter(Boolean) : [];
                    const canRemoveTime = timesForSession.length > 1;
                    if(!canRemoveTime){
                      removeTimeBtn.disabled = true;
                      removeTimeBtn.setAttribute('aria-disabled', 'true');
                    } else {
                      removeTimeBtn.disabled = false;
                      removeTimeBtn.removeAttribute('aria-disabled');
                    }
                    timeActions.appendChild(removeTimeBtn);
                    timeRow.appendChild(timeActions);

                    const seatingAreaList = document.createElement('div');
                    seatingAreaList.className = 'seating_area-list';
                    let samePricingRow = null;
                    let samePricingYesInput = null;
                    let samePricingNoInput = null;
                    const showSamePricingOptions = sessionIndex > 0 || timeIndex > 0;
                    
                    // Generate unique suffix once per time row to ensure IDs are unique across multiple venue ticketing fields
                    const uniqueSuffix = baseId ? baseId.replace(/[^a-zA-Z0-9]/g, '_') : `${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

                    const getSamePricingReference = ()=>{
                      if(timeIndex > 0){
                        const firstTime = session.session_times[0];
                        return firstTime && firstTime !== timeObj ? firstTime : null;
                      }
                      if(sessionIndex > 0){
                        const referenceSession = Array.isArray(venue.sessions) ? venue.sessions[0] : null;
                        if(referenceSession && referenceSession !== session){
                          const referenceTimes = Array.isArray(referenceSession.session_times) ? referenceSession.session_times : [];
                          const referenceByIndex = referenceTimes[timeIndex];
                          if(referenceByIndex && referenceByIndex !== timeObj){
                            return referenceByIndex;
                          }
                          const fallbackReference = referenceTimes[0];
                          if(fallbackReference && fallbackReference !== timeObj){
                            return fallbackReference;
                          }
                        }
                      }
                      const fallback = session.session_times[0];
                      return fallback && fallback !== timeObj ? fallback : null;
                    };

                    const initialReference = getSamePricingReference();
                    if(timeObj.samePricingAsAbove === true && initialReference && initialReference !== timeObj){
                      timeObj.samePricingSourceIndex = 0;
                      timeObj.seating_areas = initialReference.seating_areas;
                      if(sessionIndex > 0){
                        timeObj.tierAutofillLocked = true;
                      }
                    } else {
                      if(initialReference && timeObj.seating_areas === initialReference.seating_areas){
                        timeObj.seating_areas = initialReference.seating_areas.map(cloneVenueSessionSeatingArea);
                      }
                      if(!Array.isArray(timeObj.seating_areas) || timeObj.seating_areas.length === 0){
                        timeObj.seating_areas = [venueSessionCreateSeatingArea()];
                      }
                      if(sessionIndex > 0 && timeObj.samePricingAsAbove !== true){
                        timeObj.tierAutofillLocked = false;
                      }
                    }

                    const updateSamePricingUI = ()=>{
                      const referenceTime = getSamePricingReference();
                      const isSamePricing = showSamePricingOptions && referenceTime && referenceTime !== timeObj && timeObj.samePricingAsAbove === true;
                      seatingAreaList.hidden = isSamePricing;
                      seatingAreaList.style.display = isSamePricing ? 'none' : '';
                      timeRow.classList.toggle('has-same-pricing', isSamePricing);
                      if(samePricingRow){
                        samePricingRow.hidden = !showSamePricingOptions;
                        samePricingRow.style.display = showSamePricingOptions ? '' : 'none';
                      }
                      if(samePricingYesInput){
                        samePricingYesInput.checked = showSamePricingOptions && timeObj.samePricingAsAbove === true;
                      }
                      if(samePricingNoInput){
                        samePricingNoInput.checked = showSamePricingOptions && timeObj.samePricingAsAbove !== true;
                      }
                    };

                    const populateSeatingAreaList = ()=>{
                      seatingAreaList.innerHTML = '';
                      timeObj.seating_areas.forEach((seatingArea, seatingAreaIndex)=>{
                        const seatingAreaCard = document.createElement('div');
                        seatingAreaCard.className = 'session-pricing-card';

                        const seatingAreaPlaceholder = 'eg. General, Stalls, Balcony';
                        const seatingLabelText = `Seating Area ${seatingAreaIndex + 1}`;
                        const seatingLabel = document.createElement('label');
                        seatingLabel.className = 'seating_area-label';
                        seatingLabel.textContent = seatingLabelText;
                        const seatingInputId = `seating_area-${uniqueSuffix}-${venueIndex}-${sessionIndex}-${timeIndex}-${seatingAreaIndex}`;
                        seatingLabel.setAttribute('for', seatingInputId);
                        const seatingAreaInput = document.createElement('input');
                        seatingAreaInput.type = 'text';
                        seatingAreaInput.className = 'seating_area-input';
                        seatingAreaInput.placeholder = seatingAreaPlaceholder;
                        seatingAreaInput.setAttribute('aria-label', seatingLabelText);
                        seatingAreaInput.id = seatingInputId;
                        seatingAreaInput.value = seatingArea.name || '';
                        seatingAreaInput.dataset.venueIndex = String(venueIndex);
                        seatingAreaInput.dataset.sessionIndex = String(sessionIndex);
                        seatingAreaInput.dataset.timeIndex = String(timeIndex);
                        seatingAreaInput.dataset.seatingAreaIndex = String(seatingAreaIndex);
                        protectInputMaxLength(seatingAreaInput, getFieldLimitsByKey('seating-area').max_length);
                        seatingAreaInput.addEventListener('input', ()=>{
                          const previous = typeof seatingArea.name === 'string' ? seatingArea.name : '';
                          const nextValue = seatingAreaInput.value;
                          seatingArea.name = nextValue;
                          if(sessionIndex === 0 && !isSessionMirrorLocked(venue) && previous !== nextValue){
                            forEachOtherSession(venue, (otherSess, otherIndex)=>{
                              const otherTime = otherSess.session_times[timeIndex] || (otherSess.session_times[timeIndex] = venueSessionCreateSessionTime());
                              const otherSeatingAreas = Array.isArray(otherTime.seating_areas) ? otherTime.seating_areas : (otherTime.seating_areas = [venueSessionCreateSeatingArea()]);
                              while(otherSeatingAreas.length <= seatingAreaIndex){
                                otherSeatingAreas.push(venueSessionCreateSeatingArea());
                              }
                              const otherSeatingArea = otherSeatingAreas[seatingAreaIndex];
                              if(otherSeatingArea){
                                otherSeatingArea.name = nextValue;
                                const selector = `.seating_area-input[data-venue-index="${venueIndex}"][data-session-index="${otherIndex}"][data-time-index="${timeIndex}"][data-seating-area-index="${seatingAreaIndex}"]`;
                                const peer = editor.querySelector(selector);
                                if(peer){
                                  peer.value = nextValue;
                                }
                              }
                            });
                          } else if(sessionIndex > 0 && previous !== nextValue){
                            lockSessionMirror(venue);
                          }
                          safeNotifyChange();
                        });
                        seatingAreaCard.appendChild(seatingLabel);
                        seatingAreaCard.appendChild(seatingAreaInput);

                        const seatingAreaActions = document.createElement('div');
                        seatingAreaActions.className = 'seating-area-actions';
                        seatingAreaActions.appendChild(createActionButton('+', 'Add Seating Area', ()=> addSeatingArea(venue, venueIndex, sessionIndex, timeIndex, seatingAreaIndex)));
                        const removeSeatingAreaBtn = createActionButton('-', 'Remove Seating Area', ()=> removeSeatingArea(venue, venueIndex, sessionIndex, timeIndex, seatingAreaIndex, seatingArea));
                        if(timeObj.seating_areas.length <= 1){
                          removeSeatingAreaBtn.disabled = true;
                          removeSeatingAreaBtn.setAttribute('aria-disabled', 'true');
                        } else {
                          removeSeatingAreaBtn.disabled = false;
                          removeSeatingAreaBtn.removeAttribute('aria-disabled');
                        }
                        seatingAreaActions.appendChild(removeSeatingAreaBtn);
                        seatingAreaCard.appendChild(seatingAreaActions);

                        const tierList = document.createElement('div');
                        tierList.className = 'pricing_tier-list';
                        seatingArea.pricing_tiers.forEach((tier, tierIndex)=>{
                          const tierRow = document.createElement('div');
                          tierRow.className = 'tier-row';

                          const tierPlaceholder = 'eg. Child, Student, Adult';
                          const tierLabelText = `Pricing Tier ${tierIndex + 1}`;
                          const tierLabel = document.createElement('label');
                          tierLabel.className = 'pricing_tier-label';
                          tierLabel.textContent = tierLabelText;
                          // Use same unique suffix for consistency
                          const tierInputId = `pricing_tier-${uniqueSuffix}-${venueIndex}-${sessionIndex}-${timeIndex}-${seatingAreaIndex}-${tierIndex}`;
                          tierLabel.setAttribute('for', tierInputId);
                          const tierInput = document.createElement('input');
                          tierInput.type = 'text';
                          tierInput.className = 'pricing_tier-input';
                          tierInput.placeholder = tierPlaceholder;
                          tierInput.setAttribute('aria-label', tierLabelText);
                          tierInput.id = tierInputId;
                          tierInput.value = tier.name || '';
                          tierInput.dataset.venueIndex = String(venueIndex);
                          tierInput.dataset.sessionIndex = String(sessionIndex);
                          tierInput.dataset.timeIndex = String(timeIndex);
                          tierInput.dataset.seatingAreaIndex = String(seatingAreaIndex);
                          tierInput.dataset.tierIndex = String(tierIndex);
                          protectInputMaxLength(tierInput, getFieldLimitsByKey('pricing-tier').max_length);
                          tierRow.appendChild(tierLabel);
                          tierInput.addEventListener('input', ()=>{
                            const previous = typeof tier.name === 'string' ? tier.name : '';
                            const nextValue = tierInput.value;
                            tier.name = nextValue;
                            let syncedFromTemplate = false;
                            if(seatingAreaIndex === 0){
                              syncedFromTemplate = syncTiersFromTemplate(timeObj);
                              if(!timeObj.tierAutofillLocked){
                                const seatingAreas = Array.isArray(timeObj.seating_areas) ? timeObj.seating_areas : [];
                                for(let otherSeatingAreaIndex = 1; otherSeatingAreaIndex < seatingAreas.length; otherSeatingAreaIndex++){
                                  const selector = `.pricing_tier-input[data-venue-index="${venueIndex}"][data-session-index="${sessionIndex}"][data-time-index="${timeIndex}"][data-seating-area-index="${otherSeatingAreaIndex}"][data-tier-index="${tierIndex}"]`;
                                  const peer = editor.querySelector(selector);
                                  if(peer){
                                    peer.value = nextValue;
                                  }
                                }
                              }
                            }
                            if(sessionIndex === 0 && !isSessionMirrorLocked(venue) && previous !== nextValue){
                              forEachOtherSession(venue, (otherSess, otherIndex)=>{
                                const otherTime = otherSess.session_times[timeIndex] || (otherSess.session_times[timeIndex] = venueSessionCreateSessionTime());
                                const otherSeatingAreas = Array.isArray(otherTime.seating_areas) ? otherTime.seating_areas : (otherTime.seating_areas = [venueSessionCreateSeatingArea()]);
                                while(otherSeatingAreas.length <= seatingAreaIndex){
                                  otherSeatingAreas.push(venueSessionCreateSeatingArea());
                                }
                                const otherSeatingArea = otherSeatingAreas[seatingAreaIndex];
                                if(!otherSeatingArea) return;
                                const otherTiers = Array.isArray(otherSeatingArea.pricing_tiers) ? otherSeatingArea.pricing_tiers : (otherSeatingArea.pricing_tiers = [venueSessionCreatePricingTier()]);
                                while(otherTiers.length <= tierIndex){
                                  otherTiers.push(venueSessionCreatePricingTier());
                                }
                                const otherTier = otherTiers[tierIndex];
                                if(otherTier){
                                  otherTier.name = nextValue;
                                  const selector = `.pricing_tier-input[data-venue-index="${venueIndex}"][data-session-index="${otherIndex}"][data-time-index="${timeIndex}"][data-seating-area-index="${seatingAreaIndex}"][data-tier-index="${tierIndex}"]`;
                                  const peer = editor.querySelector(selector);
                                  if(peer){
                                    peer.value = nextValue;
                                  }
                                }
                              });
                            } else if(sessionIndex > 0 && previous !== nextValue){
                              lockSessionMirror(venue);
                            }
                            const locked = lockTierAutofillIfNeeded(timeObj, seatingAreaIndex);
                            if(previous !== nextValue || locked || syncedFromTemplate){
                              safeNotifyChange();
                            }
                          });
                          tierRow.appendChild(tierInput);

                          const tierActions = document.createElement('div');
                          tierActions.className = 'tier-actions';
                          tierActions.appendChild(createActionButton('+', 'Add Tier', ()=> addTier(venue, venueIndex, sessionIndex, timeIndex, seatingAreaIndex, tierIndex)));
                          const removeTierBtn = createActionButton('-', 'Remove Tier', ()=> removeTier(venue, venueIndex, sessionIndex, timeIndex, seatingAreaIndex, tierIndex, seatingArea, tier));
                          if(seatingArea.pricing_tiers.length <= 1){
                            removeTierBtn.disabled = true;
                            removeTierBtn.setAttribute('aria-disabled', 'true');
                          } else {
                            removeTierBtn.disabled = false;
                            removeTierBtn.removeAttribute('aria-disabled');
                          }
                          tierActions.appendChild(removeTierBtn);
                          tierRow.appendChild(tierActions);

                          const priceRow = document.createElement('div');
                          priceRow.className = 'tier-price-row';
                          const currencyWrapper = document.createElement('div');
                          currencyWrapper.className = 'options-dropdown';
                          const currencyMenuBtn = document.createElement('button');
                          currencyMenuBtn.type = 'button';
                          currencyMenuBtn.className = 'item-pricing-currency';
                          currencyMenuBtn.setAttribute('aria-haspopup', 'true');
                          currencyMenuBtn.setAttribute('aria-expanded', 'false');
                          const currencyMenuId = `session-currency-${venueIndex}-${sessionIndex}-${timeIndex}-${seatingAreaIndex}-${tierIndex}`;
                          currencyMenuBtn.setAttribute('aria-controls', currencyMenuId);
                          const existingCurrency = typeof tier.currency === 'string' && tier.currency.trim() !== '' ? tier.currency.trim() : 'USD';
                          const existingCountryCode = findCurrencyCountryCode(existingCurrency);
                          const currencyArrow = document.createElement('span');
                          currencyArrow.className = 'dropdown-arrow';
                          currencyArrow.setAttribute('aria-hidden', 'true');
                          currencyMenuBtn.innerHTML = getCurrencyButtonHTML(existingCountryCode, existingCurrency);
                          currencyMenuBtn.appendChild(currencyArrow);
                          currencyMenuBtn.dataset.value = existingCurrency;
                          // Set default currency in data model if not already set
                          if (!tier.currency || tier.currency.trim() === '') {
                            tier.currency = 'USD';
                          }
                          currencyMenuBtn.dataset.venueIndex = String(venueIndex);
                          currencyMenuBtn.dataset.sessionIndex = String(sessionIndex);
                          currencyMenuBtn.dataset.timeIndex = String(timeIndex);
                          currencyMenuBtn.dataset.seatingAreaIndex = String(seatingAreaIndex);
                          currencyMenuBtn.dataset.tierIndex = String(tierIndex);
                          const currencyMenu = document.createElement('div');
                          currencyMenu.className = 'options-menu';
                          currencyMenu.id = currencyMenuId;
                          currencyMenu.hidden = true;
                          // No placeholder needed - USD is always the default
                          // Populate currency options with full labels
                          getCurrencyOptions().forEach(opt => {
                            const { countryCode, currencyCode } = parseCurrencyValue(opt.value);
                            const optionBtn = document.createElement('button');
                            optionBtn.type = 'button';
                            optionBtn.className = 'menu-option';
                            optionBtn.innerHTML = getCurrencyDisplayText(opt);
                            optionBtn.dataset.value = currencyCode;
                            optionBtn.dataset.countryCode = countryCode || '';
                            optionBtn.dataset.label = opt.label || '';
                            optionBtn.addEventListener('click', (e) => {
                              e.stopPropagation();
                              currencyMenuBtn.innerHTML = getCurrencyButtonHTML(countryCode, currencyCode);
                              currencyMenuBtn.appendChild(currencyArrow);
                              currencyMenuBtn.dataset.value = currencyCode;
                              currencyMenu.hidden = true;
                              currencyMenuBtn.setAttribute('aria-expanded', 'false');
                              const nextCurrency = currencyCode.trim();
                              const previousCurrency = typeof tier.currency === 'string' ? tier.currency : '';
                              tier.currency = nextCurrency;
                              const shouldClearPrice = nextCurrency === '';
                              const priceCleared = updatePriceState({ clearPrice: shouldClearPrice, sanitize: true });
                              const propagated = applyCurrencyToVenueData(venue, nextCurrency, {
                                sourceTier: tier,
                                clearPrices: shouldClearPrice
                              });
                              if(sessionIndex > 0 && previousCurrency !== nextCurrency){
                                lockSessionMirror(venue);
                              }
                              if(previousCurrency !== nextCurrency || priceCleared || propagated){
                                markAutoChange();
                              }
                            });
                            currencyMenu.appendChild(optionBtn);
                          });
                          currencyMenuBtn.addEventListener('click', (e) => {
                            e.stopPropagation();
                            const open = !currencyMenu.hasAttribute('hidden');
                            if(open){
                              currencyMenu.hidden = true;
                              currencyMenuBtn.setAttribute('aria-expanded', 'false');
                            } else {
                              // Ensure currency options are populated when menu opens
                              const existingOptions = currencyMenu.querySelectorAll('.menu-option[data-value]:not([data-value=""])');
                              if(existingOptions.length === 0){
                                getCurrencyOptions().forEach(opt => {
                                  const { countryCode, currencyCode } = parseCurrencyValue(opt.value);
                                  // Check if option already exists
                                  const existing = currencyMenu.querySelector(`.menu-option[data-value="${currencyCode}"]`);
                                  if(!existing){
                                    const optionBtn = document.createElement('button');
                                    optionBtn.type = 'button';
                                    optionBtn.className = 'menu-option';
                                    optionBtn.innerHTML = getCurrencyDisplayText(opt);
                                    optionBtn.dataset.value = currencyCode;
                                    optionBtn.dataset.countryCode = countryCode || '';
                                    optionBtn.dataset.label = opt.label || '';
                                    optionBtn.addEventListener('click', (e) => {
                                      e.stopPropagation();
                                      currencyMenuBtn.innerHTML = getCurrencyButtonHTML(countryCode, currencyCode);
                                      currencyMenuBtn.appendChild(currencyArrow);
                                      currencyMenuBtn.dataset.value = currencyCode;
                                      currencyMenu.hidden = true;
                                      currencyMenuBtn.setAttribute('aria-expanded', 'false');
                                      const nextCurrency = currencyCode.trim();
                                      const previousCurrency = typeof tier.currency === 'string' ? tier.currency : '';
                                      tier.currency = nextCurrency;
                                      const shouldClearPrice = nextCurrency === '';
                                      const priceCleared = updatePriceState({ clearPrice: shouldClearPrice, sanitize: true });
                                      const propagated = applyCurrencyToVenueData(venue, nextCurrency, {
                                        sourceTier: tier,
                                        clearPrices: shouldClearPrice
                                      });
                                      if(sessionIndex > 0 && previousCurrency !== nextCurrency){
                                        lockSessionMirror(venue);
                                      }
                                      if(previousCurrency !== nextCurrency || priceCleared || propagated){
                                        markAutoChange();
                                      }
                                    });
                                    currencyMenu.appendChild(optionBtn);
                                  }
                                });
                              }
                              currencyMenu.hidden = false;
                              currencyMenuBtn.setAttribute('aria-expanded', 'true');
                              
                              // Setup keyboard navigation for currency dropdown
                              const cleanupKeyboardNav = setupCurrencyMenuKeyboardNav(currencyMenu, () => {
                                currencyMenu.hidden = true;
                                currencyMenuBtn.setAttribute('aria-expanded', 'false');
                              });
                              
                              const outsideHandler = (ev) => {
                                if(!currencyWrapper.contains(ev.target)){
                                  currencyMenu.hidden = true;
                                  currencyMenuBtn.setAttribute('aria-expanded', 'false');
                                  cleanupKeyboardNav();
                                  document.removeEventListener('click', outsideHandler);
                                  document.removeEventListener('pointerdown', outsideHandler);
                                }
                              };
                              setTimeout(() => {
                                document.addEventListener('click', outsideHandler);
                                document.addEventListener('pointerdown', outsideHandler);
                              }, 0);
                            }
                          });
                          currencyMenu.addEventListener('click', (e) => e.stopPropagation());
                          currencyWrapper.appendChild(currencyMenuBtn);
                          currencyWrapper.appendChild(currencyMenu);
                          const currencySelect = currencyMenuBtn; // Keep reference for hasCurrencySelected
                          priceRow.appendChild(currencyWrapper);

                          const priceInput = document.createElement('input');
                          priceInput.type = 'text';
                          priceInput.inputMode = 'decimal';
                          priceInput.pattern = '[0-9]+([\.,][0-9]{0,2})?';
                          priceInput.className = 'session-price-input';
                          priceInput.placeholder = '0.00';
                          const sanitizedInitialPrice = sanitizeSessionPriceValue(tier.price || '');
                          const formattedInitialPrice = formatSessionPriceValue(sanitizedInitialPrice);
                          if(typeof tier.price !== 'string' || tier.price !== formattedInitialPrice){
                            tier.price = formattedInitialPrice;
                            markAutoChange();
                          }
                          priceInput.value = formattedInitialPrice;
                          priceInput.dataset.venueIndex = String(venueIndex);
                          priceInput.dataset.sessionIndex = String(sessionIndex);
                          priceInput.dataset.timeIndex = String(timeIndex);
                          priceInput.dataset.seatingAreaIndex = String(seatingAreaIndex);
                          priceInput.dataset.tierIndex = String(tierIndex);

                          const hasCurrencySelected = ()=> (currencyMenuBtn.dataset.value || '').trim() !== '';

                          const updatePriceState = (options = {})=>{
                            const opts = options || {};
                            if(hasCurrencySelected()){
                              priceInput.readOnly = false;
                              priceInput.classList.remove('is-awaiting-currency');
                              priceInput.removeAttribute('aria-disabled');
                              if(opts.sanitize !== false){
                                const sanitized = sanitizeSessionPriceValue(priceInput.value);
                                if(priceInput.value !== sanitized){
                                  priceInput.value = sanitized;
                                }
                              }
                              return false;
                            }
                            priceInput.readOnly = true;
                            priceInput.classList.add('is-awaiting-currency');
                            priceInput.setAttribute('aria-disabled', 'true');
                            let priceChanged = false;
                            if(opts.clearPrice){
                              if(priceInput.value !== ''){
                                priceInput.value = '';
                              }
                              if(tier.price){
                                tier.price = '';
                                priceChanged = true;
                              }
                            }
                            return priceChanged;
                          };

                          const commitPriceValue = ()=>{
                            let shouldNotify = false;
                            let shouldLock = false;
                            const previous = typeof tier.price === 'string' ? tier.price : '';
                            if(!hasCurrencySelected()){
                              const cleared = updatePriceState({ clearPrice: true, sanitize: false });
                              if(cleared){
                                tier.price = '';
                                shouldNotify = true;
                                shouldLock = true;
                              }
                            } else {
                              const formattedPrice = formatSessionPriceValue(priceInput.value);
                              if(priceInput.value !== formattedPrice){
                                priceInput.value = formattedPrice;
                              }
                              if(previous !== formattedPrice){
                                tier.price = formattedPrice;
                                shouldNotify = true;
                                shouldLock = true;
                              }
                            }
                            if(sessionIndex === 0 && !isSessionMirrorLocked(venue) && previous !== tier.price){
                              const nextValue = tier.price || '';
                              forEachOtherSession(venue, (otherSess, otherIndex)=>{
                                const otherTime = otherSess.session_times[timeIndex] || (otherSess.session_times[timeIndex] = venueSessionCreateSessionTime());
                                const otherSeatingAreas = Array.isArray(otherTime.seating_areas) ? otherTime.seating_areas : (otherTime.seating_areas = [venueSessionCreateSeatingArea()]);
                                while(otherSeatingAreas.length <= seatingAreaIndex){
                                  otherSeatingAreas.push(venueSessionCreateSeatingArea());
                                }
                                const otherSeatingArea = otherSeatingAreas[seatingAreaIndex];
                                if(!otherSeatingArea) return;
                                const otherTiers = Array.isArray(otherSeatingArea.pricing_tiers) ? otherSeatingArea.pricing_tiers : (otherSeatingArea.pricing_tiers = [venueSessionCreatePricingTier()]);
                                while(otherTiers.length <= tierIndex){
                                  otherTiers.push(venueSessionCreatePricingTier());
                                }
                                const otherTier = otherTiers[tierIndex];
                                if(!otherTier) return;
                                otherTier.price = nextValue;
                                const selector = `.session-price-input[data-venue-index="${venueIndex}"][data-session-index="${otherIndex}"][data-time-index="${timeIndex}"][data-seating-area-index="${seatingAreaIndex}"][data-tier-index="${tierIndex}"]`;
                                const peer = editor.querySelector(selector);
                                if(peer){
                                  peer.value = nextValue;
                                }
                              });
                            } else if(sessionIndex > 0 && previous !== tier.price){
                              lockSessionMirror(venue);
                            }
                            if(shouldLock && lockTierAutofillIfNeeded(timeObj, seatingAreaIndex)){
                              shouldNotify = true;
                            }
                            if(shouldNotify){
                              safeNotifyChange();
                            }
                          };

                          const blockPriceAccess = event => {
                            if(hasCurrencySelected()) return false;
                            if(event && event.type === 'pointerdown' && event.button !== 0) return false;
                            if(event && typeof event.preventDefault === 'function'){
                              event.preventDefault();
                            }
                            if(event && typeof event.stopPropagation === 'function'){
                              event.stopPropagation();
                            }
                            if(typeof priceInput.blur === 'function'){
                              requestAnimationFrame(()=>{
                                try{ priceInput.blur(); }catch(err){}
                              });
                            }
                            showCurrencyAlert(priceInput);
                            return true;
                          };

                          currencySelect.addEventListener('change', ()=>{
                            const nextCurrency = currencySelect.value.trim();
                            const previousCurrency = typeof tier.currency === 'string' ? tier.currency : '';
                            tier.currency = nextCurrency;
                            const shouldClearPrice = nextCurrency === '';
                            const priceCleared = updatePriceState({ clearPrice: shouldClearPrice, sanitize: true });
                            const propagated = applyCurrencyToVenueData(venue, nextCurrency, {
                              sourceTier: tier,
                              clearPrices: shouldClearPrice
                            });
                            if(sessionIndex > 0 && previousCurrency !== nextCurrency){
                              lockSessionMirror(venue);
                            }
                            setVenueCurrencyState(venue, nextCurrency);
                            let notifyNeeded = (previousCurrency !== nextCurrency) || priceCleared || propagated;
                            if(lockTierAutofillIfNeeded(timeObj, seatingAreaIndex)){
                              notifyNeeded = true;
                            }
                            if(notifyNeeded){
                              safeNotifyChange();
                            }
                            renderVenues({ type: 'price', venueIndex, sessionIndex, timeIndex, seatingAreaIndex, tierIndex });
                          });

                          priceInput.addEventListener('beforeinput', event => {
                            if(hasCurrencySelected()){
                              const data = event && event.data;
                              if(typeof data === 'string' && /[^0-9.,]/.test(data)){
                                event.preventDefault();
                              }
                              return;
                            }
                            if(event){
                              event.preventDefault();
                            }
                            showCurrencyAlert(priceInput);
                          });
                          priceInput.addEventListener('pointerdown', blockPriceAccess);
                          priceInput.addEventListener('focus', blockPriceAccess);
                          priceInput.addEventListener('keydown', event => {
                            if(event.key === 'Tab' || event.key === 'Shift') return;
                            blockPriceAccess(event);
                          });
                          priceInput.addEventListener('input', ()=>{
                            if(!hasCurrencySelected()) return;
                            const rawValue = priceInput.value;
                            const sanitized = sanitizeSessionPriceValue(rawValue);
                            if(rawValue !== sanitized){
                              const start = priceInput.selectionStart;
                              const end = priceInput.selectionEnd;
                              priceInput.value = sanitized;
                              if(typeof priceInput.setSelectionRange === 'function' && start != null && end != null){
                                const adjustment = rawValue.length - sanitized.length;
                                const nextStart = Math.max(0, start - adjustment);
                                const nextEnd = Math.max(0, end - adjustment);
                                priceInput.setSelectionRange(nextStart, nextEnd);
                              }
                            }
                          });
                          priceInput.addEventListener('blur', commitPriceValue);
                          priceInput.addEventListener('change', commitPriceValue);

                          updatePriceState({ clearPrice: false, sanitize: false });
                          priceRow.appendChild(priceInput);
                          tierRow.appendChild(priceRow);
                          tierList.appendChild(tierRow);
                        });
                        seatingAreaCard.appendChild(tierList);
                        seatingAreaList.appendChild(seatingAreaCard);
                      });
                    };

                    const handleSamePricingSelection = (shouldMatch)=>{
                      if(sessionIndex > 0){
                        lockSessionMirror(venue);
                      }
                      const referenceTime = getSamePricingReference();
                      const canApplyReference = shouldMatch && referenceTime && referenceTime !== timeObj;
                      if(canApplyReference){
                        timeObj.samePricingAsAbove = true;
                        timeObj.samePricingSourceIndex = 0;
                        timeObj.seating_areas = referenceTime.seating_areas;
                        timeObj.tierAutofillLocked = true;
                      } else {
                        timeObj.samePricingAsAbove = false;
                        timeObj.samePricingSourceIndex = 0;
                        if(referenceTime && timeObj.seating_areas === referenceTime.seating_areas){
                          timeObj.seating_areas = referenceTime.seating_areas.map(cloneVenueSessionSeatingArea);
                        }
                        if(!Array.isArray(timeObj.seating_areas) || timeObj.seating_areas.length === 0){
                          timeObj.seating_areas = [venueSessionCreateSeatingArea()];
                        }
                        timeObj.tierAutofillLocked = false;
                      }
                      safeNotifyChange();
                      populateSeatingAreaList();
                      updateSamePricingUI();
                    };

                    if(showSamePricingOptions){
                      samePricingRow = document.createElement('div');
                      samePricingRow.className = 'same-pricing-row';
                      const samePricingLabel = document.createElement('span');
                      samePricingLabel.className = 'same-pricing-label';
                      samePricingLabel.textContent = 'Same Pricing as Above';
                      samePricingRow.appendChild(samePricingLabel);

                      const samePricingOptions = document.createElement('div');
                      samePricingOptions.className = 'same-pricing-options';
                      const radioName = `same-pricing-${venueIndex}-${sessionIndex}-${timeIndex}`;

                      const yesLabel = document.createElement('label');
                      samePricingYesInput = document.createElement('input');
                      samePricingYesInput.type = 'radio';
                      samePricingYesInput.name = radioName;
                      samePricingYesInput.value = 'yes';
                      yesLabel.appendChild(samePricingYesInput);
                      const yesText = document.createElement('span');
                      yesText.textContent = 'Yes';
                      yesLabel.appendChild(yesText);
                      samePricingYesInput.addEventListener('change', ()=>{
                        if(samePricingYesInput.checked){
                          handleSamePricingSelection(true);
                        }
                      });
                      samePricingOptions.appendChild(yesLabel);

                      const noLabel = document.createElement('label');
                      samePricingNoInput = document.createElement('input');
                      samePricingNoInput.type = 'radio';
                      samePricingNoInput.name = radioName;
                      samePricingNoInput.value = 'no';
                      noLabel.appendChild(samePricingNoInput);
                      const noText = document.createElement('span');
                      noText.textContent = 'No';
                      noLabel.appendChild(noText);
                      samePricingNoInput.addEventListener('change', ()=>{
                        if(samePricingNoInput.checked){
                          handleSamePricingSelection(false);
                        }
                      });
                      samePricingOptions.appendChild(noLabel);

                      samePricingRow.appendChild(samePricingOptions);
                      timeRow.appendChild(samePricingRow);
                    }

                    timeRow.appendChild(seatingAreaList);
                    populateSeatingAreaList();
                    updateSamePricingUI();
                    timesList.appendChild(timeRow);
                  });
                  sessionContainer.appendChild(sessionCard);
                });
                venueCard.appendChild(sessionContainer);

              });
              if(shouldNotifyAfterRender){
                notifyFormbuilderChange();
              }
              applyFocus();
              
              // Update checkout prices when venue sessions change (for Events)
              if(window._checkoutPriceUpdaters && Array.isArray(window._checkoutPriceUpdaters)){
                window._checkoutPriceUpdaters.forEach(fn => {
                  try { fn(); } catch(e) { console.warn('Checkout price update failed:', e); }
                });
              }
            };

            renderVenues();
            return editor;
          };

          // Fields now come from backend via fieldsets, no hardcoded defaults

          const fields = Array.isArray(subFieldsMap[sub]) ? subFieldsMap[sub] : (subFieldsMap[sub] = []);

          const fieldsContainerState = setupFieldContainer(fieldsList, fields);

          const formPreviewBtn = document.createElement('button');
          formPreviewBtn.type = 'button';
          formPreviewBtn.className = 'form-btn';
          formPreviewBtn.setAttribute('aria-expanded', 'false');
          formPreviewBtn.setAttribute('aria-label', `Preview ${sub} form (sandbox)`);
          const formPreviewLabel = document.createElement('span');
          formPreviewLabel.textContent = 'Form Preview (Sandbox)';
          const formPreviewArrow = document.createElement('span');
          formPreviewArrow.className = 'dropdown-arrow';
          formPreviewArrow.setAttribute('aria-hidden', 'true');
          formPreviewBtn.append(formPreviewLabel, formPreviewArrow);

          const formPreviewContainer = document.createElement('div');
          formPreviewContainer.className = 'form-container';
          formPreviewContainer.dataset.sandbox = 'true';
          formPreviewContainer.hidden = true;
          const formPreviewFields = document.createElement('div');
          formPreviewFields.className = 'form-fields';
          formPreviewContainer.appendChild(formPreviewFields);
          const formPreviewId = `${subContentId}Preview`;
          formPreviewContainer.id = formPreviewId;
          formPreviewBtn.setAttribute('aria-controls', formPreviewId);

          // Expose buildVenueSessionPreview for use in member forms
          window.buildVenueSessionPreview = buildVenueSessionPreview;

          fieldsSection.append(fieldsList, addFieldBtnWrapper, formPreviewBtn, formPreviewContainer);

          formPreviewBtn.addEventListener('click', ()=>{
            const expanded = formPreviewBtn.getAttribute('aria-expanded') === 'true';
            const nextExpanded = !expanded;
            formPreviewBtn.setAttribute('aria-expanded', String(nextExpanded));
            formPreviewContainer.hidden = !nextExpanded;
            if(nextExpanded){
              renderForm({
                formFields: formPreviewFields,
                formId: formPreviewId,
                fields: fields,
                categoryName: c && c.name,
                subcategoryName: sub,
                fieldIdCounter: formPreviewFieldIdCounter,
                formLabel: 'Form Preview (Sandbox)',
                isSandbox: true
              });
            }
          });

          const createFieldEditUI = (safeField, {
            hostElement = null,
            summaryUpdater: initialSummaryUpdater = ()=>{}
          } = {}) => {
            // Declare actionFieldBtn early so it can be referenced in updateFieldEditorsByFieldset
            let actionFieldBtn = null;
            
            const editBtn = document.createElement('button');
            editBtn.type = 'button';
            editBtn.className = 'field-edit-btn';
            editBtn.setAttribute('aria-haspopup', 'true');
            editBtn.setAttribute('aria-expanded', 'false');
            editBtn.innerHTML = '<svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor" aria-hidden="true"><path d="M12.854 1.146a.5.5 0 0 1 .707 0l1.293 1.293a.5.5 0 0 1 0 .707l-8.939 8.939a.5.5 0 0 1-.233.131l-3.5.875a.5.5 0 0 1-.606-.606l.875-3.5a.5.5 0 0 1 .131-.233l8.939-8.939z"/><path d="M2.5 12.5V14h1.5l9-9-1.5-1.5-9 9z"/></svg>';

            const editPanel = document.createElement('div');
            editPanel.className = 'field-edit-panel';
            editPanel.hidden = true;

            const matchKey = safeField.fieldsetKey || safeField.key || safeField.type;
            
            // Get existing field types in this subcategory (excluding current field)
            const existingFieldsets = new Set();
            fields.forEach(f => {
              if(f !== safeField && (f.fieldsetKey || f.key)){
                existingFieldsets.add(f.fieldsetKey || f.key);
              }
            });
            
            const fieldsetWrapper = document.createElement('div');
            fieldsetWrapper.className = 'field-type-select-wrapper options-dropdown';
            
            const fieldsetMenuBtn = document.createElement('button');
            fieldsetMenuBtn.type = 'button';
            fieldsetMenuBtn.className = 'field-type-select menu-button--fieldset-list';
            fieldsetMenuBtn.setAttribute('aria-haspopup', 'true');
            fieldsetMenuBtn.setAttribute('aria-expanded', 'false');
            const menuId = `field-type-menu-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
            fieldsetMenuBtn.setAttribute('aria-controls', menuId);
            
            const selectedFieldType = FORM_FIELDSETS.find(opt => opt.value === matchKey);
            const defaultLabel = selectedFieldType 
              ? (resolveFieldsetDisplayName(selectedFieldType) || selectedFieldType.label || selectedFieldType.value || 'Select Fieldset...')
              : 'Select Fieldset...';
            fieldsetMenuBtn.textContent = defaultLabel;
            fieldsetMenuBtn.dataset.value = matchKey || '';
            
            const arrow = document.createElement('span');
            arrow.className = 'dropdown-arrow';
            arrow.setAttribute('aria-hidden', 'true');
            fieldsetMenuBtn.appendChild(arrow);
            
            const fieldsetMenu = document.createElement('div');
            fieldsetMenu.className = 'options-menu';
            fieldsetMenu.id = menuId;
            fieldsetMenu.hidden = true;
            
            if(!matchKey){
              const placeholderBtn = document.createElement('button');
              placeholderBtn.type = 'button';
              placeholderBtn.className = 'menu-option';
              placeholderBtn.textContent = 'Select Fieldset...';
              placeholderBtn.disabled = true;
              fieldsetMenu.appendChild(placeholderBtn);
            }
            
            FORM_FIELDSETS.forEach(optionDef => {
              const optionBtn = document.createElement('button');
              optionBtn.type = 'button';
              optionBtn.className = 'menu-option menu-option--fieldset-list';
              const optionLabel = resolveFieldsetDisplayName(optionDef) || optionDef.label || optionDef.value || '';
              optionBtn.textContent = optionLabel || optionDef.value;
              optionBtn.dataset.value = optionDef.value || '';
              if(optionDef.value){
                optionBtn.dataset.fieldsetKey = optionDef.value;
              }
              if(optionLabel){
                optionBtn.dataset.fieldsetName = optionLabel;
              } else if(optionDef.value){
                optionBtn.dataset.fieldsetName = optionDef.value;
              }
              
              // Disable if this field type already exists in the subcategory
              if(existingFieldsets.has(optionDef.value) && optionDef.value !== matchKey){
                optionBtn.disabled = true;
                optionBtn.classList.add('field-type-disabled');
              }
              
              if(optionDef.value === matchKey){
                optionBtn.setAttribute('aria-pressed', 'true');
              }
              
              optionBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                const nextType = optionBtn.dataset.value || '';
                if(!nextType) return;
                
                const nextValidType = FORM_FIELDSETS.some(opt => opt.value === nextType) ? nextType : null;
                if(!nextValidType) throw new Error('Invalid field type "' + nextType + '". Must be one of: ' + FORM_FIELDSETS.map(opt => opt.value).join(', '));
                safeField.fieldsetKey = nextValidType;
                safeField.key = nextValidType;
                
                const matchingFieldset = FORM_FIELDSETS.find(opt => opt.value === nextValidType);
                const matchingDisplayName = matchingFieldset ? resolveFieldsetDisplayName(matchingFieldset) : '';
                const updatedFieldsetName = (matchingDisplayName || nextValidType || '').trim();
                safeField.fieldset_name = updatedFieldsetName;
                safeField.fieldsetName = updatedFieldsetName;
                
                const isEditable = matchingFieldset && matchingFieldset.formbuilder_editable === true;
                if(!isEditable && updatedFieldsetName){
                  safeField.name = updatedFieldsetName;
                } else if(isEditable && !safeField.name){
                  safeField.name = updatedFieldsetName;
                }
                if(matchingFieldset){
                  if(matchingFieldset.placeholder){
                    safeField.placeholder = matchingFieldset.placeholder;
                  }
                  safeField.type = nextValidType;
                }
                
                fieldsetMenuBtn.textContent = optionLabel || nextValidType;
                fieldsetMenuBtn.dataset.value = nextValidType;
                fieldsetMenuBtn.appendChild(arrow);
                fieldsetMenu.hidden = true;
                fieldsetMenuBtn.setAttribute('aria-expanded', 'false');
                
                // Update all option buttons aria-pressed
                fieldsetMenu.querySelectorAll('button.menu-option').forEach(btn => {
                  btn.setAttribute('aria-pressed', btn === optionBtn ? 'true' : 'false');
                });
                
                // If no valid type selected, auto-delete the field immediately
                if(!nextValidType || nextValidType === '' || nextValidType === 'text'){
                  const handler = typeof safeField.__handleDeleteField === 'function' 
                    ? safeField.__handleDeleteField 
                    : null;
                  if(typeof handler === 'function'){
                    handler();
                  }
                  return; // Don't continue - field is deleted
                }
                
                notifyFormbuilderChange();
                updateFieldEditorsByFieldset();
                renderForm({
                  formFields: formPreviewFields,
                  formId: formPreviewId,
                  fields: fields,
                  categoryName: c && c.name,
                  subcategoryName: sub,
                  fieldIdCounter: formPreviewFieldIdCounter,
                  formLabel: 'Form Preview (Sandbox)',
                  isSandbox: true
                });
                runSummaryUpdater();
              });
              
              fieldsetMenu.appendChild(optionBtn);
            });
            
            fieldsetMenuBtn.addEventListener('click', (e) => {
              e.stopPropagation();
              const open = !fieldsetMenu.hasAttribute('hidden');
              if(open){
                fieldsetMenu.hidden = true;
                fieldsetMenuBtn.setAttribute('aria-expanded', 'false');
                
                // If dropdown closes without a type selected, delete the field
                const currentType = safeField.fieldsetKey || safeField.key || safeField.type || '';
                if(!currentType || currentType === '' || currentType === 'text'){
                  const handler = typeof safeField.__handleDeleteField === 'function' 
                    ? safeField.__handleDeleteField 
                    : null;
                  if(typeof handler === 'function'){
                    handler();
                  }
                }
              } else {
                fieldsetMenu.hidden = false;
                fieldsetMenuBtn.setAttribute('aria-expanded', 'true');
                const outsideHandler = (ev) => {
                  if(!fieldsetWrapper.contains(ev.target)){
                    fieldsetMenu.hidden = true;
                    fieldsetMenuBtn.setAttribute('aria-expanded', 'false');
                    document.removeEventListener('click', outsideHandler);
                    document.removeEventListener('pointerdown', outsideHandler);
                    
                    // If dropdown closes without a type selected, delete the field
                    const currentType = safeField.fieldsetKey || safeField.key || safeField.type || '';
                    if(!currentType || currentType === '' || currentType === 'text'){
                      const handler = typeof safeField.__handleDeleteField === 'function' 
                        ? safeField.__handleDeleteField 
                        : null;
                      if(typeof handler === 'function'){
                        handler();
                      }
                    }
                  }
                };
                setTimeout(() => {
                  document.addEventListener('click', outsideHandler);
                  document.addEventListener('pointerdown', outsideHandler);
                }, 0);
              }
            });
            fieldsetMenu.addEventListener('click', (e) => e.stopPropagation());
            
            fieldsetWrapper.append(fieldsetMenuBtn, fieldsetMenu);

            // Field name input (shown in edit panel for editable fields)
            const fieldNameContainer = document.createElement('div');
            fieldNameContainer.className = 'field-name-editor';
            fieldNameContainer.style.display = 'none'; // Hidden until field type is known to be editable
            const fieldNameLabel = document.createElement('label');
            fieldNameLabel.textContent = 'Field Name';
            const fieldNameInput = document.createElement('input');
            fieldNameInput.type = 'text';
            fieldNameInput.className = 'field-name-input';
            fieldNameInput.placeholder = 'Field name';
            fieldNameInput.value = safeField.name || '';
            fieldNameLabel.appendChild(fieldNameInput);
            fieldNameContainer.appendChild(fieldNameLabel);
            
            // Sync field name input with field data and display
            fieldNameInput.addEventListener('input', ()=>{
              safeField.name = fieldNameInput.value;
              // Update the display span in the row header
              if(hostElement && hostElement._inlineNameDisplay){
                hostElement._inlineNameDisplay.textContent = fieldNameInput.value.trim() || 'Untitled';
              }
              notifyFormbuilderChange();
            });

            // Fieldset placeholder input (shown in edit panel for editable fields)
            const fieldPlaceholderContainer = document.createElement('div');
            fieldPlaceholderContainer.className = 'field-name-editor';
            fieldPlaceholderContainer.style.display = 'none'; // Hidden until field type is known to be editable
            const fieldPlaceholderLabel = document.createElement('label');
            fieldPlaceholderLabel.textContent = 'Field Placeholder';
            const fieldPlaceholderInput = document.createElement('input');
            fieldPlaceholderInput.type = 'text';
            fieldPlaceholderInput.className = 'field-placeholder-input';
            fieldPlaceholderInput.placeholder = 'Placeholder text';
            fieldPlaceholderInput.value = safeField.customPlaceholder || '';
            fieldPlaceholderLabel.appendChild(fieldPlaceholderInput);
            fieldPlaceholderContainer.appendChild(fieldPlaceholderLabel);
            
            // Sync placeholder input with field data
            fieldPlaceholderInput.addEventListener('input', ()=>{
              safeField.customPlaceholder = fieldPlaceholderInput.value;
              notifyFormbuilderChange();
            });

            // Fieldset tooltip input (shown in edit panel for editable fields)
            const fieldTooltipContainer = document.createElement('div');
            fieldTooltipContainer.className = 'field-name-editor';
            fieldTooltipContainer.style.display = 'none'; // Hidden until field type is known to be editable
            const fieldTooltipLabel = document.createElement('label');
            fieldTooltipLabel.textContent = 'Field Tooltip';
            const fieldTooltipInput = document.createElement('input');
            fieldTooltipInput.type = 'text';
            fieldTooltipInput.className = 'field-tooltip-input';
            fieldTooltipInput.placeholder = 'Tooltip help text';
            fieldTooltipInput.value = safeField.customTooltip || '';
            fieldTooltipLabel.appendChild(fieldTooltipInput);
            fieldTooltipContainer.appendChild(fieldTooltipLabel);
            
            // Sync tooltip input with field data
            fieldTooltipInput.addEventListener('input', ()=>{
              safeField.customTooltip = fieldTooltipInput.value;
              notifyFormbuilderChange();
            });

            const fieldRequiredToggle = document.createElement('label');
            fieldRequiredToggle.className = 'field-required-toggle';
            const fieldRequiredInput = document.createElement('input');
            fieldRequiredInput.type = 'checkbox';
            fieldRequiredInput.checked = !!safeField.required;
            fieldRequiredInput.setAttribute('aria-label', 'Toggle required field');
            const fieldRequiredText = document.createElement('span');
            fieldRequiredText.textContent = 'Required';
            fieldRequiredToggle.append(fieldRequiredInput, fieldRequiredText);

            // Order: required toggle, fieldset dropdown, field name, placeholder, tooltip
            editPanel.append(fieldRequiredToggle, fieldsetWrapper, fieldNameContainer, fieldPlaceholderContainer, fieldTooltipContainer);

            let summaryUpdater = typeof initialSummaryUpdater === 'function' ? initialSummaryUpdater : ()=>{};
            const runSummaryUpdater = ()=>{
              try{
                summaryUpdater();
              }catch(err){}
            };
            const setSummaryUpdater = fn => {
              if(typeof fn === 'function'){
                summaryUpdater = fn;
              } else {
                summaryUpdater = ()=>{};
              }
            };

            const closeEditPanel = (options = {})=>{
              if(editPanel.hidden) return;
              editPanel.hidden = true;
              editBtn.setAttribute('aria-expanded', 'false');
              if(hostElement && hostElement.classList){
                hostElement.classList.remove('field-edit-open');
              }
              
              // Auto-delete fields without a type selected when panel is closed
              // (unless explicitly skipped via options)
              if(!options.skipAutoDelete){
                const hasFieldset = safeField.fieldsetKey || safeField.key || (safeField.type && safeField.type !== 'text');
                if(!hasFieldset){
                  // Try to get delete handler from safeField
                  const handler = typeof safeField.__handleDeleteField === 'function' 
                    ? safeField.__handleDeleteField 
                    : null;
                  if(typeof handler === 'function'){
                    // Remove the incomplete field silently (no confirmation)
                    handler();
                  }
                }
              }
            };

            const handleFieldEditPointerDown = event => {
              if(hostElement && !hostElement.isConnected && !editPanel.isConnected){
                document.removeEventListener('pointerdown', handleFieldEditPointerDown, true);
                return;
              }
              if(editPanel.hidden){
                return;
              }
              const target = event.target;
              if(editPanel.contains(target)){
                return;
              }
              const clickedEditBtn = target.closest('.category-edit-btn, .subcategory-edit-btn, .field-edit-btn');
              if(clickedEditBtn){
                return;
              }
              closeEditPanel();
            };

            document.addEventListener('pointerdown', handleFieldEditPointerDown, true);

            const updateRequiredState = nextRequired => {
              const next = !!nextRequired;
              if(next === !!safeField.required) return;
              safeField.required = next;
              notifyFormbuilderChange();
              renderForm({
                formFields: formPreviewFields,
                formId: formPreviewId,
                fields: fields,
                categoryName: c && c.name,
                subcategoryName: sub,
                fieldIdCounter: formPreviewFieldIdCounter,
                formLabel: 'Form Preview (Sandbox)',
                isSandbox: true
              });
              runSummaryUpdater();
            };

            fieldRequiredInput.addEventListener('change', ()=>{
              updateRequiredState(fieldRequiredInput.checked);
            });

            const dropdownOptionsContainer = document.createElement('div');
            dropdownOptionsContainer.className = 'dropdown-options-editor';
            const dropdownOptionsLabel = document.createElement('div');
            dropdownOptionsLabel.className = 'dropdown-options-label';
            dropdownOptionsLabel.textContent = 'Field Options';
            const dropdownOptionsList = document.createElement('div');
            dropdownOptionsList.className = 'dropdown-options-list';
            dropdownOptionsContainer.append(dropdownOptionsLabel, dropdownOptionsList);

            // Always add dropdown options to edit panel (not exposed on row)
            editPanel.append(dropdownOptionsContainer);

            // Checkout options editor
            const checkoutOptionsContainer = document.createElement('div');
            checkoutOptionsContainer.className = 'checkout-options-editor';
            checkoutOptionsContainer.hidden = true;
            // Prevent clicks from opening edit panel
            checkoutOptionsContainer.addEventListener('click', (e) => e.stopPropagation());
            const checkoutOptionsLabel = document.createElement('div');
            checkoutOptionsLabel.className = 'checkout-options-label';
            checkoutOptionsLabel.textContent = 'Checkout Options (select up to 3)';
            const checkoutOptionsList = document.createElement('div');
            checkoutOptionsList.className = 'checkout-options-list';
            checkoutOptionsContainer.append(checkoutOptionsLabel, checkoutOptionsList);
            
            // Always add checkout options to edit panel (not exposed on row)
            editPanel.append(checkoutOptionsContainer);

            const renderCheckoutOptionsEditor = ()=>{
              checkoutOptionsList.innerHTML = '';
              const allCheckoutOptions = window.CHECKOUT_OPTIONS || [];
              
              // Get current selected options from field (stores checkout_options IDs)
              if(!Array.isArray(safeField.checkoutOptions)){
                  safeField.checkoutOptions = [];
                }
              
              // Filter out invalid values (empty, null, 0)
              const validOptions = safeField.checkoutOptions.filter(opt => opt !== '' && opt !== null && opt !== 0);
              
              // Preserve existing options, pad with 0 for empty slots
              safeField.checkoutOptions = validOptions.slice();
              while(safeField.checkoutOptions.length < 3){
                safeField.checkoutOptions.push(0);
              }
              
              for(let i = 0; i < 3; i++){
                const optionRow = document.createElement('div');
                optionRow.className = 'checkout-option-row';
                
                const optionLabel = document.createElement('label');
                optionLabel.textContent = `Option ${i + 1}:`;
                optionLabel.className = 'checkout-option-label';
                
                const select = document.createElement('select');
                select.className = 'checkout-option-select';
                
                // Prevent clicks from opening edit panel
                select.addEventListener('click', (e) => e.stopPropagation());
                select.addEventListener('mousedown', (e) => e.stopPropagation());
                
                // Add empty option
                const emptyOption = document.createElement('option');
                emptyOption.value = '0';
                emptyOption.textContent = '-- Select --';
                select.appendChild(emptyOption);
                
                // Add all checkout options (use ID as value)
                allCheckoutOptions.forEach(opt => {
                  const option = document.createElement('option');
                  option.value = String(opt.id || 0);
                  const priceDisplay = parseFloat(opt.checkout_flagfall_price) > 0 
                    ? `  $${parseFloat(opt.checkout_flagfall_price).toFixed(2)}` 
                    : '  Free';
                  option.textContent = (opt.checkout_title || 'Untitled') + priceDisplay;
                  select.appendChild(option);
                });
                
                // Set current value (convert to string for comparison)
                const currentValue = String(safeField.checkoutOptions[i] || 0);
                select.value = currentValue;
                
                select.addEventListener('change', ()=>{
                  // Store as number (checkout_options.id)
                  const newValue = parseInt(select.value, 10) || 0;
                  const oldValue = safeField.checkoutOptions[i] || 0;
                  
                  // Only update if value actually changed
                  if(newValue !== oldValue){
                    safeField.checkoutOptions[i] = newValue;
                    // Filter out zeros to clean up the array
                    safeField.checkoutOptions = safeField.checkoutOptions.filter(opt => opt > 0);
                    // Ensure we have 3 slots
                    while(safeField.checkoutOptions.length < 3){
                      safeField.checkoutOptions.push(0);
                    }
                    
                    notifyFormbuilderChange();
                    
                    // Update formbuilder state manager to mark as changed
                    if(window.formbuilderStateManager && typeof window.formbuilderStateManager.save === 'function'){
                      try {
                        window.formbuilderStateManager.save();
                      } catch(err) {
                        console.error('Failed to update formbuilder state:', err);
                      }
                    }
                    
                    renderForm({
                      formFields: formPreviewFields,
                      formId: formPreviewId,
                      fields: fields,
                      categoryName: c && c.name,
                      subcategoryName: sub,
                      fieldIdCounter: formPreviewFieldIdCounter,
                      formLabel: 'Form Preview (Sandbox)',
                      isSandbox: true
                    });
                  }
                });
                
                optionRow.append(optionLabel, select);
                checkoutOptionsList.appendChild(optionRow);
              }
            };

            let draggedOptionRow = null;

            const ensureDropdownSeeds = ()=>{
              if(!Array.isArray(safeField.options)){
                safeField.options = [];
              }
              const fieldsetKey = safeField.fieldsetKey || safeField.key || '';
              if((fieldsetKey === 'dropdown' || fieldsetKey === 'radio')){
                // Check if options are empty or only have empty strings
                const hasNonEmptyOptions = safeField.options.some(opt => opt && typeof opt === 'string' && opt.trim() !== '');
                if(!hasNonEmptyOptions){
                  // Try to get placeholder from fieldset to seed options
                  const matchingFieldset = FORM_FIELDSETS.find(opt => opt.value === fieldsetKey);
                  if(matchingFieldset && matchingFieldset.placeholder){
                    // Parse placeholder like "A,B,C" or "1A,2A,3A" into array
                    const placeholderStr = matchingFieldset.placeholder.trim();
                    if(placeholderStr){
                      const parsed = placeholderStr.split(',').map(s => s.trim()).filter(s => s);
                      if(parsed.length > 0){
                        safeField.options = parsed;
                      } else {
                safeField.options.push('', '', '');
                      }
                    } else {
                      safeField.options.push('', '', '');
                    }
                  } else {
                    safeField.options.push('', '', '');
                  }
                notifyFormbuilderChange();
                }
              }
            };

            const renderDropdownOptions = (focusIndex = null)=>{
              // Use fieldsetKey/key for fieldset identification (not type which is for HTML input type)
              const fieldsetKey = safeField.fieldsetKey || safeField.key || '';
              const isOptionsType = fieldsetKey === 'dropdown' || fieldsetKey === 'radio';
              if(!isOptionsType){
                dropdownOptionsList.innerHTML = '';
                return;
              }
              ensureDropdownSeeds();
              dropdownOptionsList.innerHTML = '';
              safeField.options.forEach((optionValue, optionIndex)=>{
                const optionText = typeof optionValue === 'string'
                  ? optionValue
                  : (optionValue && typeof optionValue === 'object' && typeof optionValue.item_name === 'string'
                    ? optionValue.item_name
                    : '');
                const optionRow = document.createElement('div');
                optionRow.className = 'dropdown-option-row';
                optionRow.draggable = true;
                optionRow._optionValue = safeField.options[optionIndex];

                const optionInput = document.createElement('input');
                optionInput.type = 'text';
                optionInput.className = 'dropdown-option-input';
                optionInput.placeholder = 'Enter option text';
                optionInput.value = optionText;
                // Prevent clicks on input from opening edit panel
                optionInput.addEventListener('click', (e) => {
                  e.stopPropagation();
                });
                optionInput.addEventListener('mousedown', (e) => {
                  e.stopPropagation();
                });
                optionInput.addEventListener('input', ()=>{
                  safeField.options[optionIndex] = optionInput.value;
                  optionRow._optionValue = optionInput.value;
                  notifyFormbuilderChange();
                  renderForm({
                    formFields: formPreviewFields,
                    formId: formPreviewId,
                    fields: fields,
                    categoryName: c && c.name,
                    subcategoryName: sub,
                    fieldIdCounter: formPreviewFieldIdCounter,
                    formLabel: 'Form Preview (Sandbox)',
                    isSandbox: true
                  });
                });

                const actions = document.createElement('div');
                actions.className = 'dropdown-option-actions';

                const addOptionBtn = document.createElement('button');
                addOptionBtn.type = 'button';
                addOptionBtn.className = 'dropdown-option-add';
                addOptionBtn.textContent = '+';
                addOptionBtn.setAttribute('aria-label', `Add option after this one`);
                // Prevent clicks on button from opening edit panel
                addOptionBtn.addEventListener('click', (e)=>{
                  e.stopPropagation();
                  safeField.options.splice(optionIndex + 1, 0, '');
                  notifyFormbuilderChange();
                  renderDropdownOptions(optionIndex + 1);
                  renderForm({
                    formFields: formPreviewFields,
                    formId: formPreviewId,
                    fields: fields,
                    categoryName: c && c.name,
                    subcategoryName: sub,
                    fieldIdCounter: formPreviewFieldIdCounter,
                    formLabel: 'Form Preview (Sandbox)',
                    isSandbox: true
                  });
                });

                const removeOptionBtn = document.createElement('button');
                removeOptionBtn.type = 'button';
                removeOptionBtn.className = 'dropdown-option-remove';
                removeOptionBtn.textContent = '-';
                removeOptionBtn.setAttribute('aria-label', `Remove Option ${optionIndex + 1}`);
                // Prevent clicks on button from opening edit panel
                removeOptionBtn.addEventListener('click', (e)=>{
                  e.stopPropagation();
                  if(safeField.options.length <= 1){
                    safeField.options[0] = '';
                  } else {
                    safeField.options.splice(optionIndex, 1);
                  }
                  notifyFormbuilderChange();
                  const nextFocus = Math.min(optionIndex, Math.max(safeField.options.length - 1, 0));
                  renderDropdownOptions(nextFocus);
                  renderForm({
                    formFields: formPreviewFields,
                    formId: formPreviewId,
                    fields: fields,
                    categoryName: c && c.name,
                    subcategoryName: sub,
                    fieldIdCounter: formPreviewFieldIdCounter,
                    formLabel: 'Form Preview (Sandbox)',
                    isSandbox: true
                  });
                });

                actions.append(addOptionBtn, removeOptionBtn);
                optionRow.append(optionInput, actions);

                optionRow.addEventListener('dragstart', event=>{
                  const origin = event.target;
                  const tagName = origin && origin.tagName ? origin.tagName.toLowerCase() : '';
                  if(tagName === 'input' || tagName === 'button'){
                    event.preventDefault();
                    return;
                  }
                  draggedOptionRow = optionRow;
                  optionRow.classList.add('is-dragging');
                  if(event.dataTransfer){
                    event.dataTransfer.effectAllowed = 'move';
                    try{ event.dataTransfer.setData('text/plain', optionInput.value || 'Option'); }catch(err){}
                    try{
                      const rect = optionRow.getBoundingClientRect();
                      event.dataTransfer.setDragImage(optionRow, rect.width / 2, rect.height / 2);
                    }catch(err){}
                  }
                });

                optionRow.addEventListener('dragend', ()=>{
                  optionRow.classList.remove('is-dragging');
                  draggedOptionRow = null;
                });

                dropdownOptionsList.appendChild(optionRow);

                if(focusIndex === optionIndex){
                  requestAnimationFrame(()=>{
                    try{ optionInput.focus({ preventScroll: true }); }
                    catch(err){
                      try{ optionInput.focus(); }catch(e){}
                    }
                  });
                }
              });
            };

            const getDragAfterOption = mouseY => {
              const rows = Array.from(dropdownOptionsList.querySelectorAll('.dropdown-option-row')).filter(row => row !== draggedOptionRow);
              let closest = { offset: Number.NEGATIVE_INFINITY, element: null };
              rows.forEach(row => {
                const rect = row.getBoundingClientRect();
                const offset = mouseY - (rect.top + rect.height / 2);
                if(offset < 0 && offset > closest.offset){
                  closest = { offset, element: row };
                }
              });
              return closest.element;
            };

            dropdownOptionsList.addEventListener('dragover', event=>{
              if(!draggedOptionRow) return;
              event.preventDefault();
              if(event.dataTransfer){
                event.dataTransfer.dropEffect = 'move';
              }
              const afterElement = getDragAfterOption(event.clientY);
              if(!afterElement){
                dropdownOptionsList.appendChild(draggedOptionRow);
              } else if(afterElement !== draggedOptionRow){
                dropdownOptionsList.insertBefore(draggedOptionRow, afterElement);
              }
            });

            dropdownOptionsList.addEventListener('drop', event=>{
              if(!draggedOptionRow) return;
              event.preventDefault();
              const orderedValues = Array.from(dropdownOptionsList.querySelectorAll('.dropdown-option-row')).map(row => (
                row && Object.prototype.hasOwnProperty.call(row, '_optionValue') ? row._optionValue : ''
              ));
              safeField.options.splice(0, safeField.options.length, ...orderedValues);
              if(draggedOptionRow){
                draggedOptionRow.classList.remove('is-dragging');
                draggedOptionRow = null;
              }
              notifyFormbuilderChange();
              renderDropdownOptions();
              renderForm({
                formFields: formPreviewFields,
                formId: formPreviewId,
                fields: fields,
                categoryName: c && c.name,
                subcategoryName: sub,
                fieldIdCounter: formPreviewFieldIdCounter,
                formLabel: 'Form Preview (Sandbox)',
                isSandbox: true
              });
            });

            const updateFieldEditorsByFieldset = ()=>{
              const type = safeField.type || safeField.fieldsetKey || safeField.key || '';
              // Use fieldsetKey/key for fieldset identification (not type which is for HTML input type)
              // Get fieldsetKey from the current fieldsetMenuBtn value if available, otherwise from safeField
              const selectedValue = fieldsetMenuBtn ? (fieldsetMenuBtn.dataset.value || '') : '';
              const fieldsetKey = selectedValue || safeField.fieldsetKey || safeField.key || safeField.type || '';
              const isOptionsType = fieldsetKey === 'dropdown' || fieldsetKey === 'radio';
              const showItemPricing = fieldsetKey === 'item-pricing';
              const showVenueSession = fieldsetKey === 'venue-ticketing';
              const showCheckout = fieldsetKey === 'checkout';
              // Check if this fieldset is editable - must have a valid fieldsetKey
              let isEditable = false;
              if(fieldsetKey && fieldsetKey !== ''){
                const matchingFieldset = FORM_FIELDSETS.find(ft => ft.value === fieldsetKey);
                isEditable = matchingFieldset && matchingFieldset.formbuilder_editable === true;
              }
              if(type === 'images'){
                if(safeField.placeholder){
                  safeField.placeholder = '';
                  // Don't notify - this is data normalization during render, not a user change
                }
              } else if(showVenueSession && safeField.placeholder){
                safeField.placeholder = '';
                // Don't notify - this is data normalization during render, not a user change
              }
              // Show field name, placeholder, tooltip editors only for editable field types
              fieldNameContainer.style.display = isEditable ? '' : 'none';
              fieldPlaceholderContainer.style.display = isEditable ? '' : 'none';
              fieldTooltipContainer.style.display = isEditable ? '' : 'none';
              if(isEditable){
                fieldNameInput.value = safeField.name || '';
                fieldPlaceholderInput.value = safeField.customPlaceholder || '';
                fieldTooltipInput.value = safeField.customTooltip || '';
              }
              dropdownOptionsContainer.hidden = !isOptionsType;
              checkoutOptionsContainer.hidden = !showCheckout;
              if(showCheckout){
                renderCheckoutOptionsEditor();
              }
              if(showVenueSession){
                safeField.options = normalizeVenueSessionOptions(safeField.options);
              } else if(showItemPricing){
                if(!Array.isArray(safeField.options) || safeField.options.length === 0){
                  safeField.options = [{ item_name: '', item_currency: 'USD', item_price: '' }];
                  notifyFormbuilderChange();
                } else {
                  safeField.options = safeField.options.map(opt => {
                    if(opt && typeof opt === 'object'){
                      return {
                        item_name: typeof opt.item_name === 'string' ? opt.item_name : '',
                        item_currency: typeof opt.item_currency === 'string' && opt.item_currency !== '' ? opt.item_currency : 'USD',
                        item_price: typeof opt.item_price === 'string' ? opt.item_price : ''
                      };
                    }
                    const str = typeof opt === 'string' ? opt : String(opt ?? '');
                    return { item_name: str, item_currency: 'USD', item_price: '' };
                  });
                }
              }
              if(type === 'dropdown'){
                dropdownOptionsLabel.textContent = 'Dropdown Options';
              } else if(type === 'radio'){
                dropdownOptionsLabel.textContent = 'Radio Options';
              } else {
                dropdownOptionsLabel.textContent = 'Field Options';
              }
              if(isOptionsType){
                if(!Array.isArray(safeField.options) || safeField.options.length === 0){
                  safeField.options = ['', '', ''];
                  notifyFormbuilderChange();
                }
                renderDropdownOptions();
              } else if(!showItemPricing && !showVenueSession){
                dropdownOptionsList.innerHTML = '';
              } else if(showVenueSession){
                dropdownOptionsList.innerHTML = '';
              }
              if(type === 'location'){
                if(!safeField.placeholder || !safeField.placeholder.trim()){
                  const defaultPlaceholder = 'Search for a location';
                  safeField.placeholder = defaultPlaceholder;
                }
                if(!safeField.location || typeof safeField.location !== 'object'){
                  safeField.location = { address: '', latitude: '', longitude: '' };
                } else {
                  if(typeof safeField.location.address !== 'string') safeField.location.address = '';
                  if(typeof safeField.location.latitude !== 'string') safeField.location.latitude = '';
                  if(typeof safeField.location.longitude !== 'string') safeField.location.longitude = '';
                }
              }
              runSummaryUpdater();
            };

            updateFieldEditorsByFieldset();

            const openEditPanel = ()=>{
              if(!editPanel.hidden) return;
              editPanel.hidden = false;
              editBtn.setAttribute('aria-expanded', 'true');
              if(hostElement && hostElement.classList){
                hostElement.classList.add('field-edit-open');
              }
              // Update field editors to show/hide name input for editable fields
              // Force update to ensure fieldsetKey is checked
              updateFieldEditorsByFieldset();
              // Double-check after a brief delay to catch any async updates
              requestAnimationFrame(()=>{
                updateFieldEditorsByFieldset();
                try{
                  if(fieldsetMenuBtn && typeof fieldsetMenuBtn.focus === 'function'){
                    fieldsetMenuBtn.focus({ preventScroll: true });
                  }
                }catch(err){
                  try{ 
                    if(fieldsetMenuBtn && typeof fieldsetMenuBtn.focus === 'function'){
                      fieldsetMenuBtn.focus(); 
                    }
                  }catch(e){}
                }
              });
            };

            editBtn.addEventListener('click', event=>{
              event.stopPropagation();
              document.querySelectorAll('.category-edit-panel, .subcategory-edit-panel').forEach(panel => {
                if(panel !== editPanel){
                  panel.hidden = true;
                }
              });
              closeFieldEditPanels({ exceptPanel: editPanel, exceptButton: editBtn });
              if(editPanel.hidden){
                openEditPanel();
              } else {
                closeEditPanel();
              }
            });

            let deleteHandler = null;

            actionFieldBtn = document.createElement('button');
            actionFieldBtn.type = 'button';
            actionFieldBtn.className = 'delete-field-btn';
            actionFieldBtn.textContent = 'Delete';
            actionFieldBtn.setAttribute('aria-label', 'Delete field');
            actionFieldBtn.addEventListener('click', async event=>{
              event.preventDefault();
              event.stopPropagation();
              
              // Always delete - if field has no type, it will be auto-deleted anyway
              const handler = deleteHandler || (typeof safeField.__handleDeleteField === 'function'
                ? safeField.__handleDeleteField
                : null);
              if(typeof handler === 'function'){
                try{
                  await handler();
                }catch(err){
                  console.error('Error deleting field:', err);
                }
              }
            });

            editPanel.append(actionFieldBtn);

            const destroy = ()=>{
              document.removeEventListener('pointerdown', handleFieldEditPointerDown, true);
            };

            const setDeleteHandler = handler => {
              if(typeof handler === 'function'){
                deleteHandler = handler;
                safeField.__handleDeleteField = handler;
              } else {
                deleteHandler = null;
                if(Object.prototype.hasOwnProperty.call(safeField, '__handleDeleteField')){
                  delete safeField.__handleDeleteField;
                }
              }
            };

            return {
              editBtn,
              editPanel,
              fieldsetMenuBtn,
              fieldRequiredInput,
              dropdownOptionsContainer,
              dropdownOptionsList,
              checkoutOptionsContainer,
              checkoutOptionsList,
              deleteFieldBtn: actionFieldBtn,
              closeEditPanel,
              openEditPanel,
              setSummaryUpdater,
              runSummaryUpdater,
              updateFieldEditorsByFieldset,
              destroy,
              setDeleteHandler
            };
          };

          let formPreviewFieldIdCounter = 0;

          if(fieldsContainerState){
            fieldsContainerState.onFieldsReordered = () => {
              renderForm({
                formFields: formPreviewFields,
                formId: formPreviewId,
                fields: fields,
                categoryName: c && c.name,
                subcategoryName: sub,
                fieldIdCounter: formPreviewFieldIdCounter,
                formLabel: 'Form Preview (Sandbox)',
                isSandbox: true
              });
            };
          }

          const createFieldRow = (field)=>{
            const safeField = ensureFieldDefaults(field);
            const row = document.createElement('div');
            row.className = 'subcategory-field-row';

            const header = document.createElement('div');
            header.className = 'field-row-header';

            // Display span for field name (editable only in edit panel)
            const inlineNameDisplay = document.createElement('span');
            inlineNameDisplay.className = 'field-inline-name-display';
            inlineNameDisplay.textContent = safeField.name || 'Untitled';
            inlineNameDisplay.style.display = 'none';

            const summary = document.createElement('div');
            summary.className = 'field-row-summary';

            const summaryLabel = document.createElement('span');
            summaryLabel.className = 'field-summary-label';

            summary.append(summaryLabel);
            
            const summaryRequired = document.createElement('span');
            summaryRequired.className = 'field-summary-required';

            header.append(inlineNameDisplay, summary, summaryRequired);

            const fieldEditUI = createFieldEditUI(safeField, { hostElement: row });
            const { editBtn: fieldEditBtn, editPanel, fieldsetMenuBtn, deleteFieldBtn, closeEditPanel, openEditPanel, destroy: destroyEditUI, setDeleteHandler, runSummaryUpdater: fieldRunSummaryUpdater } = fieldEditUI;
            const fieldDragHandle = createFormbuilderDragHandle('Reorder field', 'field-drag-handle');
            
            header.append(fieldDragHandle, fieldEditBtn);

            row.append(header);
            editPanel.hidden = true;
            row.append(editPanel);
            row._header = header;

            // Edit panel only opens via the edit button click (handled in createFieldEditUI)
            // Stop propagation on row/header clicks to prevent bubbling
            const stopRowPropagation = event => {
              if(event.target && event.target.closest('.field-edit-btn')) return;
              if(event.target && event.target.closest('.field-edit-panel')) return;
            };
            header.addEventListener('click', stopRowPropagation);
            row.addEventListener('click', stopRowPropagation);

            const updateFieldSummary = ()=>{
              const fieldsetKey = safeField.fieldsetKey || safeField.key || safeField.type || '';
              const matchingFieldset = FORM_FIELDSETS.find(ft => ft.value === fieldsetKey);
              const isEditable = matchingFieldset && matchingFieldset.formbuilder_editable === true;
              
              const customName = (typeof safeField.name === 'string' && safeField.name.trim()) ? safeField.name.trim() : '';
              const storedFieldsetName = (typeof safeField.fieldset_name === 'string' && safeField.fieldset_name.trim())
                ? safeField.fieldset_name.trim()
                : (typeof safeField.fieldsetName === 'string' && safeField.fieldsetName.trim())
                  ? safeField.fieldsetName.trim()
                  : '';
              const fieldsetLabelRaw = (storedFieldsetName || getFormFieldsetLabel(fieldsetKey)).trim();
              const fieldsetLabel = fieldsetLabelRaw || (typeof fieldsetKey === 'string' && fieldsetKey.trim() ? fieldsetKey.trim() : 'Field');
              
              // Show inline name display for editable fields, summary for non-editable
              if(isEditable){
                inlineNameDisplay.style.display = '';
                inlineNameDisplay.textContent = safeField.name || 'Untitled';
                summary.style.display = 'none';
              } else {
                inlineNameDisplay.style.display = 'none';
                summary.style.display = '';
                summaryLabel.textContent = fieldsetLabel || 'Field';
              }
              
              const isRequired = !!safeField.required;
              summaryRequired.textContent = isRequired ? 'Required' : 'Optional';
              summaryRequired.classList.toggle('is-required', isRequired);
              fieldEditBtn.setAttribute('aria-label', `Edit ${fieldsetLabel || 'field'} settings`);
              updateDragHandleLabel(fieldDragHandle, `Reorder ${fieldsetLabel || 'field'} field`);
              if(deleteFieldBtn){
                const deleteLabel = fieldsetLabel || 'field';
                deleteFieldBtn.setAttribute('aria-label', `Delete ${deleteLabel} field`);
              }
            };

            fieldEditUI.setSummaryUpdater(updateFieldSummary);
            fieldEditUI.runSummaryUpdater();

            // Field name input is now in the edit panel, sync handled there via fieldEditUI
            // Store reference to display element for updates from edit panel
            row._inlineNameDisplay = inlineNameDisplay;

            const handleDeleteField = async ()=>{
              const fieldDisplayName = (typeof safeField.name === 'string' && safeField.name.trim()) ? safeField.name.trim() : 'field';
              const confirmed = await confirmFormbuilderDeletion(`Delete the "${fieldDisplayName}" field?`, 'Delete Field');
              if(!confirmed) return;
              closeEditPanel({ skipAutoDelete: true });
              destroyEditUI();
              const idx = fields.indexOf(safeField);
              if(idx !== -1){
                fields.splice(idx, 1);
              }
              if(subcategoryFieldOverlayContent && typeof closeSubcategoryFieldOverlay === 'function' && subcategoryFieldOverlayContent.contains(row)){
                closeSubcategoryFieldOverlay();
              }
              const overlayPlaceholder = row.__overlayPlaceholder;
              if(overlayPlaceholder && overlayPlaceholder.parentNode){
                overlayPlaceholder.remove();
              }
              row.remove();
              if(safeField.__rowEl === row){
                delete safeField.__rowEl;
              }
              delete row.__overlayPlaceholder;
              delete row.__overlayParent;
              delete row.__overlayOverlay;
              delete row.__deleteHandler;
              setDeleteHandler(null);
              notifyFormbuilderChange();
              syncFieldOrderFromDom(fieldsList, fields);
              renderForm({
                formFields: formPreviewFields,
                formId: formPreviewId,
                fields: fields,
                categoryName: c && c.name,
                subcategoryName: sub,
                fieldIdCounter: formPreviewFieldIdCounter,
                formLabel: 'Form Preview (Sandbox)',
                isSandbox: true
              });
              
              // Update formbuilder state manager snapshot after field deletion
              if(window.formbuilderStateManager && typeof window.formbuilderStateManager.save === 'function'){
                try {
                  window.formbuilderStateManager.save();
                  window.formbuilderStateManager.getSaved();
                } catch(err) {
                  console.error('[Formbuilder] Failed to update state manager:', err);
                }
              }
            };

            setDeleteHandler(handleDeleteField);
            row.__deleteHandler = handleDeleteField;

            fieldEditUI.updateFieldEditorsByFieldset();
            row.__fieldRef = safeField;
            safeField.__rowEl = row;
            return {
              row,
              dragHandle: fieldDragHandle,
              editBtn: fieldEditBtn,
              editPanel,
              openEditPanel,
              focus(){
                try{
                  if(fieldsetMenuBtn && typeof fieldsetMenuBtn.focus === 'function'){
                    fieldsetMenuBtn.focus({ preventScroll: true });
                  }
                }catch(err){
                  try{ 
                    if(fieldsetMenuBtn && typeof fieldsetMenuBtn.focus === 'function'){
                      fieldsetMenuBtn.focus(); 
                    }
                  }catch(e){}
                }
              },
              focusTypePicker(){
                const focusSelect = ()=>{
                  try{
                    if(fieldsetMenuBtn && typeof fieldsetMenuBtn.focus === 'function'){
                      fieldsetMenuBtn.focus({ preventScroll: true });
                    }
                  }catch(err){
                    try{ 
                      if(fieldsetMenuBtn && typeof fieldsetMenuBtn.focus === 'function'){
                        fieldsetMenuBtn.focus(); 
                      }
                    }catch(e){}
                  }
                };
                focusSelect();
                requestAnimationFrame(()=>{
                  // Button elements don't have showPicker, menu is controlled by click handler
                  // Just click the button to open the menu
                  if(fieldsetMenuBtn && typeof fieldsetMenuBtn.click === 'function'){
                    try{
                      fieldsetMenuBtn.click();
                    }catch(err){}
                  }
                });
              }
            };
          };

          fields.forEach((existingField, fieldIndex) => {
            if(!existingField) return;
            const fieldRow = createFieldRow(existingField);
            if(!fieldRow || !fieldRow.row) return;
            fieldRow.row.dataset.fieldIndex = String(fieldIndex);
            fieldsList.appendChild(fieldRow.row);
            enableFieldDrag(fieldRow.row, fieldsList, fields, fieldRow.dragHandle);
          });

          // Create the dropdown menu once (not on each click)
          const addFieldMenu = document.createElement('div');
          addFieldMenu.className = 'options-menu';
          addFieldMenu.hidden = true;
          
          // Add placeholder option
          const addFieldPlaceholder = document.createElement('button');
          addFieldPlaceholder.type = 'button';
          addFieldPlaceholder.className = 'menu-option';
          addFieldPlaceholder.textContent = 'Select Fieldset...';
          addFieldPlaceholder.disabled = true;
          addFieldMenu.appendChild(addFieldPlaceholder);
          
          // Add fieldset options
          FORM_FIELDSETS.forEach(optionDef => {
            const optionBtn = document.createElement('button');
            optionBtn.type = 'button';
            optionBtn.className = 'menu-option';
            const optionLabel = resolveFieldsetDisplayName(optionDef) || optionDef.label || optionDef.value || '';
            optionBtn.textContent = optionLabel || optionDef.value;
            optionBtn.dataset.value = optionDef.value || '';
            if(optionDef.value){
              optionBtn.dataset.fieldsetKey = optionDef.value;
            }
            if(optionLabel){
              optionBtn.dataset.fieldsetName = optionLabel;
            } else if(optionDef.value){
              optionBtn.dataset.fieldsetName = optionDef.value;
            }
            
            optionBtn.addEventListener('click', (ev) => {
              ev.stopPropagation();
              const selectedFieldsetKey = optionBtn.dataset.value || '';
              if(!selectedFieldsetKey) return;
              
              // Close dropdown
              addFieldMenu.hidden = true;
              
              // Create new field with selected fieldset
              const newField = ensureFieldDefaults({});
              const matchingFieldset = FORM_FIELDSETS.find(opt => opt.value === selectedFieldsetKey);
              const matchingDisplayName = matchingFieldset ? resolveFieldsetDisplayName(matchingFieldset) : '';
              const fieldsetName = (matchingDisplayName || selectedFieldsetKey || '').trim();
              
              newField.fieldsetKey = selectedFieldsetKey;
              newField.key = selectedFieldsetKey;
              newField.fieldset_name = fieldsetName;
              newField.fieldsetName = fieldsetName;
              
              const isEditable = matchingFieldset && matchingFieldset.formbuilder_editable === true;
              if(!isEditable && fieldsetName){
                newField.name = fieldsetName;
              } else if(isEditable && !newField.name){
                newField.name = fieldsetName;
              }
              if(matchingFieldset){
                if(matchingFieldset.placeholder){
                  newField.placeholder = matchingFieldset.placeholder;
                }
                newField.type = selectedFieldsetKey;
                
                // For editable fieldsets, copy defaults to custom fields so they get saved to subcategory_edits
                if(isEditable){
                  // Copy default name as custom name
                  newField.name = fieldsetName;
                  // Copy default placeholder as custom placeholder
                  if(matchingFieldset.placeholder){
                    newField.customPlaceholder = matchingFieldset.placeholder;
                  }
                  // Copy default tooltip as custom tooltip
                  if(matchingFieldset.fieldset_tooltip){
                    newField.customTooltip = matchingFieldset.fieldset_tooltip;
                  }
                  // For dropdown/radio, copy placeholder options as field options
                  if((selectedFieldsetKey === 'dropdown' || selectedFieldsetKey === 'radio') && matchingFieldset.placeholder){
                    const defaultOptions = matchingFieldset.placeholder.split(',').map(s => s.trim()).filter(s => s);
                    if(defaultOptions.length > 0){
                      newField.options = defaultOptions;
                    }
                  }
                }
              }
              
              fields.push(newField);
              const fieldRow = createFieldRow(newField);
              if(!fieldRow || !fieldRow.row) return;
              fieldRow.row.dataset.fieldIndex = String(fields.length - 1);
              fieldsList.appendChild(fieldRow.row);
              enableFieldDrag(fieldRow.row, fieldsList, fields, fieldRow.dragHandle);
              syncFieldOrderFromDom(fieldsList, fields);
              notifyFormbuilderChange();
              if(fieldRow && fieldRow.editPanel){
                closeFieldEditPanels({ exceptPanel: fieldRow.editPanel, exceptButton: fieldRow.editBtn });
                if(typeof fieldRow.openEditPanel === 'function'){
                  fieldRow.openEditPanel();
                }
              }
              renderForm({
                formFields: formPreviewFields,
                formId: formPreviewId,
                fields: fields,
                categoryName: c && c.name,
                subcategoryName: sub,
                fieldIdCounter: formPreviewFieldIdCounter,
                formLabel: 'Form Preview (Sandbox)',
                isSandbox: true
              });
            });
            
            addFieldMenu.appendChild(optionBtn);
          });
          
          addFieldMenu.addEventListener('click', (e) => e.stopPropagation());
          addFieldBtnWrapper.appendChild(addFieldMenu);
          
          // Function to update disabled state of options based on existing fields
          const updateAddFieldMenuOptions = () => {
            const existingFieldsets = new Set();
            fields.forEach(f => {
              if(f && (f.fieldsetKey || f.key)){
                existingFieldsets.add(f.fieldsetKey || f.key);
              }
            });
            addFieldMenu.querySelectorAll('.menu-option[data-value]').forEach(btn => {
              const val = btn.dataset.value;
              if(existingFieldsets.has(val)){
                btn.disabled = true;
                btn.classList.add('field-type-disabled');
              } else {
                btn.disabled = false;
                btn.classList.remove('field-type-disabled');
              }
            });
          };
          
          addFieldBtn.addEventListener('click', (e)=>{
            e.stopPropagation();
            const isOpen = !addFieldMenu.hidden;
            if(isOpen){
              addFieldMenu.hidden = true;
            } else {
              // Update disabled states before showing
              updateAddFieldMenuOptions();
              addFieldMenu.hidden = false;
              
              // Close when clicking outside
              const outsideHandler = (ev) => {
                if(!addFieldBtnWrapper.contains(ev.target)){
                  addFieldMenu.hidden = true;
                  document.removeEventListener('click', outsideHandler);
                  document.removeEventListener('pointerdown', outsideHandler);
                }
              };
              setTimeout(() => {
                document.addEventListener('click', outsideHandler);
                document.addEventListener('pointerdown', outsideHandler);
              }, 0);
            }
          });

          renderForm({
            formFields: formPreviewFields,
            formId: formPreviewId,
            fields: fields,
            categoryName: c && c.name,
            subcategoryName: sub,
            fieldIdCounter: formPreviewFieldIdCounter,
            formLabel: 'Form Preview (Sandbox)',
            isSandbox: true
          });

          const defaultSubName = sub || 'Subcategory';
          let currentSubName = defaultSubName;
          let lastSubName = defaultSubName;
          let currentSubId = c.subIds && Object.prototype.hasOwnProperty.call(c.subIds, sub) ? c.subIds[sub] : null;
          const getSubNameValue = ()=> subNameInput.value.trim();
          const getSubDisplayName = ()=> getSubNameValue() || lastSubName || defaultSubName;
            const updateSubIconDisplay = (src)=>{
              const displayName = getSubDisplayName();
              subLogo.innerHTML = '';
              const normalizedSrc = applyNormalizeIconPath(src);
              if(normalizedSrc){
                const img = document.createElement('img');
                img.src = normalizedSrc;
                img.alt = '';
                subLogo.appendChild(img);
                subLogo.classList.add('has-icon');
                subcategoryIcons[currentSubName] = `<img src="${normalizedSrc}" alt="">`;
                writeIconPath(subcategoryIconPaths, currentSubId, currentSubName, normalizedSrc);
                // Sample dominant color from icon and apply to header/content backgrounds
                const colorImg = new Image();
                colorImg.crossOrigin = 'anonymous';
                colorImg.onload = () => {
                  try {
                    const canvas = document.createElement('canvas');
                    canvas.width = colorImg.width;
                    canvas.height = colorImg.height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(colorImg, 0, 0);
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
                    let r = 0, g = 0, b = 0, count = 0;
                    for(let i = 0; i < imageData.length; i += 4){
                      if(imageData[i + 3] > 128){ // Only count non-transparent pixels
                        r += imageData[i];
                        g += imageData[i + 1];
                        b += imageData[i + 2];
                        count++;
                      }
                    }
                    if(count > 0){
                      r = Math.round(r / count);
                      g = Math.round(g / count);
                      b = Math.round(b / count);
                      const bgColor = `rgba(${r},${g},${b},0.25)`;
                      subHeader.style.background = bgColor;
                      subContent.style.background = bgColor;
                    }
                  } catch(err){
                    // CORS or canvas error - keep default background
                  }
                };
                colorImg.src = normalizedSrc;
              } else {
                subLogo.textContent = displayName.charAt(0) || '';
                subLogo.classList.remove('has-icon');
                delete subcategoryIcons[currentSubName];
                writeIconPath(subcategoryIconPaths, currentSubId, currentSubName, '');
                // Reset to default background
                subHeader.style.background = '';
                subContent.style.background = '';
              }
              // Update iconpicker button display
              if(normalizedSrc){
                subIconImg.src = normalizedSrc;
                subIconButton.classList.add('has-icon');
                const filename = normalizedSrc.split('/').pop();
                subIconLabel.textContent = filename;
              } else {
                subIconImg.removeAttribute('src');
                subIconButton.classList.remove('has-icon');
                subIconLabel.textContent = 'Choose Icon';
              }
            };
          const applySubNameChange = ()=>{
            const rawValue = getSubNameValue();
            if(rawValue){
              lastSubName = rawValue;
            }
            const previousSubName = currentSubName;
            const previousSubId = currentSubId;
            const displayName = getSubDisplayName();
            const datasetValue = displayName;
            subLabel.textContent = displayName;
            subMenu.dataset.subcategory = datasetValue;
            subBtn.dataset.subcategory = datasetValue;
            subInput.setAttribute('aria-label', `Toggle ${displayName} subcategory`);
            updateDragHandleLabel(subDragHandle, `Reorder ${displayName} subcategory`);
            subIconButton.setAttribute('aria-label', `Choose icon for ${displayName}`);
          const categoryDisplayName = getCategoryDisplayName();
          deleteSubBtn.setAttribute('aria-label', `Delete ${displayName} subcategory from ${categoryDisplayName}`);
            addFieldBtn.setAttribute('aria-label', `Add field to ${displayName}`);
            formPreviewBtn.setAttribute('aria-label', `Preview ${displayName} form`);
            if(!subLogo.querySelector('img')){
              subLogo.textContent = displayName.charAt(0) || '';
              subLogo.classList.remove('has-icon');
            } else {
              subLogo.classList.add('has-icon');
            }
            if(previousSubName !== datasetValue){
              const updateSubNameInList = (list, primaryIndex)=>{
                if(!Array.isArray(list)) return false;
                if(Number.isInteger(primaryIndex) && primaryIndex >= 0 && primaryIndex < list.length){
                  list[primaryIndex] = datasetValue;
                  return true;
                }
                const mirrorIndex = list.indexOf(previousSubName);
                if(mirrorIndex !== -1){
                  list[mirrorIndex] = datasetValue;
                  return true;
                }
                return false;
              };
              const datasetIndex = Number.parseInt(subMenu.dataset.subIndex, 10);
              if(Array.isArray(c.subs)){
                if(!updateSubNameInList(c.subs, datasetIndex)){
                  updateSubNameInList(c.subs, subIndex);
                }
              }
              if(Array.isArray(categories) && categories[sourceIndex] && Array.isArray(categories[sourceIndex].subs)){
                const mirrorSubs = categories[sourceIndex].subs;
                if(!updateSubNameInList(mirrorSubs, datasetIndex)){
                  updateSubNameInList(mirrorSubs, subIndex);
                }
              }
              if(subcategoryIcons[previousSubName] !== undefined){
                subcategoryIcons[datasetValue] = subcategoryIcons[previousSubName];
                delete subcategoryIcons[previousSubName];
              }
              if(subFieldsMap[previousSubName] !== undefined){
                subFieldsMap[datasetValue] = subFieldsMap[previousSubName];
                delete subFieldsMap[previousSubName];
              }
              if(c.subIds && typeof c.subIds === 'object'){
                if(Object.prototype.hasOwnProperty.call(c.subIds, previousSubName)){
                  const preservedId = c.subIds[previousSubName];
                  delete c.subIds[previousSubName];
                  c.subIds[datasetValue] = preservedId;
                  currentSubId = preservedId;
                }
              }
              renameIconNameKey(subcategoryIconPaths, previousSubName, datasetValue);
              currentSubName = datasetValue;
            }
            if(c.subIds && Object.prototype.hasOwnProperty.call(c.subIds, currentSubName)){
              currentSubId = c.subIds[currentSubName];
            } else if(previousSubName === currentSubName){
              currentSubId = previousSubId;
            }
          };
          subNameUpdaters.push(applySubNameChange);
          subNameInput.addEventListener('input', ()=> applySubNameChange());

          deleteSubBtn.addEventListener('click', async ()=>{
            const categoryDisplayName = getCategoryDisplayName();
            const subDisplayName = getSubDisplayName();
            const confirmed = await confirmFormbuilderDeletion(`Delete the "${subDisplayName}" subcategory from ${categoryDisplayName}?`, 'Delete Subcategory');
            if(!confirmed) return;
            if(subcategoryFieldOverlayContent && typeof closeSubcategoryFieldOverlay === 'function'){
              const activeRow = subcategoryFieldOverlayContent.querySelector('.subcategory-field-row');
              if(activeRow && subMenu.contains(activeRow)){
                closeSubcategoryFieldOverlay();
              }
            }
            delete subcategoryIcons[currentSubName];
            deleteIconKeys(subcategoryIconPaths, currentSubId, currentSubName);
            if(c.subIds && typeof c.subIds === 'object' && Object.prototype.hasOwnProperty.call(c.subIds, currentSubName)){
              delete c.subIds[currentSubName];
            }
            if(Array.isArray(c.subs)){
              const subIndex = c.subs.indexOf(currentSubName);
              if(subIndex !== -1){
                c.subs.splice(subIndex, 1);
              }
            }
            subMenu.remove();
            delete subFieldsMap[currentSubName];
            notifyFormbuilderChange();
            
            // Update formbuilder state manager snapshot first
            if(window.formbuilderStateManager && typeof window.formbuilderStateManager.save === 'function'){
              try {
                window.formbuilderStateManager.save();
              } catch(err) {
                console.error('[Formbuilder] Failed to update state manager:', err);
              }
            }
            
            // Trigger auto-save after deletion
            if(typeof window.adminPanelModule?.runSave === 'function'){
              setTimeout(() => {
                window.adminPanelModule.runSave({ closeAfter: false });
              }, 100);
            }
          });

          const subEditPanel = document.createElement('div');
          subEditPanel.className = 'subcategory-edit-panel';
          subEditPanel.hidden = true;

          // Name row with input and 3-dot overflow menu
          const subNameRow = document.createElement('div');
          subNameRow.className = 'edit-panel-name-row';

          // 3-dot overflow button
          const subOverflowBtn = document.createElement('button');
          subOverflowBtn.type = 'button';
          subOverflowBtn.className = 'edit-panel-overflow-btn';
          subOverflowBtn.innerHTML = '<svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor"><circle cx="8" cy="3" r="1.5"/><circle cx="8" cy="8" r="1.5"/><circle cx="8" cy="13" r="1.5"/></svg>';
          subOverflowBtn.setAttribute('aria-label', 'More options');
          subOverflowBtn.setAttribute('aria-haspopup', 'true');
          subOverflowBtn.setAttribute('aria-expanded', 'false');

          const subOverflowMenu = document.createElement('div');
          subOverflowMenu.className = 'edit-panel-overflow-menu';
          subOverflowMenu.hidden = true;

          // Hide toggle inside overflow menu
          const subHideToggleRow = document.createElement('div');
          subHideToggleRow.className = 'overflow-menu-item overflow-menu-toggle';
          const subHideToggleLabel = document.createElement('span');
          subHideToggleLabel.dataset.messageKey = 'msg_label_hide_subcategory';
          subHideToggleLabel.textContent = 'Hide Subcategory';
          const subHideToggle = document.createElement('label');
          subHideToggle.className = 'switch';
          const subHideToggleInput = document.createElement('input');
          subHideToggleInput.type = 'checkbox';
          if(!c.subHidden) c.subHidden = {};
          subHideToggleInput.checked = typeof c.subHidden[sub] === 'boolean' ? c.subHidden[sub] : !subInput.checked;
          const subHideToggleSlider = document.createElement('span');
          subHideToggleSlider.className = 'slider';
          subHideToggle.append(subHideToggleInput, subHideToggleSlider);
          subHideToggleRow.append(subHideToggleLabel, subHideToggle);
          
          subHideToggleInput.addEventListener('change', ()=>{
            if(!c.subHidden) c.subHidden = {};
            c.subHidden[sub] = subHideToggleInput.checked;
            subInput.checked = !subHideToggleInput.checked;
            subInput.dispatchEvent(new Event('change', {bubbles: true}));
            notifyFormbuilderChange();
          });
          
          subInput.addEventListener('change', ()=>{
            subHideToggleInput.checked = !subInput.checked;
            if(!c.subHidden) c.subHidden = {};
            c.subHidden[sub] = subHideToggleInput.checked;
            notifyFormbuilderChange();
          });

          // Delete button inside overflow menu
          const deleteSubMenuBtn = document.createElement('button');
          deleteSubMenuBtn.type = 'button';
          deleteSubMenuBtn.className = 'overflow-menu-item overflow-menu-item--danger';
          deleteSubMenuBtn.innerHTML = '<svg width="14" height="14" viewBox="0 0 16 16" fill="currentColor"><path d="M5.5 5.5A.5.5 0 0 1 6 6v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm2.5 0a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm3 .5a.5.5 0 0 0-1 0v6a.5.5 0 0 0 1 0V6z"/><path fill-rule="evenodd" d="M14.5 3a1 1 0 0 1-1 1H13v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V4h-.5a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1H6a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1h3.5a1 1 0 0 1 1 1v1zM4.118 4 4 4.059V13a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V4.059L11.882 4H4.118zM2.5 3V2h11v1h-11z"/></svg><span>Delete Subcategory</span>';
          deleteSubMenuBtn.setAttribute('aria-label', `Delete ${sub} subcategory`);
          deleteSubMenuBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            subOverflowMenu.hidden = true;
            subOverflowBtn.setAttribute('aria-expanded', 'false');
            deleteSubBtn.click();
          });

          subOverflowMenu.append(subHideToggleRow, deleteSubMenuBtn);
          subNameRow.append(subNameInput, subOverflowBtn, subOverflowMenu);

          // Overflow button toggle
          subOverflowBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            const isOpen = !subOverflowMenu.hidden;
            document.querySelectorAll('.edit-panel-overflow-menu').forEach(m => {
              if(m !== subOverflowMenu) m.hidden = true;
            });
            document.querySelectorAll('.edit-panel-overflow-btn').forEach(b => {
              if(b !== subOverflowBtn) b.setAttribute('aria-expanded', 'false');
            });
            subOverflowMenu.hidden = isOpen;
            subOverflowBtn.setAttribute('aria-expanded', isOpen ? 'false' : 'true');
          });

          // Close overflow menu when clicking outside
          document.addEventListener('pointerdown', (e) => {
            if(!subOverflowMenu.hidden && !subOverflowBtn.contains(e.target) && !subOverflowMenu.contains(e.target)){
              subOverflowMenu.hidden = true;
              subOverflowBtn.setAttribute('aria-expanded', 'false');
            }
          }, true);
          
          // Get site currency from admin settings (default to USD)
          const siteCurrency = 'USD'; // TODO: Load from admin_settings
          
          // Initialize subFees if not exists, but don't overwrite existing database values
          if(!c.subFees) c.subFees = {};
          if(!c.subFees[sub]) {
            c.subFees[sub] = {};
          }
          // Set defaults only for missing values
          if(c.subFees[sub].checkout_surcharge === undefined) c.subFees[sub].checkout_surcharge = null;
          if(c.subFees[sub].subcategory_type === undefined) c.subFees[sub].subcategory_type = 'General';
          
          // Initialize subCheckoutOptions if not exists
          if(!c.subCheckoutOptions) c.subCheckoutOptions = {};
          if(!c.subCheckoutOptions[sub]) {
            // Try to get from fields if available (from checkout field)
            const subFields = subFieldsMap[sub];
            let checkoutOptionIds = [];
            if(subFields && Array.isArray(subFields)){
              for(const field of subFields){
                if(field && typeof field === 'object' && (field.fieldsetKey === 'checkout' || field.key === 'checkout')){
                  if(Array.isArray(field.checkoutOptions)){
                    checkoutOptionIds = field.checkoutOptions.filter(id => id && id > 0).map(id => parseInt(id, 10) || 0).filter(id => id > 0);
                  }
                  break;
                }
              }
            }
            c.subCheckoutOptions[sub] = checkoutOptionIds.length > 0 ? checkoutOptionIds : [];
          }
          
          // Checkout Options Editor - List of all enabled checkout options with prices and calculators
          const checkoutOptionsEditor = document.createElement('div');
          checkoutOptionsEditor.className = 'subcategory-checkout-options-editor';
          const checkoutOptionsLabel = document.createElement('div');
          checkoutOptionsLabel.className = 'subcategory-checkout-options-label';
          checkoutOptionsLabel.textContent = 'Checkout Options';
          const checkoutOptionsList = document.createElement('div');
          checkoutOptionsList.className = 'subcategory-checkout-options-list';
          checkoutOptionsEditor.append(checkoutOptionsLabel, checkoutOptionsList);
          
          // Define renderCheckoutOptionsEditor function first so it can be referenced by surcharge input
          const renderCheckoutOptionsEditor = ()=>{
            checkoutOptionsList.innerHTML = '';
            const allCheckoutOptions = (window.CHECKOUT_OPTIONS || []).filter(opt => opt.is_active !== false && opt.is_active !== 0);
            const surcharge = c.subFees[sub].checkout_surcharge !== null && c.subFees[sub].checkout_surcharge !== undefined 
              ? parseFloat(c.subFees[sub].checkout_surcharge) : 0;
            
            if(allCheckoutOptions.length === 0){
              checkoutOptionsList.innerHTML = '<div style="color:#888;padding:12px;text-align:center;">No enabled checkout options available.</div>';
              return;
            }
            
            allCheckoutOptions.forEach(opt => {
              const optionCard = document.createElement('div');
              optionCard.className = 'subcategory-checkout-option-card';
              const flagfall = parseFloat(opt.checkout_flagfall_price) || 0;
              const basicDayRate = opt.checkout_basic_day_rate !== null && opt.checkout_basic_day_rate !== undefined 
                ? parseFloat(opt.checkout_basic_day_rate) : null;
              const discountDayRate = opt.checkout_discount_day_rate !== null && opt.checkout_discount_day_rate !== undefined 
                ? parseFloat(opt.checkout_discount_day_rate) : null;
              
              // Calculate prices for 30 and 365 days with surcharge
              function calculatePrice(days){
                let basePrice = flagfall;
                if(days >= 365 && discountDayRate !== null && !isNaN(discountDayRate)){
                  basePrice += discountDayRate * days;
                } else if(basicDayRate !== null && !isNaN(basicDayRate)){
                  basePrice += basicDayRate * days;
                }
                // Apply surcharge (can be negative)
                if(surcharge !== 0 && !isNaN(surcharge)){
                  basePrice = basePrice * (1 + surcharge / 100);
                }
                return basePrice;
              }
              
              const price30 = calculatePrice(30);
              const price365 = calculatePrice(365);
              
              const content = document.createElement('div');
              content.className = 'subcategory-checkout-option-content';
              
              const title = document.createElement('div');
              title.className = 'subcategory-checkout-option-title';
              title.textContent = opt.checkout_title || 'Untitled';
              
              const prices = document.createElement('div');
              prices.className = 'subcategory-checkout-option-prices';
              prices.innerHTML = `
                <div class="subcategory-checkout-price-item">
                  <span class="price-label">30 days:</span>
                  <span class="price-value">${siteCurrency} ${price30.toFixed(2)}</span>
                </div>
                <div class="subcategory-checkout-price-item">
                  <span class="price-label">365 days:</span>
                  <span class="price-value">${siteCurrency} ${price365.toFixed(2)}</span>
                </div>
              `;
              
              // Calculator for this checkout option
              const calculator = document.createElement('div');
              calculator.className = 'subcategory-checkout-option-calculator';
              const calcLabel = document.createElement('label');
              calcLabel.className = 'subcategory-checkout-calc-label';
              calcLabel.textContent = 'Calculator:';
              const calcInput = document.createElement('input');
              calcInput.type = 'number';
              calcInput.className = 'subcategory-checkout-calc-days';
              calcInput.placeholder = 'Days';
              calcInput.min = '1';
              calcInput.step = '1';
              calcInput.style.width = '80px';
              calcInput.style.marginLeft = '8px';
              calcInput.style.marginRight = '8px';
              const calcTotal = document.createElement('span');
              calcTotal.className = 'subcategory-checkout-calc-total';
              calcTotal.textContent = `${siteCurrency} 0.00`;
              
              function updateCalculator(){
                const days = parseFloat(calcInput.value) || 0;
                if(days <= 0){
                  calcTotal.textContent = `${siteCurrency} 0.00`;
                  return;
                }
                const total = calculatePrice(days);
                calcTotal.textContent = `${siteCurrency} ${total.toFixed(2)}`;
              }
              
              calcInput.addEventListener('input', updateCalculator);
              calcInput.addEventListener('change', updateCalculator);
              
              calculator.append(calcLabel, calcInput, calcTotal);
              
              content.append(title, prices, calculator);
              optionCard.append(content);
              checkoutOptionsList.appendChild(optionCard);
            });
          };
          
          // Checkout Surcharge Row
          const surchargeRow = document.createElement('div');
          surchargeRow.className = 'subcategory-fee-row';
          const surchargeLabel = document.createElement('span');
          surchargeLabel.textContent = 'Checkout Surcharge';
          const surchargePercent = document.createElement('span');
          surchargePercent.className = 'fee-currency';
          surchargePercent.textContent = '%';
          const surchargeInput = document.createElement('input');
          surchargeInput.type = 'number';
          surchargeInput.step = '0.01';
          surchargeInput.min = '-100';
          surchargeInput.className = 'fee-input';
          surchargeInput.placeholder = 'N/A';
          surchargeInput.value = c.subFees[sub].checkout_surcharge !== null && c.subFees[sub].checkout_surcharge !== undefined 
            ? c.subFees[sub].checkout_surcharge.toFixed(2) 
            : '';
          surchargeInput.addEventListener('input', ()=>{
            let value = surchargeInput.value ? parseFloat(surchargeInput.value) : null;
            // Enforce minimum of -100%
            if(value !== null && value < -100){
              value = -100;
              surchargeInput.value = value.toFixed(2);
            }
            c.subFees[sub].checkout_surcharge = value !== null ? Math.round(value * 100) / 100 : null;
            notifyFormbuilderChange();
            // Re-render checkout options to update prices with new surcharge
            renderCheckoutOptionsEditor();
          });
          surchargeInput.addEventListener('blur', ()=>{
            let value = surchargeInput.value ? parseFloat(surchargeInput.value) : null;
            // Enforce minimum of -100%
            if(value !== null && value < -100){
              value = -100;
            }
            if(value !== null){
              surchargeInput.value = value.toFixed(2);
              c.subFees[sub].checkout_surcharge = Math.round(value * 100) / 100;
            }
            // Re-render checkout options to update prices with new surcharge
            renderCheckoutOptionsEditor();
          });
          surchargeRow.append(surchargeLabel, surchargePercent, surchargeInput);
          
          // Subcategory Type Row
          const subTypeRow = document.createElement('div');
          subTypeRow.className = 'subcategory-type-row';
          const subTypeLabel = document.createElement('span');
          subTypeLabel.textContent = 'Subcategory Type';
          const subTypeEventsLabel = document.createElement('label');
          subTypeEventsLabel.className = 'subcategory-type-option';
          const subTypeEventsInput = document.createElement('input');
          subTypeEventsInput.type = 'radio';
          subTypeEventsInput.name = `subType-${sub}`;
          subTypeEventsInput.value = 'Events';
          subTypeEventsInput.checked = c.subFees[sub].subcategory_type === 'Events';
          subTypeEventsInput.addEventListener('change', ()=>{
            if(subTypeEventsInput.checked){
              c.subFees[sub].subcategory_type = 'Events';
              notifyFormbuilderChange();
            }
          });
          const subTypeEventsText = document.createElement('span');
          subTypeEventsText.textContent = 'Events';
          subTypeEventsLabel.append(subTypeEventsInput, subTypeEventsText);
          
          const subTypeStandardLabel = document.createElement('label');
          subTypeStandardLabel.className = 'subcategory-type-option';
          const subTypeStandardInput = document.createElement('input');
          subTypeStandardInput.type = 'radio';
          subTypeStandardInput.name = `subType-${sub}`;
          subTypeStandardInput.value = 'General';
          subTypeStandardInput.checked = c.subFees[sub].subcategory_type === 'General';
          subTypeStandardInput.addEventListener('change', ()=>{
            if(subTypeStandardInput.checked){
              c.subFees[sub].subcategory_type = 'General';
              notifyFormbuilderChange();
            }
          });
          const subTypeStandardText = document.createElement('span');
          subTypeStandardText.textContent = 'General';
          subTypeStandardLabel.append(subTypeStandardInput, subTypeStandardText);
          
          subTypeRow.append(subTypeLabel, subTypeEventsLabel, subTypeStandardLabel);
          
          renderCheckoutOptionsEditor();
          
          subEditPanel.append(subNameRow, subIconPicker, surchargeRow, subTypeRow, checkoutOptionsEditor);
          
          subEditBtn.addEventListener('click', (e)=>{
            e.stopPropagation();
            document.querySelectorAll('.category-edit-panel, .subcategory-edit-panel').forEach(panel => {
              if(panel === subEditPanel) return;
              panel.hidden = true;
              const relatedButton = panel.parentElement
                ? panel.parentElement.querySelector('.category-edit-btn, .subcategory-edit-btn')
                : null;
              if(relatedButton){
                relatedButton.setAttribute('aria-expanded','false');
              }
            });
            closeFieldEditPanels();
            const willShow = subEditPanel.hidden;
            subEditPanel.hidden = !willShow;
            subEditBtn.setAttribute('aria-expanded', willShow ? 'true' : 'false');
            // Also expand the subcategory content if showing edit panel
            if(willShow && subContent.hidden){
              subContent.hidden = false;
              subMenu.setAttribute('aria-expanded', 'true');
              subBtn.setAttribute('aria-expanded', 'true');
            }
          });

          const handleSubcategoryEditPointerDown = event => {
            if(subEditPanel.hidden){
              return;
            }
            const target = event.target;
            if(subEditPanel.contains(target)){
              return;
            }
            const clickedEditBtn = target.closest('.category-edit-btn, .subcategory-edit-btn, .field-edit-btn');
            if(clickedEditBtn){
              return;
            }
            subEditPanel.hidden = true;
            subEditBtn.setAttribute('aria-expanded', 'false');
          };
          document.addEventListener('pointerdown', handleSubcategoryEditPointerDown, true);

          subContent.append(subEditPanel, fieldsSection);

          subMenu.append(subContent);

          applySubNameChange();
      const initialIconSource = applyNormalizeIconPath(initialSubIconPath) || initialSubIconPath || '';
          if(initialIconSource){
            updateSubIconDisplay(initialIconSource);
          }

          subBtn.addEventListener('click', ()=>{
            const isExpanded = subMenu.getAttribute('aria-expanded') === 'true';
            const next = !isExpanded;
            subMenu.setAttribute('aria-expanded', next ? 'true' : 'false');
            subBtn.setAttribute('aria-expanded', next ? 'true' : 'false');
            subContent.hidden = !next;
            if(!next && subcategoryFieldOverlayContent && typeof closeSubcategoryFieldOverlay === 'function'){
              const activeRow = subcategoryFieldOverlayContent.querySelector('.subcategory-field-row');
              if(activeRow && subMenu.contains(activeRow)){
                closeSubcategoryFieldOverlay();
              }
            }
          });

          subInput.addEventListener('change', ()=>{
            const isOn = subInput.checked;
            subMenu.classList.toggle('subcategory-off', !isOn);
            if(!isOn){
              if(subcategoryFieldOverlayContent && typeof closeSubcategoryFieldOverlay === 'function'){
                const activeRow = subcategoryFieldOverlayContent.querySelector('.subcategory-field-row');
                if(activeRow && subMenu.contains(activeRow)){
                  closeSubcategoryFieldOverlay();
                }
              }
              if(subMenu.getAttribute('aria-expanded') === 'true'){
                subMenu.setAttribute('aria-expanded','false');
                subBtn.setAttribute('aria-expanded','false');
                subContent.hidden = true;
              }
            }
          });

          subMenusContainer.insertBefore(subMenu, addSubAnchor);
          enableSubcategoryDrag(subMenu, subMenusContainer, c, subHeader, addSubAnchor, subDragHandle);
        });

        setupSubcategoryContainer(subMenusContainer, c, addSubAnchor);

        const handleAddSubClick = async ()=>{
          const categoryDisplayName = getCategoryDisplayName();
          const confirmed = await confirmFormbuilderAction({
            titleText: 'Add Subcategory',
            messageKey: 'msg_confirm_add_subcategory',
            placeholders: { category: categoryDisplayName },
            confirmLabel: 'Add Subcategory',
            confirmClassName: 'formbuilder-confirm-primary',
            focusCancel: false
          });
          if(!confirmed) return;
          if(!Array.isArray(c.subs)){
            c.subs = [];
          }
          if(!c.subIds || typeof c.subIds !== 'object' || Array.isArray(c.subIds)){
            c.subIds = {};
          }
          const baseName = 'New Subcategory';
          const existing = new Set(c.subs.map(sub => (sub && typeof sub === 'string') ? sub : ''));
          let candidate = baseName;
          let counter = 2;
          while(existing.has(candidate)){
            candidate = `${baseName} ${counter++}`;
          }
          c.subs.push(candidate);
          c.subIds[candidate] = null;
          subFieldsMap[candidate] = [];
          const categoryIndex = categories.indexOf(c);
          renderFormbuilderCats();
          notifyFormbuilderChange();
          requestAnimationFrame(()=> requestAnimationFrame(()=>{
            if(!formbuilderCats) return;
            const categorySelector = categoryIndex >= 0 ? `.category-form-menu[data-category-index="${categoryIndex}"]` : null;
            const categoryMenu = categorySelector ? formbuilderCats.querySelector(categorySelector) : null;
            if(!categoryMenu) return;
            categoryMenu.setAttribute('aria-expanded','true');
            const menuTrigger = categoryMenu.querySelector('.filter-category-trigger');
            const content = categoryMenu.querySelector('.category-form-content');
            if(menuTrigger) menuTrigger.setAttribute('aria-expanded','true');
            if(content) content.hidden = false;
            const subMenus = categoryMenu ? categoryMenu.querySelectorAll('.subcategory-form-menu') : null;
            const newSubMenu = subMenus && subMenus.length ? subMenus[subMenus.length - 1] : null;
            if(!newSubMenu) return;
            newSubMenu.setAttribute('aria-expanded','true');
            const subTrigger = newSubMenu.querySelector('.subcategory-form-trigger');
            const subContent = newSubMenu.querySelector('.subcategory-form-content');
            if(subTrigger) subTrigger.setAttribute('aria-expanded','true');
            if(subContent) subContent.hidden = false;
            const newSubEditPanel = newSubMenu.querySelector('.subcategory-edit-panel');
            const newSubEditBtn = newSubMenu.querySelector('.subcategory-edit-btn');
            if(newSubEditPanel){
              document.querySelectorAll('.category-edit-panel, .subcategory-edit-panel').forEach(panel => {
                if(panel !== newSubEditPanel){
                  panel.hidden = true;
                }
              });
              document.querySelectorAll('.category-edit-btn, .subcategory-edit-btn').forEach(btn => {
                if(btn !== newSubEditBtn){
                  btn.setAttribute('aria-expanded', 'false');
                }
              });
              closeFieldEditPanels();
              newSubEditPanel.hidden = false;
              if(newSubEditBtn){
                newSubEditBtn.setAttribute('aria-expanded', 'true');
              }
            }
            const subNameField = newSubMenu.querySelector('.subcategory-name-input');
            if(subNameField){
              try{ subNameField.focus({ preventScroll: true }); }
              catch(err){
                try{ subNameField.focus(); }catch(e){}
              }
            }
          }));
        };
        const oldSubHandler = addSubBtn.__addSubcategoryHandler;
        if(oldSubHandler){
          addSubBtn.removeEventListener('click', oldSubHandler);
        }
        addSubBtn.addEventListener('click', handleAddSubClick);
        addSubBtn.__addSubcategoryHandler = handleAddSubClick;

        applyCategoryNameChange();

        content.append(editPanel, subMenusContainer, editMenu);
        menu.append(content);

        menuBtn.addEventListener('click', ()=>{
          const isExpanded = menu.getAttribute('aria-expanded') === 'true';
          const next = !isExpanded;
          menu.setAttribute('aria-expanded', next ? 'true' : 'false');
          menuBtn.setAttribute('aria-expanded', next ? 'true' : 'false');
          content.hidden = !next;
        });

        toggleInput.addEventListener('change', ()=>{
          const isOn = toggleInput.checked;
          menu.classList.toggle('cat-off', !isOn);
          if(!isOn){
            if(menu.getAttribute('aria-expanded') === 'true'){
              menu.setAttribute('aria-expanded','false');
              menuBtn.setAttribute('aria-expanded','false');
              content.hidden = true;
            }
          }
        });

        frag.appendChild(menu);
        enableCategoryDrag(menu, header, categoryDragHandle);
      });
      formbuilderCats.innerHTML = '';
      formbuilderCats.appendChild(frag);
      refreshFormbuilderSubcategoryLogos();
    };
    // Expose renderFormbuilderCats globally so it can be called when Forms tab opens
    window.renderFormbuilderCats = renderFormbuilderCats;
    if(formbuilderAddCategoryBtn){
      async function handleFormbuilderAddCategoryClick(){
        const confirmed = await confirmFormbuilderAction({
          titleText: 'Add Category',
          messageKey: 'msg_confirm_add_category',
          confirmLabel: 'Add Category',
          confirmClassName: 'formbuilder-confirm-primary',
          focusCancel: false
        });
        if(!confirmed) return;
        if(!Array.isArray(categories)) return;
        const baseName = 'New Category';
        const existing = new Set(categories.map(cat => (cat && typeof cat.name === 'string') ? cat.name : ''));
        let candidate = baseName;
        let counter = 2;
        while(existing.has(candidate)){
          candidate = `${baseName} ${counter++}`;
        }
        categories.push({ name: candidate, subs: [], subFields: {}, sort_order: null });
        renderFormbuilderCats();
        notifyFormbuilderChange();
        const newMenu = formbuilderCats ? formbuilderCats.querySelector('.category-form-menu:last-of-type') : null;
        if(!newMenu) return;
        const menuTrigger = newMenu.querySelector('.filter-category-trigger');
        const content = newMenu.querySelector('.category-form-content');
        const editPanel = newMenu.querySelector('.category-edit-panel');
        const nameField = newMenu.querySelector('.category-name-input');
        newMenu.setAttribute('aria-expanded','true');
        if(menuTrigger) menuTrigger.setAttribute('aria-expanded','true');
        if(content) content.hidden = false;
        if(editPanel){
          document.querySelectorAll('.category-edit-panel, .subcategory-edit-panel').forEach(panel => {
            if(panel !== editPanel){
              panel.hidden = true;
            }
          });
          closeFieldEditPanels();
          editPanel.hidden = false;
        }
        if(nameField){
          requestAnimationFrame(()=>{
            try{ nameField.focus({ preventScroll: true }); }
            catch(err){
              try{ nameField.focus(); }catch(e){}
            }
          });
        }
      }
      const oldCategoryHandler = formbuilderAddCategoryBtn[FORM_BUILDER_ADD_CATEGORY_HANDLER_PROP];
      if(oldCategoryHandler){
        formbuilderAddCategoryBtn.removeEventListener('click', oldCategoryHandler);
      }
      formbuilderAddCategoryBtn.addEventListener('click', handleFormbuilderAddCategoryClick);
      formbuilderAddCategoryBtn[FORM_BUILDER_ADD_CATEGORY_HANDLER_PROP] = handleFormbuilderAddCategoryClick;
    }
    function cloneFieldsMap(source){
      const out = {};
      if(source && typeof source === 'object' && !Array.isArray(source)){
        Object.keys(source).forEach(key => {
          const value = source[key];
          if(Array.isArray(value)){
            // Always include the key, even if the array is empty
            out[key] = value.length === 0 ? [] : value.map(field => {
              const cloned = {
                id: field && field.id,
                key: field && typeof field.key === 'string' ? field.key : undefined,
                fieldsetKey: field && typeof field.fieldsetKey === 'string' ? field.fieldsetKey : undefined,
                name: field && typeof field.name === 'string' ? field.name : '',
                type: field && typeof field.type === 'string' ? field.type : '',
                placeholder: field && typeof field.placeholder === 'string' ? field.placeholder : '',
                required: !!(field && field.required),
                options: Array.isArray(field && field.options)
                ? field.options.map(opt => {
                    if(field && field.type === 'item-pricing'){
                      if(opt && typeof opt === 'object'){
                        return {
                          item_name: typeof opt.item_name === 'string' ? opt.item_name : '',
                          item_currency: typeof opt.item_currency === 'string' && opt.item_currency !== '' ? opt.item_currency : 'USD',
                          item_price: typeof opt.item_price === 'string' ? opt.item_price : ''
                        };
                      }
                      const str = typeof opt === 'string' ? opt : String(opt ?? '');
                      return { item_name: str, item_currency: 'USD', item_price: '' };
                    }
                    if(field && field.type === 'venue-ticketing'){
                      return cloneVenueSessionVenue(opt);
                    }
                    if(typeof opt === 'string') return opt;
                    if(opt && typeof opt === 'object' && typeof opt.item_name === 'string'){
                      return opt.item_name;
                    }
                    return String(opt ?? '');
                  })
                : []
              };
              // Preserve nested fields for complex field types
              if(Array.isArray(field && field.fields)){
                cloned.fields = field.fields;
              }
              // Preserve checkoutOptions for checkout field type (stores checkout_options IDs)
              // Filter out zeros when cloning for saving
              if(Array.isArray(field && field.checkoutOptions)){
                // Filter out zeros and invalid values (only keep valid IDs)
                cloned.checkoutOptions = field.checkoutOptions.filter(opt => opt !== 0 && opt !== '' && opt !== null);
              } else if(field && (field.type === 'checkout' || field.fieldsetKey === 'checkout')){
                // Initialize empty array for checkout fields if missing
                cloned.checkoutOptions = [];
              }
              // Preserve custom placeholder and tooltip for editable fieldsets
              if(field && typeof field.customPlaceholder === 'string'){
                cloned.customPlaceholder = field.customPlaceholder;
              }
              if(field && typeof field.customTooltip === 'string'){
                cloned.customTooltip = field.customTooltip;
              }
              return cloned;
            });
          } else {
            out[key] = [];
          }
        });
      }
      return out;
    }
    function cloneCategoryList(list){
      return Array.isArray(list) ? list.map(item => {
        const sortOrder = normalizeCategorySortOrderValue(item ? (item.sort_order ?? item.sortOrder) : null);
        return {
          id: item && Number.isInteger(item.id) ? item.id : (typeof item.id === 'string' && /^\d+$/.test(item.id) ? parseInt(item.id, 10) : null),
          name: item && typeof item.name === 'string' ? item.name : '',
          subs: Array.isArray(item && item.subs) ? item.subs.slice() : [],
          subFields: cloneFieldsMap(item && item.subFields),
          subIds: cloneMapLike(item && item.subIds),
          subHidden: cloneMapLike(item && item.subHidden),
          subFees: cloneMapLike(item && item.subFees),
          sort_order: sortOrder,
          hidden: item && typeof item.hidden === 'boolean' ? item.hidden : false
        };
      }) : [];
    }
    function cloneMapLike(source){
      const out = {};
      if(source && typeof source === 'object'){
        Object.keys(source).forEach(key => {
          out[key] = source[key];
        });
      }
      return out;
    }
    function assignMapLike(target, source){
      if(!target || typeof target !== 'object') return;
      Object.keys(target).forEach(key => { delete target[key]; });
      if(source && typeof source === 'object'){
        Object.keys(source).forEach(key => {
          target[key] = source[key];
        });
      }
    }
    function captureFormbuilderSnapshot(){
      return {
        categories: cloneCategoryList(categories),
        categoryIcons: cloneMapLike(categoryIcons),
        subcategoryIcons: cloneMapLike(subcategoryIcons),
        categoryIconPaths: cloneMapLike(categoryIconPaths),
        subcategoryIconPaths: cloneMapLike(subcategoryIconPaths),
        subcategoryMarkers: cloneMapLike(subcategoryMarkers),
        fieldsets: Array.isArray(FORM_FIELDSETS)
          ? FORM_FIELDSETS.map(option => ({ ...option }))
          : [],
        checkoutOptions: Array.isArray(CHECKOUT_OPTIONS)
          ? CHECKOUT_OPTIONS.map(opt => ({ ...opt }))
          : [],
        currencies: Array.isArray(window.currencies)
          ? [...window.currencies]
          : []
      };
    }
    let savedFormbuilderSnapshot = captureFormbuilderSnapshot();
    function restoreFormbuilderSnapshot(snapshot, options = {}){
      if(!snapshot) return;
      const skipFormbuilderUI = options.skipFormbuilderUI === true;
      const existingFieldsets = (() => {
        if(Array.isArray(initialFormbuilderSnapshot.fieldsets) && initialFormbuilderSnapshot.fieldsets.length){
          return initialFormbuilderSnapshot.fieldsets.map(option => ({ ...option }));
        }
        if(Array.isArray(FORM_FIELDSETS) && FORM_FIELDSETS.length){
          return FORM_FIELDSETS.map(option => ({ ...option }));
        }
        return [];
      })();
      const normalized = normalizeFormbuilderSnapshot(snapshot);
      let sanitizedFieldsets = sanitizeFieldsetOptions(normalized.fieldsets);
      if(sanitizedFieldsets.length === 0 && existingFieldsets.length){
        sanitizedFieldsets = sanitizeFieldsetOptions(existingFieldsets);
      }
      initialFormbuilderSnapshot.fieldsets = sanitizedFieldsets.map(option => ({ ...option }));
      FORM_FIELDSETS.splice(0, FORM_FIELDSETS.length, ...initialFormbuilderSnapshot.fieldsets.map(option => ({ ...option })));
      window.FORM_FIELDSETS = FORM_FIELDSETS;
      
      // Reload fieldset tooltips if messages tab is open (always try to reload)
      if(typeof loadFieldsetTooltips === 'function'){
        setTimeout(() => loadFieldsetTooltips(), 100);
      }
      
      // Update checkout options from snapshot
      if(Array.isArray(normalized.checkoutOptions)){
        initialFormbuilderSnapshot.checkoutOptions = normalized.checkoutOptions.map(opt => ({ ...opt }));
        CHECKOUT_OPTIONS.splice(0, CHECKOUT_OPTIONS.length, ...initialFormbuilderSnapshot.checkoutOptions);
        window.CHECKOUT_OPTIONS = CHECKOUT_OPTIONS;
      }
      
      // Update banned words from snapshot
      if(Array.isArray(normalized.bannedWords)){
        initialFormbuilderSnapshot.bannedWords = [...normalized.bannedWords];
        BANNED_WORDS.splice(0, BANNED_WORDS.length, ...initialFormbuilderSnapshot.bannedWords);
        window.BANNED_WORDS = BANNED_WORDS;
      }
      
      // Update fieldset limits from snapshot (keyed by fieldset_key)
      if(normalized.fieldsetLimits && typeof normalized.fieldsetLimits === 'object'){
        initialFormbuilderSnapshot.fieldsetLimits = { ...normalized.fieldsetLimits };
        Object.keys(FIELD_LIMITS).forEach(key => delete FIELD_LIMITS[key]);
        Object.assign(FIELD_LIMITS, initialFormbuilderSnapshot.fieldsetLimits);
        window.FIELD_LIMITS = FIELD_LIMITS;
      }
      // Update field limits from snapshot (keyed by field_key)
      if(normalized.fieldLimits && typeof normalized.fieldLimits === 'object'){
        initialFormbuilderSnapshot.fieldLimits = { ...normalized.fieldLimits };
        Object.keys(FIELD_RAW_LIMITS).forEach(key => delete FIELD_RAW_LIMITS[key]);
        Object.assign(FIELD_RAW_LIMITS, initialFormbuilderSnapshot.fieldLimits);
        window.FIELD_RAW_LIMITS = FIELD_RAW_LIMITS;
      }

      // Update currencies from snapshot
      if(Array.isArray(normalized.currencies)){
        initialFormbuilderSnapshot.currencies = [...normalized.currencies];
        window.currencies = initialFormbuilderSnapshot.currencies;
      }
      
      const nextCategories = cloneCategoryList(normalized.categories);
      if(Array.isArray(nextCategories)){
        categories.splice(0, categories.length, ...nextCategories);
      }
      categories.forEach(cat => {
        if(!cat || typeof cat !== 'object') return;
        if(!cat.subFields || typeof cat.subFields !== 'object' || Array.isArray(cat.subFields)){
          cat.subFields = {};
        }
        (cat.subs || []).forEach(subName => {
          if(!Array.isArray(cat.subFields[subName])){
            cat.subFields[subName] = [];
          }
        });
      });
      assignMapLike(categoryIcons, snapshot.categoryIcons);
      assignMapLike(subcategoryIcons, snapshot.subcategoryIcons);
      assignMapLike(categoryIconPaths, normalizeIconPathMap(snapshot.categoryIconPaths));
      assignMapLike(subcategoryIconPaths, normalizeIconPathMap(snapshot.subcategoryIconPaths));
      const multiIconSrc = subcategoryMarkers[MULTI_POST_MARKER_ICON_ID];
      Object.keys(subcategoryMarkers).forEach(key => {
        if(key !== MULTI_POST_MARKER_ICON_ID){
          delete subcategoryMarkers[key];
        }
      });
      if(multiIconSrc){
        subcategoryMarkers[MULTI_POST_MARKER_ICON_ID] = multiIconSrc;
      }
      const markerOverrides = snapshot && snapshot.subcategoryMarkers;
      if(markerOverrides && typeof markerOverrides === 'object'){
        Object.keys(markerOverrides).forEach(name => {
          const url = markerOverrides[name];
          if(typeof url !== 'string'){
            return;
          }
          const trimmedUrl = url.trim();
          if(!trimmedUrl){
            return;
          }
          const slugKey = slugify(typeof name === 'string' ? name : '');
          if(slugKey){
            subcategoryMarkers[slugKey] = trimmedUrl;
          }
          if(typeof name === 'string' && name){
            subcategoryMarkers[name] = trimmedUrl;
          }
        });
      }
      renderFilterCategories();
      // SKIP renderFormbuilderCats() on startup - only render when Forms tab opens (this is the slow part)
      if(!skipFormbuilderUI){
        renderFormbuilderCats();
      }
      refreshFormbuilderSubcategoryLogos();
      if(typeof document !== 'undefined' && typeof document.dispatchEvent === 'function'){
        try{
          document.dispatchEvent(new CustomEvent('subcategory-icons-ready'));
        }catch(err){}
      }
      if(window.postsLoaded && window.__markersLoaded && typeof addPostSource === 'function'){
        try{ addPostSource(); }catch(err){ console.error('addPostSource failed after snapshot restore', err); }
      }
      updateFormbuilderSnapshot();
    }
    function updateFormbuilderSnapshot(){
      savedFormbuilderSnapshot = captureFormbuilderSnapshot();
    }
    window.formbuilderStateManager = {
      capture: captureFormbuilderSnapshot,
      restoreSaved(){ restoreFormbuilderSnapshot(savedFormbuilderSnapshot); },
      save(){ updateFormbuilderSnapshot(); },
      getSaved(){ return savedFormbuilderSnapshot ? JSON.parse(JSON.stringify(savedFormbuilderSnapshot)) : null; },
      restore(snapshot, options){ restoreFormbuilderSnapshot(snapshot, options); },
      // LAZY LOADING: Load and restore formbuilder snapshot on-demand
      async ensureLoaded(options = {}){
        if(this._loaded && !options.forceReload) {
          // If already loaded but we need to render formbuilder UI (was skipped on startup), do it now
          // Defer rendering to ensure tab opens first
          if(!options.skipFormbuilderUI && typeof window.renderFormbuilderCats === 'function'){
            setTimeout(() => {
              window.renderFormbuilderCats();
            }, 0);
          }
          return;
        }
        try {
          const snapshot = await getFormbuilderSnapshotPromise();
          if(!snapshot) return;
          if(typeof this.restore === 'function'){
            this.restore(snapshot, options);
          }
          if(typeof this.save === 'function'){
            this.save();
          }
          this._loaded = true;
          // Only regenerate posts if they were created with empty categories (race condition fix)
          // Check if categories now have data but posts cache was built with empty categories
          if(Array.isArray(window.categories) && window.categories.length > 0){
            if(typeof window.invalidateAllPostsCache === 'function' && window.__postsBuiltWithEmptyCategories){
              window.invalidateAllPostsCache();
              window.__postsBuiltWithEmptyCategories = false;
              if(typeof window.scheduleCheckLoadPosts === 'function'){
                window.scheduleCheckLoadPosts();
              }
            }
          }
        } catch(err) {
          console.error('Failed to load formbuilder snapshot:', err);
        }
      },
      _loaded: false
    };
    function updateCategoryResetBtn(){
      if(!resetCategoriesBtn) return;
      const anyCategoryOff = Object.values(categoryControllers).some(ctrl=>ctrl && typeof ctrl.isActive === 'function' && !ctrl.isActive());
      const totalSubs = allSubcategoryKeys.length;
      const activeSubs = selection.subs instanceof Set ? selection.subs.size : 0;
      const anySubOff = totalSubs > 0 && activeSubs < totalSubs;
      resetCategoriesBtn.classList.toggle('active', anyCategoryOff || anySubOff);
    }
    function refreshSubcategoryLogos(){
      Object.values(categoryControllers).forEach(ctrl=>{
        if(ctrl && typeof ctrl.refreshLogos === 'function'){
          ctrl.refreshLogos();
        }
      });
    }
    
    // ============= Messages Tab =============
    const messagesCats = document.getElementById('messagesCats');
    const MESSAGE_CATEGORIES = [
      { name: 'User Messages', key: 'user', icon: '', description: 'Messages for public visitors' },
      { name: 'Member Messages', key: 'member', icon: '', description: 'Messages for authenticated members' },
      { name: 'Admin Messages', key: 'admin', icon: '', description: 'Messages for admin panel' },
      { name: 'Email Messages', key: 'email', icon: '', description: 'Email communications' },
      { name: 'Fieldset Tooltips', key: 'fieldset-tooltips', icon: '', description: 'Tooltip help text for form fieldsets' }
    ];
    
    // Load message category icons from admin_settings
    async function loadMessageCategoryIcons(){
      try {
        const response = await apiRequest('/gateway.php?action=get-admin-settings', {}, 5000);
        if(response.ok){
          const data = await response.json();
          if(data.success && data.settings){
            MESSAGE_CATEGORIES.forEach(cat => {
              const settingKey = `msg_category_${cat.key}_icon`;
              if(data.settings[settingKey]){
                cat.icon = data.settings[settingKey];
              }
            });
          }
        }
      } catch(err) {
        console.error('Failed to load message category icons:', err);
      }
    }
    
    // Load custom category names and icons from database if available
    MESSAGE_CATEGORIES.forEach(cat => {
      // Categories should only come from backend - no localStorage override
      // Removed localStorage fallback to prevent showing stale category data
    });
    
    function renderMessagesCategories(){
      if(!messagesCats) return;
      messagesCats.innerHTML = '';
      const frag = document.createDocumentFragment();
      
      MESSAGE_CATEGORIES.forEach((cat, index) => {
        const menu = document.createElement('div');
        menu.className = 'category-form-menu filter-category-menu messages-category-menu';
        menu.dataset.messageCategory = cat.key;
        menu.setAttribute('role', 'group');
        menu.setAttribute('aria-expanded', 'false');
        
        const header = document.createElement('div');
        header.className = 'formbuilder-category-header';
        
        const triggerWrap = document.createElement('div');
        triggerWrap.className = 'options-dropdown filter-category-trigger-wrap';
        
        const menuBtn = document.createElement('button');
        menuBtn.type = 'button';
        menuBtn.className = 'filter-category-trigger';
        menuBtn.setAttribute('aria-haspopup', 'true');
        menuBtn.setAttribute('aria-expanded', 'false');
        
        const logo = document.createElement('span');
        logo.className = cat.icon ? 'category-logo has-icon' : 'category-logo';
        if(cat.icon){
          const logoImg = document.createElement('img');
          logoImg.src = cat.icon;
          logoImg.alt = '';
          logo.appendChild(logoImg);
        }
        
        const label = document.createElement('span');
        label.className = 'label';
        label.textContent = cat.name;
        
        const arrow = document.createElement('span');
        arrow.className = 'dropdown-arrow';
        arrow.setAttribute('aria-hidden', 'true');
        
        menuBtn.append(logo, label, arrow);
        triggerWrap.appendChild(menuBtn);
        
        const editBtn = document.createElement('button');
        editBtn.type = 'button';
        editBtn.className = 'category-edit-btn';
        editBtn.innerHTML = '<svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor" aria-hidden="true"><path d="M12.854 1.146a.5.5 0 0 1 .707 0l1.293 1.293a.5.5 0 0 1 0 .707l-8.939 8.939a.5.5 0 0 1-.233.131l-3.5.875a.5.5 0 0 1-.606-.606l.875-3.5a.5.5 0 0 1 .131-.233l8.939-8.939z"/><path d="M2.5 12.5V14h1.5l9-9-1.5-1.5-9 9z"/></svg>';
        editBtn.setAttribute('aria-label', `Edit ${cat.name} category`);
        editBtn.setAttribute('aria-expanded', 'false');
        
        const messageDragHandle = createFormbuilderDragHandle(`Reorder ${cat.name} category`, 'category-drag-handle');
        
        header.append(triggerWrap, messageDragHandle, editBtn);
        
        const content = document.createElement('div');
        content.className = 'category-form-content';
        content.hidden = true;
        
        const editPanel = document.createElement('div');
        editPanel.className = 'category-edit-panel';
        editPanel.hidden = true;
        editPanel.style.position = 'absolute';
        editPanel.style.right = '0';
        editPanel.style.top = 'calc(100% + 10px)';
        editPanel.style.zIndex = '100';
        
        const nameInput = document.createElement('input');
        nameInput.type = 'text';
        nameInput.className = 'category-name-input';
        nameInput.placeholder = 'Category Name';
        nameInput.value = cat.name;
        
        // Auto-save category name on change
        nameInput.addEventListener('blur', () => {
          const newName = nameInput.value.trim();
          if(newName && newName !== cat.name){
            cat.name = newName;
            label.textContent = newName;
            const settingKey = `msg_category_${cat.key}_name`;
            fetch('/gateway.php?action=save-admin-settings', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ [settingKey]: newName })
            }).catch(err => console.error('Failed to save category name:', err));
          }
        });
        
        const iconPicker = document.createElement('div');
        iconPicker.className = 'menu menu--system-image-picker';
        
        const iconPickerButton = document.createElement('button');
        iconPickerButton.type = 'button';
        iconPickerButton.className = 'menu-button--system-image-picker';
        iconPickerButton.setAttribute('aria-haspopup', 'true');
        iconPickerButton.setAttribute('aria-expanded', 'false');
        
        const buttonImg = document.createElement('img');
        buttonImg.className = 'menu-button-img--system-image-picker';
        buttonImg.alt = '';
        const buttonLabel = document.createElement('span');
        buttonLabel.className = 'menu-button-label--system-image-picker';
        buttonLabel.textContent = 'Choose Image';
        const buttonArrow = document.createElement('span');
        buttonArrow.className = 'dropdown-arrow';
        buttonArrow.setAttribute('aria-hidden', 'true');
        
        if(cat.icon){
          buttonImg.src = cat.icon;
          iconPickerButton.classList.add('has-image');
          const filename = cat.icon.split('/').pop();
          buttonLabel.textContent = filename;
        }
        
        iconPickerButton.append(buttonImg, buttonLabel, buttonArrow);
        iconPicker.append(iconPickerButton);
        
        // Attach icon picker functionality
        if(typeof window.attachIconPicker === 'function'){
          window.attachIconPicker(iconPickerButton, iconPicker, {
            getCurrentPath: () => cat.icon,
            onSelect: (value) => {
              // Update button preview immediately
              if(value){
                buttonImg.src = value;
                iconPickerButton.classList.add('has-image');
                const filename = value.split('/').pop();
                buttonLabel.textContent = filename;
              } else {
                buttonImg.src = '';
                iconPickerButton.classList.remove('has-image');
                buttonLabel.textContent = 'Choose Image';
              }
              
              // Update category icon
              cat.icon = value || '';
              
              // Update logo in menu header
              const existingLogoImg = logo.querySelector('img');
              if(value){
                if(existingLogoImg){
                  existingLogoImg.src = value;
                } else {
                  const newLogoImg = document.createElement('img');
                  newLogoImg.src = value;
                  newLogoImg.alt = '';
                  logo.appendChild(newLogoImg);
                }
                logo.classList.add('has-icon');
              } else {
                if(existingLogoImg){
                  existingLogoImg.remove();
                }
                logo.classList.remove('has-icon');
              }
              
                // Save to admin_settings
                const settingKey = `msg_category_${cat.key}_icon`;
                fetch('/gateway.php?action=save-admin-settings', {
                  method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' },
                body: JSON.stringify({ [settingKey]: value || '' })
              }).then((response) => {
                if(!response.ok){
                  throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
              }).then((data) => {
                if(data.success){
                  console.log(`Message category icon saved: ${settingKey} = ${value || '(empty)'}`);
                } else {
                  throw new Error(data.message || 'Save failed');
                }
              }).catch(err => {
                console.error('Failed to save category icon:', err);
                alert(`Failed to save icon: ${err.message}`);
              });
            },
            label: `Choose icon for ${cat.name}`,
            parentMenu: content,
            parentCategoryMenu: menu,
            iconFolder: (() => {
              const systemImagesFolderInput = document.getElementById('adminSystemImagesFolder');
              return systemImagesFolderInput?.value.trim() || window.systemImagesFolder || null;
            })()
          });
        }
        
        const saveBtn = document.createElement('button');
        saveBtn.type = 'button';
        saveBtn.className = 'save-changes primary-action formbuilder-inline-save';
        saveBtn.textContent = 'Save';
        saveBtn.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          if(typeof window.adminPanelModule?.runSave === 'function'){
            window.adminPanelModule.runSave({ closeAfter: false });
          }
          editPanel.hidden = true;
          editBtn.setAttribute('aria-expanded', 'false');
        });
        
        editPanel.append(nameInput, iconPicker, saveBtn);
        header.appendChild(editPanel);
        
        menu.append(header, content);
        frag.appendChild(menu);
        
        // Toggle category dropdown on button click
        menuBtn.addEventListener('click', () => {
          const isExpanded = menu.getAttribute('aria-expanded') === 'true';
          menu.setAttribute('aria-expanded', String(!isExpanded));
          menuBtn.setAttribute('aria-expanded', String(!isExpanded));
          content.hidden = isExpanded;
        });
        
        // Toggle edit panel on edit button click
        editBtn.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          // Close all other edit panels
          document.querySelectorAll('.category-edit-panel, .subcategory-edit-panel').forEach(panel => {
            if(panel === editPanel) return;
            panel.hidden = true;
            const relatedButton = panel.parentElement
              ? panel.parentElement.querySelector('.category-edit-btn, .subcategory-edit-btn')
              : null;
            if(relatedButton){
              relatedButton.setAttribute('aria-expanded','false');
            }
          });
          // Toggle this edit panel
          editPanel.hidden = !editPanel.hidden;
          editBtn.setAttribute('aria-expanded', editPanel.hidden ? 'false' : 'true');
        });
        
        // Close edit panel when clicking outside
        const handleEditPointerDown = event => {
          if(editPanel.hidden) return;
          const target = event.target;
          if(editPanel.contains(target)) return;
          const clickedEditBtn = target.closest('.category-edit-btn, .subcategory-edit-btn, .field-edit-btn');
          if(clickedEditBtn) return;
          editPanel.hidden = true;
          editBtn.setAttribute('aria-expanded', 'false');
        };
        document.addEventListener('pointerdown', handleEditPointerDown, true);
      });
      
      messagesCats.appendChild(frag);
    }
    
    // Fetch and populate admin messages from database
    async function loadAdminMessages(){
      try {
        // Fetch messages directly for messages tab to get full container structure
        // This preserves the original container format needed by populateMessagesIntoContainers
        const response = await apiRequest('/gateway.php?action=get-admin-settings&include_messages=true', {}, 5000);
        if(!response.ok){
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        const result = await response.json();
        
        if(result.success && result.messages){
          populateMessagesIntoContainers(result.messages);
        } else {
          console.error('Failed to load admin messages:', result.message || result.messages_error);
        }
      } catch(error){
        console.error('Error loading admin messages:', error);
        // Don't call updateAllMessageElements here - it would overwrite the messages tab
      }
    }
    
    // Load and populate fieldset tooltips
    async function loadFieldsetTooltips(){
      try {
        // Get fieldsets from the snapshot (should be loaded by ensureLoaded before this is called)
        const fieldsets = window.FORM_FIELDSETS || [];
        
        if(!fieldsets.length){
          // Fieldsets not available - this shouldn't happen if ensureLoaded was called first
          return;
        }
        
        
        // Find the fieldset-tooltips category menu
        const categoryMenu = messagesCats?.querySelector(`[data-message-category="fieldset-tooltips"]`);
        if(!categoryMenu) return;
        
        const content = categoryMenu.querySelector('.category-form-content');
        if(!content) return;
        
        // Clear existing content
        content.innerHTML = '';
        
        // Create tooltips list
        if(fieldsets.length > 0){
          const tooltipsList = document.createElement('div');
          tooltipsList.className = 'messages-list';
          
          // Sort fieldsets by sort_order or name
          const sortedFieldsets = [...fieldsets].sort((a, b) => {
            const orderA = a.sort_order !== undefined ? a.sort_order : 999;
            const orderB = b.sort_order !== undefined ? b.sort_order : 999;
            if(orderA !== orderB) return orderA - orderB;
            const nameA = (a.name || a.label || a.value || '').toLowerCase();
            const nameB = (b.name || b.label || b.value || '').toLowerCase();
            return nameA.localeCompare(nameB);
          });
          
          sortedFieldsets.forEach(fieldset => {
            const tooltipItem = document.createElement('div');
            tooltipItem.className = 'message-item';
            tooltipItem.dataset.fieldsetId = fieldset.id;
            tooltipItem.dataset.fieldsetKey = fieldset.key || fieldset.value || '';
            
            // Fieldset label
            const fieldsetLabel = document.createElement('div');
            fieldsetLabel.className = 'message-label';
            fieldsetLabel.textContent = fieldset.name || fieldset.label || fieldset.value || 'Unknown Fieldset';
            
            // Tooltip text display (shown by default)
            const tooltipDisplay = document.createElement('div');
            tooltipDisplay.className = 'message-text-display';
            tooltipDisplay.textContent = fieldset.fieldset_tooltip || '(empty)';
            tooltipDisplay.title = 'Click to edit';
            if(!fieldset.fieldset_tooltip){
              tooltipDisplay.style.color = 'var(--text-muted, #888)';
              tooltipDisplay.style.fontStyle = 'italic';
            }
            
            // Tooltip text input (hidden by default)
            const textArea = document.createElement('textarea');
            textArea.className = 'message-text-input';
            textArea.value = fieldset.fieldset_tooltip || '';
            textArea.rows = 3;
            textArea.placeholder = 'Enter tooltip help text (character limits will be added automatically)';
            textArea.dataset.fieldsetId = fieldset.id;
            textArea.dataset.fieldsetKey = fieldset.key || fieldset.value || '';
            textArea.dataset.originalValue = fieldset.fieldset_tooltip || '';
            textArea.hidden = true;
            
            // Track changes
            textArea.addEventListener('input', () => {
              if(textArea.value !== textArea.dataset.originalValue){
                tooltipItem.classList.add('modified');
                tooltipDisplay.textContent = textArea.value || '(empty)';
                if(!textArea.value){
                  tooltipDisplay.style.color = 'var(--text-muted, #888)';
                  tooltipDisplay.style.fontStyle = 'italic';
                } else {
                  tooltipDisplay.style.color = '';
                  tooltipDisplay.style.fontStyle = '';
                }
                // Mark admin panel as dirty
                if(typeof window.adminPanelModule?.markDirty === 'function'){
                  window.adminPanelModule.markDirty();
                }
              } else {
                tooltipItem.classList.remove('modified');
              }
            });
            
            // Click to switch to edit mode
            tooltipDisplay.addEventListener('click', () => {
              tooltipDisplay.hidden = true;
              textArea.hidden = false;
              textArea.focus();
            });
            
            // Click outside or blur to switch back to display mode
            textArea.addEventListener('blur', () => {
              // Update display with current textarea value before hiding
              tooltipDisplay.textContent = textArea.value || '(empty)';
              
              // Update modified state based on comparison with original
              if(textArea.value !== textArea.dataset.originalValue){
                tooltipItem.classList.add('modified');
                if(!textArea.value){
                  tooltipDisplay.style.color = 'var(--text-muted, #888)';
                  tooltipDisplay.style.fontStyle = 'italic';
                } else {
                  tooltipDisplay.style.color = '';
                  tooltipDisplay.style.fontStyle = '';
                }
                // Mark admin panel as dirty
                if(typeof window.adminPanelModule?.markDirty === 'function'){
                  window.adminPanelModule.markDirty();
                }
              } else {
                tooltipItem.classList.remove('modified');
              }
              
              tooltipDisplay.hidden = false;
              textArea.hidden = true;
            });
            
            tooltipItem.append(fieldsetLabel, tooltipDisplay, textArea);
            tooltipsList.appendChild(tooltipItem);
          });
          
          content.appendChild(tooltipsList);
        } else {
          const emptyMsg = document.createElement('div');
          emptyMsg.className = 'messages-empty';
          emptyMsg.textContent = 'No fieldsets found';
          content.appendChild(emptyMsg);
        }
      } catch(error){
        console.error('Error loading fieldset tooltips:', error);
      }
    }
    
    function populateMessagesIntoContainers(messageContainers){
      // Map container_key to MESSAGE_CATEGORIES key
      const containerKeyMap = {
        'msg_user': 'user',
        'msg_member': 'member',
        'msg_admin': 'admin',
        'msg_email': 'email'
      };
      
      messageContainers.forEach(container => {
        const categoryKey = containerKeyMap[container.container_key];
        if(!categoryKey) return;
        
        // Find the category menu element
        const categoryMenu = messagesCats.querySelector(`[data-message-category="${categoryKey}"]`);
        if(!categoryMenu) return;
        
        const content = categoryMenu.querySelector('.category-form-content');
        if(!content) return;
        
        // Clear existing content
        content.innerHTML = '';
        
        // Create messages list
        if(container.messages && container.messages.length > 0){
          const messagesList = document.createElement('div');
          messagesList.className = 'messages-list';
          
          container.messages.forEach(message => {
            const messageItem = document.createElement('div');
            messageItem.className = 'message-item';
            messageItem.dataset.messageId = message.id;
            messageItem.dataset.messageKey = message.message_key;
            
            // Message label with hover popup
            const messageLabel = document.createElement('div');
            messageLabel.className = 'message-label';
            messageLabel.textContent = message.message_name || message.message_key;
            
            // Create hover popup with metadata
            const hoverPopup = document.createElement('div');
            hoverPopup.className = 'message-hover-popup';
            
            // Type badge in popup
            const typeBadge = document.createElement('span');
            typeBadge.className = `message-type-badge type-${message.message_type}`;
            typeBadge.textContent = message.message_type;
            hoverPopup.appendChild(typeBadge);
            
            // Description in popup
            if(message.message_description){
              const description = document.createElement('div');
              description.className = 'message-popup-description';
              description.textContent = message.message_description;
              hoverPopup.appendChild(description);
            }
            
            // Placeholders in popup
            if(message.placeholders && message.placeholders.length > 0){
              const placeholdersInfo = document.createElement('div');
              placeholdersInfo.className = 'message-popup-placeholders';
              placeholdersInfo.innerHTML = `<strong>Placeholders:</strong> ${message.placeholders.map(p => `<code>{${p}}</code>`).join(', ')}`;
              hoverPopup.appendChild(placeholdersInfo);
            }
            
            messageLabel.appendChild(hoverPopup);
            
            // Message text display (shown by default)
            const messageTextDisplay = document.createElement('div');
            messageTextDisplay.className = 'message-text-display';
            messageTextDisplay.innerHTML = message.message_text || '';
            messageTextDisplay.title = 'Click to edit';
            
            // Message text input (hidden by default)
            const textArea = document.createElement('textarea');
            textArea.className = 'message-text-input';
            textArea.value = message.message_text || '';
            textArea.rows = 3;
            textArea.dataset.messageId = message.id;
            textArea.dataset.originalValue = message.message_text || '';
            textArea.hidden = true;
            
            // Track changes
            textArea.addEventListener('input', () => {
              if(textArea.value !== textArea.dataset.originalValue){
                messageItem.classList.add('modified');
                messageTextDisplay.innerHTML = textArea.value;
                // Mark admin panel as dirty
                if(typeof window.adminPanelModule?.markDirty === 'function'){
                  window.adminPanelModule.markDirty();
                }
              } else {
                messageItem.classList.remove('modified');
              }
            });
            
            // Click to switch to edit mode
            messageTextDisplay.addEventListener('click', () => {
              messageTextDisplay.hidden = true;
              textArea.hidden = false;
              textArea.focus();
            });
            
            // Click outside or blur to switch back to display mode
            textArea.addEventListener('blur', () => {
              // Update display with current textarea value before hiding
              messageTextDisplay.innerHTML = textArea.value;
              
              // Update modified state based on comparison with original
              if(textArea.value !== textArea.dataset.originalValue){
                messageItem.classList.add('modified');
                // Mark admin panel as dirty
                if(typeof window.adminPanelModule?.markDirty === 'function'){
                  window.adminPanelModule.markDirty();
                }
              } else {
                messageItem.classList.remove('modified');
              }
              
              messageTextDisplay.hidden = false;
              textArea.hidden = true;
            });
            
            messageItem.append(messageLabel, messageTextDisplay, textArea);
            messagesList.appendChild(messageItem);
          });
          
          content.appendChild(messagesList);
        } else {
          const emptyMsg = document.createElement('div');
          emptyMsg.className = 'messages-empty';
          emptyMsg.textContent = 'No messages in this category';
          content.appendChild(emptyMsg);
        }
      });
    }
    
    // Initialize messages categories when admin panel opens
    if(messagesCats){
      // Load message category icons before rendering, then load messages after categories exist
      (async function(){
        await loadMessageCategoryIcons();
        renderMessagesCategories();
        // Now that category boxes exist, load messages into them
        loadAdminMessages();
      })();
      
      // Load fieldset tooltips (uses data already in memory, doesn't need to wait)
      loadFieldsetTooltips();
      
      // Add drag and drop functionality for Messages tab categories
      let draggedMessageCategory = null;
      let messageCategoryDropIndicatorTarget = null;
      let messageCategoryDropIndicatorBefore = null;
      
      messagesCats.addEventListener('dragstart', event => {
        const menu = event.target.closest('.messages-category-menu');
        if(!menu) return;
        draggedMessageCategory = menu;
        menu.classList.add('is-dragging');
        if(event.dataTransfer){
          event.dataTransfer.effectAllowed = 'move';
          event.dataTransfer.setData('text/html', menu.innerHTML);
        }
      });
      
      messagesCats.addEventListener('dragend', event => {
        if(draggedMessageCategory){
          draggedMessageCategory.classList.remove('is-dragging');
          draggedMessageCategory = null;
        }
        messageCategoryDropIndicatorTarget = null;
        messageCategoryDropIndicatorBefore = null;
        messagesCats.querySelectorAll('.drag-target-before, .drag-target-after').forEach(el => {
          el.classList.remove('drag-target-before', 'drag-target-after');
        });
      });
      
      messagesCats.addEventListener('dragover', event => {
        if(!draggedMessageCategory) return;
        event.preventDefault();
        if(event.dataTransfer){
          event.dataTransfer.dropEffect = 'move';
        }
        const target = event.target.closest('.messages-category-menu');
        if(!target || target === draggedMessageCategory) return;
        
        const rect = target.getBoundingClientRect();
        const midpoint = rect.top + rect.height / 2;
        const before = event.clientY < midpoint;
        
        if(messageCategoryDropIndicatorTarget && messageCategoryDropIndicatorTarget !== target){
          messageCategoryDropIndicatorTarget.classList.remove('drag-target-before', 'drag-target-after');
        }
        messageCategoryDropIndicatorTarget = target;
        messageCategoryDropIndicatorBefore = before;
        target.classList.remove('drag-target-before', 'drag-target-after');
        target.classList.add(before ? 'drag-target-before' : 'drag-target-after');
      });
      
      messagesCats.addEventListener('drop', event => {
        if(!draggedMessageCategory) return;
        event.preventDefault();
        const target = messageCategoryDropIndicatorTarget;
        const before = messageCategoryDropIndicatorBefore;
        if(target && target !== draggedMessageCategory){
          const reference = before ? target : target.nextSibling;
          if(reference !== draggedMessageCategory && reference !== draggedMessageCategory.nextSibling){
            messagesCats.insertBefore(draggedMessageCategory, reference || null);
          }
        }
      });
    }
    // ============= End Messages Tab =============
    
    function renderFilterCategories(){
      if(!catsEl) return;
      catsEl.textContent = '';
      Object.keys(categoryControllers).forEach(key=>{ delete categoryControllers[key]; });
      allSubcategoryKeys.length = 0;
      selection.cats = new Set();
      selection.subs = new Set();
      const seedSubs = true;
      const sortedCategories = getSortedCategories(categories);
      sortedCategories.forEach(c=>{
        const el = document.createElement('div');
        el.className='filter-category-menu';
        el.dataset.category = c.name;
        el.setAttribute('role','group');
        el.setAttribute('aria-expanded','false');

        const header = document.createElement('div');
        header.className='filter-category-header';

        const triggerWrap = document.createElement('div');
        triggerWrap.className='options-dropdown filter-category-trigger-wrap';

        const menuBtn = document.createElement('button');
        menuBtn.type='button';
        menuBtn.className='filter-category-trigger';
        menuBtn.setAttribute('aria-haspopup','true');
        menuBtn.setAttribute('aria-expanded','false');
        const menuId = `filter-category-menu-${slugify(c.name)}`;
        menuBtn.setAttribute('aria-controls', menuId);

        const categoryLogo = document.createElement('span');
        categoryLogo.className='category-logo';
        const categoryIconHtml = categoryIcons[c.name] || '';
        if(categoryIconHtml){
          categoryLogo.innerHTML = categoryIconHtml;
          categoryLogo.classList.add('has-icon');
        } else {
          categoryLogo.textContent = c.name.charAt(0) || '';
        }

        const label = document.createElement('span');
        label.className='label';
        label.textContent=c.name;

        const arrow = document.createElement('span');
        arrow.className='dropdown-arrow';
        arrow.setAttribute('aria-hidden','true');

        menuBtn.append(categoryLogo, label, arrow);

        const optionsMenu = document.createElement('div');
        optionsMenu.className='options-menu';
        optionsMenu.id = menuId;
        optionsMenu.hidden = true;

        triggerWrap.append(menuBtn, optionsMenu);

        const toggle = document.createElement('label');
        toggle.className='cat-switch';
        const input = document.createElement('input');
        input.type='checkbox';
        input.setAttribute('aria-label',`Toggle ${c.name} category`);
        const slider = document.createElement('span');
        slider.className='slider';
        toggle.append(input, slider);

        const subButtons = [];
        c.subs.forEach(s=>{
          const subBtn=document.createElement('button');
          subBtn.type='button';
          subBtn.className='subcategory-option';
          subBtn.dataset.category = c.name;
          subBtn.dataset.subcategory = s;
          const key = c.name+'::'+s;
          if(!allSubcategoryKeys.includes(key)){
            allSubcategoryKeys.push(key);
          }
          if(seedSubs){
            selection.subs.add(key);
          }
          const isSelected = selection.subs.has(key);
          subBtn.setAttribute('aria-pressed', isSelected ? 'true' : 'false');
          if(isSelected){
            subBtn.classList.add('on');
          }
          subBtn.innerHTML='<span class="subcategory-logo"></span><span class="subcategory-label"></span><span class="subcategory-switch" aria-hidden="true"><span class="track"></span><span class="thumb"></span></span>';
          const subLabel = subBtn.querySelector('.subcategory-label');
          if(subLabel){
            subLabel.textContent = s;
          }
          subBtn.addEventListener('click',()=>{
            if(!input.checked) return;
            const isActive = subBtn.getAttribute('aria-pressed') === 'true';
            if(isActive){
              subBtn.setAttribute('aria-pressed','false');
              subBtn.classList.remove('on');
              selection.subs.delete(key);
            } else {
              subBtn.setAttribute('aria-pressed','true');
              subBtn.classList.add('on');
              selection.subs.add(key);
            }
            applyFilters();
            updateCategoryResetBtn();
          });
          optionsMenu.appendChild(subBtn);
          subButtons.push(subBtn);
        });

        header.append(triggerWrap, toggle);
        el.appendChild(header);
        catsEl.appendChild(el);

        let openState = false;
        function syncExpanded(){
          const expanded = input.checked && openState;
          el.setAttribute('aria-expanded', expanded ? 'true' : 'false');
          menuBtn.setAttribute('aria-expanded', expanded ? 'true' : 'false');
          optionsMenu.hidden = !expanded;
        }
        function setOpenState(next){
          openState = !!next;
          syncExpanded();
        }
        function setCategoryActive(active, opts={}){
          const enabled = !!active;
          input.checked = enabled;
          el.classList.toggle('cat-off', !enabled);
          menuBtn.disabled = !enabled;
          menuBtn.setAttribute('aria-disabled', enabled ? 'false' : 'true');
          subButtons.forEach(btn=>{
            btn.disabled = !enabled;
            btn.setAttribute('aria-disabled', enabled ? 'false' : 'true');
          });
          if(enabled){
            selection.cats.add(c.name);
          } else {
            selection.cats.delete(c.name);
            setOpenState(false);
          }
          syncExpanded();
          if(!opts.silent){
            applyFilters();
            updateResetBtn();
          }
          updateCategoryResetBtn();
        }
        menuBtn.addEventListener('click', ()=>{
          if(menuBtn.disabled) return;
          setOpenState(!openState);
        });
        input.addEventListener('change', ()=>{
          setCategoryActive(input.checked);
        });

        const controller = {
          name: c.name,
          element: el,
          setActive: (active, opts={})=> setCategoryActive(active, opts),
          setOpen: (open)=> setOpenState(open),
          getOpenState: ()=> openState,
          isActive: ()=> input.checked,
          syncSubs: ()=>{
            subButtons.forEach(btn=>{
              const subName = btn.dataset.subcategory;
              const key = c.name+'::'+subName;
              const selected = selection.subs.has(key);
              btn.setAttribute('aria-pressed', selected ? 'true' : 'false');
              btn.classList.toggle('on', selected);
            });
          },
          refreshLogos: ()=>{
            if(categoryLogo){
              const catIconHtml = categoryIcons[c.name] || '';
              if(catIconHtml){
                categoryLogo.innerHTML = catIconHtml;
                categoryLogo.classList.add('has-icon');
              } else {
                categoryLogo.textContent = c.name.charAt(0) || '';
                categoryLogo.classList.remove('has-icon');
              }
            }
            subButtons.forEach(btn=>{
              const logoSpan = btn.querySelector('.subcategory-logo');
              if(!logoSpan) return;
              const iconHtml = subcategoryIcons[btn.dataset.subcategory] || '';
              if(iconHtml){
                logoSpan.innerHTML = iconHtml;
                logoSpan.classList.add('has-icon');
              } else {
                const label = btn.dataset.subcategory || '';
                logoSpan.textContent = label.charAt(0) || '';
                logoSpan.classList.remove('has-icon');
              }
            });
          }
        };
        categoryControllers[c.name] = controller;
        setCategoryActive(true, {silent:true});
        controller.syncSubs();
        syncExpanded();
      });
      refreshSubcategoryLogos();
      updateCategoryResetBtn();
      updateResetBtn();
    }
    if(catsEl){
      renderFilterCategories();
      renderFormbuilderCats();
      updateFormbuilderSnapshot();
      const handleIconsReady = ()=>{
        refreshSubcategoryLogos();
        refreshFormbuilderSubcategoryLogos();
      };
      document.addEventListener('subcategory-icons-ready', handleIconsReady);
    }

    if(resetCategoriesBtn){
      resetCategoriesBtn.addEventListener('click', ()=>{
        selection.subs = new Set(allSubcategoryKeys);
        Object.values(categoryControllers).forEach(ctrl=>{
          ctrl.setActive(true, {silent:true});
          ctrl.setOpen(false);
          ctrl.syncSubs();
        });
        applyFilters();
        updateResetBtn();
        updateCategoryResetBtn();
      });
    }

    // Reset
    $('#resetBtn').addEventListener('click',()=>{
      $('#keyword-textbox').value='';
      $('#daterange-textbox').value='';
      const minPriceInput = $('#min-price-input');
      const maxPriceInput = $('#max-price-input');
      if(minPriceInput) minPriceInput.value='';
      if(maxPriceInput) maxPriceInput.value='';
      const expired = $('#expiredToggle');
      if(expired){
        expired.checked = false;
        expiredWasOn = false;
      }
      dateStart = null;
      dateEnd = null;
      dateRangeWasCleared = true;
      buildFilterCalendar(minPickerDate, maxPickerDate);
      updateRangeClasses();
      updateInput();
      closeCalendarPopup();
      if(geocoder) geocoder.clear();
      applyFilters();
      updateClearButtons();
    });

    function updateClearButtons(){
      const kw = $('#keyword-textbox');
      const kwX = kw.parentElement.querySelector('.keyword-clear-button');
      kwX && kwX.classList.toggle('active', kw.value.trim() !== '');
      const minPriceInput = $('#min-price-input');
      const maxPriceInput = $('#max-price-input');
      const priceClear = $('#filterPanel .price-clear-button');
      const hasPrice = (minPriceInput && minPriceInput.value.trim() !== '') || (maxPriceInput && maxPriceInput.value.trim() !== '');
      priceClear && priceClear.classList.toggle('active', hasPrice);
      const date = $('#daterange-textbox');
      const dateX = date.parentElement.querySelector('.daterange-clear-button');
      const hasDate = (dateStart || dateEnd) || $('#expiredToggle').checked;
      dateX && dateX.classList.toggle('active', !!hasDate);
      updateResetBtn();
    }

    function nonLocationFiltersActive(){
      const kw = $('#keyword-textbox').value.trim() !== '';
      const raw = $('#daterange-textbox').value.trim();
      const hasDate = !!(dateStart || dateEnd || raw);
      const expired = $('#expiredToggle').checked;
      const {min, max} = getPriceFilterValues();
      const priceActive = min !== null || max !== null;
      return kw || hasDate || expired || priceActive;
    }

    function updateResetBtn(){
      const active = nonLocationFiltersActive();
      document.body.classList.toggle('filters-active', active);
      const reset = $('#resetBtn');
      reset && reset.classList.toggle('active', active);
    }

    function fmtShort(iso){
      return parseISODate(iso).toLocaleDateString('en-GB', {weekday:'short', day:'numeric', month:'short'}).replace(/,/g,'');
    }

    const dateRangeInput = $('#daterange-textbox');
    $('#keyword-textbox').addEventListener('input', ()=>{ applyFilters(); updateClearButtons(); });
    const minPriceInput = $('#min-price-input');
    const maxPriceInput = $('#max-price-input');
    [minPriceInput, maxPriceInput].forEach(input=>{
      if(!input) return;
      input.addEventListener('input', ()=>{
        const sanitized = input.value.replace(/\D+/g,'');
        if(sanitized !== input.value){ input.value = sanitized; }
        applyFilters();
        updateClearButtons();
      });
    });
    dateRangeInput?.addEventListener('input', ()=>{ applyFilters(); updateClearButtons(); });
    if(dateRangeInput){
      dateRangeInput.addEventListener('focus', ()=> openCalendarPopup());
      dateRangeInput.addEventListener('click', ()=> openCalendarPopup());
    }
    $('#daterange-textbox').addEventListener('keydown', e=>{
      if(e.key === 'Tab'){
        closeCalendarPopup();
        return;
      }
      if(e.key === 'Escape'){
        e.preventDefault();
        closeCalendarPopup();
        return;
      }
      if(e.key === 'Enter' || e.key === ' ' || e.key === 'ArrowDown'){
        e.preventDefault();
        openCalendarPopup(true);
        return;
      }
      if(e.key==='ArrowLeft' || e.key==='ArrowRight'){
        e.preventDefault();
        openCalendarPopup();
        const month = calendarScroll ? calendarScroll.querySelector('.month') : null;
        const w = month ? month.offsetWidth : 0;
        if(calendarScroll && w){
          calendarScroll.scrollBy({left:e.key==='ArrowLeft'?-w:w, behavior:'smooth'});
        }
        return;
      }
      e.preventDefault();
    });
    const today = new Date();
    today.setHours(0,0,0,0);
    const minPickerDate = new Date(today);
    minPickerDate.setMonth(minPickerDate.getMonth() - 12);
    const maxPickerDate = new Date(today);
    maxPickerDate.setFullYear(maxPickerDate.getFullYear() + 2);
    const expiredToggle = $('#expiredToggle');
    const calendarScroll = $('#datePickerContainer');
    const filterBasics = $('#filterPanel .filter-basics-container');
    const filterPanelBody = $('#filterPanel .panel-body');
    let calendarPopupOpen = false;
    let calendarFirstOpen = true;
    let lastExpiredState = null;
    let dateRangeWasCleared = false;

    function positionCalendarPopup(){
      if(!calendarScroll || !dateRangeInput || !filterBasics) return;
      const inputRect = dateRangeInput.getBoundingClientRect();
      const containerRect = filterBasics.getBoundingClientRect();
      const left = inputRect.left - containerRect.left;
      const top = inputRect.bottom - containerRect.top + 8;
      const popupWidth = calendarScroll.offsetWidth || 0;
      const maxLeft = Math.max(0, containerRect.width - popupWidth);
      const clampedLeft = Math.min(Math.max(left, 0), maxLeft);
      calendarScroll.style.left = `${Math.round(clampedLeft)}px`;
      calendarScroll.style.top = `${Math.round(top)}px`;
    }

    function handleCalendarOutsideClick(e){
      if(!calendarScroll) return;
      if(calendarScroll.contains(e.target)) return;
      if(dateRangeInput && dateRangeInput.contains(e.target)) return;
      closeCalendarPopup();
    }

    function openCalendarPopup(focusCalendar = false){
      if(!calendarScroll) return;
      
      // Rebuild calendar only if expired state changed
      const expiredChecked = expiredToggle && expiredToggle.checked;
      if(lastExpiredState !== expiredChecked){
        lastExpiredState = expiredChecked;
        const minDate = expiredChecked ? minPickerDate : today;
        buildFilterCalendar(minDate, maxPickerDate);
        // Scroll to today after rebuild
        setTimeout(() => scrollCalendarToToday('auto'), 0);
      }
      
      if(!calendarPopupOpen){
        calendarPopupOpen = true;
        calendarScroll.classList.add('is-visible');
        calendarScroll.setAttribute('tabindex','0');
        calendarScroll.setAttribute('aria-hidden','false');
        if(dateRangeInput) dateRangeInput.setAttribute('aria-expanded','true');
        document.addEventListener('click', handleCalendarOutsideClick, true);
        window.addEventListener('resize', positionCalendarPopup);
        filterPanelBody?.addEventListener('scroll', positionCalendarPopup, { passive:true });
        
        // Scroll to today on first open, after clear, or expired state change
        if(calendarFirstOpen || dateRangeWasCleared){
          calendarFirstOpen = false;
          dateRangeWasCleared = false;
          setTimeout(() => scrollCalendarToToday('auto'), 0);
        }
      }
      
      positionCalendarPopup();
      if(focusCalendar){
        calendarScroll.focus({ preventScroll:true });
      }
    }

    function closeCalendarPopup(){
      if(!calendarScroll || !calendarPopupOpen) return;
      calendarPopupOpen = false;
      if(calendarScroll.contains(document.activeElement)){
        const activeEl = document.activeElement;
        if(activeEl && typeof activeEl.blur === 'function'){
          activeEl.blur();
        }
      }
      calendarScroll.setAttribute('tabindex','-1');
      calendarScroll.classList.remove('is-visible');
      calendarScroll.setAttribute('aria-hidden','true');
      if(dateRangeInput) dateRangeInput.setAttribute('aria-expanded','false');
      document.removeEventListener('click', handleCalendarOutsideClick, true);
      window.removeEventListener('resize', positionCalendarPopup);
      filterPanelBody?.removeEventListener('scroll', positionCalendarPopup);
    }

    function verticalCanScroll(el, delta){
      if(!el) return false;
      if(delta < 0) return el.scrollTop > 0;
      if(delta > 0) return el.scrollTop < el.scrollHeight - el.clientHeight;
      return false;
    }

    function setupHorizontalWheel(scroller){
      if(!scroller) return;
      scroller.addEventListener('wheel', e=>{
        const delta = Math.abs(e.deltaX) > Math.abs(e.deltaY) ? e.deltaX : e.deltaY;
        if(delta !== 0){
          scroller.scrollLeft += delta;
          e.preventDefault();
        }
      }, {passive:false});
    }
    
    function setupCalendarScrollRestriction(){
      if(!calendarScroll) return;
      calendarScroll.addEventListener('scroll', ()=>{
        const expiredChecked = expiredToggle && expiredToggle.checked;
        if(!expiredChecked && calendarScroll.dataset.todayScroll){
          const todayScrollPos = parseFloat(calendarScroll.dataset.todayScroll) || 0;
          if(calendarScroll.scrollLeft < todayScrollPos){
            calendarScroll.scrollLeft = todayScrollPos;
          }
        }
      }, {passive:true});
    }

    function smoothScroll(el, to, duration=600){
      const start = el.scrollLeft;
      const change = to - start;
      const startTime = performance.now();
      function animate(time){
        const elapsed = time - startTime;
        const progress = Math.min(elapsed / duration, 1);
        el.scrollLeft = start + change * progress;
        if(progress < 1) requestAnimationFrame(animate);
      }
      requestAnimationFrame(animate);
    }

    function setupCalendarScroll(scroller){
      if(!scroller) return;
      scroller.setAttribute('tabindex','0');
      setupHorizontalWheel(scroller);
      const container = scroller.closest('.calendar-container');
      const adjustScale = () => {
        if(!container) return;
        const base = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--calendar-width')) || 0;
        const available = container.parentElement ? container.parentElement.clientWidth : container.clientWidth;
        const scale = base ? Math.min(1, available / base) : 1;
        container.style.setProperty('--calendar-scale', scale);
        if(calendarPopupOpen){
          positionCalendarPopup();
        }
      };
      if('ResizeObserver' in window && container){
        const ro = new ResizeObserver(adjustScale);
        ro.observe(container);
      }
      adjustScale();
      scroller.addEventListener('keydown', e=>{
        if(e.key==='Escape'){
          e.preventDefault();
          closeCalendarPopup();
          dateRangeInput?.focus({ preventScroll:true });
          return;
        }
        if(e.key==='ArrowLeft' || e.key==='ArrowRight'){
          const m = scroller.querySelector('.month') || scroller.querySelector('.month-item');
          const w = m ? m.offsetWidth : 0;
          scroller.scrollLeft += e.key==='ArrowLeft'?-w:w;
          e.preventDefault();
        }
      });
        addPassiveScrollListener(scroller, ()=>{
          const marker = scroller.querySelector('.today-marker');
          if(marker){
            const base = parseFloat(marker.dataset.pos || '0');
            marker.style.left = `${base + Math.round(scroller.scrollLeft)}px`;
          }
        });
      }
      setupCalendarScroll(calendarScroll);
      expiredWasOn = expiredToggle && expiredToggle.checked;

    function scrollCalendarToToday(behavior='auto'){
      const calScroll = $('#datePickerContainer');
      if(!calScroll) return;
      const todayCell = calScroll.querySelector('.day.today');
      if(todayCell){
        const month = todayCell.closest('.month');
        const left = month ? month.offsetLeft : 0;
        calScroll.dataset.todayScroll = left;
        calScroll.scrollTo({left, behavior});
        const marker = calScroll.querySelector('.today-marker');
        if(marker){
          const base = parseFloat(marker.dataset.pos || '0');
          marker.style.left = `${base + left}px`;
        }
      }
    }
    window.scrollCalendarToToday = scrollCalendarToToday;

    function formatDisplay(date){
      const wd = date.toLocaleDateString('en-GB',{weekday:'short'});
      const day = date.getDate();
      const mon = date.toLocaleDateString('en-GB',{month:'short'});
      let str = `${wd} ${day} ${mon}`;
      if(date.getFullYear() !== today.getFullYear()) str += `, ${date.getFullYear()}`;
      return str;
    }

    function orderedRange(){
      if(dateStart && dateEnd){
        return dateStart <= dateEnd ? {start:dateStart,end:dateEnd} : {start:dateEnd,end:dateStart};
      }
      return {start:dateStart,end:dateEnd};
    }

    function sameDay(a,b){ return a.toDateString()===b.toDateString(); }
    function isToday(d){ return sameDay(d,today); }

    function updateRangeClasses(){
      const {start,end} = orderedRange();
      $('#datePicker').querySelectorAll('.day').forEach(day=>{
        const iso = day.dataset.iso;
        if(!iso) return;
        const [yy, mm, dd] = iso.split('-').map(Number);
        const d = new Date(yy, mm - 1, dd);
        day.classList.remove('selected','in-range','range-start','range-end');
        if(start && sameDay(d, start)) day.classList.add('selected','range-start');
        if(end && sameDay(d, end)) day.classList.add('selected','range-end');
        if(start && end && d>start && d<end) day.classList.add('in-range');
      });
    }

    function updateInput(){
      const input = $('#daterange-textbox');
      const {start,end} = orderedRange();
      if(start && end){
        input.value = `${formatDisplay(start)} - ${formatDisplay(end)}`;
      } else if(start){
        input.value = formatDisplay(start);
      } else {
        input.value = '';
      }
      applyFilters();
      updateClearButtons();
    }

    function selectRangeDate(date){
      if(!dateStart || dateEnd){ dateStart = date; dateEnd = null; }
      else { dateEnd = date; }
      updateRangeClasses();
      updateInput();
      if(dateEnd){
        closeCalendarPopup();
      }
    }

    function buildFilterCalendar(minDate, maxDate){
      const container = $('#datePicker');
      container.innerHTML='';
      const cal = document.createElement('div');
      cal.className='calendar';
      let current = new Date(minDate.getFullYear(), minDate.getMonth(),1);
      const end = new Date(maxDate.getFullYear(), maxDate.getMonth(),1);
      const todayDate = new Date();
      todayDate.setHours(0,0,0,0);
      let monthIndex = 0;
      let currentMonthIndex = 0;
      while(current <= end){
        const monthEl = document.createElement('div');
        monthEl.className='month';
        const header = document.createElement('div');
        header.className='calendar-header';
        header.textContent=current.toLocaleDateString('en-GB',{month:'long',year:'numeric'});
        monthEl.appendChild(header);
        const grid = document.createElement('div');
        grid.className='grid';

        const weekdays=['Sun','Mon','Tue','Wed','Thu','Fri','Sat'];
        weekdays.forEach(wd=>{
          const w=document.createElement('div');
          w.className='weekday';
          w.textContent=wd;
          grid.appendChild(w);
        });

        const firstDay = new Date(current.getFullYear(), current.getMonth(),1);
        const startDow = firstDay.getDay();
        const daysInMonth = new Date(current.getFullYear(), current.getMonth()+1,0).getDate();
        const totalCells = 42;
        for(let i=0;i<totalCells;i++){
          const cell=document.createElement('div');
          cell.className='day';
          const dayNum=i-startDow+1;
          if(i<startDow || dayNum>daysInMonth){
            cell.classList.add('empty');
          }else{
            cell.textContent=dayNum;
            const date=new Date(current.getFullYear(), current.getMonth(), dayNum);
            cell.dataset.iso = toISODate(date);
            if(date < todayDate) cell.classList.add('past');
            else cell.classList.add('future');
            if(isToday(date)) cell.classList.add('today');
            if(date >= minDate) cell.addEventListener('click', ()=> selectRangeDate(date));
          }
          grid.appendChild(cell);
        }
        monthEl.appendChild(grid);
        cal.appendChild(monthEl);
        if(current.getFullYear() === todayDate.getFullYear() && current.getMonth() === todayDate.getMonth()){
          currentMonthIndex = monthIndex;
        }
        current.setMonth(current.getMonth()+1);
        monthIndex++;
      }
      container.appendChild(cal);
      updateRangeClasses();
      if(calendarScroll){
        const monthWidth = cal.querySelector('.month').offsetWidth;
        const scrollPos = monthWidth * currentMonthIndex;
        const maxScroll = calendarScroll.scrollWidth - calendarScroll.clientWidth;
        const track = calendarScroll.clientWidth - 20;
        const pos = maxScroll ? scrollPos / maxScroll * track + 10 : 10;
        calendarScroll.querySelector('.today-marker')?.remove();
        const marker = document.createElement('div');
        marker.className = 'today-marker';
        marker.dataset.pos = pos;
        calendarScroll.appendChild(marker);
        marker.addEventListener('click', ()=> scrollCalendarToToday('smooth'));
      }
    }

    buildFilterCalendar(minPickerDate, maxPickerDate);
    setupCalendarScrollRestriction();
    closeCalendarPopup();

    $$('#filterPanel .keyword-clear-button, #filterPanel .daterange-clear-button, #filterPanel .price-clear-button').forEach(btn=> btn.addEventListener('click',()=>{
      if(btn.classList.contains('price-clear-button')){
        const minInputEl = $('#min-price-input');
        const maxInputEl = $('#max-price-input');
        if(minInputEl) minInputEl.value='';
        if(maxInputEl) maxInputEl.value='';
        (minInputEl || maxInputEl)?.focus();
        applyFilters();
        updateClearButtons();
        return;
      }
      const input = btn.parentElement.querySelector('input');
      if(input){
        if(input.id==='daterange-textbox'){
          dateStart = null;
          dateEnd = null;
          updateRangeClasses();
          updateInput();
          const expiredToggle = $('#expiredToggle');
          if(expiredToggle) expiredToggle.checked = false;
          dateRangeWasCleared = true;
        } else {
          input.value='';
          input.focus();
        }
        applyFilters();
        updateClearButtons();
      }
    }));
    if(expiredToggle){
      expiredToggle.addEventListener('change', ()=>{
        const input = $('#daterange-textbox');
        const todayDate = new Date();
        todayDate.setHours(0,0,0,0);
        dateStart = null;
        dateEnd = null;
        if(expiredToggle.checked){
          buildFilterCalendar(minPickerDate, maxPickerDate);
        } else {
          buildFilterCalendar(todayDate, maxPickerDate);
        }
        expiredWasOn = expiredToggle.checked;
        updateRangeClasses();
        updateInput();
        closeCalendarPopup();
      });
      if(expiredToggle.checked){
        expiredToggle.dispatchEvent(new Event('change'));
      }
    }
    updateClearButtons();
    updateResetBtn();
    const optionsBtn = $('#optionsBtn');
    const optionsMenu = $('#optionsMenu');
    const favToggle = $('#favToggle');
    const sortButtons = $$('.sort-option');

    function updateSortBtnLabel(text){
      const hasMultiple = optionsMenu.querySelectorAll('button').length > 1;
      if(hasMultiple){
        optionsBtn.innerHTML = `${text}<span class="results-arrow" aria-hidden="true"></span>`;
      } else {
        optionsBtn.textContent = text;
      }
    }

    updateSortBtnLabel(optionsBtn.textContent);

    favToggle.addEventListener('click', ()=>{
      favToTop = !favToTop;
      favSortDirty = favToTop ? false : true;
      favToggle.setAttribute('aria-pressed', favToTop);
      renderLists(filtered);
    });

    sortButtons.forEach(btn=>{
      btn.addEventListener('click', ()=>{
        currentSort = btn.dataset.sort;
        sortButtons.forEach(b=> b.setAttribute('aria-pressed', b===btn ? 'true' : 'false'));
        updateSortBtnLabel(btn.textContent);
        renderLists(filtered);
      });
    });

    optionsBtn.addEventListener('click', e=>{
      e.stopPropagation();
      const open = !optionsMenu.hasAttribute('hidden');
      if(open){
        optionsMenu.setAttribute('hidden','');
        optionsBtn.setAttribute('aria-expanded','false');
      } else {
        optionsMenu.removeAttribute('hidden');
        optionsBtn.setAttribute('aria-expanded','true');
      }
    });
    optionsMenu.addEventListener('click', e=> e.stopPropagation());
      document.addEventListener('click', ()=>{
        optionsMenu.setAttribute('hidden','');
        optionsBtn.setAttribute('aria-expanded','false');
      });

      const recentsBoard = $('#recentsBoard');
      const adBoard = $('.ad-board');
      const boardsContainer = $('.post-mode-boards');
      const postBoard = $('.post-board');
      const recentsButton = $('#recents-button');
      const postsButton = $('#posts-button');
      const mapButton = $('#map-button');
      const boardDisplayCache = new WeakMap();
      let boardsInitialized = false;
      let userClosedPostBoard = false;
      const WIDE_SCREEN_MULTI_POST_MIN_WIDTH = 1200;

      function isWideScreenPostBoard(){
        return window.innerWidth >= WIDE_SCREEN_MULTI_POST_MIN_WIDTH;
      }

      function autoOpenPostBoardForMultiPost({ multiIds = [], multiCount = 0, trigger = 'click' } = {}){
        if(trigger !== 'click' && trigger !== 'touch') return;
        if(userClosedPostBoard) return;
        if(!isWideScreenPostBoard()) return;
        const normalizedIds = Array.isArray(multiIds)
          ? multiIds.map(id => String(id)).filter(Boolean)
          : [];
        const numericCount = Number(multiCount);
        const normalizedCount = Number.isFinite(numericCount) && numericCount > 0 ? numericCount : 0;
        const total = Math.max(normalizedIds.length, normalizedCount, 0);
        if(total <= 1) return;
        if(typeof setMode !== 'function') return;
        const wasPostsMode = document.body.classList.contains('mode-posts');
        const hadHistory = document.body.classList.contains('show-history');
        if(hadHistory){
          document.body.classList.remove('show-history');
        }
        if(!wasPostsMode){
          setMode('posts');
        } else if(hadHistory && typeof adjustBoards === 'function'){
          adjustBoards();
        }
      }

      updatePostsButtonState = function(currentZoom){
        const threshold = MARKER_ZOOM_THRESHOLD;
        let zoomValue = Number.isFinite(currentZoom) ? currentZoom : null;
        if(!Number.isFinite(zoomValue) && map && typeof map.getZoom === 'function'){
          try{ zoomValue = map.getZoom(); }catch(err){ zoomValue = null; }
        }
        const postsEnabled = Number.isFinite(zoomValue) ? zoomValue >= threshold : false;
        if(postsButton){
          postsButton.setAttribute('aria-disabled', postsEnabled ? 'false' : 'true');
          postsButton.classList.toggle('is-disabled', !postsEnabled);
        }
        document.body.classList.toggle('hide-posts-ui', !postsEnabled);
        if(!postsEnabled){
          if(typeof setMode === 'function' && document.body.classList.contains('mode-posts')){
            setMode('map', true);
          }
          document.body.classList.remove('show-history');
          if(typeof adjustBoards === 'function'){ adjustBoards(); }
          if(typeof updateModeToggle === 'function'){ updateModeToggle(); }
        }
      };

      updatePostsButtonState(startZoom);

      // Add click handler for disabled posts button
      if(postsButton){
        postsButton.addEventListener('click', (e) => {
          if(postsButton.classList.contains('is-disabled')){
            e.preventDefault();
            e.stopPropagation();
            showZoomToast();
            return false;
          }
        }, true);
      }

      async function showZoomToast(){
        let toast = document.getElementById('zoom-toast');
        if(!toast){
          toast = document.createElement('div');
          toast.id = 'zoom-toast';
          toast.className = 'zoom-toast';
          document.body.appendChild(toast);
        }
        
        const msg = await getMessage('msg_map_zoom_required', {}, false) || 'Zoom the map to see posts';
        toast.textContent = msg;
        toast.classList.add('show');
        setTimeout(() => {
          toast.classList.remove('show');
        }, 2000);
      }

      function getDefaultBoardDisplay(board){
        if(!board) return 'block';
        if(boardDisplayCache.has(board)) return boardDisplayCache.get(board);
        let value = '';
        try{
          value = getComputedStyle(board).display;
        }catch(err){ value = ''; }
        if(!value || value === 'none'){
          if(board.classList.contains('post-board')) value = 'flex';
          else if(board.classList.contains('ad-board')) value = 'block';
          else value = 'block';
        }
        boardDisplayCache.set(board, value);
        return value;
      }

      function clearBoardHide(board){
        if(!board) return;
        if(board._boardHideHandler){
          board.removeEventListener('transitionend', board._boardHideHandler);
          board._boardHideHandler = null;
        }
        if(board._boardHideTimer){
          clearTimeout(board._boardHideTimer);
          board._boardHideTimer = null;
        }
      }

      function showBoard(board, immediate=false){
        if(!board) return;
        clearBoardHide(board);
        const defaultDisplay = getDefaultBoardDisplay(board);
        board.style.display = defaultDisplay;
        board.setAttribute('aria-hidden','false');
        if(immediate){
          board.classList.add('panel-visible');
          board.style.transform = '';
        } else {
          const wasHidden = !board.classList.contains('panel-visible');
          schedulePanelEntrance(board, wasHidden);
        }
      }

      function hideBoard(board, immediate=false){
        if(!board) return;
        clearBoardHide(board);
        board.setAttribute('aria-hidden','true');
        const finalize = ()=>{
          board.style.display = 'none';
          board._boardHideHandler = null;
          board._boardHideTimer = null;
          try{
            board.style.removeProperty('transform');
          }catch(err){}
        };
        if(immediate){
          board.classList.remove('panel-visible');
          finalize();
          return;
        }
        if(!board.classList.contains('panel-visible')){
          finalize();
          return;
        }
        const handler = event=>{
          if(event && event.target !== board) return;
          board.removeEventListener('transitionend', handler);
          finalize();
        };
        board._boardHideHandler = handler;
        board.addEventListener('transitionend', handler);
        const removeVisible = ()=>{
          if(!board.isConnected){
            board.removeEventListener('transitionend', handler);
            finalize();
            return;
          }
          board.classList.remove('panel-visible');
        };
        if('requestAnimationFrame' in window){
          requestAnimationFrame(removeVisible);
        } else {
          removeVisible();
        }
        board._boardHideTimer = setTimeout(()=>{
          if(board._boardHideHandler){
            board._boardHideHandler();
          }
        }, 400);
      }

      function toggleBoard(board, shouldShow, immediate=false){
        if(shouldShow){
          showBoard(board, immediate);
        } else {
          hideBoard(board, immediate);
        }
      }

      function updateModeToggle(){
        const historyActive = document.body.classList.contains('show-history');
        const isPostsMode = document.body.classList.contains('mode-posts');
        const isMapMode = document.body.classList.contains('mode-map');
        if(recentsButton){
          recentsButton.setAttribute('aria-pressed', historyActive ? 'true' : 'false');
        }
        if(postsButton){
          postsButton.setAttribute('aria-pressed', !historyActive && isPostsMode ? 'true' : 'false');
        }
        if(mapButton){
          mapButton.setAttribute('aria-pressed', isMapMode ? 'true' : 'false');
        }
      }

      function adjustBoards(){
        const small = window.innerWidth < 1200;
        const historyActive = document.body.classList.contains('show-history');
        const isPostsMode = document.body.classList.contains('mode-posts');
        const filterPanel = document.getElementById('filterPanel');
        const filterContent = filterPanel ? filterPanel.querySelector('.panel-content') : null;
        const pinBtn = filterPanel ? filterPanel.querySelector('.pin-panel') : null;
        const filterPinned = !!(filterPanel && filterPanel.classList.contains('show') && pinBtn && pinBtn.getAttribute('aria-pressed') === 'true');
        const historyOpenPost = recentsBoard ? recentsBoard.querySelector('.open-post') : null;
        const postsOpenPost = postBoard ? postBoard.querySelector('.open-post') : null;
        const anyOpenPost = historyOpenPost || postsOpenPost;
        const gap = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--gap')) || 10;
        let filterWidth = filterPinned && filterContent ? filterContent.getBoundingClientRect().width : 0;
        const postWidth = postBoard ? (postBoard.offsetWidth || 530) : 0;
        const historyWidth = recentsBoard ? (recentsBoard.offsetWidth || 530) : 0;
        const boardsWidths = [];
        if(historyActive && recentsBoard){
          boardsWidths.push(historyWidth);
        } else if(postBoard){
          boardsWidths.push(postWidth);
        }
        let totalBoardsWidth = boardsWidths.reduce((sum, w)=> sum + w, 0);
        if(boardsWidths.length > 1){
          totalBoardsWidth += gap * (boardsWidths.length - 1);
        }
        const adWidth = adBoard ? (adBoard.offsetWidth || 440) : 0;
        const shouldShowAds = adBoard && window.innerWidth >= 1900;
        let hideAds = !shouldShowAds || !isPostsMode;
        let requiredWidth = totalBoardsWidth;
        if(filterPinned && filterWidth){
          requiredWidth += filterWidth;
        } else {
          filterWidth = 0;
        }
        if(shouldShowAds && adWidth){
          requiredWidth += adWidth + gap;
        }
        const canAnchor = filterPinned && filterWidth && requiredWidth <= window.innerWidth;
        document.body.classList.toggle('filter-anchored', canAnchor);
        document.documentElement.style.setProperty('--filter-panel-offset', canAnchor ? `${filterWidth}px` : '0px');
        boardsContainer.style.justifyContent = 'flex-start';
        const skipAnimation = !boardsInitialized;
        toggleBoard(recentsBoard, isPostsMode && historyActive, skipAnimation);
        toggleBoard(postBoard, isPostsMode && !historyActive, skipAnimation);
        document.body.classList.toggle('detail-open', !!anyOpenPost);
        if(adBoard){
          toggleBoard(adBoard, isPostsMode && !hideAds && shouldShowAds, skipAnimation);
        }
        document.body.classList.toggle('hide-ads', hideAds);
        updateModeToggle();
        boardsInitialized = true;
      }
      window.adjustBoards = adjustBoards;
      adjustBoards();
      window.addEventListener('resize', adjustBoards);
      window.adjustListHeight();
        setTimeout(()=>{
          if(map && typeof map.resize === 'function'){
            map.resize();
            updatePostPanel();
            applyFilters();
          }
        }, 0);

      recentsButton && recentsButton.addEventListener('click', ()=>{
        const isPostsMode = document.body.classList.contains('mode-posts');
        const historyActive = document.body.classList.contains('show-history');
        if(isPostsMode && historyActive){
          userClosedPostBoard = true;
          setModeFromUser('map');
          return;
        }
        setMode('posts');
        document.body.classList.add('show-history');
        renderHistoryBoard();
        adjustBoards();
        setTimeout(()=>{
          if(map && typeof map.resize === 'function'){
            map.resize();
            updatePostPanel();
          }
        }, 300);
        updateModeToggle();
      });

      postsButton && postsButton.addEventListener('click', ()=>{
        const historyActive = document.body.classList.contains('show-history');
        const isPostsMode = document.body.classList.contains('mode-posts');
        if(isPostsMode && !historyActive){
          userClosedPostBoard = true;
          setModeFromUser('map');
          return;
        }
        document.body.classList.remove('show-history');
        if(!isPostsMode || historyActive){
          setMode('posts');
          setTimeout(()=>{
            if(map && typeof map.resize === 'function'){
              map.resize();
              updatePostPanel();
            }
          }, 0);
        } else {
          updateModeToggle();
        }
      });

      mapButton && mapButton.addEventListener('click', ()=>{
        const isMapMode = document.body.classList.contains('mode-map');
        if(!isMapMode){
          userClosedPostBoard = true;
          setModeFromUser('map');
        } else if(document.body.classList.contains('show-history')){
          document.body.classList.remove('show-history');
          adjustBoards();
          updateModeToggle();
        }
      });

    function buildDetail(p, existingCard = null, isRecentsBoard = false){
      const locationList = Array.isArray(p.locations) ? p.locations : [];
      const loc0 = locationList[0] || {};
      const selectSuffix = '<span style="display:inline-block;margin-left:10px;">(Select Session)</span>';
      const loc0Dates = Array.isArray(loc0.dates)
        ? loc0.dates.slice().sort((a,b)=> (a.full||'').localeCompare(b.full||''))
        : [];
      const basePrice = loc0 && loc0.price !== undefined ? loc0.price : '';
      const defaultInfo = loc0Dates.length
        ? ` ${basePrice} |  ${loc0Dates[0].date} - ${loc0Dates[loc0Dates.length-1].date}${selectSuffix}`
        : ` ${basePrice}${selectSuffix}`;
      const thumbSrc = thumbUrl(p);
      const posterName = p.member ? p.member.username : 'Anonymous';
      const postedTime = formatPostTimestamp(p.created);
      const postedMeta = postedTime ? `Posted by ${posterName}  ${postedTime}` : `Posted by ${posterName}`;
      
      // Create wrapper for open post
      const wrap = document.createElement('div');
      wrap.className = 'open-post post-collapsed';
      wrap.dataset.id = p.id;
      
      // Use existing card or create new one - preserve type (recents-card vs post-card)
      let cardEl = existingCard;
      const isValidCard = cardEl && (cardEl.classList.contains('post-card') || cardEl.classList.contains('recents-card'));
      if(!isValidCard){
        cardEl = card(p, !isRecentsBoard);
      }
      
      // Remove any highlight classes and force #1f2750 background
      if(cardEl){
        cardEl.classList.remove('is-map-highlight');
        cardEl.style.background = '#1f2750';
        if(cardEl.dataset){
          cardEl.dataset.surfaceBg = '#1f2750';  // Update the stored background so restoration uses correct color
          delete cardEl.dataset.prevHighlightBackground;
        }
      }
      
      // Add share button ONLY if it doesn't exist (preserves existing card state)
      if(cardEl && !cardEl.querySelector('.share')){
        const cardActions = cardEl.querySelector('.card-actions');
        if(cardActions){
          const shareBtn = document.createElement('button');
          shareBtn.className = 'share';
          shareBtn.setAttribute('aria-label', 'Share post');
          shareBtn.innerHTML = '<svg viewBox="0 0 24 24"><path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.06-.23.09-.46.09-.7s-.03-.47-.09-.7l7.13-4.17A2.99 2.99 0 0 0 18 9a3 3 0 1 0-3-3c0 .24.03.47.09.7L7.96 10.87A3.003 3.003 0 0 0 6 10a3 3 0 1 0 3 3c0-.24-.03-.47-.09-.7l7.13 4.17c.53-.5 1.23-.81 1.96-.81a3 3 0 1 0 0 6 3 3 0 0 0 0-6z"/></svg>';
          cardActions.appendChild(shareBtn);
        }
      }
      
      // Create post body
      const postBody = document.createElement('div');
      postBody.className = 'post-body';
      postBody.innerHTML = `
        <div class="post-nav-buttons">
          <button class="venue-menu-button" type="button" aria-label="View Map" aria-haspopup="true" aria-expanded="false" data-nav="map">
            <img src="assets/Map Screenshot.png" alt="Map view">
            <span class="venue-name">${loc0.venue||''}</span><span class="address_line">${loc0.address||''}</span>${locationList.length>1?'<span class="results-arrow" aria-hidden="true"></span>':''}
          </button>
          <button class="session-menu-button" type="button" aria-label="View Calendar" aria-haspopup="true" aria-expanded="false" data-nav="calendar">
            <img src="assets/Calendar Screenshot.png" alt="Calendar view">
          </button>
        </div>
        <div id="venue-${p.id}" class="venue-dropdown options-dropdown"><div class="venue-menu post-venue-menu" hidden><div class="map-container"><div id="map-${p.id}" class="post-map"></div></div><div class="venue-options">${locationList.map((loc,i)=>`<button data-index="${i}"><span class="venue-name">${loc.venue}</span><span class="address_line">${loc.address}</span></button>`).join('')}</div></div></div>
        <div id="sess-${p.id}" class="session-dropdown options-dropdown"><div class="session-menu options-menu" hidden><div class="calendar-container"><div class="calendar-scroll"><div id="cal-${p.id}" class="post-calendar"></div></div></div><div class="session-options"></div></div></div>
        <div class="post-details">
          <div class="post-venue-selection-container"></div>
          <div class="post-session-selection-container"></div>
          <div class="post-details-info-container">
            <div id="venue-info-${p.id}" class="venue-info"></div>
            <div id="session-info-${p.id}" class="session-info">
              <div>${defaultInfo}</div>
            </div>
          </div>
          <div class="post-details-description-container">
            <div class="desc-wrap"><div class="desc" tabindex="0" aria-expanded="false"></div></div>
            <div class="member-avatar-row"><img src="${memberAvatarUrl(p)}" alt="${posterName} avatar" width="50" height="50"/><span>${postedMeta}</span></div>
          </div>
        </div>
        <div class="post-images">
          <div class="image-box"><div class="image-track"><img id="hero-img" class="lqip" src="${thumbSrc}" data-full="${heroUrl(p)}" alt="" loading="eager" fetchpriority="high" referrerpolicy="no-referrer" onerror="this.onerror=null; this.src='${thumbSrc}';"/></div></div>
          <div class="thumbnail-row"></div>
        </div>`;
      
      // Assemble the structure
      wrap.appendChild(cardEl);
      wrap.appendChild(postBody);
      
      // Card click no longer toggles post body (removed per user request)
      
      // Set up favorites button handler for the card in open post
      const favBtnInCard = cardEl.querySelector('.fav');
      if(favBtnInCard && !favBtnInCard._favHandlerBound){
        favBtnInCard.addEventListener('click', (e)=>{
          e.stopPropagation();
          e.preventDefault();
          p.fav = !p.fav;
          favSortDirty = true;
          document.querySelectorAll(`[data-id="${p.id}"] .fav`).forEach(btn=>{
            btn.setAttribute('aria-pressed', p.fav ? 'true' : 'false');
          });
          renderHistoryBoard();
        });
        favBtnInCard._favHandlerBound = true;
      }
      
      // Open post immediately - no animation delay
      wrap._triggerAnimation = () => {
        wrap.classList.remove('post-collapsed');
      };
      
      // Trigger immediately on creation - don't wait for scroll
      wrap.classList.remove('post-collapsed');
      
      // Progressive hero swap
      (function(){
        const img = wrap.querySelector('#hero-img');
        if(img){
          const full = img.getAttribute('data-full');
          const hi = new Image();
          hi.referrerPolicy = 'no-referrer';
          hi.fetchPriority = 'high';
          hi.onload = ()=>{
            const swap = ()=>{ img.src = full; img.classList.remove('lqip'); img.classList.add('ready'); };
            if(hi.decode){ hi.decode().then(swap).catch(swap); } else { swap(); }
          };
          hi.onerror = ()=>{};
          hi.src = full;
        }
      })();
      
      return wrap;
    }

      function ensurePostCardForId(id){
        if(!postsWideEl) return null;
        
        // Check if there's already an open post - if so, don't trigger a full reload
        const hasOpenPost = postsWideEl.querySelector('.open-post');
        
        if(!postSentinel || !postsWideEl.contains(postSentinel)){
          // Only do a full renderLists if there's no open post
          if(!hasOpenPost){
            renderLists(filtered);
          } else {
            // If there's an open post, just ensure the sentinel exists without clearing everything
            if(!postSentinel || !postsWideEl.contains(postSentinel)){
              postSentinel = document.createElement('div');
              postSentinel.style.height = '1px';
              postsWideEl.appendChild(postSentinel);
            }
          }
        }
        let cardEl = postsWideEl.querySelector(`.post-card[data-id="${id}"]`);
        if(cardEl) return cardEl;

        const index = sortedPostList.findIndex(item => item && item.id === id);
        if(index === -1) return null;

        while(renderedPostCount <= index){
          const before = renderedPostCount;
          appendPostBatch();
          cardEl = postsWideEl.querySelector(`.post-card[data-id="${id}"]`);
          if(cardEl) return cardEl;
          if(renderedPostCount === before) break;
        }

        return postsWideEl.querySelector(`.post-card[data-id="${id}"]`);
      }

      async function openPost(id, fromHistory=false, fromMap=false, originEl=null){
        // ========================================================================
        // ENTRY POINT TRACKING
        // ========================================================================
        let entryPoint = 'unknown';
        if(fromHistory && originEl && originEl.classList.contains('recents-card')){
          entryPoint = 'recents-card';
        } else if(!fromHistory && !fromMap && originEl && originEl.classList.contains('post-card')){
          entryPoint = 'post-card';
        } else if(fromMap){
          entryPoint = 'map-marker';
        } else if(!fromHistory && !fromMap && !originEl){
          entryPoint = 'ad-board'; // Ad board calls without originEl
        }
        // Entry point logging removed
        
        lockMap(false);
        touchMarker = null;
        spinEnabled = false;
        stopSpin();
        const p = getPostByIdAnywhere(id); if(!p) return;
        activePostId = id;
        selectedVenueKey = null;
        syncPostCardHighlights();

        if(!fromHistory){
          if(document.body.classList.contains('show-history')){
            document.body.classList.remove('show-history');
            adjustBoards();
            updateModeToggle();
          }
          if(mode !== 'posts'){
            setMode('posts', true);
            await nextFrame();
          }
        }
        $$('.recents-card[aria-selected="true"], .post-card[aria-selected="true"]').forEach(el=>el.removeAttribute('aria-selected'));

        const container = fromHistory ? document.getElementById('recentsBoard') : postsWideEl;
        if(!container){
          console.error('[openPost] Container not found!', { fromHistory, postsWideEl: !!postsWideEl, recentsBoard: !!document.getElementById('recentsBoard') });
          return;
        }
        
        // Capture scroll position EARLY - before any DOM operations that might reset it
        const earlyScrollTop = container.scrollTop;
        const earlyScrollHeight = container.scrollHeight;
        const earlyClientHeight = container.clientHeight;
        
        // Container selection logging removed

        const alreadyOpen = container.querySelector(`.open-post[data-id="${id}"]`);
        if(alreadyOpen){
          return;
        }

        if(originEl && !container.contains(originEl)){
          originEl = null;
        }
        let target = originEl || container.querySelector(`[data-id="${id}"]`);

        // ========================================================================
        // CLOSE PREVIOUS OPEN POST
        // ========================================================================
        (function(){
          const ex = container.querySelector('.open-post');
          if(ex){
            
            const seenDetailMaps = new Set();
            const cleanupDetailMap = node=>{
              if(!node || !node._detailMap) return;
              const ref = node._detailMap;
              if(!seenDetailMaps.has(ref)){
                if(ref.resizeHandler){
                  window.removeEventListener('resize', ref.resizeHandler);
                }
                if(ref.map && typeof ref.map.remove === 'function'){
                  ref.map.remove();
                }
                seenDetailMaps.add(ref);
              }
              if(ref){
                ref.map = null;
                ref.resizeHandler = null;
              }
              if(node && node.__map){
                node.__map = null;
              }
              delete node._detailMap;
            };
            cleanupDetailMap(ex);
            const mapNode = ex.querySelector('.post-map');
            if(mapNode){
              cleanupDetailMap(mapNode);
            }
            const exId = ex.dataset && ex.dataset.id;
            // Preserve the existing card from the open post instead of creating a new one
            const existingCard = ex.querySelector('.post-card, .recents-card');
            if(existingCard){
              // Remove share button if it was added
              const shareBtn = existingCard.querySelector('.share');
              if(shareBtn) shareBtn.remove();
              // Restore original card background
              existingCard.style.background = CARD_SURFACE;
              if(existingCard.dataset){
                existingCard.dataset.surfaceBg = CARD_SURFACE;
              }
              ex.replaceWith(existingCard);
            } else {
              const prev = getPostByIdAnywhere(exId);
              if(prev){ ex.replaceWith(card(prev, fromHistory ? false : true)); } else { ex.remove(); }
            }
          }
        })();

        if(originEl && !container.contains(originEl)){
          originEl = null;
        }
        target = originEl || container.querySelector(`[data-id="${id}"]`);

        const pointerEvt = window.__lastPointerDown;
        let pointerTarget = null;
        if(pointerEvt && pointerEvt.target instanceof Element){
          let consider = true;
          if(typeof pointerEvt.timeStamp === 'number'){
            const nowTs = (typeof performance !== 'undefined' && typeof performance.now === 'function') ? performance.now() : Date.now();
            const evtTs = pointerEvt.timeStamp;
            if(typeof evtTs === 'number'){
              const diff = nowTs - evtTs;
              if(Number.isFinite(diff) && (diff > 2000 || diff < -2000)){
                consider = false;
              }
            }
          }
          if(consider){
            pointerTarget = pointerEvt.target;
          }
        }
        const pointerCard = pointerTarget ? pointerTarget.closest('.post-card, .recents-card') : null;
        const pointerInsideCardContainer = pointerCard && container.contains(pointerCard);
        const shouldReorderToTop = false; // Never reorder posts - maintain sort order

        if(!target && !fromHistory){
          target = ensurePostCardForId(id);
        }

        if(!target){
          target = card(p, fromHistory ? false : true);
          if(!fromHistory && container === postsWideEl){
            if(postSentinel && postSentinel.parentElement === container){
              container.insertBefore(target, postSentinel);
            } else {
              container.appendChild(target);
            }
          } else {
            container.prepend(target);
          }
        } else if(shouldReorderToTop && container.contains(target) && !pointerInsideCardContainer){
          const firstCard = container.querySelector('.open-post, .post-card, .recents-card');
          if(firstCard && firstCard !== target){
            container.insertBefore(target, firstCard);
          } else if(!firstCard){
            container.prepend(target);
          }
        }
        const resCard = resultsEl ? resultsEl.querySelector(`[data-id="${id}"]`) : null;
        if(resCard){
          resCard.setAttribute('aria-selected','true');
          if(fromMap){
            const qb = resCard.closest('.quick-list-board');
            if(qb){
              // intentionally skipping automatic scrolling
            }
          }
        }

        // Store position before buildDetail modifies DOM
        const targetParent = target.parentElement;
        const targetNext = target.nextSibling;
        const isCardValid = target && target.classList && (target.classList.contains('post-card') || target.classList.contains('recents-card'));
        
        // Scroll the card to the top BEFORE converting it to open-post
        // Find the actual scrollable element
        let scrollElement = container;
        if(container === postsWideEl || container.classList.contains('post-board')){
          const postsEl = container.querySelector('.posts');
          if(postsEl){
            scrollElement = postsEl;
          }
        }
        
        // Scroll the card to the top of the scroll container - ALWAYS scroll to top
        // This prevents posts from opening where they are instead of at the top
        if(scrollElement && typeof scrollElement.scrollTop !== 'undefined'){
          // Always scroll to top immediately - no delays
          scrollElement.scrollTop = 0;
        }
        
        // Pass the existing target card to buildDetail to preserve it without recreating
        const detail = buildDetail(p, isCardValid ? target : null, fromHistory);
        
        // If target wasn't reused, remove it
        if(!isCardValid && target.parentElement){
          target.remove();
        }
        
        // Insert detail at the original position
        if(targetNext && targetNext.parentElement === targetParent){
          targetParent.insertBefore(detail, targetNext);
        } else if(targetParent){
          targetParent.appendChild(detail);
        } else {
          container.appendChild(detail);
        }
        
        hookDetailActions(detail, p);
        if (typeof updateStickyImages === 'function') {
          updateStickyImages();
        }
        if (typeof initPostLayout === 'function') {
          initPostLayout(container);
          if (typeof updateStickyImages === 'function') {
            updateStickyImages();
          }
        }
        
        // Update mapcard states after post opens
        if(typeof window.updateMapCardStates === 'function'){
          requestAnimationFrame(() => {
            window.updateMapCardStates();
          });
        }
        
        // Update icon-size for expanded state
        if(typeof updateMarkerLabelHighlightIconSize === 'function'){
          requestAnimationFrame(() => {
            updateMarkerLabelHighlightIconSize();
          });
        }

        await nextFrame();

        // Update history on open (keep newest-first)
        viewHistory = viewHistory.filter(x=>x.id!==id);
        viewHistory.unshift({id:p.id, title:p.title, url:postUrl(p), lastOpened: Date.now()});
        if(viewHistory.length>100) viewHistory.length=100;
        saveHistory();
        if(!fromHistory){
          renderHistoryBoard();
        }

        // Ensure all layout operations complete before scrolling
        if(typeof window.adjustBoards === 'function'){
          window.adjustBoards();
        }
        if(typeof window.adjustListHeight === 'function'){
          window.adjustListHeight();
        }

        // Ensure scroll is at top after layout operations
        // The card should already be scrolled to top, but verify and adjust if needed
        const scrollToTop = (attempt = 1) => {
          if(!container){
            console.warn(`[openPost] Scroll attempt ${attempt}: Container missing`);
            return;
          }
          
          // Find the actual scrollable element
          // For post-board: .posts element is scrollable (has overflow-y: auto)
          // For recents-board: container itself is scrollable
          let scrollElement = container;
          if(container === postsWideEl || container.classList.contains('post-board')){
            // Post board - find the .posts element inside
            const postsEl = container.querySelector('.posts');
            if(postsEl){
              scrollElement = postsEl;
            }
          }
          // For recents-board, container itself is scrollable, so use it directly
          
          // Find the open-post element that was just created
          // The card becomes the header (sticky top:0) and post-body slides out underneath
          const openPostEl = container.querySelector(`.open-post[data-id="${id}"]`);
          
          const beforeScroll = scrollElement.scrollTop;
          const scrollHeight = scrollElement.scrollHeight;
          const clientHeight = scrollElement.clientHeight;
          const canScroll = scrollHeight > clientHeight;
          
          if(scrollElement && typeof scrollElement.scrollTop !== 'undefined'){
            // Ensure we're at the top - use instant scroll for final positioning
            // (The smooth scroll should have already happened, this is just a safety check)
            if(beforeScroll > 5){
              scrollElement.scrollTop = 0;
            }
            
            const afterScroll = scrollElement.scrollTop;
            // Success if we scrolled to the top (or very close to it, within 5px tolerance)
            const scrollSuccess = afterScroll <= 5;
            
            // Enhanced logging with inline values for easy reading
            // Scroll logging removed - errors/warnings still logged below
            
            if(!scrollSuccess && attempt === 3){
              console.error(
                `[openPost]  SCROLL FAILED after 3 attempts for ${entryPoint}!`,
                `\n  Container: ${containerName}`,
                `\n  Scroll element: ${scrollElementName}`,
                `\n  Final position: ${afterScroll}px (expected: 0px)`,
                `\n  Content height: ${scrollHeight}px, Viewport: ${clientHeight}px`,
                {
                  entryPoint,
                  container: containerName,
                  scrollElement: scrollElementName,
                  finalScrollTop: afterScroll,
                  scrollHeight,
                  clientHeight,
                  element: scrollElement
                }
              );
            }
          } else {
            console.warn(
              `[openPost] Scroll attempt ${attempt}: scrollTop property undefined`,
              `\n  Has element: ${!!scrollElement}`,
              `\n  scrollTop type: ${typeof scrollElement?.scrollTop}`,
              {
                hasElement: !!scrollElement,
                scrollTopType: typeof scrollElement?.scrollTop,
                element: scrollElement
              }
            );
          }
        };

        // Use multiple attempts to ensure scroll happens after all layout operations
        // This handles timing issues with layout operations, DOM updates, and animations
        // Find the actual scrollable element first
        let actualScrollElement = container;
        if(container === postsWideEl || container.classList.contains('post-board')){
          const postsEl = container.querySelector('.posts');
          if(postsEl){
            actualScrollElement = postsEl;
          }
        }
        
        const containerName = container.id || container.className;
        const scrollElementName = actualScrollElement === container ? 'container' : (actualScrollElement.className || 'posts');
        const initialScrollTop = actualScrollElement.scrollTop;
        const initialScrollHeight = actualScrollElement.scrollHeight;
        const initialClientHeight = actualScrollElement.clientHeight;
        
        // Capture early scroll from actual scroll element too
        const earlyActualScrollTop = actualScrollElement.scrollTop;
        
        // Scroll sequence logging removed
        
        // Scroll to top BEFORE animation to prevent flicker
        // Post already opens immediately (no animation delay)
        // Just scroll to top
        scrollToTop(1);
      }

      function closeActivePost(){
        const openEl = document.querySelector('.post-board .open-post, #recentsBoard .open-post');
        if(!openEl){
          document.body.classList.remove('detail-open');
          if(typeof initPostLayout === 'function') initPostLayout(postsWideEl);
          if(typeof window.adjustBoards === 'function') window.adjustBoards();
          return;
        }
        const openBody = openEl.querySelector('.post-body');
        if(openBody){
          openBody.style.removeProperty('--second-post-height');
          openBody.style.removeProperty('min-height');
          if(openBody.dataset) delete openBody.dataset.secondPostHeight;
        }
        const container = openEl.closest('.post-board, #recentsBoard') || postsWideEl;
        const isHistory = container && container.id === 'recentsBoard';
        const id = openEl.dataset ? openEl.dataset.id : null;
        const post = id ? getPostByIdAnywhere(id) : null;
        const detachedColumn = document.querySelector('.post-mode-boards > .post-body');
        if(detachedColumn){
          detachedColumn.classList.remove('is-visible');
          if(detachedColumn.dataset) delete detachedColumn.dataset.openPostId;
          detachedColumn.remove();
        }
        document.body.classList.remove('detail-open');
        $$('.recents-card[aria-selected="true"], .post-card[aria-selected="true"]').forEach(el=> el.removeAttribute('aria-selected'));
        // Preserve the existing card instead of creating a new one
        const existingCard = openEl.querySelector('.post-card, .recents-card');
        if(existingCard){
          // Remove share button if it was added
          const shareBtn = existingCard.querySelector('.share');
          if(shareBtn) shareBtn.remove();
          // Restore original card background
          existingCard.style.background = CARD_SURFACE;
          if(existingCard.dataset){
            existingCard.dataset.surfaceBg = CARD_SURFACE;
          }
          openEl.replaceWith(existingCard);
        } else if(post){
          const replacement = card(post, !isHistory);
          openEl.replaceWith(replacement);
        } else {
          openEl.remove();
        }
        activePostId = null;
        selectedVenueKey = null;
        syncPostCardHighlights();
        if(typeof initPostLayout === 'function') initPostLayout(postsWideEl);
        if(typeof updateStickyImages === 'function') updateStickyImages();
        if(typeof window.adjustBoards === 'function') window.adjustBoards();
        
        // Update mapcard states when post closes
        if(typeof window.updateMapCardStates === 'function'){
          window.updateMapCardStates();
        }
        
        // Update icon-size when post closes
        if(typeof updateMarkerLabelHighlightIconSize === 'function'){
          updateMarkerLabelHighlightIconSize();
        }
      }

      window.openPost = openPost;
      if(typeof window.__wrapForInputYield === 'function'){
        window.__wrapForInputYield('openPost');
      }

      const resLists = $$('.recents-board');
      resLists.forEach(list=>{
          list.addEventListener('click', (e)=>{
            // Check if clicking on fav button or any of its children (like SVG)
            if(e.target.closest('.fav, .share')) return;
            const cardEl = e.target.closest('.recents-card');
            if(!cardEl) return;
            e.preventDefault();
            const id = cardEl.getAttribute('data-id');
            if(!id) return;
            
            // Set active state on corresponding mapcard via MapCards API
            if(window.MapCards && window.MapCards.setMapCardActive){
              window.MapCards.setMapCardActive(id);
            }
            
            callWhenDefined('openPost', (fn)=>{
              requestAnimationFrame(() => {
                try{
                  stopSpin();
                  // CASE 1: RECENTS CARD CLICKED - SCROLL TO TOP
                  // Parameters: (id, fromHistory=true, fromMap=false, originEl=cardEl)
                  fn(id, true, false, cardEl);
                }catch(err){ console.error(err); }
              });
            });
          }, { capture: true });
        });

      const postsWide = $('.post-board');
      if(postsWide){
        postsWide.addEventListener('click', e=>{
          // Check if clicking on fav/share button or any of its children (like SVG)
          if(e.target.closest('.fav, .share')) return;
          const cardEl = e.target.closest('.post-card');
          if(cardEl){
            const id = cardEl.getAttribute('data-id');
            if(id){
              e.preventDefault();
              
              // Set active state on corresponding mapcard via MapCards API
              if(window.MapCards && window.MapCards.setMapCardActive){
                window.MapCards.setMapCardActive(id);
              }
              
              callWhenDefined('openPost', (fn)=>{
                requestAnimationFrame(() => {
                  try{
                    stopSpin();
                    // CASE 2: POST CARD CLICKED - SCROLL TO TOP
                    // Parameters: (id, fromHistory=false, fromMap=false, originEl=cardEl)
                    fn(id, false, false, cardEl);
                  }catch(err){ console.error(err); }
                });
              });
            }
            return;
          }
          if(e.target === postsWide && postsWide.querySelector('.open-post')){
            userClosedPostBoard = true;
            setTimeout(()=> setModeFromUser('map'), 0);
          }
        }, { capture:true });
      }

      recentsBoard && recentsBoard.addEventListener('click', e=>{
        if(e.target === recentsBoard){
          userClosedPostBoard = true;
          setModeFromUser('map');
        }
      });

      function setMode(m, skipFilters = false){
        mode = m;
        document.body.classList.remove('mode-map','mode-posts','hide-posts-ui');
        document.body.classList.add('mode-'+m);
        if(m==='map'){
          document.body.classList.remove('show-history');
        }
        // ALWAYS initialize map - it's visible in background even in posts mode
        startMainMapInit();
        const shouldAdjustListHeight = m === 'posts' && typeof window.adjustListHeight === 'function';
        adjustBoards();
        if(shouldAdjustListHeight){
          window.adjustListHeight();
        }
        updateModeToggle();
        if(m === 'posts'){
          userClosedPostBoard = false;
          const boardEl = document.querySelector('.post-board');
          if(boardEl){
            boardEl.style.width = '';
          }
          if(window.adjust){
            window.adjust();
          }
        }
        if(map){
          if(typeof map.resize === 'function'){
            map.resize();
          }
          updatePostPanel();
        }
        if(m==='posts'){
          spinEnabled = false;
          stopSpin();
        }
        if(!skipFilters) applyFilters();
      }
    window.setMode = setMode;

      function setModeFromUser(m, skipFilters = false){
        const previous = modeChangeWasUserInitiated;
        modeChangeWasUserInitiated = true;
        try{
          setMode(m, skipFilters);
        } finally {
          modeChangeWasUserInitiated = previous;
        }
      }

    // Mapbox
    let mapboxBundlePromise = null;
    let mapboxBundleReady = false;
    let mainMapInitPromise = null;
    let mapInitTriggered = false;
    let mapInitQueued = false;
    let modeChangeWasUserInitiated = false;

    function loadMapbox(cb){
      const invokeCallback = () => {
        if(typeof cb === 'function'){
          try{ cb(); }catch(err){ console.error(err); }
        }
      };

      if(mapboxBundleReady){
        return Promise.resolve().then(invokeCallback);
      }

      if(!mapboxBundlePromise){
        mapboxBundlePromise = new Promise((resolve, reject) => {
          const mapboxVerRaw = window.MAPBOX_VERSION || 'v3.15.0';
          const mapboxVer = mapboxVerRaw.startsWith('v') ? mapboxVerRaw : `v${mapboxVerRaw}`;
          const mapboxVerNoV = mapboxVer.replace(/^v/, '');
          const cssSources = [
            {
              selector: 'link[href*="mapbox-gl.css"], link[href*="mapbox-gl@"], style[data-mapbox]',
              primary: `https://api.mapbox.com/mapbox-gl-js/${mapboxVer}/mapbox-gl.css`,
              fallback: `https://unpkg.com/mapbox-gl@${mapboxVerNoV}/dist/mapbox-gl.css`
            },
            {
              selector: 'link[href*="mapbox-gl-geocoder.css"], link[href*="mapbox-gl-geocoder@"]',
              primary: 'https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-geocoder/v5.0.0/mapbox-gl-geocoder.css',
              fallback: 'https://unpkg.com/@mapbox/mapbox-gl-geocoder@5.0.0/dist/mapbox-gl-geocoder.css'
            }
          ];

          let settled = false;

          function fail(error){
            if(settled){
              return;
            }
            settled = true;
            mapboxBundleReady = false;
            mapboxBundlePromise = null;
            reject(error instanceof Error ? error : new Error(error || 'Mapbox bundle failed to load'));
          }

          function finalize(){
            if(settled){
              return;
            }
            Promise.resolve(ensureMapboxCssFor(document.body))
              .catch(()=>{})
              .then(() => {
                if(settled){
                  return;
                }
                if(window && window.mapboxgl){
                  settled = true;
                  mapboxBundleReady = true;
                  resolve();
                } else {
                  fail(new Error('Mapbox GL failed to load'));
                }
              });
          }

          function monitorLink(link, onReady, fallbackUrl){
            if(!link || (link.tagName && link.tagName.toLowerCase() === 'style')){
              onReady();
              return;
            }
            if(fallbackUrl && link.dataset && !link.dataset.fallback){
              link.dataset.fallback = fallbackUrl;
            }

            let settled = false;

            function cleanup(){
              link.removeEventListener('load', handleLoad);
              link.removeEventListener('error', handleError);
            }

            function complete(){
              if(settled){
                return;
              }
              settled = true;
              cleanup();
              onReady();
            }

            function handleLoad(){
              complete();
            }

            function handleError(){
              const attempts = link.dataset && link.dataset.fallbackErrors ? Number(link.dataset.fallbackErrors) : 0;
              const nextAttempts = (Number.isNaN(attempts) ? 0 : attempts) + 1;
              if(link.dataset){
                link.dataset.fallbackErrors = String(nextAttempts);
              }
              const fallback = link.dataset ? link.dataset.fallback : fallbackUrl;
              if(fallback && link.href !== fallback){
                link.href = fallback;
                return;
              }
              if(fallback && nextAttempts === 1){
                return;
              }
              complete();
            }

            function needsListeners(){
              if(!link.sheet){
                return true;
              }
              try {
                void link.sheet.cssRules;
                return false;
              } catch(err){
                if(err && (err.name === 'SecurityError' || err.code === 18)){
                  return false;
                }
                return true;
              }
            }

            if(needsListeners()){
              link.addEventListener('load', handleLoad, {once:true});
              link.addEventListener('error', handleError);
            } else {
              complete();
            }
          }

          function ensureCss(index, onReady){
            const {selector, primary, fallback} = cssSources[index];
            const selectors = selector.split(',').map(s => s.trim());
            for(const sel of selectors){
              const candidate = document.querySelector(sel);
              if(candidate){
                if(candidate.tagName && candidate.tagName.toLowerCase() === 'style'){
                  onReady();
                  return;
                }
                monitorLink(candidate, onReady, fallback);
                return;
              }
            }
            const link = document.createElement('link');
            link.rel = 'stylesheet';
            link.href = primary;
            monitorLink(link, onReady, fallback);
            document.head.appendChild(link);
          }

          if(window.mapboxgl && window.MapboxGeocoder){
            let pending = cssSources.length;
            if(pending === 0){
              finalize();
              return;
            }
            const done = () => {
              if(--pending === 0){
                finalize();
              }
            };
            cssSources.forEach((_, i) => ensureCss(i, done));
            return;
          }

          cssSources.forEach((_, i) => ensureCss(i, ()=>{}));
          loadScripts();

          function loadScripts(){
            let successTriggered = false;

            function done(){
              if(successTriggered){
                return;
              }
              successTriggered = true;
              finalize();
            }

            const loadGeocoder = ()=>{
              const g = document.createElement('script');
              g.src='https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-geocoder/v5.0.0/mapbox-gl-geocoder.min.js';
              g.async = true;
              g.defer = true;
              g.onload = done;
              g.onerror = ()=>{
                const gf = document.createElement('script');
                gf.src='https://unpkg.com/@mapbox/mapbox-gl-geocoder@5.0.0/dist/mapbox-gl-geocoder.min.js';
                gf.async = true;
                gf.defer = true;
                gf.onload = done;
                gf.onerror = ()=>{
                  fail(new Error('Mapbox Geocoder failed to load'));
                };
                document.head.appendChild(gf);
              };
              document.head.appendChild(g);
            };

            const s = document.createElement('script');
            s.src=`https://api.mapbox.com/mapbox-gl-js/${mapboxVer}/mapbox-gl.js`;
            s.async = true;
            s.defer = true;
            s.onload = loadGeocoder;
            s.onerror = ()=>{
              const sf = document.createElement('script');
              sf.src=`https://unpkg.com/mapbox-gl@${mapboxVerNoV}/dist/mapbox-gl.js`;
              sf.async = true;
              sf.defer = true;
              sf.onload = loadGeocoder;
              sf.onerror = ()=>{
                fail(new Error('Mapbox GL failed to load from fallback source'));
              };
              document.head.appendChild(sf);
            };
            document.head.appendChild(s);
          }
        });
      }

      return mapboxBundlePromise.then(() => {
        invokeCallback();
      });
    }

    function startMainMapInit(){
      if(mainMapInitPromise){
        return mainMapInitPromise;
      }
      mapInitQueued = false;
      if(typeof __notifyMapOnInteraction === 'function'){
        __notifyMapOnInteraction = null;
      }
      mainMapInitPromise = loadMapbox().then(() => {
        if(mapInitTriggered){
          return;
        }
        mapInitTriggered = true;
        return Promise.resolve(initMap()).catch(err => {
          console.error(err);
        });
      }).catch(err => {
        console.error(err);
      });
      return mainMapInitPromise;
    }

    function queueMainMapInitAfterInteraction(){
      if(mainMapInitPromise || mapInitTriggered){
        return;
      }
      if(__userInteractionObserved){
        startMainMapInit();
        return;
      }
      if(mapInitQueued){
        return;
      }
      mapInitQueued = true;
      loadMapbox().catch(err => console.error(err));
      const notify = () => {
        mapInitQueued = false;
        startMainMapInit();
      };
      __notifyMapOnInteraction = notify;
    }

    function addControls(){
      // Wait for Google Places API to load
      if(typeof google === 'undefined' || !google.maps || !google.maps.places){
        setTimeout(addControls, 100);
        return;
      }
      const cssLink = document.querySelector('style[data-mapbox], link[href*="mapbox-gl.css"], link[href*="mapbox-gl@"]');
      if(!cssLink || !cssLink.sheet){
        setTimeout(addControls, 50);
        return;
      }
      geocoders.length = 0;
      geocoder = null;

      const sets = [
        {geo:'#geocoder-welcome', locate:'#geolocate-welcome', compass:'#compass-welcome'},
        {geo:'#geocoder-map', locate:'#geolocate-map', compass:'#compass-map'},
        {geo:'#geocoder-filter', locate:'#geolocate-filter', compass:'#compass-filter'}
      ];
      const cityZoomLevel = 12;

      sets.forEach((sel, idx)=>{
        const gEl = sel && sel.geo ? document.querySelector(sel.geo) : null;
        
        // Create Google Places geocoder
        let gc = null;
        if(gEl){
          // Create wrapper and input
          const wrapper = document.createElement('div');
          wrapper.className = 'google-places-geocoder';
          const input = document.createElement('input');
          input.type = 'text';
          input.placeholder = 'Search venues or places';
          input.setAttribute('autocomplete', 'off');
          input.setAttribute('data-lpignore', 'true');
          input.setAttribute('data-form-type', 'other');
          wrapper.appendChild(input);
          gEl.appendChild(wrapper);
          
          // Initialize Google Places Autocomplete
          const autocomplete = new google.maps.places.Autocomplete(input, {
            fields: ['formatted_address', 'geometry', 'name', 'place_id', 'types', 'address_components']
          });
          
          // Store reference for clear functionality
          gc = {
            _inputEl: input,
            _autocomplete: autocomplete,
            clear: function(){
              input.value = '';
            },
            _inputReference: input
          };
          
          // Handle place selection
          autocomplete.addListener('place_changed', function(){
            const place = autocomplete.getPlace();
            if(!place || !place.geometry || !place.geometry.location){
              return;
            }
            
            // Convert Google Places result to Mapbox-like format for handleGeocoderResult
            const lat = place.geometry.location.lat();
            const lng = place.geometry.location.lng();
            const result = {
              center: [lng, lat],
              geometry: {
                type: 'Point',
                coordinates: [lng, lat]
              },
              place_name: place.formatted_address || place.name,
              text: place.name || place.formatted_address
            };
            
            // Add bbox if viewport is available
            if(place.geometry.viewport){
              const ne = place.geometry.viewport.getNorthEast();
              const sw = place.geometry.viewport.getSouthWest();
              result.bbox = [sw.lng(), sw.lat(), ne.lng(), ne.lat()];
            }
            
            handleGeocoderResult(result);
          });
        }
        
        geocoders.push(gc);
        if(idx === 1){
          geocoder = gc;
        }

        const handleGeocoderResult = (result) => {
          if(!map || !result) return;
          closeWelcomeModalIfOpen();

          const toLngLatArray = (value) => {
            if(Array.isArray(value) && value.length >= 2){
              const lng = Number(value[0]);
              const lat = Number(value[1]);
              if(Number.isFinite(lng) && Number.isFinite(lat)){
                return [lng, lat];
              }
            } else if(value && typeof value === 'object'){
              const lng = Number(value.lng);
              const lat = Number(value.lat);
              if(Number.isFinite(lng) && Number.isFinite(lat)){
                return [lng, lat];
              }
            }
            return null;
          };

          const waitForIdle = () => {
            if(!map) return;
            if(typeof map.isMoving === 'function'){
              let moving = false;
              try{
                moving = map.isMoving();
              }catch(err){ moving = false; }
              if(moving){
                requestAnimationFrame(waitForIdle);
                return;
              }
            }
            applyFlight();
          };

          const applyFlight = () => {
            if(!map) return;

            const minZoom = Math.max(cityZoomLevel, MARKER_ZOOM_THRESHOLD + 0.01);
            let maxZoom = 22;
            if(typeof map.getMaxZoom === 'function'){
              try{
                const candidate = map.getMaxZoom();
                if(Number.isFinite(candidate)){
                  maxZoom = candidate;
                }
              }catch(err){}
            }

            let cameraFromBounds = null;
            if(Array.isArray(result?.bbox) && result.bbox.length === 4 && typeof map.cameraForBounds === 'function'){
              const [minLng, minLat, maxLng, maxLat] = result.bbox.map(Number);
              const hasBounds = [minLng, minLat, maxLng, maxLat].every(Number.isFinite);
              if(hasBounds){
                try{
                  cameraFromBounds = map.cameraForBounds([[minLng, minLat], [maxLng, maxLat]], {
                    padding: { top: 60, bottom: 60, left: 60, right: 60 }
                  });
                }catch(err){ cameraFromBounds = null; }
              }
            }

            const currentCenter = (() => {
              if(typeof map.getCenter === 'function'){
                try{
                  const center = map.getCenter();
                  return toLngLatArray(center);
                }catch(err){ 
                  console.error('Failed to get bearing:', err);
                  return null; 
                }
              }
              return null;
            })();

            let targetCenter = null;
            if(cameraFromBounds?.center){
              targetCenter = toLngLatArray(cameraFromBounds.center);
            }
            if(!targetCenter){
              const geometry = result?.geometry;
              if(geometry && String(geometry.type).toLowerCase() === 'point'){
                targetCenter = toLngLatArray(geometry.coordinates);
              }
            }
            if(!targetCenter){
              targetCenter = toLngLatArray(result?.center);
            }
            if(!targetCenter){
              targetCenter = currentCenter;
            }

            let zoomCandidate = Number(cameraFromBounds?.zoom);
            if(!Number.isFinite(zoomCandidate) && Number.isFinite(result?.zoom)){
              zoomCandidate = result.zoom;
            }
            if(!Number.isFinite(zoomCandidate) && Number.isFinite(result?.properties?.zoom)){
              zoomCandidate = result.properties.zoom;
            }
            if(!Number.isFinite(zoomCandidate)){
              if(typeof map.getZoom === 'function'){
                try{
                  const currentZoom = map.getZoom();
                  if(Number.isFinite(currentZoom)){
                    zoomCandidate = currentZoom;
                  }
                }catch(err){}
              }
            }

            let targetZoom = Number.isFinite(zoomCandidate) ? zoomCandidate : minZoom;
            if(targetZoom < minZoom){
              targetZoom = minZoom;
            }
            if(Number.isFinite(maxZoom) && targetZoom > maxZoom){
              targetZoom = maxZoom;
            }

            const currentBearing = (() => {
              if(typeof map.getBearing === 'function'){
                try{
                  const bearing = map.getBearing();
                  return Number.isFinite(bearing) ? bearing : null;
                }catch(err){ 
                  console.error('Failed to get bearing:', err);
                  return null; 
                }
              }
              return null;
            })();

            let targetBearing = Number(cameraFromBounds?.bearing);
            if(!Number.isFinite(targetBearing) && Number.isFinite(result?.bearing)){
              targetBearing = result.bearing;
            }
            if(!Number.isFinite(targetBearing) && Number.isFinite(result?.properties?.bearing)){
              targetBearing = result.properties.bearing;
            }
            if(!Number.isFinite(targetBearing)){
              targetBearing = currentBearing;
            }

            const currentPitch = (() => {
              if(typeof map.getPitch === 'function'){
                try{
                  const pitch = map.getPitch();
                  return Number.isFinite(pitch) ? pitch : null;
                }catch(err){ 
                  console.error('Failed to get bearing:', err);
                  return null; 
                }
              }
              return null;
            })();

            let targetPitch = Number(cameraFromBounds?.pitch);
            if(!Number.isFinite(targetPitch) && Number.isFinite(result?.pitch)){
              targetPitch = result.pitch;
            }
            if(!Number.isFinite(targetPitch) && Number.isFinite(result?.properties?.pitch)){
              targetPitch = result.properties.pitch;
            }
            if(!Number.isFinite(targetPitch)){
              targetPitch = currentPitch;
            }

            const flight = {
              essential: true,
              center: targetCenter || currentCenter || undefined,
              zoom: Number.isFinite(targetZoom) ? targetZoom : minZoom,
              speed: 1.35,
              curve: 1.5,
              easing: t => 1 - Math.pow(1 - t, 3)
            };

            if(Number.isFinite(targetBearing)){
              flight.bearing = targetBearing;
            }
            if(Number.isFinite(targetPitch)){
              flight.pitch = targetPitch;
            }

            try{
              if(typeof map.flyTo === 'function'){
                map.flyTo(flight);
              }
            }catch(err){}
          };

          waitForIdle();
        };
        // Note: Google Places result handling is done inline in autocomplete.addListener above

        const geolocateToken = `geolocate:${idx}`;
        let geolocateButton = null;
        let geolocateFallbackTimeout = null;

        const getMapLoading = () => (typeof mapLoading !== 'undefined' ? mapLoading : null);

        const clearGeolocateLoading = () => {
          if(geolocateFallbackTimeout){
            clearTimeout(geolocateFallbackTimeout);
            geolocateFallbackTimeout = null;
          }
          const loader = getMapLoading();
          if(loader){
            loader.removeMotion(geolocateToken);
          }
        };

        const ensureGeolocateLoading = () => {
          const loader = getMapLoading();
          if(!loader) return;
          loader.addMotion(geolocateToken);
          if(geolocateFallbackTimeout){
            clearTimeout(geolocateFallbackTimeout);
          }
          geolocateFallbackTimeout = setTimeout(() => {
            geolocateFallbackTimeout = null;
            const loader = getMapLoading();
            if(loader){
              loader.removeMotion(geolocateToken);
            }
          }, 15000);
        };

        const awaitGeolocateIdle = () => {
          const loader = getMapLoading();
          if(!loader){
            clearGeolocateLoading();
            return;
          }
          const finalize = () => {
            clearGeolocateLoading();
          };
          let bound = false;
          if(map && typeof map.once === 'function'){
            try{
              map.once('idle', finalize);
              bound = true;
            }catch(err){
              finalize();
              return;
            }
          }
          if(!bound){
            finalize();
          } else {
            if(geolocateFallbackTimeout){
              clearTimeout(geolocateFallbackTimeout);
            }
            geolocateFallbackTimeout = setTimeout(() => {
              finalize();
            }, 8000);
          }
        };

        const geolocate = new mapboxgl.GeolocateControl({
          positionOptions:{ enableHighAccuracy:true },
          trackUserLocation:false,
          fitBoundsOptions:{ maxZoom: cityZoomLevel }
        });
        geolocate.on('geolocate', (event)=>{
          ensureGeolocateLoading();
          spinEnabled = false; stopSpin();
          closeWelcomeModalIfOpen();
          if(mode!=='map') setModeFromUser('map');
          if(event && event.coords){
            setAllGeocoderProximity(event.coords.longitude, event.coords.latitude);
          }
          if(map && typeof map.easeTo === 'function' && event && event.coords){
            let targetZoom = cityZoomLevel;
            if(typeof map.getMaxZoom === 'function'){
              try{
                const maxZoom = map.getMaxZoom();
                if(typeof maxZoom === 'number' && maxZoom < targetZoom){
                  targetZoom = maxZoom;
                }
              }catch(err){}
            }
            const currentZoom = (typeof map.getZoom === 'function') ? map.getZoom() : null;
            const needsZoomAdjust = !Number.isFinite(currentZoom) || Math.abs(currentZoom - targetZoom) > 0.05;
            const center = [event.coords.longitude, event.coords.latitude];
            if(needsZoomAdjust){
              let currentPitch = null;
              try{
                currentPitch = typeof map.getPitch === 'function' ? map.getPitch() : null;
              }catch(err){
                currentPitch = null;
              }
              const options = { center, zoom: targetZoom, duration: 800, essential: true };
              if(Number.isFinite(currentPitch)){
                options.pitch = currentPitch;
              }
              try{
                map.easeTo(options);
              }catch(err){}
            }
          }
          awaitGeolocateIdle();
        });
        geolocate.on('error', () => {
          clearGeolocateLoading();
        });
        const geoHolder = sel && sel.locate ? document.querySelector(sel.locate) : null;
        if(geoHolder){
          const controlEl = geolocate.onAdd(map);
          geoHolder.appendChild(controlEl);
          if(controlEl){
            geolocateButton = controlEl.querySelector('button');
            if(geolocateButton){
              const handlePress = (evt) => {
                if(evt && evt.type === 'keydown'){
                  const key = evt.key || evt.code;
                  if(!key) return;
                  if(key !== 'Enter' && key !== ' ' && key !== 'Spacebar'){ return; }
                }
                ensureGeolocateLoading();
              };
              geolocateButton.addEventListener('click', handlePress, { passive: true });
              geolocateButton.addEventListener('keydown', handlePress);
            }
          }
        }
        const nav = new mapboxgl.NavigationControl({showZoom:false, visualizePitch:true});
        const compassHolder = sel && sel.compass ? document.querySelector(sel.compass) : null;
        if(compassHolder) compassHolder.appendChild(nav.onAdd(map));
      });

      syncGeocoderProximityToMap();
    }

    async function initMap(){
      // PERFORMANCE FIX: Don't block map on formbuilder snapshot
      // The formbuilder is only needed for admin Forms tab and member Create Post tab
      // It will be loaded lazily via getFormbuilderSnapshotPromise() when those tabs open
      
      if(typeof mapboxgl === 'undefined'){
        console.error('Mapbox GL failed to load');
        return;
      }
      try{
        await ensureMapboxCssFor(document.body);
      }catch(err){}
      // Validate Mapbox token before initialization
      if(!MAPBOX_TOKEN || typeof MAPBOX_TOKEN !== 'string' || MAPBOX_TOKEN.trim() === ''){
        console.error('Mapbox token is missing or invalid');
        return;
      }
      mapboxgl.accessToken = MAPBOX_TOKEN;
      if(typeof mapboxgl.setLogLevel === 'function'){
        mapboxgl.setLogLevel('error');
      }
      
      // Wait for settings to load (fast - just DB query for coordinates)
      await window._adminSettingsReady;
      
      // Ensure startCenter has a value (settings should have set it, fallback if not)
      if(!startCenter){
        startCenter = [0, 0];
        startZoom = 1.5;
      }
      
        // Mark map initialization start
        const mapInitStart = performance.now();
        
        // Hide map initially until tiles are loaded (if waitForMapTiles is enabled)
        const mapContainer = document.getElementById('map');
        let mapFadedIn = false;
        if(mapContainer){
          if(waitForMapTiles){
            mapContainer.style.opacity = '0';
            mapContainer.style.transition = 'opacity 0.8s ease-in';
          } else {
            // Show map immediately - no waiting for tiles
            mapContainer.style.opacity = '1';
            mapFadedIn = true;
          }
        }
        
        map = new mapboxgl.Map({
          container:'map',
          style:'mapbox://styles/mapbox/standard',
          projection:'globe',
          center: startCenter,
          zoom: startZoom,
          pitch: startPitch,
          bearing: startBearing,
          attributionControl:true
        });
        // Add error handler for token/auth errors
        map.on('error', (e) => {
          if(e && e.error && (e.error.message || '').includes('token') || (e.error.message || '').includes('Unauthorized')){
            console.error('Mapbox authentication error:', e.error);
          }
        });
        
        // Determine if markers need to be ready before showing map
        // Markers are visible at zoom >= 8, so if starting zoom >= 8, wait for markers
        const needsMarkers = startZoom !== null && Number.isFinite(startZoom) && startZoom >= 8;
        
        // Fade in map only when required elements are loaded
        const fadeInMap = () => {
          if(mapContainer && !mapFadedIn && mapContainer.style.opacity === '0'){
            mapFadedIn = true;
            requestAnimationFrame(() => {
              mapContainer.style.opacity = '1';
            });
          }
        };
        
        // Check if tiles are loaded
        const areTilesLoaded = () => {
          if(typeof map.areTilesLoaded === 'function'){
            return map.areTilesLoaded();
          }
          return false;
        };
        
        // Check if markers are ready (only needed if starting zoom >= 8)
        const areMarkersReady = () => {
          if(!needsMarkers) return true; // Don't wait for markers if they won't be visible
          return markersLoaded || window.__markersLoaded || false;
        };
        
        // Check if everything is ready and fade in map
        const checkReadyAndFadeIn = () => {
          if(mapFadedIn) return true;
          if(areTilesLoaded() && areMarkersReady()){
            fadeInMap();
            return true;
          }
          return false;
        };
        
        // Hook into mapLoading to fade in when tiles finish loading
        if(mapLoading && typeof mapLoading.onTilesLoaded === 'function'){
          mapLoading.onTilesLoaded(() => {
            // Tiles are loaded, check if markers are also ready (if needed)
            if(!needsMarkers || areMarkersReady()){
              fadeInMap();
            }
          });
        }
        
        // Also check on 'idle' event (fires when map is idle and tiles are loaded)
        map.once('idle', () => {
          checkReadyAndFadeIn();
        });
        
        // Also check on 'load' event (fires when style + initial tiles are ready)
        map.once('load', () => {
          // Start checking periodically for tiles and markers (if needed)
          if(!checkReadyAndFadeIn()){
            const checkInterval = setInterval(() => {
              if(checkReadyAndFadeIn() || mapFadedIn){
                clearInterval(checkInterval);
              }
            }, 100);
            // Stop checking after 5 seconds
            setTimeout(() => {
              clearInterval(checkInterval);
              if(!mapFadedIn) fadeInMap(); // Safety fallback - show map even if markers aren't ready
            }, 5000);
          }
        });
        
        // If markers are needed, also check when they load
        if(needsMarkers){
          // Monitor for markers loading
          const checkMarkersInterval = setInterval(() => {
            if(areMarkersReady() && areTilesLoaded() && !mapFadedIn){
              fadeInMap();
              clearInterval(checkMarkersInterval);
            }
          }, 100);
          // Stop checking after 5 seconds
          setTimeout(() => {
            clearInterval(checkMarkersInterval);
          }, 5000);
        }
        
        // Safety timeout: show map after 5 seconds max (prevents waiting forever)
        setTimeout(() => {
          fadeInMap();
        }, 5000);
        
        // Mark map initialization complete when map loads
        map.once('load', () => {
          const mapInitEnd = performance.now();
          window.__startupTimings.components.map = {
            start: mapInitStart,
            end: mapInitEnd,
            duration: mapInitEnd - mapInitStart,
            tilesLoaded: typeof map.areTilesLoaded === 'function' ? map.areTilesLoaded() : null
          };
        });
        
        try{ ensurePlaceholderSprites(map); }catch(err){}
        const zoomIndicatorEl = document.getElementById('mapZoomIndicator');
        const updateZoomIndicator = () => {
          if(!map || !zoomIndicatorEl || typeof map.getZoom !== 'function') return;
          try{
            const zoomLevel = map.getZoom();
            const pitchLevel = typeof map.getPitch === 'function' ? map.getPitch() : NaN;
            if(Number.isFinite(zoomLevel)){
              const zoomText = `Zoom ${zoomLevel.toFixed(2)}`;
              if(Number.isFinite(pitchLevel)){
                zoomIndicatorEl.textContent = `${zoomText}  Pitch ${Math.round(pitchLevel)}`;
              } else {
                zoomIndicatorEl.textContent = zoomText;
              }
            } else {
              zoomIndicatorEl.textContent = 'Zoom --  Pitch --';
            }
          }catch(err){}
        };
        if(zoomIndicatorEl && map && typeof map.on === 'function'){
          ['zoom','zoomend','pitch','pitchend'].forEach(evt => {
            try{ map.on(evt, updateZoomIndicator); }catch(err){}
          });
          if(typeof map.once === 'function'){
            try{ map.once('load', updateZoomIndicator); }catch(err){}
          }
          updateZoomIndicator();
        }

        // Create map scale bar for checking map card scaling
        const createMapScaleBar = () => {
          const mapArea = document.querySelector('.map-area');
          const mapControls = document.querySelector('.map-controls-map');
          if(!mapArea || !mapControls) return;
          
          // Remove existing scale bar if present
          const existingScaleBar = document.getElementById('mapScaleBar');
          if(existingScaleBar){
            existingScaleBar.remove();
          }
          
          const scaleBar = document.createElement('div');
          scaleBar.id = 'mapScaleBar';
          scaleBar.className = 'map-scale-bar';
          
          // Position scale bar 10px below map control row
          const updateScaleBarPosition = () => {
            const controlsRect = mapControls.getBoundingClientRect();
            const mapAreaRect = mapArea.getBoundingClientRect();
            const topOffset = controlsRect.bottom - mapAreaRect.top + 10;
            scaleBar.style.top = topOffset + 'px';
          };
          
          // Create scale line
          const scaleLine = document.createElement('div');
          scaleLine.className = 'scale-line';
          
          // Create marks every 10px (30 marks total for 300px)
          for(let i = 0; i <= 30; i++){
            const mark = document.createElement('div');
            mark.className = 'scale-mark';
            const position = (i / 30) * 100;
            mark.style.left = position + '%';
            // Major marks every 50px (every 5th mark)
            if(i % 5 === 0){
              mark.classList.add('major');
            }
            scaleLine.appendChild(mark);
          }
          
          // Create labels every 50px
          for(let i = 0; i <= 6; i++){
            const label = document.createElement('div');
            label.className = 'scale-label';
            const position = (i * 50);
            label.textContent = position + 'px';
            label.style.left = ((position / 300) * 100) + '%';
            scaleBar.appendChild(label);
          }
          
          scaleBar.appendChild(scaleLine);
          mapArea.appendChild(scaleBar);
          
          // Update position on resize
          updateScaleBarPosition();
          window.addEventListener('resize', updateScaleBarPosition);
          if(typeof map.on === 'function'){
            map.on('resize', updateScaleBarPosition);
          }
        };
        
        // Create scale bar after a short delay to ensure controls are rendered
        setTimeout(createMapScaleBar, 100);
        if(typeof map.once === 'function'){
          map.once('load', () => {
            setTimeout(createMapScaleBar, 100);
          });
        }

        let recentMapInteraction = false;
        let recentInteractionTimeout = null;
        const markRecentInteraction = () => {
          recentMapInteraction = true;
          if(recentInteractionTimeout){
            clearTimeout(recentInteractionTimeout);
          }
          recentInteractionTimeout = setTimeout(() => {
            recentMapInteraction = false;
            recentInteractionTimeout = null;
          }, 1200);
        };

        const mapCanvasContainer = (typeof map.getCanvasContainer === 'function') ? map.getCanvasContainer() : null;
        if(mapCanvasContainer){
          ['mousedown','touchstart','wheel','pointerdown'].forEach(evtName => {
            try{
              mapCanvasContainer.addEventListener(evtName, markRecentInteraction, { passive: true });
            }catch(err){}
          });
          if(map && typeof map.on === 'function'){
            try{
              map.on('remove', () => {
                if(recentInteractionTimeout){
                  clearTimeout(recentInteractionTimeout);
                  recentInteractionTimeout = null;
                }
                ['mousedown','touchstart','wheel','pointerdown'].forEach(evtName => {
                  try{ mapCanvasContainer.removeEventListener(evtName, markRecentInteraction, false); }catch(err){}
                });
              });
            }catch(err){}
          }
        }

        const handleWelcomeOnMapMotion = (evt) => {
          if(evt && evt.originalEvent){
            // Don't close if triggered from welcome modal compass
            const welcomeControls = document.querySelector('#welcomeBody .map-controls-welcome');
            const target = evt.originalEvent.target;
            // Check target is a valid Node before calling contains()
            if(welcomeControls && target instanceof Node && welcomeControls.contains(target)) return;
            closeWelcomeModalIfOpen();
            return;
          }
          if(recentMapInteraction){
            closeWelcomeModalIfOpen();
          }
        };

        if(map && typeof map.on === 'function'){
          ['movestart','dragstart','zoomstart','rotatestart','pitchstart','boxzoomstart'].forEach(evtName => {
            try{ map.on(evtName, handleWelcomeOnMapMotion); }catch(err){}
          });
        }
// === Pill hooks (safe) ===

        const applyStyleAdjustments = () => {
          try{ ensurePlaceholderSprites(map); }catch(err){}
          applyNightSky(map);
          patchMapboxStyleArtifacts(map);
        };
        whenStyleReady(map, applyStyleAdjustments);
        map.on('style.load', applyStyleAdjustments);
        
        map.on('styledata', () => {
          try{ ensurePlaceholderSprites(map); }catch(err){}
          if(map.isStyleLoaded && map.isStyleLoaded()){
            patchMapboxStyleArtifacts(map);
          }
        });
        ensureMapIcon = attachIconLoader(map);
        const pendingStyleImageRequests = new Map();
        const handleStyleImageMissing = (evt) => {
          const imageId = evt && evt.id;
          if(!imageId){
            return;
          }
          // Normal behavior: check cache first (fast performance)
          try{
            if(map.hasImage?.(imageId)){
              return;
            }
          }catch(err){
            console.error(err);
          }
          if(pendingStyleImageRequests.has(imageId)){
            return;
          }
          const result = generateMarkerImageFromId(imageId, map, { ensureIcon: ensureMapIcon });
          if(result && typeof result.then === 'function'){
            const task = result.then(output => {
              if(!output){
                return;
              }
              const { image, options } = output;
              if(!image){
                return;
              }
              try{
                if(!map.hasImage?.(imageId)){
                  map.addImage(imageId, image, options || {});
                }
              }catch(error){
                console.error(error);
              }
            }).catch(error => {
              console.error(error);
            }).finally(() => {
              pendingStyleImageRequests.delete(imageId);
            });
            pendingStyleImageRequests.set(imageId, task);
            return;
          }
          if(result && result.image){
            try{
              if(!map.hasImage?.(imageId)){
                map.addImage(imageId, result.image, result.options || {});
              }
            }catch(error){
              console.error(error);
            }
          }
        };
        try{ map.on('styleimagemissing', handleStyleImageMissing); }
        catch(err){ console.error(err); }

        // Map loading state management
        mapLoading = (() => {
          const loader = window.__logoLoading;
          if(!loader || typeof loader.begin !== 'function' || typeof loader.end !== 'function'){
            return null;
          }
          const motionTokens = new Set();
          let tilesPending = false;
          let active = false;
          let tilesLoadedCallback = null;

          const isMapMovingNow = () => {
            if(!map) return false;
            try{
              if(typeof map.isMoving === 'function' && map.isMoving()) return true;
              if(typeof map.isZooming === 'function' && map.isZooming()) return true;
              if(typeof map.isRotating === 'function' && map.isRotating()) return true;
              if(typeof map.isEasing === 'function' && map.isEasing()) return true;
            }catch(err){}
            return false;
          };

          const apply = (forceStop = false) => {
            const busy = !forceStop && (tilesPending || motionTokens.size > 0 || isMapMovingNow());
            if(busy){
              if(!active){
                active = true;
                try{ loader.begin('map'); }catch(err){}
              }
            } else {
              if(active){
                active = false;
                try{ loader.end('map'); }catch(err){}
              }
            }
          };

          return {
            apply,
            setTiles(pending){
              const wasPending = tilesPending;
              if(tilesPending === pending) return;
              tilesPending = pending;
              apply();
              // Fade in map when tiles finish loading (transition from pending to not pending)
              if(wasPending && !pending && tilesLoadedCallback){
                tilesLoadedCallback();
              }
            },
            onTilesLoaded(callback){
              tilesLoadedCallback = callback;
            },
            addMotion(token){
              if(motionTokens.has(token)) return;
              motionTokens.add(token);
              apply();
            },
            removeMotion(token){
              if(!motionTokens.has(token)) return;
              motionTokens.delete(token);
              apply();
            },
            clearAll(){
              motionTokens.clear();
              tilesPending = false;
              if(active){
                active = false;
                try{ loader.end('map'); }catch(err){}
              }
            }
          };
        })();

        if(mapLoading){
          const updateRenderState = () => {
            let tileBusy = false;
            if(map){
              try{
                if(typeof map.isStyleLoaded === 'function' && !map.isStyleLoaded()){
                  tileBusy = true;
                } else if(typeof map.areTilesLoaded === 'function'){
                  tileBusy = !map.areTilesLoaded();
                }
              }catch(err){
                tileBusy = true;
              }
            }
            mapLoading.setTiles(tileBusy);
            mapLoading.apply();
          };

          map.on('sourcedataloading', () => mapLoading.setTiles(true));
          map.on('render', updateRenderState);
          map.on('idle', () => {
            mapLoading.setTiles(false);
            mapLoading.apply();
          });

          ['move','zoom','rotate','pitch','drag'].forEach(evt => {
            const startEv = `${evt}start`;
            const endEv = `${evt}end`;
            map.on(startEv, () => mapLoading.addMotion(evt));
            map.on(endEv, () => mapLoading.removeMotion(evt));
          });
          ['moveend','zoomend','rotateend','pitchend','dragend'].forEach(evt => {
            map.on(evt, () => mapLoading.apply());
          });
          map.on('remove', () => mapLoading.clearAll());
        }
      map.on('zoomstart', ()=>{
        if(waitForInitialZoom){
          initialZoomStarted = true;
        }
      });
      map.on('zoom', (e)=>{
        const zoomValue = getZoomFromEvent(e);
        if(waitForInitialZoom){
          if(!initialZoomStarted){
            updateZoomState(zoomValue);
            return;
          }
          waitForInitialZoom = false;
          window.waitForInitialZoom = waitForInitialZoom;
          initialZoomStarted = false;
        }
        updateZoomState(zoomValue);
        
        // Clear composites when zoom < 8 (MARKER_ZOOM_THRESHOLD is 8) (NO FALLBACKS)
        if(Number.isFinite(zoomValue) && zoomValue < 8){
          window.MapCardComposites.clearMapCardComposites(map);
        }
        
        if(!spinning){
          scheduleCheckLoadPosts({ zoom: zoomValue, target: map });
        }
      });
      map.on('zoomend', ()=>{
        // Clear map card markers when zoom < 8
        if(window.MapCards){
          let zoomForMarkers = NaN;
          try{ zoomForMarkers = map.getZoom(); }catch(err){ zoomForMarkers = NaN; }
          if(Number.isFinite(zoomForMarkers) && zoomForMarkers < MARKER_ZOOM_THRESHOLD){
            window.MapCards.clearAllMapCardMarkers();
          }
        }
        
        if(markersLoaded) return;
        if(!map || typeof map.getZoom !== 'function') return;
        let currentZoom = NaN;
        try{ currentZoom = map.getZoom(); }catch(err){ currentZoom = NaN; }
        if(!Number.isFinite(currentZoom) || currentZoom < MARKER_PRELOAD_ZOOM){
          return;
        }
        try{ loadPostMarkers(); }catch(err){ console.error(err); }
        markersLoaded = true;
        window.__markersLoaded = true;
      });
      map.on('moveend', ()=>{
        syncGeocoderProximityToMap();
        if(!spinning){
          scheduleCheckLoadPosts({ zoom: lastKnownZoom, target: map });
        }
      });
      addControls();
      try{
        map.scrollZoom.setWheelZoomRate(1/240);
        map.scrollZoom.setZoomRate(1/240);
      }catch(e){}
      map.on('load', ()=>{
        const mapLoadStart = performance.now();
        setupSeedLayers(map);
        applyNightSky(map);
        $$('.map-overlay').forEach(el=>el.remove());
        if(spinEnabled){
          startSpin(true);
        }
        updatePostPanel();
        applyFilters();
        updateZoomState(getZoomFromEvent());
        if(!markersLoaded){
          const markersLoadStart = performance.now();
          const zoomLevel = Number.isFinite(lastKnownZoom) ? lastKnownZoom : getZoomFromEvent();
          if(Number.isFinite(zoomLevel) && zoomLevel >= MARKER_PRELOAD_ZOOM){
            try{ 
              loadPostMarkers();
              const markersLoadEnd = performance.now();
              if(!window.__startupTimings.components.markers){
                window.__startupTimings.components.markers = {
                  start: markersLoadStart,
                  end: markersLoadEnd,
                  duration: markersLoadEnd - markersLoadStart
                };
              }
            }catch(err){ 
              console.error(err);
              const markersLoadEnd = performance.now();
              if(!window.__startupTimings.components.markers){
                window.__startupTimings.components.markers = {
                  start: markersLoadStart,
                  end: markersLoadEnd,
                  duration: markersLoadEnd - markersLoadStart,
                  error: err.message || 'Unknown error'
                };
              }
            }
            markersLoaded = true;
            window.__markersLoaded = true;
          }
        }
        checkLoadPosts();
        
        // Ensure map cards are created after initial load completes
        requestAnimationFrame(() => {
          if(postsLoaded && markersLoaded){
            applyFilters();
          }
        });
        
        const mapLoadEnd = performance.now();
        if(!window.__startupTimings.components.mapLoad){
          window.__startupTimings.components.mapLoad = {
            start: mapLoadStart,
            end: mapLoadEnd,
            duration: mapLoadEnd - mapLoadStart
          };
        }
      });

      map.on('style.load', ()=>{
        setupSeedLayers(map);
        updateLayerVisibility(lastKnownZoom);
      });

        ['mousedown','wheel','touchstart','dragstart','pitchstart','rotatestart','zoomstart'].forEach(ev=> map.on(ev, haltSpin));
        let suppressNextRefresh = false;
        const refreshMapView = () => {
          if(suppressNextRefresh) return;
          scheduleCheckLoadPosts({ zoom: lastKnownZoom, target: map });
          updatePostPanel();
          updateFilterCounts();
          refreshMarkers();
          const center = map.getCenter().toArray();
          const zoom = map.getZoom();
          const pitch = map.getPitch();
          const bearing = map.getBearing();
          updateClusterSourceForZoom(zoom);
          localStorage.setItem('mapView', JSON.stringify({center, zoom, pitch, bearing}));
        };
        // Suppress initial save when map loads with saved view to prevent overwriting saved state
        suppressNextRefresh = true;
        map.once('load', () => {
          // Allow saves after initial load completes
          setTimeout(() => { suppressNextRefresh = false; }, 100);
        });
        ['moveend','zoomend','rotateend','pitchend'].forEach(ev => map.on(ev, refreshMapView));
        map.on('dragend', clearMapGeocoder);
        map.on('click', clearMapGeocoder);
        map.on('touchstart', () => requestAnimationFrame(blurAllGeocoderInputs));
      }

    function startSpin(fromCurrent=false){
      if(mode!=='map') setModeFromUser('map');
      if(!spinEnabled || spinning || !map) return;
      if(map.getZoom() >= spinZoomMax) return;
      if(typeof filterPanel !== 'undefined' && filterPanel) closePanel(filterPanel);
      spinning = true;
      hideResultIndicators();
      historyWasActive = document.body.classList.contains('show-history');
      if(historyWasActive){
        document.body.classList.remove('show-history');
        adjustBoards();
        updateModeToggle();
      }
      function step(){
        if(!spinning || !map) return;
        const isBusy = (map.isMoving && map.isMoving()) || (map.areTilesLoaded && !map.areTilesLoaded());
        if(isBusy){
          requestAnimationFrame(step);
          return;
        }
        const c = map.getCenter();
        map.setCenter([c.lng + spinSpeed, c.lat]);
        requestAnimationFrame(step);
      }
      if(fromCurrent){
        requestAnimationFrame(step);
      }else{
        const targetPitch = Number.isFinite(startPitch) ? startPitch : LEGACY_DEFAULT_PITCH;
        // Use startCenter which is already set from saved location or admin starting location
        map.easeTo({center:startCenter, zoom:startZoom, pitch:targetPitch, essential:true});
        map.once('moveend', () => requestAnimationFrame(step));
      }
    }
    function stopSpin(){
      spinning = false;
      const wasHistory = historyWasActive;
      historyWasActive = false;
      if(wasHistory){
        document.body.classList.add('show-history');
        adjustBoards();
        updateModeToggle();
      }
      const shouldLoadPosts = pendingPostLoad;
      pendingPostLoad = false;
      if(shouldLoadPosts){
        scheduleCheckLoadPosts({ zoom: lastKnownZoom, target: map });
        return;
      }
      applyFilters();
    }

    function haltSpin(e){
      const target = (e && e.originalEvent && e.originalEvent.target) || (e && e.target);
      if(target instanceof Node && logoEls.some(el=>el.contains(target))) return;
      if(spinEnabled || spinning){
        spinEnabled = false;
        stopSpin();
      }
    }

    ['pointerdown','wheel','keydown','touchstart'].forEach(ev=>
      document.addEventListener(ev, haltSpin, {capture:true})
    );

    function updateSpinState(){
      const shouldSpin = spinLoadStart && (spinLoadType === 'everyone' || (spinLoadType === 'new_users' && firstVisit));
      if(shouldSpin !== spinEnabled){
        spinEnabled = shouldSpin;
        if(spinEnabled) startSpin(); else stopSpin();
      }
    }

    window.spinGlobals = {
      get spinEnabled(){ return spinEnabled; },
      set spinEnabled(v){ spinEnabled = v; },
      get spinLoadStart(){ return spinLoadStart; },
      set spinLoadStart(v){ spinLoadStart = v; updateSpinState(); },
      get spinLoadType(){ return spinLoadType; },
      set spinLoadType(v){ spinLoadType = v; updateSpinState(); },
      get spinLogoClick(){ return spinLogoClick; },
      set spinLogoClick(v){ spinLogoClick = v; updateLogoClickState(); },
      get spinZoomMax(){ return spinZoomMax; },
      set spinZoomMax(v){ spinZoomMax = v; },
      get spinSpeed(){ return spinSpeed; },
      set spinSpeed(v){ spinSpeed = v; },
      get waitForMapTiles(){ return waitForMapTiles; },
      set waitForMapTiles(v){ waitForMapTiles = v; },
      startSpin,
      stopSpin,
      updateSpinState,
      updateLogoClickState
    };

    // Map layers
    function collectLocationEntries(post){
      const entries = [];
      const locs = Array.isArray(post?.locations) ? post.locations : [];
      locs.forEach((loc, idx) => {
        if(!loc) return;
        const lng = Number(loc.lng);
        const lat = Number(loc.lat);
        if(!Number.isFinite(lng) || !Number.isFinite(lat)) return;
        entries.push({
          post,
          loc,
          lng,
          lat,
          index: idx,
          key: venueKey(lng, lat)
        });
      });
      if(!entries.length && Number.isFinite(post?.lng) && Number.isFinite(post?.lat)){
        const fallbackVenue = typeof post?.venue === 'string' && post.venue
          ? post.venue
          : (post?.city || '');
        entries.push({
          post,
          loc:{
            venue: fallbackVenue,
            address: post?.city || '',
            lng: post.lng,
            lat: post.lat
          },
          lng: post.lng,
          lat: post.lat,
          index: 0,
          key: venueKey(post.lng, post.lat)
        });
      }
      return entries.filter(entry => entry.key);
    }

    function postsToGeoJSON(list){
      const features = [];
      if(!Array.isArray(list) || !list.length){
        return { type:'FeatureCollection', features };
      }

      const venueGroups = new Map();
      const orphanEntries = [];

      list.forEach(p => {
        if(!p) return;
        const entries = collectLocationEntries(p);
        entries.forEach(entry => {
          if(!entry) return;
          const key = entry.key;
          const post = entry.post || p;
          if(!key){
            orphanEntries.push({ post, entry });
            return;
          }
          let group = venueGroups.get(key);
          if(!group){
            group = { key, entries: [], postIds: new Set() };
            venueGroups.set(key, group);
          }
          group.entries.push({ post, entry });
          if(post && post.id !== undefined && post.id !== null){
            const strId = String(post.id);
            if(strId) group.postIds.add(strId);
          }
        });
      });

      const buildSingleFeature = ({ post, entry }) => {
        if(!post || !entry) return null;
        const key = entry.key || '';
        const baseSub = slugify(post.subcategory);
        const labelLines = getMarkerLabelLines(post);
        const combinedLabel = buildMarkerLabelText(post, labelLines);
        const featureId = key
          ? `post:${post.id}::${key}::${entry.index}`
          : `post:${post.id}::${entry.index}`;
        const venueName = entry.loc && entry.loc.venue ? entry.loc.venue : getPrimaryVenueName(post);
        // Get thumbnail URL for big composites (thumbUrl is a global function)
        const thumbnailUrl = typeof thumbUrl === 'function' ? thumbUrl(post) : null;
        return {
          type:'Feature',
          id: featureId,
          properties:{
            id: post.id,
            featureId,
            title: post.title,
            label: combinedLabel,
            labelLine1: labelLines.line1,
            labelLine2: labelLines.line2,
            venueName,
            city: post.city,
            cat: post.category,
            sub: baseSub,
            baseSub,
            venueKey: key,
            locationIndex: entry.index,
            isMultiPost: false,
            thumbnailUrl
          },
          geometry:{ type:'Point', coordinates:[entry.lng, entry.lat] }
        };
      };

      const buildMultiFeature = (group) => {
        if(!group || !group.entries.length) return null;
        const multiCount = group.postIds.size;
        if(multiCount <= 1){
          return group.entries.map(buildSingleFeature).filter(Boolean);
        }
        const primary = group.entries[0];
        if(!primary || !primary.post || !primary.entry) return null;
        const { post, entry } = primary;
        const baseSub = slugify(post.subcategory);
        const multiIconId = MULTI_POST_MARKER_ICON_ID;
        const venueName = (() => {
          for(const item of group.entries){
            const candidate = item && item.entry && item.entry.loc && item.entry.loc.venue;
            if(candidate){
              return candidate;
            }
          }
          return getPrimaryVenueName(post);
        })() || '';
        const multiCountLabel = `${multiCount} posts here`;
        const multiPostText = shortenMarkerLabelText(venueName, markerLabelTextAreaWidthPx);
        const combinedLabel = multiPostText ? `${multiCountLabel}\n${multiPostText}` : multiCountLabel;
        // Include venueKey in sprite source to ensure unique sprite IDs for different venues
        // Even if they have same icon, count, and venue name
        const featureId = `venue:${group.key}::${post.id}`;
        const coordinates = [entry.lng, entry.lat];
        const multiIds = Array.from(group.postIds);
        // Get thumbnail URL for big composites (use first post's thumbnail)
        const thumbnailUrl = typeof thumbUrl === 'function' ? thumbUrl(post) : null;
        return [{
          type:'Feature',
          id: featureId,
          properties:{
            id: post.id,
            featureId,
            title: multiCountLabel,
            label: combinedLabel,
            labelLine1: multiCountLabel,
            labelLine2: multiPostText,
            venueName,
            city: post.city,
            cat: post.category,
            sub: multiIconId,
            baseSub,
            venueKey: group.key,
            locationIndex: entry.index,
            isMultiPost: true,
            multiCount,
            multiPostIds: multiIds,
            thumbnailUrl
          },
          geometry:{ type:'Point', coordinates }
        }];
      };

      venueGroups.forEach(group => {
        const result = buildMultiFeature(group);
        if(Array.isArray(result)){
          result.forEach(feature => { 
            if(feature) {
              // Prevent duplicate multi-post features - check if feature with same coordinates already exists
              const existing = features.find(f => 
                f && f.geometry && feature.geometry &&
                Array.isArray(f.geometry.coordinates) && Array.isArray(feature.geometry.coordinates) &&
                f.geometry.coordinates.length >= 2 && feature.geometry.coordinates.length >= 2 &&
                Math.abs(f.geometry.coordinates[0] - feature.geometry.coordinates[0]) < 0.0001 &&
                Math.abs(f.geometry.coordinates[1] - feature.geometry.coordinates[1]) < 0.0001 &&
                f.properties && f.properties.isMultiPost && feature.properties && feature.properties.isMultiPost
              );
              if(!existing){
                features.push(feature);
              }
            }
          });
        }
      });

      orphanEntries.forEach(item => {
        const feature = buildSingleFeature(item);
        if(feature) features.push(feature);
      });

      return {
        type:'FeatureCollection',
        features
      };
    }

    let addingPostSource = false;
    let pendingAddPostSource = false;

    // --- Section 7: Map Source Integration ---
    function loadPostMarkers(){
      try{
        addPostSource();
      }catch(err){
        console.error('loadPostMarkers failed', err);
      }
    }

    async function addPostSource(){
      if(!map){
        return;
      }
      if(addingPostSource){
        pendingAddPostSource = true;
        return;
      }
      addingPostSource = true;
      if(map && Number.isFinite(lastKnownZoom) && lastKnownZoom >= MARKER_SPRITE_ZOOM){
        map.__retainAllMarkerSprites = true;
      }
      try{
      const markerList = filtersInitialized && Array.isArray(filtered) ? filtered : posts;
      const collections = getMarkerCollections(markerList);
      const { postsData, signature, featureIndex } = collections;
      markerFeatureIndex = featureIndex instanceof Map ? featureIndex : new Map();
      const featureCount = Array.isArray(postsData.features) ? postsData.features.length : 0;
      if(featureCount > 1000){
        await new Promise(resolve => scheduleIdle(resolve, 120));
      }
      const MARKER_MIN_ZOOM = MARKER_ZOOM_THRESHOLD;
      
      // NEW MARKER SYSTEM: Create DOM Markers instead of composites
      const currentZoom = typeof map.getZoom === 'function' ? map.getZoom() : 0;
      
      // Only show markers at zoom >= 8
      if(Number.isFinite(currentZoom) && currentZoom >= MARKER_ZOOM_THRESHOLD && window.MapCards){
        const featuresToProcess = Array.isArray(postsData.features) ? postsData.features : [];
        
        // Build set of feature IDs to keep
        const newFeatureIds = new Set();
        featuresToProcess.forEach(feature => {
          if(!feature || !feature.properties || feature.properties.point_count) return;
          newFeatureIds.add(feature.properties.id);
        });
        
        // Remove markers that are no longer in the feature set
        const existingMarkers = window.MapCards.getAllMapCardMarkers();
        existingMarkers.forEach((entry, postId) => {
          if(!newFeatureIds.has(postId)){
            window.MapCards.removeMapCardMarker(postId);
          }
        });
        
        // Create or update markers
        featuresToProcess.forEach(feature => {
          if(!feature || !feature.properties || feature.properties.point_count) return;
          
          const props = feature.properties;
          const coords = feature.geometry && feature.geometry.coordinates;
          if(!Array.isArray(coords) || coords.length < 2) return;
          
          // Skip if marker already exists
          if(window.MapCards.getMapCardMarker(props.id)) return;
          
          // Parse multiPostIds - GeoJSON may stringify arrays
          let multiPostIds = props.multiPostIds || [];
          if(typeof multiPostIds === 'string'){
            try { multiPostIds = JSON.parse(multiPostIds); } catch(e) { multiPostIds = []; }
          }
          if(!Array.isArray(multiPostIds)) multiPostIds = [];
          
          const post = {
            id: props.id,
            title: props.title || '',
            sub: props.sub || null,
            venue: props.venue || '',
            city: props.city || '',
            isMultiPost: props.isMultiPost || false,
            multiPostIds: multiPostIds,
            multiCount: props.multiCount || 0,
            locations: props.locations || [],
            thumbnailUrl: typeof thumbUrl === 'function' ? thumbUrl(props) : null
          };
          
          window.MapCards.createMapCardMarker(map, post, {
            lng: coords[0],
            lat: coords[1]
          });
        });
      } else if(window.MapCards){
        // Below zoom 8 - clear all markers
        window.MapCards.clearAllMapCardMarkers();
      }
      
      const existing = map.getSource('posts');
      if(!existing){
        map.addSource('posts', { type:'geojson', data: postsData, promoteId: 'featureId' });
        const source = map.getSource('posts');
        if(source){ source.__markerSignature = signature; }
      } else {
        existing.setData(postsData);
        existing.__markerSignature = signature;
      }
      const iconIds = Object.keys(subcategoryMarkers);
      if(typeof ensureMapIcon === 'function'){
        // NO FALLBACKS - errors will be thrown
        await Promise.all(iconIds.map(id => ensureMapIcon(id)));
      }
      // Pre-load marker-icon sprites and add them to map
      const markerIconIds = new Set();
      postsData.features.forEach(feature => {
        if(feature.properties && !feature.properties.point_count){
          const iconId = feature.properties.sub || MULTI_POST_MARKER_ICON_ID;
          markerIconIds.add(iconId);
        }
      });
      markerIconIds.add(MULTI_POST_MARKER_ICON_ID);
      for(const iconId of markerIconIds){
        if(typeof ensureMapIcon === 'function'){
          // NO FALLBACKS - errors will be thrown
          await ensureMapIcon(iconId);
        }
        const iconUrl = subcategoryMarkers[iconId];
        if(iconUrl && !map.hasImage(iconId)){
          // Load marker icon (NO FALLBACKS - errors will be thrown)
          const img = await loadMarkerLabelImage(iconUrl);
          if(img){
            let deviceScale = 2;
            const ratio = window.devicePixelRatio;
            if(Number.isFinite(ratio) && ratio > 0){
              deviceScale = ratio;
            }
            if(!Number.isFinite(deviceScale) || deviceScale <= 0){
              deviceScale = 2;
            }
            const iconSize = Math.round(markerIconBaseSizePx * deviceScale);
            const canvas = document.createElement('canvas');
            canvas.width = iconSize;
            canvas.height = iconSize;
            const ctx = canvas.getContext('2d');
            if(ctx){
              ctx.drawImage(img, 0, 0, iconSize, iconSize);
              const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
              map.addImage(iconId, imageData, { pixelRatio: deviceScale });
            }
          }
        }
      }
      
      // NEW MARKER SYSTEM: Pills are CSS background-images, not Mapbox sprites
      // No need to load pill sprites or create composite layers
      
      updateMapFeatureHighlights(lastHighlightedPostIds);
      
      // Expose map instance getter
      window.getMapInstance = () => map;
      
      // updateMapCardLayerOpacity is now a no-op (Markers use CSS)
      window.updateMapCardLayerOpacity = function(displayMode) {
        // Markers handle visibility via CSS, not Mapbox layer opacity
      };
      
      if(!postSourceEventsBound){

        const handleMarkerClick = (e)=>{
          stopSpin();
          const f = e.features && e.features[0]; if(!f) return;
          const props = f.properties || {};
          const venueKey = props.venueKey || null;
          const id = props.id;
          const rawMultiIds = Array.isArray(props.multiPostIds) ? props.multiPostIds : [];
          const normalizedMultiIds = rawMultiIds.map(item => String(item)).filter(Boolean);
          const multiCountFromProps = Number(props.multiCount);
          let normalizedMultiCount = Number.isFinite(multiCountFromProps) && multiCountFromProps > 0 ? multiCountFromProps : 0;
          if(!normalizedMultiCount){
            normalizedMultiCount = normalizedMultiIds.length;
          }
          const helperMultiCount = Math.max(normalizedMultiIds.length, normalizedMultiCount, props.isMultiPost ? 2 : 0);
          const isMultiPost = helperMultiCount > 1;
          const touchClick = isTouchDevice || (e.originalEvent && (e.originalEvent.pointerType === 'touch' || e.originalEvent.pointerType === 'pen'));
          
            // Set active state on mapcard via MapCards API
            if(id !== undefined && id !== null){
              if(window.MapCards && window.MapCards.setMapCardActive){
                window.MapCards.setMapCardActive(id);
              }
            }
          
          if(touchClick){
            // Two-tap system: first tap shows accent pill, second tap opens post
            if(touchMarker === id){
              // Second tap on same marker - open the post
              touchMarker = null;
              hoveredPostIds = [];
              if(id !== undefined && id !== null){
                activePostId = id;
                selectedVenueKey = venueKey;
                syncPostCardHighlights();
              }
              const p = posts.find(x=>x.id===id);
              if(p){
                callWhenDefined('openPost', (fn)=>{
                  requestAnimationFrame(() => {
                    try{
                      stopSpin();
                      if(typeof closePanel === 'function' && typeof filterPanel !== 'undefined' && filterPanel){
                        try{ closePanel(filterPanel); }catch(err){}
                      }
                      fn(id, false, true, null);
                    }catch(err){ console.error(err); }
                  });
                });
              }
              if(isMultiPost){
                autoOpenPostBoardForMultiPost({
                  multiIds: normalizedMultiIds,
                  multiCount: helperMultiCount,
                  trigger: 'touch'
                });
              }
              return;
            } else {
              // First tap - show accent pill, don't open
              touchMarker = id;
              if(id !== undefined && id !== null){
                hoveredPostIds = [{ id: String(id), venueKey: venueKey }];
                syncPostCardHighlights();
              }
              return;
            }
          }
          
          // Non-touch: open immediately
          if(id !== undefined && id !== null){
            activePostId = id;
            selectedVenueKey = venueKey;
            syncPostCardHighlights();
          }
          const coords = f.geometry && f.geometry.coordinates;
          const hasCoords = Array.isArray(coords) && coords.length >= 2 && Number.isFinite(coords[0]) && Number.isFinite(coords[1]);
          const baseLngLat = hasCoords ? { lng: coords[0], lat: coords[1] } : (e && e.lngLat ? { lng: e.lngLat.lng, lat: e.lngLat.lat } : null);
          const fixedLngLat = baseLngLat || (e && e.lngLat ? { lng: e.lngLat.lng, lat: e.lngLat.lat } : null);
          const targetLngLat = baseLngLat || (e ? e.lngLat : null);
          if(isMultiPost){
            autoOpenPostBoardForMultiPost({
              multiIds: normalizedMultiIds,
              multiCount: helperMultiCount,
              trigger: 'click'
            });
          } else {
            const p = posts.find(x=>x.id===id);
            if(p){
              callWhenDefined('openPost', (fn)=>{
                requestAnimationFrame(() => {
                  try{
                    touchMarker = null;
                    stopSpin();
                    if(typeof closePanel === 'function' && typeof filterPanel !== 'undefined' && filterPanel){
                      try{ closePanel(filterPanel); }catch(err){}
                    }
                    fn(id, false, true, null);
                  }catch(err){ console.error(err); }
                });
              });
            }
          }
        };
      // Attach click handlers to interactive layers (dynamic based on mapCardDisplay)
      const attachClickHandlers = () => {
        // Remove old handlers from all possible layers (including obsolete ones for cleanup)
        const allPossibleLayers = ['mapmarker-icon', 'small-map-card-pill', 'big-map-card-pill', 'small-map-card-composite', 'big-map-card-composite'];
        allPossibleLayers.forEach(layer => {
          try {
            map.off('click', layer, handleMarkerClick);
          } catch(e) {}
        });
        // Add handlers to current interactive layers
        getMarkerInteractiveLayers().forEach(layer => {
          try {
            map.on('click', layer, handleMarkerClick);
          } catch(e) {}
        });
      };
      attachClickHandlers();
      // Expose globally so handlers can be updated when mapCardDisplay changes
      window.attachClickHandlers = attachClickHandlers;

      // Function to update mapcard click and post-open states
      function updateMapCardStates(){
        const openPostEl = document.querySelector('.open-post[data-id]');
        const openPostId = openPostEl && openPostEl.dataset ? String(openPostEl.dataset.id || '') : '';
        
        // Use MapCards API for state management
        if(window.MapCards){
          const markers = window.MapCards.getAllMapCardMarkers ? window.MapCards.getAllMapCardMarkers() : null;
          if(markers){
            let foundMarker = false;
            // Find marker that contains the open post (check multiPostIds for multi-post markers)
            if(openPostId){
              markers.forEach((entry, markerId) => {
                const post = entry.post;
                const markerIds = [String(markerId)];
                // Include all IDs from multiPostIds array
                if(post && Array.isArray(post.multiPostIds)){
                  post.multiPostIds.forEach(pid => {
                    if(pid) markerIds.push(String(pid));
                  });
                }
                // Check if open post is in this marker's IDs
                if(markerIds.includes(openPostId)){
                  window.MapCards.setMapCardActive(markerId);
                  foundMarker = true;
                } else if(entry.state === 'big'){
                  window.MapCards.removeMapCardActive(markerId);
                }
              });
            }
            // If no open post, clear all active states
            if(!openPostId || !foundMarker){
              markers.forEach((entry, id) => {
                if(entry.state === 'big'){
                  window.MapCards.removeMapCardActive(id);
                }
              });
            }
          }
        }
      }
      
      // Expose globally
      window.updateMapCardStates = updateMapCardStates;
      
      map.on('click', e=>{
        const originalTarget = e.originalEvent && e.originalEvent.target;
        // Check for clicks on map card markers (new Marker system)
        const mapCardContainer = originalTarget && typeof originalTarget.closest === 'function'
          ? originalTarget.closest('.map-card-container')
          : null;
        if(mapCardContainer){
          const pillEl = mapCardContainer.querySelector('.map-card-pill');
          const pid = pillEl && pillEl.dataset ? pillEl.dataset.id : null;
          if(pid){
            // Set active state via MapCards API
            if(window.MapCards && window.MapCards.setMapCardActive){
              window.MapCards.setMapCardActive(pid);
            }
            
            callWhenDefined('openPost', (fn)=>{
              requestAnimationFrame(() => {
                try{
                  touchMarker = null;
                  stopSpin();
                  if(typeof closePanel === 'function' && typeof filterPanel !== 'undefined' && filterPanel){
                    try{ closePanel(filterPanel); }catch(err){}
                  }
                  fn(pid, false, true, null);
                }catch(err){ console.error(err); }
              });
            });
          }
          return;
        }
        const feats = map.queryRenderedFeatures(e.point);
        if(!feats.length){
          // Clicked elsewhere - clear active states
          syncPostCardHighlights();
          touchMarker = null;
          hoveredPostIds = [];
          syncPostCardHighlights();
          updateMapCardStates();
        } else {
          const clickedMarkerLabel = feats.some(f => getMarkerInteractiveLayers().includes(f.layer && f.layer.id));
          if(!clickedMarkerLabel){
            // Clicked elsewhere - clear active states
            touchMarker = null;
            hoveredPostIds = [];
            syncPostCardHighlights();
            updateMapCardStates();
          }
        }
      });

      syncPostCardHighlights();

      // Set pointer cursor when hovering over markers (dynamic based on mapCardDisplay)
      // Store cursor handler functions so we can remove only these specific handlers
      const cursorEnterHandler = () => {
        map.getCanvas().style.cursor = 'pointer';
      };
      const cursorLeaveHandler = () => {
        map.getCanvas().style.cursor = 'grab';
      };
      const attachCursorHandlers = () => {
        // Remove only our cursor handlers from all possible layers (including obsolete ones for cleanup)
        const allPossibleLayers = ['mapmarker-icon', 'small-map-card-pill', 'big-map-card-pill', 'small-map-card-composite', 'big-map-card-composite'];
        allPossibleLayers.forEach(layer => {
          try {
            map.off('mouseenter', layer, cursorEnterHandler);
            map.off('mouseleave', layer, cursorLeaveHandler);
          } catch(e) {}
        });
        // Add cursor handlers to current interactive layers only
        getMarkerInteractiveLayers().forEach(layer => {
          try {
            map.on('mouseenter', layer, cursorEnterHandler);
            map.on('mouseleave', layer, cursorLeaveHandler);
          } catch(e) {}
        });
      };
      attachCursorHandlers();
      // Expose globally so handlers can be updated when mapCardDisplay changes
      window.attachCursorHandlers = attachCursorHandlers;

      // Handle hover/tap to show accent pill
      // Uses Mapbox sprite layer system only - no DOM handlers to avoid conflicts
      // Only uses marker-icon layer for precise hover zone
      // Uses mousemove to track hover continuously for smooth transitions between markers
      let currentHoveredId = null;
      let hoverCheckTimeout = null;
      
      const updateHoverFromPoint = (point) => {
        if(!point) return;
        
        // Clear any pending hover check
        if(hoverCheckTimeout){
          clearTimeout(hoverCheckTimeout);
          hoverCheckTimeout = null;
        }
        
        // Query what's under the cursor
        const features = map.queryRenderedFeatures(point, {
          layers: ['mapmarker-icon']
        });
        
        if(features.length > 0){
          const f = features[0];
          const props = f.properties || {};
          const id = props.id;
          const venueKey = props.venueKey || null;
          
          if(id !== undefined && id !== null && String(id) !== currentHoveredId){
            currentHoveredId = String(id);
            hoveredPostIds = [{ id: String(id), venueKey: venueKey }];
            syncPostCardHighlights();
          }
        } else {
          // Not over any marker - clear hover after a short delay
          hoverCheckTimeout = setTimeout(() => {
            // Double-check we're still not over a marker
            const recheckFeatures = map.queryRenderedFeatures(point, {
              layers: ['mapmarker-icon']
            });
            if(recheckFeatures.length === 0){
              currentHoveredId = null;
              hoveredPostIds = [];
              syncPostCardHighlights();
            }
            hoverCheckTimeout = null;
          }, 50);
        }
      };
      
      const handleMarkerHover = (e) => {
        // Cancel any pending hover clear
        if(hoverCheckTimeout){
          clearTimeout(hoverCheckTimeout);
          hoverCheckTimeout = null;
        }
        
        const f = e.features && e.features[0];
        if(!f) return;
        const props = f.properties || {};
        const id = props.id;
        const venueKey = props.venueKey || null;
        
        if(id !== undefined && id !== null){
          currentHoveredId = String(id);
          hoveredPostIds = [{ id: String(id), venueKey: venueKey }];
          syncPostCardHighlights();
        }
      };

      const handleMarkerHoverEnd = (e) => {
        // Use mousemove to check what we're over now - this handles smooth transitions
        if(e.point){
          updateHoverFromPoint(e.point);
        } else {
          // No point info, clear after delay
          hoverCheckTimeout = setTimeout(() => {
            currentHoveredId = null;
            hoveredPostIds = [];
            syncPostCardHighlights();
            hoverCheckTimeout = null;
          }, 50);
        }
      };
      
      // Also track mousemove over the map to catch transitions between markers
      const handleMapMouseMove = (e) => {
        if(e.point){
          updateHoverFromPoint(e.point);
        }
      };
      
      // Expose hover handlers globally so they can be updated when mapCardDisplay changes
      window.handleMarkerHover = handleMarkerHover;
      window.handleMarkerHoverEnd = handleMarkerHoverEnd;

      // Add hover handlers - ONLY on marker-icon layer for precise hover zone
      // marker-icon is a small icon (30px), so hover zone is precise and matches visual
      // Using only marker-icon ensures hover works reliably and precisely
      map.on('mouseenter', 'mapmarker-icon', handleMarkerHover);
      map.on('mouseleave', 'mapmarker-icon', handleMarkerHoverEnd);
      // Track mousemove to catch smooth transitions between markers
      map.on('mousemove', 'mapmarker-icon', handleMapMouseMove);


      // Maintain pointer cursor for clusters and surface multi-post cards when applicable
        postSourceEventsBound = true;
      }
      } catch (err) {
        console.error('addPostSource failed', err);
      } finally {
        addingPostSource = false;
        const shouldReplay = pendingAddPostSource;
        pendingAddPostSource = false;
        if(shouldReplay){
          addPostSource();
        }
      }
    }
    window.addPostSource = addPostSource;
    function renderLists(list){
      if(spinning || !postsLoaded) return;
      
      // Build set of filtered post IDs for quick lookup
      const filteredIds = new Set(list.map(p => String(p.id)));
      
      // Helper to update visibility of post cards based on filter
      const updateCardVisibility = (container) => {
        if(!container) return;
        // Hide regular post cards
        container.querySelectorAll('.post-card').forEach(card => {
          const cardId = card.dataset.id;
          if(cardId && !filteredIds.has(cardId)){
            card.style.display = 'none';
          } else {
            card.style.display = '';
          }
        });
        // Also hide open posts that are outside the filter
        container.querySelectorAll('.open-post').forEach(openPost => {
          const postId = openPost.dataset.id;
          if(postId && !filteredIds.has(postId)){
            openPost.style.display = 'none';
          } else {
            openPost.style.display = '';
          }
        });
      };
      
      // If there's an open post, update visibility of existing cards instead of full re-render
      const existingOpenPost = postsWideEl.querySelector('.open-post');
      if(existingOpenPost){
        // Hide/show post cards based on filtered list
        updateCardVisibility(postsWideEl);
        updateCardVisibility(resultsEl);
        
        // Just update the sorted list and counts without rebuilding the DOM
        const sort = currentSort;
        const arr = list.slice();
        if(sort==='az') arr.sort((a,b)=> a.title.localeCompare(b.title));
        if(sort==='soon') arr.sort((a,b)=> a.dates[0].localeCompare(b.dates[0]));
        if(sort==='nearest'){
          let ref = {lng:0,lat:0}; if(map){ const c = map.getCenter(); ref = {lng:c.lng,lat:c.lat}; }
          arr.sort((a,b)=> distKm({lng:a.lng,lat:a.lat}, ref) - distKm({lng:b.lng,lat:b.lat}, ref));
        }
        if(favToTop && !favSortDirty) arr.sort((a,b)=> (b.fav - a.fav));
        
        const { postsData } = getMarkerCollections(arr);
        const boundsForCount = getVisibleMarkerBoundsForCount();
        const markerTotal = boundsForCount ? countMarkersForVenue(arr, null, boundsForCount) : countMarkersForVenue(arr);
        
        sortedPostList = arr;
        updateResultCount(markerTotal);
        
        // Show/hide empty state message based on visible cards
        let existingEmptyWrap = postsWideEl.querySelector('.post-board-empty');
        if(markerTotal === 0){
          // Show empty state if not already showing
          if(!existingEmptyWrap){
            existingEmptyWrap = document.createElement('div');
            existingEmptyWrap.className = 'post-board-empty';
            const summaryEl = $('#filterSummary');
            const summaryText = summaryEl ? summaryEl.textContent.trim() : '';
            const summaryCopy = document.createElement('div');
            summaryCopy.className = 'msg--summary post-board-empty-summary';
            summaryCopy.textContent = summaryText || 'No results match your filters.';
            existingEmptyWrap.appendChild(summaryCopy);
            const emptyImg = document.createElement('img');
            emptyImg.src = 'assets/monkeys/Firefly_cute-little-monkey-in-red-cape-pointing-up-937096.png';
            emptyImg.alt = 'Cute little monkey in red cape pointing up';
            emptyImg.className = 'post-board-empty-image';
            existingEmptyWrap.appendChild(emptyImg);
            const emptyMsg = document.createElement('p');
            emptyMsg.className = 'post-board-empty-message';
            emptyMsg.dataset.messageKey = 'msg_posts_empty_state';
            emptyMsg.textContent = 'There are no posts here. Try moving the map or changing your filter settings.';
            existingEmptyWrap.appendChild(emptyMsg);
            postsWideEl.appendChild(existingEmptyWrap);
          }
          existingEmptyWrap.style.display = '';
        } else if(existingEmptyWrap){
          existingEmptyWrap.style.display = 'none';
        }
        
        return;
      }
      
      const sort = currentSort;
      const arr = list.slice();
      if(sort==='az') arr.sort((a,b)=> a.title.localeCompare(b.title));
      if(sort==='soon') arr.sort((a,b)=> a.dates[0].localeCompare(b.dates[0]));
      if(sort==='nearest'){
        let ref = {lng:0,lat:0}; if(map){ const c = map.getCenter(); ref = {lng:c.lng,lat:c.lat}; }
        arr.sort((a,b)=> distKm({lng:a.lng,lat:a.lat}, ref) - distKm({lng:b.lng,lat:b.lat}, ref));
      }
      if(favToTop && !favSortDirty) arr.sort((a,b)=> (b.fav - a.fav));

      const { postsData } = getMarkerCollections(arr);
      const boundsForCount = getVisibleMarkerBoundsForCount();
      const markerTotal = boundsForCount ? countMarkersForVenue(arr, null, boundsForCount) : countMarkersForVenue(arr);

      sortedPostList = arr;
      renderedPostCount = 0;

      if(postBatchObserver) postBatchObserver.disconnect();
      removeScrollListener(postsWideEl, onPostBoardScroll, postBoardScrollOptions);
      postBoardScrollOptions = null;
      if(postSentinel) postSentinel.remove();
      postSentinel = null;

      if(resultsEl) resultsEl.innerHTML = '';
      postsWideEl.innerHTML = '';

      if(markerTotal === 0){
        updateResultCount(0);
        const emptyWrap = document.createElement('div');
        emptyWrap.className = 'post-board-empty';
        const summaryEl = $('#filterSummary');
        const summaryText = summaryEl ? summaryEl.textContent.trim() : '';
        const summaryCopy = document.createElement('div');
        summaryCopy.className = 'msg--summary post-board-empty-summary';
        summaryCopy.textContent = summaryText || 'No results match your filters.';
        emptyWrap.appendChild(summaryCopy);
        const emptyImg = document.createElement('img');
        emptyImg.src = 'assets/monkeys/Firefly_cute-little-monkey-in-red-cape-pointing-up-937096.png';
        emptyImg.alt = 'Cute little monkey in red cape pointing up';
        emptyImg.className = 'post-board-empty-image';
        emptyWrap.appendChild(emptyImg);
        const emptyMsg = document.createElement('p');
        emptyMsg.className = 'post-board-empty-message';
        emptyMsg.dataset.messageKey = 'msg_posts_empty_state';
        emptyMsg.textContent = 'There are no posts here. Try moving the map or changing your filter settings.';
        emptyWrap.appendChild(emptyMsg);
        // Load message from DB asynchronously
        (async () => {
          const msg = await getMessage('msg_posts_empty_state', {}, false);
          if(msg) emptyMsg.textContent = msg;
        })();
        postsWideEl.appendChild(emptyWrap);
        return;
      }

      postSentinel = document.createElement('div');
      postSentinel.style.height = '1px';
      postsWideEl.appendChild(postSentinel);

      if(spinning && arr.length){
        const sample = card(arr[0], true);
        sample.style.visibility = 'hidden';
        postsWideEl.insertBefore(sample, postSentinel);
        const rect = sample.getBoundingClientRect();
        const style = getComputedStyle(sample);
        const cardHeight = rect.height + parseFloat(style.marginBottom || 0);
        postsWideEl.removeChild(sample);
        const max = Math.max(1, Math.floor(postsModeEl.clientHeight / cardHeight));
        appendPostBatch(max);
      } else {
        appendPostBatch(INITIAL_RENDER_COUNT);
      }

      updateResultCount(markerTotal);

      if('IntersectionObserver' in window){
        postBatchObserver = new IntersectionObserver(entries => {
          entries.forEach(entry => {
            if(entry.isIntersecting){
              appendPostBatch();
            }
          });
        }, {root: postsWideEl, rootMargin:'0px 0px 200px 0px'});
        postBatchObserver.observe(postSentinel);
      } else {
        postBoardScrollOptions = addPassiveScrollListener(postsWideEl, onPostBoardScroll);
      }
    }
    function updateResultCount(n){
      const el = $('#resultCount');
      if(!el) return;
      if(spinning){
        el.innerHTML = '';
        el.style.display = 'none';
        return;
      }
      el.innerHTML = `<strong>${n}</strong>`;
      el.style.display = '';
    }
    function formatDates(d){
      if(!d || !d.length) return '';
      const sorted = d.slice().sort();
      const currentYear = new Date().getFullYear();
      const formatPart = (dateObj, includeYear=false)=>{
        const base = dateObj.toLocaleDateString('en-GB',{weekday:'short', day:'numeric', month:'short'}).replace(/,/g,'');
        return includeYear ? `${base}, ${dateObj.getFullYear()}` : base;
      };
      const first = parseISODate(sorted[0]);
      const last = parseISODate(sorted[sorted.length-1]);
      if(sorted.length === 1){
        const includeYear = first.getFullYear() !== currentYear;
        return formatPart(first, includeYear);
      }
      const firstYear = first.getFullYear();
      const lastYear = last.getFullYear();
      const crossYear = firstYear !== lastYear;
      const firstIncludeYear = crossYear && firstYear !== currentYear;
      const lastIncludeYear = (crossYear && lastYear !== currentYear) || (!crossYear && lastYear !== currentYear);
      const startText = formatPart(first, firstIncludeYear);
      const endText = formatPart(last, lastIncludeYear);
      return `${startText} - ${endText}`;
    }

    function parseCreatedToDate(created){
      if(!created) return null;
      const parts = created.split('T');
      if(parts.length < 2) return null;
      const [datePart, rawTime] = parts;
      if(!datePart) return null;
      const hasZ = rawTime.endsWith('Z');
      const timeCore = hasZ ? rawTime.slice(0, -1) : rawTime;
      const [hh = '00', mm = '00', ss = '00', ms = ''] = timeCore.split('-');
      const iso = `${datePart}T${hh.padStart(2,'0')}:${mm.padStart(2,'0')}:${ss.padStart(2,'0')}${ms ? '.' + ms : ''}${hasZ ? 'Z' : ''}`;
      const dt = new Date(iso);
      return Number.isNaN(dt.getTime()) ? null : dt;
    }

    function formatPostTimestamp(created){
      const dt = parseCreatedToDate(created);
      if(!dt) return '';
      const y = dt.getUTCFullYear();
      const m = String(dt.getUTCMonth()+1).padStart(2,'0');
      const d = String(dt.getUTCDate()).padStart(2,'0');
      const hh = String(dt.getUTCHours()).padStart(2,'0');
      const mm = String(dt.getUTCMinutes()).padStart(2,'0');
      return `${y}-${m}-${d} ${hh}:${mm} UTC`;
    }

    function prioritizeVisibleImages(){
      const roots = [postsWideEl];
      if(resultsEl) roots.push(resultsEl);
      roots.forEach(root => {
        const imgs = root.querySelectorAll('img.thumb');
        if(!imgs.length) return;
        if('IntersectionObserver' in window){
          const observerRoot = root === postsWideEl ? root.closest('.post-board') : root;
          const obs = new IntersectionObserver(entries => {
            entries.forEach(entry => {
              if(entry.isIntersecting){
                const img = entry.target;
                if(img.dataset.src){
                  img.addEventListener('load', ()=> img.classList.remove('lqip'), {once:true});
                  img.src = img.dataset.src;
                  img.removeAttribute('data-src');
                }
                img.fetchPriority = 'high';
                obs.unobserve(img);
              }
            });
          }, {root: observerRoot});
          imgs.forEach(img => obs.observe(img));
        } else {
          imgs.forEach(img => {
            img.loading = 'lazy';
            if(img.dataset.src){
              img.addEventListener('load', ()=> img.classList.remove('lqip'), {once:true});
              img.src = img.dataset.src;
              img.removeAttribute('data-src');
            }
          });
        }
      });
    }

    function card(p, wide=false){
      const el = document.createElement('article');
      el.className = wide ? 'post-card' : 'recents-card';
      el.dataset.id = p.id;
      const thumbSrc = thumbUrl(p);
      const thumb = `<img class="thumb lqip" loading="lazy" src="${thumbSrc}" alt="" referrerpolicy="no-referrer" />`;
        el.innerHTML = `
          ${thumb}
        <div class="meta">
          <div class="title">${p.title}</div>
          <div class="info">
            <div class="cat-line"><span class="sub-icon">${subcategoryIcons[p.subcategory]||''}</span> ${p.category} &gt; ${p.subcategory}</div>
            <div class="loc-line"><span class="badge" title="Venue"></span><span>${p.city}</span></div>
            <div class="date-line"><span class="badge" title="Dates"></span><span>${formatDates(p.dates)}</span></div>
          </div>
        </div>
        <div class="card-actions">
          <button class="fav" aria-pressed="${p.fav?'true':'false'}" aria-label="Toggle favourite">
            <svg viewBox="0 0 24 24"><path d="M12 17.3 6.2 21l1.6-6.7L2 9.3l6.9-.6L12 2l3.1 6.7 6.9.6-5.8 4.9L17.8 21 12 17.3z"/></svg>
          </button>
        </div>
      `;
      el.dataset.surfaceBg = CARD_SURFACE;
      el.style.background = CARD_SURFACE;
      el.querySelector('.fav').addEventListener('click', (e)=>{
        e.stopPropagation();
        p.fav = !p.fav;
        favSortDirty = true;
        document.querySelectorAll(`[data-id="${p.id}"] .fav`).forEach(btn=>{
          btn.setAttribute('aria-pressed', p.fav ? 'true' : 'false');
        });
        renderHistoryBoard();
      });

      el.dataset.hoverHighlightBound = '1';
      return el;
    }


    // History board
    function loadHistory(){ 
      try{ 
        const historyStr = localStorage.getItem('openHistoryV2');
        if(!historyStr) return [];
        return JSON.parse(historyStr);
      }catch(e){ 
        console.error('Failed to load history:', e);
        // Don't return empty array - show error or return null
        return null; // Or throw error
      } 
    }
    function saveHistory(){ localStorage.setItem('openHistoryV2', JSON.stringify(viewHistory)); }
    function formatLastOpened(ts){
      if(!ts) return '';
      const diff = Date.now() - ts;
      const mins = Math.floor(diff/60000);
      let ago;
      if(mins < 60){
        ago = mins + ' minute' + (mins===1?'':'s');
      } else if(mins < 1440){
        const hrs = Math.floor(mins/60);
        ago = hrs + ' hour' + (hrs===1?'':'s');
      } else {
        const days = Math.floor(mins/1440);
        ago = days + ' day' + (days===1?'':'s');
      }
      const d = new Date(ts);
      const weekday = d.toLocaleDateString('en-GB', {weekday:'short'});
      const day = d.getDate();
      const month = d.toLocaleDateString('en-GB', {month:'short'});
      const year = d.getFullYear();
      const hour = String(d.getHours()).padStart(2,'0');
      const minute = String(d.getMinutes()).padStart(2,'0');
      return `Last opened ${ago} ago - ${weekday} ${day} ${month}, ${year} ${hour}:${minute}`;
    }

    function captureState(){
      const {start,end} = orderedRange();
      const openCats = Object.values(categoryControllers).filter(ctrl=>ctrl.getOpenState && ctrl.getOpenState()).map(ctrl=>ctrl.name);
      return {
        bounds: map ? map.getBounds().toArray() : null,
        kw: $('#keyword-textbox').value,
        date: $('#daterange-textbox').value,
        start: start ? toISODate(start) : null,
        end: end ? toISODate(end) : null,
        expired: $('#expiredToggle').checked,
        minPrice: $('#min-price-input') ? $('#min-price-input').value : '',
        maxPrice: $('#max-price-input') ? $('#max-price-input').value : '',
        cats: [...selection.cats],
        subs: [...selection.subs],
        openCats
      };
    }

    function restoreState(st){
      if(!st) return;
      $('#keyword-textbox').value = st.kw || '';
      if($('#min-price-input')){
        const minEl = $('#min-price-input');
        minEl.value = (st.minPrice || '').toString().replace(/\D+/g,'');
      }
      if($('#max-price-input')){
        const maxEl = $('#max-price-input');
        maxEl.value = (st.maxPrice || '').toString().replace(/\D+/g,'');
      }
      dateStart = st.start ? parseISODate(st.start) : null;
      dateEnd = st.end ? parseISODate(st.end) : null;
      if(!st.start && st.range){
        const parts = st.range.split(' to ').map(s=>s.trim());
        if(parts[0]) dateStart = parseISODate(parts[0]);
        if(parts[1]) dateEnd = parseISODate(parts[1]);
      }
      $('#expiredToggle').checked = st.expired || false;
      if($('#expiredToggle').checked){
        buildFilterCalendar(minPickerDate, maxPickerDate);
      } else {
        buildFilterCalendar(today, maxPickerDate);
      }
      if(dateStart){
        const sIso = toISODate(dateStart);
        const sDisp = fmtShort(sIso);
        if(dateEnd && dateEnd.getTime() !== dateStart.getTime()){
          const eIso = toISODate(dateEnd);
          const eDisp = fmtShort(eIso);
          $('#daterange-textbox').value = `${sDisp} - ${eDisp}`;
        } else {
          $('#daterange-textbox').value = sDisp;
        }
      } else {
        $('#daterange-textbox').value = '';
      }
      expiredWasOn = $('#expiredToggle').checked;
      updateRangeClasses();
      updateInput();
      const savedCatsArray = Array.isArray(st.cats) && st.cats.length ? st.cats : categories.map(cat=>cat.name);
      const savedCats = new Set(savedCatsArray);
      const savedSubsArray = Array.isArray(st.subs) ? st.subs : null;
      const subsToUse = savedSubsArray && savedSubsArray.length ? savedSubsArray : allSubcategoryKeys;
      const openCats = Array.isArray(st.openCats) ? new Set(st.openCats) : null;
      selection.cats = new Set();
      selection.subs = new Set(subsToUse);
      const controllers = Object.values(categoryControllers);
      if(controllers.length){
        controllers.forEach(ctrl=>{
          const active = savedCats.has(ctrl.name);
          ctrl.setActive(active, {silent:true});
          const shouldOpen = active && (openCats ? openCats.has(ctrl.name) : false);
          ctrl.setOpen(shouldOpen);
          ctrl.syncSubs();
        });
      } else {
        selection.cats = new Set(savedCatsArray);
      }
      if(map && st.bounds){
        stopSpin();
        const bounds = new mapboxgl.LngLatBounds(st.bounds);
        map.fitBounds(bounds, {padding:10});
        postPanel = bounds;
      }
      applyFilters();
      updateClearButtons();
      updateCategoryResetBtn();
    }
    function renderHistoryBoard(){
      if(!recentsBoard) return;
      recentsBoard.innerHTML='';
      const validHistory = viewHistory.filter(v => getPostByIdAnywhere(v.id));
      viewHistory = validHistory;
      saveHistory();
      const items = viewHistory.slice(0,100);
      for(const v of items){
        const p = getPostByIdAnywhere(v.id);
        if(!p) continue;
        if(!v.lastOpened) v.lastOpened = Date.now();
        const labelEl = document.createElement('div');
        labelEl.className = 'last-opened-label';
        labelEl.textContent = formatLastOpened(v.lastOpened);
        recentsBoard.appendChild(labelEl);
        const el = card(p);
        recentsBoard.appendChild(el);
      }
      const reminderWrap = document.createElement('div');
      reminderWrap.className = 'recents-board-reminder';
      const reminderImg = document.createElement('img');
      reminderImg.src = 'assets/monkeys/Firefly_cute-little-monkey-in-red-cape-pointing-up-937096.png';
      reminderImg.alt = 'Cute little monkey in red cape pointing up';
      reminderWrap.appendChild(reminderImg);
      const reminderMsg = document.createElement('p');
      reminderMsg.dataset.messageKey = 'msg_member_login_reminder';
      reminderMsg.textContent = 'When you log in as a member, I can remember your recent posts and favourites on any device.';
      // Load message from DB asynchronously
      (async () => {
        const msg = await getMessage('msg_member_login_reminder', {}, false);
        if(msg) reminderMsg.textContent = msg;
      })();
      reminderWrap.appendChild(reminderMsg);
      recentsBoard.appendChild(reminderWrap);
    }

    renderHistoryBoard();

function openPostModal(id){
      const p = getPostByIdAnywhere(id);
      if(!p) return;
      activePostId = id;
      syncPostCardHighlights();
      const container = document.getElementById('post-modal-container');
      if(!container) return;
      const modal = container.querySelector('.post-modal');
      modal.innerHTML='';
      const wrap = document.createElement('div');
      wrap.className = 'post-board';
      const detail = buildDetail(p);
      const cardEl = detail.querySelector('.post-card');
      const favBtn = cardEl && cardEl.querySelector('.fav');
      if(cardEl && favBtn){
        const closeBtn = document.createElement('button');
        closeBtn.type='button';
        closeBtn.className='close-post';
        closeBtn.setAttribute('aria-label','Close post');
        closeBtn.textContent='';
        closeBtn.style.marginLeft='10px';
        favBtn.after(closeBtn);
        closeBtn.addEventListener('click', e=>{ e.stopPropagation(); closePostModal(); });
      }
      wrap.appendChild(detail);
      modal.appendChild(wrap);
      hookDetailActions(detail, p);
      container.classList.remove('hidden');
      if(!panelStack.includes(container)) panelStack.push(container);
      bringToTop(container);
      requestAnimationFrame(()=>{
        const imgArea = detail.querySelector('.post-images');
        const text = detail.querySelector('.post-details');
        if(headerEl){
          headerEl.style.position='sticky';
          headerEl.style.top='0';
          headerEl.style.zIndex='2';
        }
        if(imgArea && text && text.offsetTop === imgArea.offsetTop){
          imgArea.style.position='sticky';
          imgArea.style.top = headerEl ? headerEl.offsetHeight + 'px' : '0';
        }
      });
      viewHistory = viewHistory.filter(x=>x.id!==id);
      viewHistory.unshift({id:p.id, title:p.title, url:postUrl(p), lastOpened: Date.now()});
      if(viewHistory.length>100) viewHistory.length=100;
      saveHistory(); renderHistoryBoard();
      location.hash = `/post/${p.slug}-${p.created}`;
    }

    function closePostModal(){
      const container = document.getElementById('post-modal-container');
      if(!container) return;
      container.classList.add('hidden');
      const idx = panelStack.indexOf(container);
      if(idx!==-1) panelStack.splice(idx,1);
      const modal = container.querySelector('.post-modal');
      if(modal) modal.innerHTML='';
      location.hash = '';
    }
    window.closePostModal = closePostModal;

    function handleHash(){
      if(!location.hash){
        closePostModal();
        return;
      }
      const m = location.hash.match(/\/post\/([^\/]+)-([^\/]+)$/);
      if(!m) return;
      const slug = decodeURIComponent(m[1]);
      const created = m[2];
      const matchPost = (list) => {
        if(!Array.isArray(list) || !list.length) return null;
        return list.find(x => x && x.slug === slug && x.created === created) || null;
      };
      let post = matchPost(posts);
      if(!post){
        const cache = getAllPostsCache({ allowInitialize: true });
        post = matchPost(cache);
      }
      if(post){ openPostModal(post.id); }
    }

    window.addEventListener('hashchange', handleHash);

    window.addEventListener('resize', ()=>{});

    document.addEventListener('DOMContentLoaded', ()=>{
      const container = document.getElementById('post-modal-container');
      if(container){
        container.addEventListener('click', e=>{ if(e.target===container) closePostModal(); });
      }
      handleHash();
    });


    function hookDetailActions(el, p){
      const locationList = Array.isArray(p.locations) ? p.locations : [];
      // Card click handler is now set in buildDetail() to toggle post-collapsed
      
      el.querySelectorAll('.fav').forEach(favBtn => {
        favBtn.addEventListener('click', (e)=>{
          e.stopPropagation();
          p.fav = !p.fav;
          favSortDirty = true;
          document.querySelectorAll(`[data-id="${p.id}"] .fav`).forEach(btn=>{
            btn.setAttribute('aria-pressed', p.fav ? 'true' : 'false');
          });
          const detailEl = el;
          renderHistoryBoard();
          const replacement = postsWideEl.querySelector(`[data-id="${p.id}"]`);
          if(replacement){
            replacement.replaceWith(detailEl);
          }
        });
      });

      el.querySelectorAll('.share').forEach(shareBtn => {
        shareBtn.addEventListener('click', (e)=>{
          e.stopPropagation();
          const url = postUrl(p);
          navigator.clipboard.writeText(url).then(()=>{ showCopyMsg(shareBtn); });
        });
      });

      const postImagesEl = el.querySelector('.post-images');
      const descEl = el.querySelector('.post-details .desc');

      const animatePostImages = direction => {
        if(!postImagesEl || typeof postImagesEl.animate !== 'function'){
          return;
        }
        try {
          if(postImagesEl._descAnimation){
            postImagesEl._descAnimation.cancel();
          }
        } catch(err){}
        const distance = 16;
        let keyframes;
        let duration = 260;
        let easing = 'cubic-bezier(0.22, 0.61, 0.36, 1)';
        if(direction === 'down'){
          keyframes = [
            { transform: `translateY(-${distance}px)` },
            { transform: 'translateY(0)' }
          ];
        } else {
          // No bounce animation on collapse
          return;
        }
        const animation = postImagesEl.animate(keyframes, { duration, easing });
        postImagesEl._descAnimation = animation;
        if(animation){
          animation.onfinish = animation.oncancel = () => {
            if(postImagesEl._descAnimation === animation){
              postImagesEl._descAnimation = null;
            }
          };
        }
      };

      const setDescExpandedState = targetState => {
        const openPostEl = el;
        if(!openPostEl || !openPostEl.classList){
          return false;
        }
        const desired = !!targetState;
        const current = openPostEl.classList.contains('desc-expanded');
        if(current === desired){
          return false;
        }
        if(descEl){
          if(descEl.classList){
            descEl.classList.toggle('expanded', desired);
          }
          if(typeof descEl.setAttribute === 'function'){
            descEl.setAttribute('aria-expanded', desired ? 'true' : 'false');
          }
        }
        openPostEl.classList.toggle('desc-expanded', desired);
        if(desired){
          document.body.classList.remove('open-post-sticky-images');
          animatePostImages('down');
        } else {
          if(typeof updateStickyImages === 'function'){
            updateStickyImages();
          }
          animatePostImages('up');
        }
        return true;
      };

      if(descEl){
        const descWrap = descEl.closest('.desc-wrap');
        const fullText = p.desc || '';
        let needsTruncation = false;
        
        const truncateToTwoLines = () => {
          descEl.textContent = fullText;
          const lineHeight = parseFloat(getComputedStyle(descEl).lineHeight) || 20;
          const maxHeight = lineHeight * 2;
          if(descEl.scrollHeight <= maxHeight){
            needsTruncation = false;
            return;
          }
          needsTruncation = true;
          const suffix = '... See More';
          let text = fullText;
          while(text.length > 0 && descEl.scrollHeight > maxHeight){
            text = text.slice(0, -10);
            descEl.innerHTML = text.trim() + suffix.replace('See More', '<span class="see-more-toggle">See More</span>');
          }
        };
        
        const render = (expanded) => {
          if(expanded){
            descEl.innerHTML = fullText + ' <span class="see-more-toggle">See Less</span>';
          } else {
            truncateToTwoLines();
          }
        };
        
        const handleDescToggle = evt => {
          if(!needsTruncation) return;
          if(evt.type === 'keydown' && !['Enter',' '].includes(evt.key)) return;
          evt.preventDefault();
          const isExpanded = el.classList.contains('desc-expanded');
          setDescExpandedState(!isExpanded);
          render(!isExpanded);
        };
        
        descWrap.addEventListener('click', handleDescToggle);
        descWrap.addEventListener('keydown', handleDescToggle);
        render(false);
        if(needsTruncation) descWrap.style.cursor = 'pointer';
      }

      const imgs = p.images && p.images.length ? p.images : [heroUrl(p)];
      const thumbCol = el.querySelector('.thumbnail-row');
      const imageBox = el.querySelector('.image-box');
      const imageTrack = imageBox ? imageBox.querySelector('.image-track') : null;
      const baseImg = imageTrack ? imageTrack.querySelector('img') : null;
      const slides = [];
      if(imageBox){
        imageBox._modalImages = imgs.slice();
        try {
          imageBox.dataset.modalImages = JSON.stringify(imgs);
        } catch(err) {
          imageBox.dataset.modalImages = '';
        }
        if(typeof imageBox.dataset.index === 'undefined'){
          imageBox.dataset.index = '0';
        }
      }
      if(baseImg){
        baseImg.dataset.index = '0';
        baseImg.dataset.full = imgs[0];
        if(!baseImg.classList.contains('ready')){
          baseImg.classList.add('lqip');
        }
        slides[0] = baseImg;
      }
      if(imageTrack){
        imageTrack.style.transform = 'translateX(0)';
      }
      for(let i=1;i<imgs.length;i++){
        if(!imageTrack) break;
        const slide = document.createElement('img');
        slide.dataset.index = i;
        slide.dataset.full = imgs[i];
        slide.alt = '';
        slide.decoding = 'async';
        slide.loading = 'lazy';
        slide.classList.add('lqip');
        slide.src = imgs[i];
        imageTrack.appendChild(slide);
        slides[i] = slide;
      }
      if(thumbCol){
        imgs.forEach((url,i)=>{
          const t = document.createElement('img');
          t.src = url;
          t.dataset.full = url;
          t.dataset.index = i;
          t.tabIndex = 0;
          thumbCol.appendChild(t);
        });
      }
      const clampIdx = idx => Math.min(Math.max(idx, 0), imgs.length - 1);
      let currentIdx = 0;
      const ensureSlide = idx => {
        if(!imageTrack) return null;
        if(!slides[idx]){
          const slide = document.createElement('img');
          slide.dataset.index = idx;
          slide.dataset.full = imgs[idx];
          slide.alt = '';
          slide.decoding = 'async';
          slide.loading = 'lazy';
          slide.classList.add('lqip');
          slide.src = imgs[idx];
          imageTrack.appendChild(slide);
          slides[idx] = slide;
        }
        return slides[idx];
      };
      const scrollThumbIntoView = target => {
        if(!thumbCol || !target) return;
        const rowRect = thumbCol.getBoundingClientRect();
        const tRect = target.getBoundingClientRect();
        if(tRect.left < rowRect.left){
          thumbCol.scrollBy({left: tRect.left - rowRect.left - 8, behavior:'smooth'});
        } else if(tRect.right > rowRect.right){
          thumbCol.scrollBy({left: tRect.right - rowRect.right + 8, behavior:'smooth'});
        }
      };
      const moveTo = (idx, {instant=false}={})=>{
        if(!imageTrack) return;
        if(instant){
          imageTrack.style.transition = 'none';
        }
        const apply = ()=>{ imageTrack.style.transform = `translateX(-${idx * 100}%)`; };
        if(instant){
          apply();
          requestAnimationFrame(()=>{ imageTrack.style.transition = ''; });
        } else {
          apply();
        }
      };
      function show(idx, {instant=false}={}){
        idx = clampIdx(idx);
        const t = thumbCol ? thumbCol.querySelector(`img[data-index="${idx}"]`) : null;
        const slide = ensureSlide(idx);
        if(!slide) return;
        const prevIdx = currentIdx;
        const alreadyReady = slide.classList.contains('ready');
        currentIdx = idx;
        if(prevIdx !== idx || instant){
          moveTo(idx, {instant});
        }
        if(imageBox){
          imageBox.dataset.index = idx;
        }
        if(slides.length){
          slides.forEach((img,i)=>{
            if(img){
              img.classList.toggle('active', i===idx);
            }
          });
        }
        if(t && thumbCol){
          thumbCol.querySelectorAll('img').forEach(im=> im.classList.toggle('selected', im===t));
          scrollThumbIntoView(t);
        }
        const full = (t && (t.dataset.full || t.src)) || slide.dataset.full || slide.src;
        if(!slide.dataset.full){
          slide.dataset.full = full;
        }
        
        // Seamless image transition - preload full-res, only swap when ready
        if(slide.src !== full){
          const hi = new Image();
          hi.onload = ()=>{
            const swap = ()=>{
              if(slide.dataset.full !== full){ slide.dataset.full = full; }
              // Swap immediately - image is already loaded so no flicker
              slide.src = full;
              slide.classList.remove('lqip');
              slide.classList.add('ready');
            };
            if(hi.decode){ hi.decode().then(swap).catch(swap); } else { swap(); }
          };
          hi.onerror = ()=>{
            // On error, still mark as ready to prevent infinite loading
            slide.classList.remove('lqip');
            slide.classList.add('ready');
          };
          hi.src = full;
        } else if(!alreadyReady){
          // Already showing correct image, just mark as ready
          slide.classList.remove('lqip');
          slide.classList.add('ready');
        }
      }
      show(0, {instant:true});
      if(thumbCol){
        thumbCol.scrollLeft = 0;
        setupHorizontalWheel(thumbCol);
        thumbCol.addEventListener('click', e=>{
          const t = e.target.closest('img');
          if(!t) return;
          const idx = clampIdx(parseInt(t.dataset.index,10));
          if(currentIdx === idx && t.classList.contains('selected')){
            const fullSrc = t.dataset.full || t.src;
            openImageModal(fullSrc, {images: imgs, startIndex: idx, origin: t});
          } else {
            show(idx);
          }
        });
        thumbCol.addEventListener('keydown', e=>{
          if(e.key==='ArrowDown'){
            e.preventDefault();
            const ni = clampIdx(currentIdx + 1);
            show(ni);
            const nextThumb = thumbCol.querySelector(`img[data-index="${ni}"]`);
            if(nextThumb) nextThumb.focus();
          } else if(e.key==='ArrowUp'){
            e.preventDefault();
            const ni = clampIdx(currentIdx - 1);
            show(ni);
            const prevThumb = thumbCol.querySelector(`img[data-index="${ni}"]`);
            if(prevThumb) prevThumb.focus();
          }
        });
      }
      if(imageBox){
        let dragStartX = null;
        let dragStartY = null;
        let dragActive = false;
        let lastDragTime = 0;
        const resetDragState = ()=>{
          dragStartX = null;
          dragStartY = null;
          dragActive = false;
          if(imageTrack){
            imageTrack.style.transition = '';
          }
        };
        imageBox.addEventListener('click', e=>{
          if(Date.now() - lastDragTime < 400){
            e.preventDefault();
            return;
          }
          const imgTarget = e.target.closest('.image-track img');
          if(!imgTarget) return;
          e.stopPropagation();
          // Image click directly opens modal (expand/collapse is now controlled by description text)
          const currentSlide = ensureSlide(currentIdx) || slides[currentIdx] || imgTarget;
          const fullSrc = currentSlide ? (currentSlide.dataset.full || currentSlide.src) : imgs[currentIdx];
          openImageModal(fullSrc, {images: imgs, startIndex: currentIdx, origin: imgTarget});
        });
        imageBox.addEventListener('touchstart', e=>{
          if(e.touches.length !== 1) return;
          dragStartX = e.touches[0].clientX;
          dragStartY = e.touches[0].clientY;
          dragActive = false;
        });
        imageBox.addEventListener('touchmove', e=>{
          if(dragStartX===null || !imageTrack) return;
          const touch = e.touches[0];
          const deltaX = touch.clientX - dragStartX;
          const deltaY = touch.clientY - dragStartY;
          if(!dragActive){
            if(Math.abs(deltaX) < 5) return;
            if(Math.abs(deltaY) > Math.abs(deltaX)){
              resetDragState();
              return;
            }
            dragActive = true;
            imageTrack.style.transition = 'none';
          }
          const width = imageBox.clientWidth || 1;
          let adjustedDelta = deltaX;
          if((currentIdx === 0 && adjustedDelta > 0) || (currentIdx === imgs.length-1 && adjustedDelta < 0)){
            adjustedDelta = 0;
          }
          const deltaPercent = (adjustedDelta / width) * 100;
          const basePercent = -currentIdx * 100;
          imageTrack.style.transform = `translateX(${basePercent + deltaPercent}%)`;
          e.preventDefault();
        }, {passive:false});
        imageBox.addEventListener('touchend', e=>{
          if(dragStartX===null){
            resetDragState();
            return;
          }
          const deltaX = e.changedTouches[0].clientX - dragStartX;
          if(imageTrack){
            imageTrack.style.transition = '';
          }
          if(dragActive){
            const prevIdx = currentIdx;
            let targetIdx = prevIdx;
            const threshold = (imageBox.clientWidth || 1) * 0.15;
            if(deltaX <= -threshold && prevIdx < imgs.length - 1){
              targetIdx = prevIdx + 1;
            } else if(deltaX >= threshold && prevIdx > 0){
              targetIdx = prevIdx - 1;
            }
            lastDragTime = Date.now();
            requestAnimationFrame(()=> show(targetIdx));
          }
          resetDragState();
        });
        imageBox.addEventListener('touchcancel', ()=>{
          if(dragActive && imageTrack){
            imageTrack.style.transition = '';
            requestAnimationFrame(()=> show(currentIdx));
          }
          resetDragState();
        });
      }
      const venueDropdown = el.querySelector(`#venue-${p.id}`);
      const venueBtn = el.querySelector('.venue-menu-button');
      const venueMenu = venueDropdown ? venueDropdown.querySelector('.venue-menu') : null;
      const venueOptions = venueMenu ? venueMenu.querySelector('.venue-options') : null;
      let venueCloseTimer = null;
      const venueInfo = el.querySelector(`#venue-info-${p.id}`);
      const sessDropdown = el.querySelector(`#sess-${p.id}`);
      const sessBtn = el.querySelector('.session-menu-button');
      const sessMenu = sessDropdown ? sessDropdown.querySelector('.session-menu') : null;
      const sessionOptions = sessMenu ? sessMenu.querySelector('.session-options') : null;
      const showMenu = menu => { if(menu) menu.removeAttribute('hidden'); };
      const hideMenu = menu => { if(menu) menu.setAttribute('hidden',''); };
      const isMenuOpen = menu => !!(menu && !menu.hasAttribute('hidden'));
      const sessionInfo = el.querySelector(`#session-info-${p.id}`);
      const calendarEl = el.querySelector(`#cal-${p.id}`);
      const mapEl = el.querySelector(`#map-${p.id}`);
      const calContainer = el.querySelector('.calendar-container');
      const calScroll = calContainer ? calContainer.querySelector('.calendar-scroll') : null;
      if(calScroll){
        setupCalendarScroll(calScroll);
      }
      let map, locationMarkers = [], sessionHasMultiple = false, lastClickedCell = null, resizeHandler = null, detailMapRef = null;
      let currentVenueIndex = 0;

      function updateDetailMarkerSelection(selectedIdx = currentVenueIndex){
        if(!Number.isInteger(selectedIdx)){
          selectedIdx = currentVenueIndex;
        }
        locationMarkers.forEach(({ element, index }) => {
          const isSelected = index === selectedIdx;
          element.classList.toggle('is-selected', isSelected);
          element.classList.toggle('is-dimmed', !isSelected);
          element.setAttribute('aria-pressed', isSelected ? 'true' : 'false');
        });
      }
      let sessionCloseTimer = null;
      let ensureMapForVenue = async ()=>{};
      const shouldShowExpiredSessions = () => {
        const expiredToggle = document.getElementById('expiredToggle');
        return !!(expiredToggle && expiredToggle.checked);
      };
      const sessionThresholdDate = () => {
        const base = new Date();
        base.setHours(0,0,0,0);
        base.setDate(base.getDate() - 1);
        return base;
      };
      const parseSessionDate = (value) => {
        if(typeof value !== 'string') return new Date(Number.NaN);
        const parts = value.split('-').map(Number);
        const yy = parts[0];
        const mm = parts[1];
        const dd = parts[2];
        return new Date(yy, (mm || 1) - 1, dd || 1);
      };
      function computeVisibleSessionsForLocation(location){
        if(!location || !Array.isArray(location.dates)) return [];
        const showExpired = shouldShowExpiredSessions();
        const threshold = sessionThresholdDate();
        return location.dates
          .map((d,i)=>({d,i}))
          .filter(({d})=>{
            if(!d || typeof d.full !== 'string') return false;
            if(showExpired) return true;
            const parsed = parseSessionDate(d.full);
            return parsed instanceof Date && !Number.isNaN(parsed.getTime()) && parsed >= threshold;
          });
      }
      let visibleVenueState = { byIndex: new Map(), visibleIndices: [] };
      function computeVenueVisibility(){
        const byIndex = new Map();
        const visibleIndices = [];
        locationList.forEach((location, idx) => {
          if(location && Array.isArray(location.dates)){
            location.dates.sort((a,b)=>{
              const fullA = (a && a.full) || '';
              const fullB = (b && b.full) || '';
              const fullCompare = fullA.localeCompare(fullB);
              if(fullCompare !== 0) return fullCompare;
              const timeA = (a && a.time) || '';
              const timeB = (b && b.time) || '';
              return timeA.localeCompare(timeB);
            });
          }
          const visibleSessions = computeVisibleSessionsForLocation(location);
          const hasVisible = visibleSessions.length > 0;
          byIndex.set(idx, { visibleSessions, hasVisible });
          if(venueOptions){
            const button = venueOptions.querySelector(`button[data-index="${idx}"]`);
            if(button){
              button.hidden = !hasVisible;
              if(hasVisible){
                button.removeAttribute('hidden');
                button.disabled = false;
                button.tabIndex = 0;
                button.removeAttribute('aria-hidden');
              } else {
                button.setAttribute('hidden','');
                button.disabled = true;
                button.tabIndex = -1;
                button.setAttribute('aria-hidden','true');
                button.classList.remove('selected');
              }
            }
          }
          if(hasVisible){
            visibleIndices.push(idx);
          }
        });
        visibleVenueState = { byIndex, visibleIndices };
        return visibleVenueState;
      }
      let syncingVenueFromSessions = false;
        function scheduleSessionMenuClose({waitForScroll=false, targetLeft=null}={}){
          if(!sessMenu) return;
          if(sessionCloseTimer){
            clearTimeout(sessionCloseTimer);
            sessionCloseTimer = null;
          }
          const begin = ()=>{
            requestAnimationFrame(()=>requestAnimationFrame(()=>{
              sessionCloseTimer = setTimeout(()=>{
                hideMenu(sessMenu);
                if(sessBtn) sessBtn.setAttribute('aria-expanded','false');
                sessionCloseTimer = null;
              }, 100);
            }));
          };
          if(waitForScroll && calScroll && targetLeft !== null){
            let attempts = 0;
            const maxAttempts = 60;
            const check = ()=>{
              const distance = Math.abs(calScroll.scrollLeft - targetLeft);
              if(distance <= 0.5 || attempts >= maxAttempts){
                begin();
              } else {
                attempts += 1;
                requestAnimationFrame(check);
              }
            };
            requestAnimationFrame(check);
          } else {
            begin();
          }
        }
        if(mapEl && mapEl._detailMap){
          detailMapRef = mapEl._detailMap;
          map = detailMapRef.map || map;
          resizeHandler = detailMapRef.resizeHandler || resizeHandler;
          if(!el._detailMap){
            el._detailMap = detailMapRef;
          }
        }
      function updateVenue(idx){
        const locations = locationList;
        const hasLocations = locations.length > 0;
        let targetIndex = Number.isInteger(idx) ? idx : 0;
        if(hasLocations){
          targetIndex = Math.min(Math.max(targetIndex, 0), locations.length - 1);
        } else {
          targetIndex = 0;
        }
        const visibility = computeVenueVisibility();
        const visibleIndices = visibility.visibleIndices || [];
        const multipleVisible = visibleIndices.length > 1;
        if(visibleIndices.length){
          if(!visibleIndices.includes(targetIndex)){
            targetIndex = visibleIndices[0];
          }
        }
        currentVenueIndex = targetIndex;
        const loc = hasLocations ? locations[targetIndex] : null;

        if(venueOptions){
          const buttons = venueOptions.querySelectorAll('button');
          buttons.forEach((button, optionIndex) => {
            const isSelected = optionIndex === currentVenueIndex && !button.hidden && !button.disabled;
            button.classList.toggle('selected', isSelected);
          });
        }

        if(loc){
          setSelectedVenueHighlight(loc.lng, loc.lat);
        } else {
          setSelectedVenueHighlight();
        }

        updateDetailMarkerSelection(targetIndex);

        if(venueBtn){
          if(loc){
            venueBtn.innerHTML = `<img src="assets/Map Screenshot.png" alt="Map view"><span class="venue-name">${loc.venue}</span><span class="address_line">${loc.address}</span>${multipleVisible?'<span class="results-arrow" aria-hidden="true"></span>':''}`;
          } else {
            venueBtn.innerHTML = `<img src="assets/Map Screenshot.png" alt="Map view"><span class="venue-name">${p.city || ''}</span><span class="address_line">${p.city || ''}</span>`;
          }
        }

        if(venueInfo){
          if(loc){
            venueInfo.innerHTML = `<strong>${loc.venue}</strong><br>${loc.address}`;
          } else {
            venueInfo.innerHTML = '';
          }
        }

        const hasDates = loc && Array.isArray(loc.dates) && loc.dates.length;
        if(!hasDates){
          sessionHasMultiple = false;
          if(sessionInfo){
            sessionInfo.innerHTML = '';
          }
          ensureMapForVenue();
          return;
        }

        loc.dates.sort((a,b)=>{
          const fullA = (a && a.full) || '';
          const fullB = (b && b.full) || '';
          const fullCompare = fullA.localeCompare(fullB);
          if(fullCompare !== 0) return fullCompare;
          const timeA = (a && a.time) || '';
          const timeB = (b && b.time) || '';
          return timeA.localeCompare(timeB);
        });

        const currentYear = new Date().getFullYear();
        const parseDate = s => parseSessionDate(s);
        const formatDate = d => {
          const y = parseDate(d.full).getFullYear();
          return y !== currentYear ? `${d.date}, ${y}` : d.date;
        };

        if(venueInfo){
          venueInfo.innerHTML = `<strong>${loc.venue}</strong><br>${loc.address}`;
        }
        if(venueBtn){
          venueBtn.innerHTML = `<img src="assets/Map Screenshot.png" alt="Map view"><span class="venue-name">${loc.venue}</span><span class="address_line">${loc.address}</span>${multipleVisible?'<span class="results-arrow" aria-hidden="true"></span>':''}`;
        }

        let cal = null;
        let selectedIndex = null;
        let dateStrings = [];
        let allowedSet = new Set();
        let minDate = null;
        let maxDate = null;
        let months = [];
        let visibleDateEntries = [];
        let defaultInfoHTML = '';

        function recomputeVisibleDateData(visibilityState){
          if(!loc || !Array.isArray(loc.dates)){
            visibleDateEntries = [];
            dateStrings = [];
            allowedSet = new Set();
            minDate = null;
            maxDate = null;
            months = [];
            return;
          }
          const snapshot = visibilityState || computeVenueVisibility();
          const entry = snapshot && snapshot.byIndex ? snapshot.byIndex.get(currentVenueIndex) : null;
          visibleDateEntries = entry && Array.isArray(entry.visibleSessions)
            ? entry.visibleSessions.map(({ d, i }) => ({ d, i }))
            : [];

          const seen = new Set();
          const uniqueEntries = [];
          visibleDateEntries.forEach(({d}) => {
            if(!d || typeof d.full !== 'string') return;
            if(seen.has(d.full)) return;
            const parsed = parseDate(d.full);
            if(!(parsed instanceof Date) || Number.isNaN(parsed.getTime())) return;
            seen.add(d.full);
            uniqueEntries.push({ iso: d.full, date: parsed });
          });

          dateStrings = uniqueEntries.map(entry => entry.iso);
          allowedSet = new Set(dateStrings);
          if(uniqueEntries.length){
            minDate = new Date(uniqueEntries[0].date.getTime());
            maxDate = new Date(uniqueEntries[uniqueEntries.length - 1].date.getTime());
          } else {
            minDate = null;
            maxDate = null;
          }

          months = [];
          if(minDate && maxDate){
            const cursor = new Date(minDate.getFullYear(), minDate.getMonth(), 1);
            const limit = new Date(maxDate.getFullYear(), maxDate.getMonth(), 1);
            while(cursor <= limit){
              months.push(new Date(cursor.getTime()));
              cursor.setMonth(cursor.getMonth() + 1);
            }
          }
        }

        function refreshDefaultSessionInfo(){
          const visible = visibleDateEntries;
          sessionHasMultiple = visible.length > 1;
          if(!sessionInfo){
            defaultInfoHTML = '';
            return;
          }
          const suffix = '<span style="display:inline-block;margin-left:10px;">(Select Session)</span>';
          if(visible.length){
            const firstDate = visible[0].d;
            const lastDate = visible[visible.length - 1].d;
            const rangeText = `${formatDate(firstDate)} - ${formatDate(lastDate)}`;
            defaultInfoHTML = `<div> ${loc.price} |  ${rangeText}${suffix}</div>`;
          } else if(Array.isArray(loc.dates) && loc.dates.length){
            defaultInfoHTML = `<div> ${loc.price}${suffix}</div>`;
          } else {
            defaultInfoHTML = '';
          }
          sessionInfo.innerHTML = defaultInfoHTML;
        }

        function markSelected(){
          if(!calendarEl) return;
          calendarEl.querySelectorAll('.day').forEach(d=> d.classList.remove('selected'));
          if(selectedIndex!==null){
            const dt = loc.dates[selectedIndex];
            const cell = calendarEl.querySelector(`.day[data-iso="${dt.full}"]`);
            if(cell) cell.classList.add('selected');
          }
        }

        function scrollCalendarToMonth(dt, {smooth=false}={}){
          if(!dt || !calendarEl || !calScroll) return null;
          const cell = calendarEl.querySelector(`.day[data-iso="${dt.full}"]`);
          if(!cell) return null;
          const monthEl = cell.closest('.month');
          if(!monthEl) return null;
          const currentLeft = calScroll.scrollLeft;
          let targetLeft = monthEl.offsetLeft;
          if(typeof monthEl.getBoundingClientRect === 'function' && typeof calScroll.getBoundingClientRect === 'function'){
            const monthRect = monthEl.getBoundingClientRect();
            const scrollRect = calScroll.getBoundingClientRect();
            const delta = monthRect.left - scrollRect.left;
            const adjusted = currentLeft + delta;
            if(Number.isFinite(adjusted)){
              targetLeft = adjusted;
            }
          }
          const maxLeft = Math.max(0, calScroll.scrollWidth - calScroll.clientWidth);
          targetLeft = Math.min(Math.max(targetLeft, 0), maxLeft);
          const distance = Math.abs(currentLeft - targetLeft);
          if(typeof calScroll.scrollTo === 'function'){
            if(smooth && distance > 1){
              calScroll.scrollTo({left: targetLeft, behavior: 'smooth'});
              return {targetLeft, waitForScroll: true};
            }
            calScroll.scrollTo({left: targetLeft});
          } else {
            calScroll.scrollLeft = targetLeft;
          }
          return {targetLeft, waitForScroll: false};
        }

        function selectSession(i){
          if(!sessMenu || !sessionOptions) return;
          selectedIndex = Number.isInteger(i) ? i : null;
          sessionOptions.querySelectorAll('button').forEach(b=> b.classList.remove('selected'));
          const btn = selectedIndex !== null ? sessionOptions.querySelector(`button[data-index="${selectedIndex}"]`) : null;
          if(btn) btn.classList.add('selected');
          const dt = selectedIndex !== null ? loc.dates[selectedIndex] : null;
          let waitForScroll = false;
          let targetScrollLeft = null;
          if(dt){
            if(sessionInfo){
              sessionInfo.innerHTML = `<div><strong>${formatDate(dt)} ${dt.time}</strong></div><div>Adults $20, Kids $10, Pensioners $15</div><div> Buy at venue |  Accessible |  Kid-friendly</div>`;
            }
            if(sessBtn){
              sessBtn.innerHTML = `<img src="assets/Calendar Screenshot.png" alt="Calendar view"><span class="session-date">${formatDate(dt)}</span><span class="session-time">${dt.time}</span>${sessionHasMultiple?'<span class="results-arrow" aria-hidden="true"></span>':''}`;
            }
            markSelected();
            const scrollResult = scrollCalendarToMonth(dt, {smooth: true});
            if(scrollResult){
              targetScrollLeft = scrollResult.targetLeft;
              waitForScroll = scrollResult.waitForScroll;
            }
          } else {
            if(sessionInfo){
              sessionInfo.innerHTML = defaultInfoHTML;
            }
            if(sessBtn){
              sessBtn.innerHTML = sessionHasMultiple ? '<img src="assets/Calendar Screenshot.png" alt="Calendar view">Select Session<span class="results-arrow" aria-hidden="true"></span>' : '<img src="assets/Calendar Screenshot.png" alt="Calendar view">Select Session';
              sessBtn.setAttribute('aria-expanded','false');
            }
            markSelected();
          }
          if(isMenuOpen(sessMenu)){
            scheduleSessionMenuClose({waitForScroll, targetLeft: targetScrollLeft});
          } else if(sessBtn){
            sessBtn.setAttribute('aria-expanded','false');
          }
        }

        function showTimePopup(matches){
          if(!calContainer) return;
          const existing = calContainer.querySelector('.time-popup');
          if(existing) existing.remove();
          const popup = document.createElement('div');
          popup.className = 'time-popup';
          popup.innerHTML = `<div class="time-list">${matches.map(m=>`<button data-index="${m.i}">${m.d.time}</button>`).join('')}</div>`;
          calContainer.appendChild(popup);
          if(lastClickedCell){
            const rect = lastClickedCell.getBoundingClientRect();
            const containerRect = calContainer.getBoundingClientRect();
            const dateCenterX = rect.left + rect.width / 2 - containerRect.left;
            const containerCenterX = calContainer.clientWidth / 2;
            popup.style.top = (rect.top - containerRect.top) + 'px';
            if (dateCenterX < containerCenterX) {
              popup.style.left = (rect.right - containerRect.left + 4) + 'px';
            } else {
              popup.style.left = (rect.left - containerRect.left) + 'px';
            }
            requestAnimationFrame(() => {
              const popupRect = popup.getBoundingClientRect();
              const minMargin = 10;
              let left = parseFloat(popup.style.left);
              let top = parseFloat(popup.style.top);
              if (dateCenterX >= containerCenterX) {
                left = left - popupRect.width - 4;
              }
              if (left < minMargin) left = minMargin;
              if (top < minMargin) top = minMargin;
              if (left + popupRect.width + minMargin > calContainer.clientWidth) {
                left = calContainer.clientWidth - popupRect.width - minMargin;
              }
              if (top + popupRect.height + minMargin > calContainer.clientHeight) {
                top = calContainer.clientHeight - popupRect.height - minMargin;
              }
              popup.style.left = left + 'px';
              popup.style.top = top + 'px';
            });
          }
          popup.querySelectorAll('button').forEach(b=> b.addEventListener('click',()=>{ selectSession(parseInt(b.dataset.index,10)); popup.remove(); }));
          setTimeout(()=> document.addEventListener('click', function handler(e){ if(!popup.contains(e.target)){ popup.remove(); document.removeEventListener('click', handler); } }),0);
        }

        function renderMonth(monthDate){
          if(!cal) return;
          const monthEl = document.createElement('div');
          monthEl.className='month';
          const header = document.createElement('div');
          header.className='calendar-header';
          header.textContent = monthDate.toLocaleDateString('en-GB',{month:'long',year:'numeric'});
          monthEl.appendChild(header);
          const grid = document.createElement('div');
          grid.className='grid';
          ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'].forEach(wd=>{
            const w=document.createElement('div');
            w.className='weekday';
            w.textContent=wd;
            grid.appendChild(w);
          });
          const firstDay = new Date(monthDate.getFullYear(), monthDate.getMonth(),1);
          const startDow = firstDay.getDay();
          const daysInMonth = new Date(monthDate.getFullYear(), monthDate.getMonth()+1,0).getDate();
          const totalCells = 42;
          for(let i=0;i<totalCells;i++){
            const cell=document.createElement('div');
            cell.className='day';
            const dayNum=i-startDow+1;
            if(i<startDow || dayNum>daysInMonth){
              cell.classList.add('empty');
            }else{
              cell.textContent=dayNum;
              const dateObj=new Date(monthDate.getFullYear(), monthDate.getMonth(), dayNum);
              const iso=toISODate(dateObj);
              cell.dataset.iso = iso;
              if(allowedSet.has(iso)){
                cell.classList.add('available-day');
                cell.addEventListener('mousedown',()=>{ lastClickedCell = cell; });
                cell.addEventListener('click',()=>{
                  const matches = visibleDateEntries.filter(entry => entry.d.full === iso);
                  if(matches.length===1){ selectSession(matches[0].i); }
                  else if(matches.length>1){ showTimePopup(matches); }
                });
              } else {
                cell.classList.add('empty');
              }
              if(isToday(dateObj)) cell.classList.add('today');
            }
            grid.appendChild(cell);
          }
          monthEl.appendChild(grid);
          cal.appendChild(monthEl);
        }

        function buildCalendarShell(){
          if(!calendarEl) return;
          calendarEl.innerHTML='';
          cal = document.createElement('div');
          cal.className='calendar';
          calendarEl.appendChild(cal);
          if(!calendarEl._calendarClickStopper){
            calendarEl.addEventListener('click', e=> e.stopPropagation());
            calendarEl._calendarClickStopper = true;
          }
        }

        function finalizeCalendar(){
          markSelected();
        }

        function renderCalendar(){
          if(!calendarEl) return;
          buildCalendarShell();
          months.forEach(monthDate => renderMonth(monthDate));
          finalizeCalendar();
        }

        function updateSessionOptionsList(){
          if(!loc || !Array.isArray(loc.dates)){
            visibleDateEntries = [];
            if(sessionOptions){
              sessionOptions.innerHTML = '';
            }
            if(sessBtn){
              sessBtn.innerHTML = '<img src="assets/Calendar Screenshot.png" alt="Calendar view">Select Session';
              sessBtn.setAttribute('aria-expanded','false');
            }
            if(sessionInfo){
              sessionInfo.innerHTML = defaultInfoHTML;
            }
            return;
          }
          const visibility = computeVenueVisibility();
          const visibleIndices = visibility.visibleIndices || [];
          if(!syncingVenueFromSessions && visibleIndices.length && !visibleIndices.includes(currentVenueIndex)){
            const fallbackIndex = visibleIndices[0];
            if(fallbackIndex !== undefined){
              syncingVenueFromSessions = true;
              try{
                updateVenue(fallbackIndex);
              } finally {
                syncingVenueFromSessions = false;
              }
              return;
            }
          }
          recomputeVisibleDateData(visibility);
          refreshDefaultSessionInfo();
          if(calContainer){
            const existingPopup = calContainer.querySelector('.time-popup');
            if(existingPopup) existingPopup.remove();
          }
          lastClickedCell = null;
          if(calendarEl){
            renderCalendar();
          }

          const visibleDates = visibleDateEntries;

          if(sessionOptions){
            sessionOptions.innerHTML = visibleDates
              .map(({d,i})=> `<button data-index="${i}"><span class="session-date">${formatDate(d)}</span><span class="session-time">${d.time}</span></button>`)
              .join('');
          }

          if(sessMenu){
            sessMenu.scrollTop = 0;
          }

          const hasVisible = visibleDates.length > 0;

          const selectedIsVisible = visibleDates.some(({i})=> i === selectedIndex);
          if(!selectedIsVisible){
            selectedIndex = null;
          }

          if(sessionHasMultiple){
            selectedIndex = null;
            markSelected();
            if(sessionInfo) sessionInfo.innerHTML = defaultInfoHTML;
            if(sessBtn){
              sessBtn.innerHTML = '<img src="assets/Calendar Screenshot.png" alt="Calendar view">Select Session<span class="results-arrow" aria-hidden="true"></span>';
              sessBtn.setAttribute('aria-expanded','false');
            }
          } else if(hasVisible){
            selectSession(visibleDates[0].i);
          } else {
            selectedIndex = null;
            markSelected();
            if(sessionInfo) sessionInfo.innerHTML = defaultInfoHTML;
            if(sessBtn){
              sessBtn.innerHTML = '<img src="assets/Calendar Screenshot.png" alt="Calendar view">Select Session';
              sessBtn.setAttribute('aria-expanded','false');
            }
          }

          if(sessionOptions){
            sessionOptions.querySelectorAll('button').forEach(btn=>{
              btn.addEventListener('click', ()=> selectSession(parseInt(btn.dataset.index,10)));
            });
          }

          try{
            if(typeof ensureMapForVenue === 'function'){
              ensureMapForVenue();
            }
          }catch(err){}

          setTimeout(()=>{
            if(map && typeof map.resize === 'function') map.resize();
          },0);
        }

        function attachSessionButtonHandler(){
          if(!sessBtn || !sessMenu) return;
          const handler = ()=>{
            const expanded = sessBtn.getAttribute('aria-expanded') === 'true';
            const opening = !expanded;
            sessBtn.setAttribute('aria-expanded', String(opening));
            if(opening){
              showMenu(sessMenu);
              if(selectedIndex !== null){
                const dt = loc.dates[selectedIndex];
                if(dt){
                  requestAnimationFrame(()=> scrollCalendarToMonth(dt));
                }
              }
            } else {
              hideMenu(sessMenu);
            }
          };
          if(sessBtn._sessionToggle){
            sessBtn.removeEventListener('click', sessBtn._sessionToggle);
          }
          sessBtn._sessionToggle = handler;
          sessBtn.addEventListener('click', handler);
        }

        ensureMapForVenue = async function(){
          if(!mapEl) return;

          const visibility = computeVenueVisibility();
          const visibleIndices = Array.isArray(visibility.visibleIndices) ? visibility.visibleIndices : [];
          const locationEntries = locationList
            .map((location, idx) => ({ location, idx }))
            .filter(entry => entry.location && Number.isFinite(entry.location.lng) && Number.isFinite(entry.location.lat));
          const allIndicesVisible = visibleIndices.length > 0 && visibleIndices.length === locationEntries.length;
          const allowedIndices = allIndicesVisible ? null : new Set(visibleIndices);
          const effectiveEntries = allowedIndices
            ? locationEntries.filter(entry => allowedIndices.has(entry.idx))
            : locationEntries;

          if(!effectiveEntries.length){
            locationMarkers.forEach(({ marker }) => { try{ marker.remove(); }catch(e){} });
            locationMarkers = [];
            return;
          }

          const selectedEntry = effectiveEntries.find(entry => entry.idx === currentVenueIndex) || effectiveEntries[0];
          if(!selectedEntry){
            locationMarkers.forEach(({ marker }) => { try{ marker.remove(); }catch(e){} });
            locationMarkers = [];
            return;
          }

          const selectedIdx = selectedEntry.idx;
          const selectedLoc = selectedEntry.location;
          const center = [selectedLoc.lng, selectedLoc.lat];
          const subId = slugify(p.subcategory);
          const markerUrl = subcategoryMarkers[subId];

          const assignDetailRef = ()=>{
            detailMapRef = detailMapRef || {};
            detailMapRef.map = map;
            detailMapRef.resizeHandler = resizeHandler;
            if(mapEl){
              mapEl._detailMap = detailMapRef;
              mapEl.__map = map;
            }
            if(el){
              el._detailMap = detailMapRef;
            }
            if(map){
              MapRegistry.register(map);
            }
          };

          const refreshMarkers = () => {
            if(!map) return;
            locationMarkers.forEach(({ marker }) => { try{ marker.remove(); }catch(e){} });
            locationMarkers = [];
            effectiveEntries.forEach(({ location, idx }) => {
              if(!Number.isFinite(location.lng) || !Number.isFinite(location.lat)){
                return;
              }
              let element;
              if(markerUrl){
                element = new Image();
                element.src = markerUrl;
                element.alt = '';
                element.decoding = 'async';
              } else {
                element = document.createElement('div');
                element.style.background = '#0f172a';
              }
              element.classList.add('post-location-marker');
              element.dataset.index = String(idx);
              element.tabIndex = 0;
              element.setAttribute('role', 'button');
              element.setAttribute('aria-pressed', 'false');
              element.setAttribute('aria-label', `${location.venue} (${location.address})`);
              element.addEventListener('click', () => {
                if(idx === currentVenueIndex) return;
                updateVenue(idx);
              });
              element.addEventListener('keydown', evt => {
                if(evt.key === 'Enter' || evt.key === ' ' || evt.key === 'Spacebar'){
                  evt.preventDefault();
                  element.click();
                }
              });
              const markerInstance = new mapboxgl.Marker({ element, anchor: 'center' }).setLngLat([location.lng, location.lat]).addTo(map);
              locationMarkers.push({ marker: markerInstance, element, index: idx });
            });
            updateDetailMarkerSelection(selectedIdx);
          };

          const fitToLocations = () => {
            if(!map || !effectiveEntries.length){
              return;
            }
            const validPoints = effectiveEntries
              .map(entry => entry.location)
              .filter(location => Number.isFinite(location.lng) && Number.isFinite(location.lat));
            if(!validPoints.length){
              return;
            }
            if(validPoints.length === 1){
              try{
                map.setCenter([validPoints[0].lng, validPoints[0].lat]);
                map.setZoom(10);
              }catch(e){}
              return;
            }
            try{
              const bounds = validPoints.reduce((acc, location) => {
                if(acc){
                  acc.extend([location.lng, location.lat]);
                  return acc;
                }
                return new mapboxgl.LngLatBounds([location.lng, location.lat], [location.lng, location.lat]);
              }, null);
              if(bounds){
                map.fitBounds(bounds, { padding: 40, duration: 0, maxZoom: 10 });
              }
            }catch(e){}
          };

          if(!map){
            setTimeout(async () => {
              if(map) {
                refreshMarkers();
                fitToLocations();
                return;
              }

              await ensureMapboxCssFor(mapEl);

              if (mapEl && mapEl.__map && typeof mapEl.__map.remove === 'function') {
                try { mapEl.__map.remove(); } catch {}
                mapEl.__map = null;
              }
              locationMarkers.forEach(({ marker }) => { try{ marker.remove(); }catch(e){} });
              locationMarkers = [];

              map = new mapboxgl.Map({
                container: mapEl,
                style: mapStyle,
                center,
                zoom: 3,
                interactive: false
              });

              const ensureDetailIcon = attachIconLoader(map);

              const pendingDetailStyleImageRequests = new Map();

              const handleDetailStyleImageMissing = (evt) => {
                const imageId = evt && evt.id;
                if(!imageId){
                  return;
                }
                try{
                  if(map.hasImage?.(imageId)){
                    return;
                  }
                }catch(err){
                  console.error(err);
                }
                if(pendingDetailStyleImageRequests.has(imageId)){
                  return;
                }
                const result = generateMarkerImageFromId(imageId, map, { ensureIcon: ensureDetailIcon });
                if(result && typeof result.then === 'function'){
                  const task = result.then(output => {
                    if(!output){
                      return;
                    }
                    const { image, options } = output;
                    if(!image){
                      return;
                    }
                    try{
                      if(map.hasImage?.(imageId)){
                        return;
                      }
                      map.addImage(imageId, image, options || {});
                    }catch(error){
                      console.error(error);
                    }
                  }).catch(error => {
                    console.error(error);
                  }).finally(() => {
                    pendingDetailStyleImageRequests.delete(imageId);
                  });
                  pendingDetailStyleImageRequests.set(imageId, task);
                  return;
                }
                if(result && result.image){
                  try{
                    if(!map.hasImage?.(imageId)){
                      map.addImage(imageId, result.image, result.options || {});
                    }
                  }catch(error){
                    console.error(error);
                  }
                }
              };

              map.on('mousemove', (e) => {
                const has = !!(e.features && e.features.length);
                map.getCanvas().style.cursor = has ? 'pointer' : '';
              });

              armPointerOnSymbolLayers(map);

              const applyDetailStyleAdjustments = () => {
                applyNightSky(map);
                patchMapboxStyleArtifacts(map);
              };
              whenStyleReady(map, applyDetailStyleAdjustments);
              map.on('style.load', applyDetailStyleAdjustments);
              map.on('styledata', () => {
                if(map.isStyleLoaded && map.isStyleLoaded()){
                  patchMapboxStyleArtifacts(map);
                }
              });

              try{ map.on('styleimagemissing', handleDetailStyleImageMissing); }
              catch(err){ console.error(err); }

              if(resizeHandler){
                window.removeEventListener('resize', resizeHandler);
              }
              resizeHandler = ()=>{ if(map) map.resize(); };
              window.addEventListener('resize', resizeHandler);

              const ready = () => {
                refreshMarkers();
                fitToLocations();
              };
              if(map.loaded()){
                ready();
              } else {
                map.once('load', ready);
              }

              assignDetailRef();

              setTimeout(()=>{ if(map && typeof map.resize === 'function') map.resize(); },0);
            }, 0);
          } else {
            refreshMarkers();
            fitToLocations();
            setTimeout(()=> map && map.resize(),0);
            assignDetailRef();
          }
        };
        window.ensureMapForVenue = ensureMapForVenue;

        const expiredToggle = document.getElementById('expiredToggle');
        if(expiredToggle){
          const handler = ()=> updateSessionOptionsList();
          if(expiredToggle._detailExpiredHandler){
            expiredToggle.removeEventListener('change', expiredToggle._detailExpiredHandler);
          }
          expiredToggle._detailExpiredHandler = handler;
          expiredToggle.addEventListener('change', handler);
        }

        if(sessMenu){
          const filterHandler = ()=> updateSessionOptionsList();
          if(sessMenu._detailSessionFilterHandler){
            ['sessionfilterchange','sessionfilterreset'].forEach(evt => {
              sessMenu.removeEventListener(evt, sessMenu._detailSessionFilterHandler);
            });
          }
          sessMenu._detailSessionFilterHandler = filterHandler;
          ['sessionfilterchange','sessionfilterreset'].forEach(evt => {
            sessMenu.addEventListener(evt, filterHandler);
          });
        }

        const tasks = [];
        if(mapEl){
          tasks.push(()=> {
            const ensure = typeof window.callWhenDefined === 'function'
              ? window.callWhenDefined
              : function(name, cb, timeoutMs){
                  const start = performance.now(), max = timeoutMs ?? 5000;
                  (function check(){
                    const fn = window[name];
                    if (typeof fn === 'function') { try { cb(fn); } catch(e){} return; }
                    if (performance.now() - start < max) requestAnimationFrame(check);
                  })();
                };
            ensure('ensureMapForVenue', fn => fn());
          });
        }
        tasks.push(()=> updateSessionOptionsList());
        tasks.push(()=> attachSessionButtonHandler());

        function runNext(){
          const task = tasks.shift();
          if(!task) return;
          const start = performance.now();
          try{ task(); }catch(err){}
          if(performance.now() - start > 6){
            setTimeout(runNext, 0);
          } else {
            runNext();
          }
        }
        runNext();
      }

      window.updateVenue = updateVenue;
      window.ensureMapForVenue = ensureMapForVenue;
      if(typeof window.__wrapForInputYield === 'function'){
        window.__wrapForInputYield('updateVenue');
        window.__wrapForInputYield('ensureMapForVenue');
      }

        if(mapEl){
          setTimeout(()=>{
            loadMapbox().then(()=>{
              updateVenue(0);
              if(venueMenu && venueBtn && venueOptions){
                venueOptions.querySelectorAll('button').forEach(btn=>{
                  const btnIndex = parseInt(btn.dataset.index, 10);
                  const isVisible = !btn.hidden && !btn.disabled;
                  btn.classList.toggle('selected', isVisible && btnIndex === currentVenueIndex);
                  btn.addEventListener('click', ()=>{
                    if(btn.hidden || btn.disabled){
                      hideMenu(venueMenu);
                      venueBtn.setAttribute('aria-expanded','false');
                      return;
                    }
                    const targetIndex = parseInt(btn.dataset.index, 10);
                    if(!Number.isInteger(targetIndex)){
                      return;
                    }
                    if(targetIndex === currentVenueIndex){
                      if(venueCloseTimer){
                        clearTimeout(venueCloseTimer);
                      }
                      venueCloseTimer = setTimeout(()=>{
                        hideMenu(venueMenu);
                        venueBtn.setAttribute('aria-expanded','false');
                        venueCloseTimer = null;
                      }, 100);
                      return;
                    }
                    venueOptions.querySelectorAll('button').forEach(b=> b.classList.remove('selected'));
                    btn.classList.add('selected');
                    updateVenue(targetIndex);
                    if(venueCloseTimer){
                      clearTimeout(venueCloseTimer);
                    }
                    venueCloseTimer = setTimeout(()=>{
                      hideMenu(venueMenu);
                      venueBtn.setAttribute('aria-expanded','false');
                      venueCloseTimer = null;
                    }, 100);
                  });
                });
                venueBtn.addEventListener('click', ()=>{
                  const expanded = venueBtn.getAttribute('aria-expanded') === 'true';
                  const opening = !expanded;
                  venueBtn.setAttribute('aria-expanded', String(opening));
                  if(opening){
                    showMenu(venueMenu);
                  } else {
                    hideMenu(venueMenu);
                  }
                  if(opening){
                    const adjustMap = ()=>{
                      if(map && typeof map.resize === 'function') map.resize();
                      if(typeof ensureMapForVenue === 'function') ensureMapForVenue();
                    };
                    if(typeof requestAnimationFrame === 'function'){
                      requestAnimationFrame(adjustMap);
                    } else {
                      setTimeout(adjustMap, 0);
                    }
                  }
                });
                document.addEventListener('click', e=>{ if(venueDropdown && !venueDropdown.contains(e.target) && venueBtn && !venueBtn.contains(e.target)){ hideMenu(venueMenu); venueBtn.setAttribute('aria-expanded','false'); } });
              }
              if(sessBtn && sessMenu){
                if(!sessDropdown._sessionOutsideHandler){
                  const outsideHandler = e=>{
                    if(sessDropdown && !sessDropdown.contains(e.target) && sessBtn && !sessBtn.contains(e.target)){
                      hideMenu(sessMenu);
                      sessBtn.setAttribute('aria-expanded','false');
                    }
                  };
                  sessDropdown._sessionOutsideHandler = outsideHandler;
                  document.addEventListener('click', outsideHandler);
                }
              }
              if(map && typeof map.resize === 'function') map.resize();
            }).catch(err => console.error(err));
          },0);
        }
    }

    function inBounds(p){
      if(!postPanel) return true;
      return p.lng >= postPanel.getWest() && p.lng <= postPanel.getEast() &&
             p.lat >= postPanel.getSouth() && p.lat <= postPanel.getNorth();
    }
    function kwMatch(p){ const kw = $('#keyword-textbox').value.trim().toLowerCase(); if(!kw) return true; return (p.title+' '+p.city+' '+p.category+' '+p.subcategory).toLowerCase().includes(kw); }
    function getPriceFilterValues(){
      const minInput = $('#min-price-input');
      const maxInput = $('#max-price-input');
      const rawMin = minInput ? minInput.value.trim() : '';
      const rawMax = maxInput ? maxInput.value.trim() : '';
      let min = rawMin === '' ? null : Number(rawMin);
      let max = rawMax === '' ? null : Number(rawMax);
      if(min !== null && !Number.isFinite(min)) min = null;
      if(max !== null && !Number.isFinite(max)) max = null;
      if(min !== null && max !== null && min > max){ const swap = min; min = max; max = swap; }
      return {min, max};
    }
    function parsePriceRange(value){
      if(typeof value !== 'string') return {min:null, max:null};
      const matches = value.match(/\d+(?:\.\d+)?/g);
      if(!matches || !matches.length) return {min:null, max:null};
      const nums = matches.map(Number).filter(n => Number.isFinite(n));
      if(!nums.length) return {min:null, max:null};
      const min = Math.min(...nums);
      const max = Math.max(...nums);
      return {min, max};
    }
    function priceMatch(p){
      const {min, max} = getPriceFilterValues();
      if(min === null && max === null) return true;
      const ranges = [];
      const addRange = value => {
        const parsed = parsePriceRange(value);
        if(!parsed) return;
        const hasMin = parsed.min !== null;
        const hasMax = parsed.max !== null;
        if(!hasMin && !hasMax) return;
        const normalizedMin = hasMin ? parsed.min : parsed.max;
        const normalizedMax = hasMax ? parsed.max : parsed.min;
        if(normalizedMin === null && normalizedMax === null) return;
        ranges.push({
          min: normalizedMin,
          max: normalizedMax
        });
      };
      addRange(p && p.price);
      if(p && Array.isArray(p.locations)){
        p.locations.forEach(loc => {
          if(loc) addRange(loc.price);
        });
      }
      if(!ranges.length) return false;
      const aggregatedMin = ranges.reduce((acc, range) => {
        const candidate = range.min !== null ? range.min : range.max;
        if(candidate === null) return acc;
        return acc === null ? candidate : Math.min(acc, candidate);
      }, null);
      const aggregatedMax = ranges.reduce((acc, range) => {
        const candidate = range.max !== null ? range.max : range.min;
        if(candidate === null) return acc;
        return acc === null ? candidate : Math.max(acc, candidate);
      }, null);
      if(min !== null && aggregatedMax !== null && aggregatedMax < min) return false;
      if(max !== null && aggregatedMin !== null && aggregatedMin > max) return false;
      const satisfiesBounds = ranges.some(range => {
        if(min !== null && range.max !== null && range.max < min) return false;
        if(max !== null && range.min !== null && range.min > max) return false;
        return true;
      });
      if(!satisfiesBounds) return false;
      return true;
    }
    function dateMatch(p){
      const {start,end} = orderedRange();
      const expiredChk = $('#expiredToggle');
      if(!start && !end){
        if(expiredChk && expiredChk.checked){
          return true;
        }
        const today = new Date(); today.setHours(0,0,0,0);
        return p.dates.some(d => parseISODate(d) >= today);
      }
      return p.dates.some(d => {
        const dt = parseISODate(d);
        if(start && dt < start) return false;
        if(end && dt > end) return false;
        return true;
      });
    }
    function catMatch(p){
      const haveCategoryControllers = Object.keys(categoryControllers).length > 0;
      if(!haveCategoryControllers){
        return true;
      }
      if(selection.cats.size===0){
        return false;
      }
      const cOk = selection.cats.has(p.category);
      if(!cOk) return false;
      if(selection.subs.size===0){
        return false;
      }
      return selection.subs.has(p.category+'::'+p.subcategory);
    }

    function hideResultIndicators(){
      const resultCountEl = $('#resultCount');
      if(resultCountEl){
        resultCountEl.innerHTML = '';
        resultCountEl.style.display = 'none';
      }
      const summaryEl = $('#filterSummary');
      if(summaryEl){
        summaryEl.textContent = '';
      }
    }

    function getVisibleMarkerBoundsForCount(){
      let zoomCandidate = Number.isFinite(lastKnownZoom) ? lastKnownZoom : NaN;
      if(!Number.isFinite(zoomCandidate) && map && typeof map.getZoom === 'function'){
        try {
          zoomCandidate = map.getZoom();
        } catch(err){
          zoomCandidate = NaN;
        }
      }
      if(!Number.isFinite(zoomCandidate) || zoomCandidate < MARKER_ZOOM_THRESHOLD){
        return null;
      }
      const boundsSource = postPanel || (map && typeof map.getBounds === 'function' ? map.getBounds() : null);
      if(!boundsSource) return null;
      return normalizeBounds(boundsSource);
    }

    function updateFilterCounts(){
      if(spinning){
        hideResultIndicators();
        updateResetBtn();
        return;
      }
      if(!postsLoaded) return;
      const basePosts = posts.filter(p => (spinning || inBounds(p)) && dateMatch(p));
      filtered = basePosts.filter(p => kwMatch(p) && catMatch(p) && priceMatch(p));
      const boundsForCount = getVisibleMarkerBoundsForCount();
      const filteredMarkers = boundsForCount ? countMarkersForVenue(filtered, null, boundsForCount) : countMarkersForVenue(filtered);
      const rawTotalMarkers = boundsForCount ? countMarkersForVenue(basePosts, null, boundsForCount) : countMarkersForVenue(basePosts);
      const totalMarkers = Math.max(filteredMarkers, rawTotalMarkers);
      const summary = $('#filterSummary');
      if(summary){ summary.textContent = `${filteredMarkers} results showing out of ${totalMarkers} results in the area.`; }
      updateResultCount(filteredMarkers);
      updateResetBtn();
    }

    function refreshMarkers(render = true){
      if(spinning) return;
      if(!postsLoaded) return;
      const newAdPosts = filtered.filter(p => p.sponsored);
      const ids = newAdPosts.map(p => p.id).join(',');
      if(adPanel && ids !== adIdsKey){
        adPanel.innerHTML = '';
        adIndex = -1;
        if(adTimer){ clearInterval(adTimer); }
        adPosts = newAdPosts;
        if(adPosts.length){
          showNextAd();
          adTimer = setInterval(showNextAd,20000);
        } else {
          const img = document.createElement('img');
          img.src = 'assets/welcome%20001.jpg';
          img.alt = 'Welcome';
          img.style.width = '100%';
          img.style.height = '100%';
          img.style.objectFit = 'cover';
          adPanel.appendChild(img);
        }
        adIdsKey = ids;
      } else {
        adPosts = newAdPosts;
      }
      if(render) renderLists(filtered);
      syncMarkerSources(filtered);
      
      // Ensure map card markers are created/updated
      const currentZoom = map && typeof map.getZoom === 'function' ? map.getZoom() : 0;
      if(Number.isFinite(currentZoom) && currentZoom >= MARKER_ZOOM_THRESHOLD && window.MapCards){
        const collections = getMarkerCollections(filtered);
        const featuresToProcess = Array.isArray(collections.postsData.features) ? collections.postsData.features : [];
        
        // Build set of feature IDs to keep
        const newFeatureIds = new Set();
        featuresToProcess.forEach(feature => {
          if(!feature || !feature.properties || feature.properties.point_count) return;
          newFeatureIds.add(feature.properties.id);
        });
        
        // Remove markers that are no longer in the feature set
        const existingMarkers = window.MapCards.getAllMapCardMarkers();
        existingMarkers.forEach((entry, postId) => {
          if(!newFeatureIds.has(postId)){
            window.MapCards.removeMapCardMarker(postId);
          }
        });
        
        // Create markers for features that don't have one
        featuresToProcess.forEach(feature => {
          if(!feature || !feature.properties || feature.properties.point_count) return;
          const props = feature.properties;
          const coords = feature.geometry && feature.geometry.coordinates;
          if(!Array.isArray(coords) || coords.length < 2) return;
          if(window.MapCards.getMapCardMarker(props.id)) return;
          
          // Parse multiPostIds - GeoJSON may stringify arrays
          let multiPostIds = props.multiPostIds || [];
          if(typeof multiPostIds === 'string'){
            try { multiPostIds = JSON.parse(multiPostIds); } catch(e) { multiPostIds = []; }
          }
          if(!Array.isArray(multiPostIds)) multiPostIds = [];
          
          const post = {
            id: props.id,
            title: props.title || '',
            sub: props.sub || null,
            venue: props.venue || '',
            city: props.city || '',
            isMultiPost: props.isMultiPost || false,
            multiPostIds: multiPostIds,
            multiCount: props.multiCount || 0,
            locations: props.locations || [],
            thumbnailUrl: typeof thumbUrl === 'function' ? thumbUrl(props) : null
          };
          
          window.MapCards.createMapCardMarker(map, post, {
            lng: coords[0],
            lat: coords[1]
          });
        });
      } else if(window.MapCards && currentZoom < MARKER_ZOOM_THRESHOLD){
        // Clear all markers if below threshold
        window.MapCards.clearAllMapCardMarkers();
      }
      
      updateLayerVisibility(lastKnownZoom);
      filtersInitialized = true;
      
      // Ensure post cards outside filter are hidden (backup for all code paths)
      const filteredIds = new Set(filtered.map(p => String(p.id)));
      if(postsWideEl){
        // Hide regular post cards
        postsWideEl.querySelectorAll('.post-card').forEach(card => {
          const cardId = card.dataset.id;
          if(cardId && !filteredIds.has(cardId)){
            card.style.display = 'none';
          } else {
            card.style.display = '';
          }
        });
        // Also hide open posts that are outside the filter
        postsWideEl.querySelectorAll('.open-post').forEach(openPost => {
          const postId = openPost.dataset.id;
          if(postId && !filteredIds.has(postId)){
            openPost.style.display = 'none';
          } else {
            openPost.style.display = '';
          }
        });
        
        // Show/hide empty state based on visible filtered posts
        let existingEmptyWrap = postsWideEl.querySelector('.post-board-empty');
        if(filtered.length === 0){
          if(!existingEmptyWrap){
            existingEmptyWrap = document.createElement('div');
            existingEmptyWrap.className = 'post-board-empty';
            const summaryEl = $('#filterSummary');
            const summaryText = summaryEl ? summaryEl.textContent.trim() : '';
            const summaryCopy = document.createElement('div');
            summaryCopy.className = 'msg--summary post-board-empty-summary';
            summaryCopy.textContent = summaryText || 'No results match your filters.';
            existingEmptyWrap.appendChild(summaryCopy);
            const emptyImg = document.createElement('img');
            emptyImg.src = 'assets/monkeys/Firefly_cute-little-monkey-in-red-cape-pointing-up-937096.png';
            emptyImg.alt = 'Cute little monkey in red cape pointing up';
            emptyImg.className = 'post-board-empty-image';
            existingEmptyWrap.appendChild(emptyImg);
            const emptyMsg = document.createElement('p');
            emptyMsg.className = 'post-board-empty-message';
            emptyMsg.dataset.messageKey = 'msg_posts_empty_state';
            emptyMsg.textContent = 'There are no posts here. Try moving the map or changing your filter settings.';
            existingEmptyWrap.appendChild(emptyMsg);
            postsWideEl.appendChild(existingEmptyWrap);
          }
          existingEmptyWrap.style.display = '';
        } else if(existingEmptyWrap){
          existingEmptyWrap.style.display = 'none';
        }
      }
    }

    function applyFilters(render = true){
      if(spinning){
        hideResultIndicators();
        return;
      }
      updatePostPanel(); // Ensure postPanel has current map bounds before filtering
      updateFilterCounts();
      refreshMarkers(render);
    }

    function showNextAd(){
      if(!adPanel || !adPosts.length) return;
      adIndex = (adIndex + 1) % adPosts.length;
      const p = adPosts[adIndex];
      const slide = document.createElement('a');
      slide.className = 'ad-slide';
      slide.dataset.id = p.id;
      slide.href = postUrl(p);
      const img = new Image();
      img.src = heroUrl(p);
      img.alt = '';
      img.decode().catch(()=>{}).then(()=>{
        slide.appendChild(img);
        const info = document.createElement('div');
        info.className = 'info';
        info.innerHTML = `
          <div class="title">${p.title}</div>
          <div class="cat-line"><span class="sub-icon">${subcategoryIcons[p.subcategory]||''}</span> ${p.category} &gt; ${p.subcategory}</div>
          <div class="loc-line"><span class="badge" title="Venue"></span><span>${p.city}</span></div>
          <div class="date-line"><span class="badge" title="Dates"></span><span>${formatDates(p.dates)}</span></div>
        `;
        slide.appendChild(info);
        adPanel.appendChild(slide);
        requestAnimationFrame(()=> slide.classList.add('active'));
        const slides = adPanel.querySelectorAll('.ad-slide');
        if(slides.length > 1){
          const old = slides[0];
          old.classList.remove('active');
          setTimeout(()=> old.remove(),1500);
        }
      });
    }

    function handleAdPanelClick(e){
      const slide = e.target.closest('.ad-slide');
      if(!slide) return;
      e.preventDefault();
      const id = slide.dataset.id;
      requestAnimationFrame(() => {
        callWhenDefined('openPost', (fn)=>{
          // CASE 4: AD BOARD CLICKED - SCROLL TO TOP
          // Parameters: (id, fromHistory=false, fromMap=false, originEl=null)
          Promise.resolve(fn(id, false, false, null)).then(() => {
            requestAnimationFrame(() => {
              document.querySelectorAll('.recents-card[aria-selected="true"]').forEach(el=>el.removeAttribute('aria-selected'));
              const quickCard = document.querySelector(`.recents-board .recents-card[data-id="${id}"]`);
              if(quickCard){
                quickCard.setAttribute('aria-selected','true');
              }
            });
          }).catch(err => console.error(err));
        });
      });
    }

    function initAdBoard(){
      adPanel = document.querySelector('.ad-panel');
      if(!adPanel) return;
      if(!adPanel.__adListenerBound){
        adPanel.addEventListener('click', handleAdPanelClick, { capture: true });
        adPanel.__adListenerBound = true;
      }
    }

    // Load categories and render filter on startup (skip slow formbuilder UI)
    // This is needed for filter panel and posts to work, but we skip renderFormbuilderCats() which is slow
    if(window.formbuilderStateManager && typeof window.formbuilderStateManager.ensureLoaded === 'function'){
      window.formbuilderStateManager.ensureLoaded({ skipFormbuilderUI: true }).catch(err => {
        console.error('Failed to load categories for filter panel:', err);
      });
    }
    
    // applyFilters();
    setMode(mode);
    if(historyWasActive && mode === 'posts'){
      document.body.classList.add('show-history');
      adjustBoards();
    }
    window.addEventListener('beforeunload', () => {
      localStorage.setItem('mode', mode);
      localStorage.setItem('historyActive', document.body.classList.contains('show-history') ? 'true' : 'false');
    });
  })();
  
// 0577 helpers (safety)
function isPortrait(id){ let h=0; for(let i=0;i<id.length;i++){ h=(h<<5)-h+id.charCodeAt(i); h|=0; } return Math.abs(h)%2===0; }
function heroUrl(p){ const id = (typeof p==='string')? p : p.id; const port=isPortrait(id); return `https://picsum.photos/seed/${encodeURIComponent(id)}-t/${port?'800/1200':'1200/800'}`; }
function thumbUrl(p){ const id = (typeof p==='string')? p : p.id; const port=isPortrait(id); return `https://picsum.photos/seed/${encodeURIComponent(id)}-t/${port?'200/300':'300/200'}`; }
var __stableViewportHeight = (()=>{
  const initialInner = window.innerHeight || 0;
  const initialClient = document.documentElement ? document.documentElement.clientHeight : 0;
  const initialVisual = window.visualViewport ? (window.visualViewport.height || 0) : 0;
  const initial = Math.max(initialInner, initialClient, initialVisual);
  return Number.isFinite(initial) && initial > 0 ? initial : 0;
})();

function getViewportHeight(){
  const innerHeight = window.innerHeight || 0;
  const clientHeight = document.documentElement ? document.documentElement.clientHeight : 0;
  if(window.visualViewport){
    const viewport = window.visualViewport;
    const viewportHeight = viewport.height || 0;
    const offsetTop = typeof viewport.offsetTop === 'number' ? viewport.offsetTop : 0;
    if(offsetTop > 0){
      if(Number.isFinite(__stableViewportHeight) && __stableViewportHeight > 0){
        return __stableViewportHeight;
      }
      return Math.max(innerHeight, clientHeight, viewportHeight, 0);
    }
    const candidate = Math.max(innerHeight, clientHeight, viewportHeight, 0);
    if(Number.isFinite(candidate) && candidate > 0){
      __stableViewportHeight = candidate;
      return candidate;
    }
    return Number.isFinite(__stableViewportHeight) && __stableViewportHeight > 0 ? __stableViewportHeight : 0;
  }
  const fallback = Math.max(innerHeight, clientHeight, 0);
  if(Number.isFinite(fallback) && fallback > 0){
    if(!Number.isFinite(__stableViewportHeight) || __stableViewportHeight <= 0){
      __stableViewportHeight = fallback;
    } else {
      const delta = Math.abs(fallback - __stableViewportHeight);
      if(delta <= 120 || fallback > __stableViewportHeight){
        __stableViewportHeight = fallback;
      }
    }
    return fallback;
  }
  return Number.isFinite(__stableViewportHeight) && __stableViewportHeight > 0 ? __stableViewportHeight : 0;
}
const panelStack = [];
function updateHeaderButtonStates(){
  const adminPanel = document.getElementById('adminPanel');
  const memberPanel = document.getElementById('memberPanel');
  const adminBtn = document.getElementById('adminBtn');
  const memberBtn = document.getElementById('memberBtn');
  
  // Find the topmost showing panel
  let topPanel = null;
  for(let i = panelStack.length - 1; i >= 0; i--){
    const p = panelStack[i];
    if(p instanceof Element && p.classList.contains('show')){
      topPanel = p;
      break;
    }
  }
  
  // Update admin button
  if(adminBtn){
    const isTop = topPanel === adminPanel && adminPanel && adminPanel.classList.contains('show');
    adminBtn.classList.toggle('active', isTop);
    adminBtn.setAttribute('aria-pressed', isTop ? 'true' : 'false');
  }
  
  // Update member button
  if(memberBtn){
    const isTop = topPanel === memberPanel && memberPanel && memberPanel.classList.contains('show');
    memberBtn.classList.toggle('active', isTop);
    memberBtn.setAttribute('aria-pressed', isTop ? 'true' : 'false');
  }
}
function bringToTop(item){
  const idx = panelStack.indexOf(item);
  if(idx!==-1) panelStack.splice(idx,1);
  panelStack.push(item);
  panelStack.forEach((p,i)=>{
    if(p instanceof Element){ 
      // Use CSS variables for z-index, ensuring devtools buttons (z-index 100) stay on top
      const baseZ = p.classList.contains('panel') ? 60 : (p.classList.contains('modal') ? 90 : 60);
      p.style.zIndex = String(baseZ + i);
    }
  });
  updateHeaderButtonStates();
}
function registerPopup(p){
  bringToTop(p);
  if(typeof p.on==='function'){
    p.on('close',()=>{
      const i = panelStack.indexOf(p);
      if(i!==-1) panelStack.splice(i,1);
    });
  }
  const el = p.getElement && p.getElement();
  if(el){
    el.addEventListener('mousedown', ()=> bringToTop(p));
  }
}
function savePanelState(m){
  if(!m || !m.id || m.id === 'welcome-modal') return;
  const content = m.querySelector('.panel-content');
  if(!content) return;
  const state = {
    left: content.style.left,
    top: content.style.top,
    width: content.style.width,
    height: content.style.height
  };
  localStorage.setItem(`panel-${m.id}`, JSON.stringify(state));
}
function loadPanelState(m){
  if(!m || !m.id) return false;
  const content = m.querySelector('.panel-content');
  if(!content) return false;
  const saved = JSON.parse(localStorage.getItem(`panel-${m.id}`) || 'null');
  if(saved){
    ['width','height','left','top'].forEach(prop=>{
      if(saved[prop]) content.style[prop] = saved[prop];
    });
    if(saved.left || saved.top) content.style.transform = 'none';
    return true;
  }
  return false;
}
const panelButtons = {
  filterPanel: 'filterBtn',
  memberPanel: 'memberBtn',
  adminPanel: 'adminBtn'
};


(function(){
  const MIN_HEADER_WIDTH = 390;
  const SIDE_MARGIN = 10;
  let mapControls = null;
  let originalParent = null;
  let originalNext = null;
  let header = null;
  let firstAccessButton = null;
  let welcomeModal = null;
  let placedInHeader = false;
  let rafId = null;

  function cacheElements(){
    if(!mapControls || !mapControls.isConnected){
      mapControls = document.querySelector('.map-controls-map');
      if(mapControls){
        if(!originalParent) originalParent = mapControls.parentElement;
        if(!originalNext) originalNext = mapControls.nextElementSibling;
      }
    }
    if(!header || !header.isConnected){
      header = document.querySelector('.container--header');
    }
    if(header){
      if(!firstAccessButton || !header.contains(firstAccessButton)){
        firstAccessButton = header.querySelector('.button--header-access');
      }
    } else {
      firstAccessButton = null;
    }
    if(!welcomeModal || !welcomeModal.isConnected){
      welcomeModal = document.getElementById('welcome-modal');
    }
    return Boolean(mapControls && header);
  }

  function moveToHeader(){
    if(!cacheElements() || placedInHeader) return;
    const insertBeforeNode = (firstAccessButton && firstAccessButton.parentNode === header) ? firstAccessButton : null;
    if(insertBeforeNode){
      header.insertBefore(mapControls, insertBeforeNode);
    } else {
      header.appendChild(mapControls);
    }
    mapControls.classList.add('in-header');
    placedInHeader = true;
  }

  function moveToOriginal(){
    if(!mapControls || !originalParent || !placedInHeader) return;
    if(originalNext && originalNext.parentNode === originalParent){
      originalParent.insertBefore(mapControls, originalNext);
    } else {
      originalParent.appendChild(mapControls);
    }
    mapControls.classList.remove('in-header');
    mapControls.style.left = '';
    mapControls.style.width = '';
    mapControls.style.maxWidth = '';
    placedInHeader = false;
  }

  function performUpdate(){
    rafId = null;
    if(!cacheElements()) return;
    const welcomeOpen = welcomeModal && welcomeModal.classList.contains('show');
    if(welcomeOpen){
      moveToOriginal();
      return;
    }
    const modeSwitchContainer = header.querySelector('.container--header-mode-switch');
    if(!firstAccessButton || !modeSwitchContainer){
      moveToOriginal();
      return;
    }
    const headerRect = header.getBoundingClientRect();
    const modeSwitchRect = modeSwitchContainer.getBoundingClientRect();
    const accessRect = firstAccessButton.getBoundingClientRect();
    const leftBoundary = Math.max(modeSwitchRect.right, headerRect.left) + SIDE_MARGIN;
    const rightBoundary = Math.min(accessRect.left, headerRect.right) - SIDE_MARGIN;
    const available = rightBoundary - leftBoundary;
    if(available < MIN_HEADER_WIDTH){
      moveToOriginal();
      return;
    }
    moveToHeader();
    const center = leftBoundary + available / 2;
    mapControls.style.left = (center - headerRect.left) + 'px';
    mapControls.style.width = '';
    mapControls.style.maxWidth = '';
    const ctrlRect = mapControls.getBoundingClientRect();
    if(ctrlRect.width > available){
      moveToOriginal();
    }
  }

  function scheduleUpdate(){
    if(rafId !== null) return;
    rafId = requestAnimationFrame(performUpdate);
  }

  window.addEventListener('resize', scheduleUpdate);
  window.addEventListener('orientationchange', scheduleUpdate);
  document.addEventListener('DOMContentLoaded', scheduleUpdate);
  window.addEventListener('load', scheduleUpdate);
  if(document.readyState !== 'loading') scheduleUpdate();

  const getWelcome = () => {
    if(!welcomeModal || !welcomeModal.isConnected){
      welcomeModal = document.getElementById('welcome-modal');
    }
    return welcomeModal;
  };
  const observedWelcome = getWelcome();
  if(observedWelcome && typeof MutationObserver === 'function'){
    const observer = new MutationObserver(scheduleUpdate);
    observer.observe(observedWelcome, {attributes:true, attributeFilter:['class','style']});
  }

  window.updateHeaderMapControls = scheduleUpdate;
})();

function schedulePanelEntrance(content, force=false){
  if(!content) return;
  if(force){
    content.classList.remove('panel-visible');
  }
  content.style.transform = '';
  if(force || !content.classList.contains('panel-visible')){
    requestAnimationFrame(()=>{
      if(!content.isConnected) return;
      content.classList.add('panel-visible');
    });
  }
}
function openPanel(m){
  if(!m) return;
  // Require admin authentication to access admin panel
  if(m.id === 'adminPanel' && window.adminAuthManager && !window.adminAuthManager.isAuthenticated()){
    window.adminAuthManager.ensureAuthenticated();
    return;
  }
  
  // Load formbuilder DATA (not UI) when admin panel opens - needed by Messages, Map tabs
  if(m.id === 'adminPanel' && window.formbuilderStateManager){
    window.formbuilderStateManager.ensureLoaded({ skipFormbuilderUI: true });
  }
  
  // Initialize admin panel spin controls with current values
  if(m.id === 'adminPanel'){
    const spinLoadStartCheckbox = document.getElementById('spinLoadStart');
    const spinTypeRadios = document.querySelectorAll('input[name="spinType"]');
    const spinLogoClickCheckbox = document.getElementById('spinLogoClick');
    const spinZoomMaxSlider = document.getElementById('spinZoomMax');
    const spinZoomMaxDisplay = document.getElementById('spinZoomMaxDisplay');
    const spinSpeedSlider = document.getElementById('spinSpeed');
    const spinSpeedDisplay = document.getElementById('spinSpeedDisplay');
    const waitForMapTilesCheckbox = document.getElementById('waitForMapTiles');
    
    if(window.spinGlobals){
      if(spinLoadStartCheckbox){
        spinLoadStartCheckbox.checked = window.spinGlobals.spinLoadStart || false;
      }
      if(spinTypeRadios.length){
        spinTypeRadios.forEach(radio => {
          radio.checked = (radio.value === (window.spinGlobals.spinLoadType || 'everyone'));
        });
      }
      if(spinLogoClickCheckbox){
        spinLogoClickCheckbox.checked = window.spinGlobals.spinLogoClick !== undefined ? window.spinGlobals.spinLogoClick : true;
      }
      if(spinZoomMaxSlider && spinZoomMaxDisplay){
        const zoomValue = window.spinGlobals.spinZoomMax || 4;
        spinZoomMaxSlider.value = zoomValue;
        spinZoomMaxDisplay.textContent = zoomValue;
      }
      if(spinSpeedSlider && spinSpeedDisplay){
        const speedValue = window.spinGlobals.spinSpeed || 0.3;
        spinSpeedSlider.value = speedValue;
        spinSpeedDisplay.textContent = speedValue.toFixed(1);
      }
      if(waitForMapTilesCheckbox){
        waitForMapTilesCheckbox.checked = window.spinGlobals.waitForMapTiles !== undefined ? window.spinGlobals.waitForMapTiles : true;
      }
    }
    
    // Auto-save function for map settings
    async function autoSaveMapSettings(){
      const settings = {};
      if(spinLoadStartCheckbox) settings.spin_on_load = spinLoadStartCheckbox.checked;
      if(spinLogoClickCheckbox) settings.spin_on_logo = spinLogoClickCheckbox.checked;
      if(waitForMapTilesCheckbox) settings.wait_for_map_tiles = waitForMapTilesCheckbox.checked;
      const checkedRadio = Array.from(spinTypeRadios).find(r => r.checked);
      if(checkedRadio) settings.spin_load_type = checkedRadio.value;
      if(spinZoomMaxSlider){
        const zoomValue = parseInt(spinZoomMaxSlider.value, 10);
        if(!isNaN(zoomValue)) settings.spin_zoom_max = zoomValue;
      }
      if(spinSpeedSlider){
        const speedValue = parseFloat(spinSpeedSlider.value);
        if(!isNaN(speedValue)) settings.spin_speed = speedValue;
      }
      
      // Include icon folder setting
      const iconFolderInput = document.getElementById('adminIconFolder');
      if(iconFolderInput){
        const iconFolderValue = iconFolderInput.value.trim();
        if(iconFolderValue){
          settings.icon_folder = iconFolderValue;
          window.iconFolder = iconFolderValue;
        }
      }
      
      // Include system images folder setting
      const systemImagesFolderInput = document.getElementById('adminSystemImagesFolder');
      if(systemImagesFolderInput){
        const systemImagesFolderValue = systemImagesFolderInput.value.trim();
        if(systemImagesFolderValue){
          settings.system_images_folder = systemImagesFolderValue;
        }
      }
      
      try {
        await fetch('/gateway.php?action=save-admin-settings', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' },
          body: JSON.stringify(settings)
        });
      } catch(err){
        console.warn('Auto-save failed:', err);
      }
    }
    
    // Make value displays editable on click
    function makeValueEditable(display, slider, min, max, decimals){
      if(!display || display.dataset.editableAdded) return;
      display.dataset.editableAdded = 'true';
      display.style.cursor = 'pointer';
      
      display.addEventListener('click', ()=>{
        const currentValue = display.textContent;
        const input = document.createElement('input');
        input.type = 'number';
        input.value = currentValue;
        input.min = min;
        input.max = max;
        input.step = decimals ? '0.1' : '1';
        input.className = 'slider-value-input';
        input.style.width = '60px';
        input.style.textAlign = 'center';
        input.style.fontSize = '16px';
        input.style.fontWeight = 'bold';
        input.style.background = 'rgba(0,0,0,0.5)';
        input.style.color = '#fff';
        input.style.border = '1px solid #2e3a72';
        input.style.borderRadius = '4px';
        input.style.padding = '2px';
        
        const commitValue = ()=>{
          let newValue = decimals ? parseFloat(input.value) : parseInt(input.value, 10);
          if(isNaN(newValue)) newValue = decimals ? parseFloat(currentValue) : parseInt(currentValue, 10);
          newValue = Math.max(min, Math.min(max, newValue));
          const formattedValue = decimals ? newValue.toFixed(1) : newValue.toString();
          display.textContent = formattedValue;
          display.style.display = '';
          input.remove();
          if(slider) slider.value = newValue;
          // Don't update window.spinGlobals - settings will be applied on next page load
          autoSaveMapSettings();
        };
        
        input.addEventListener('blur', commitValue);
        input.addEventListener('keydown', (e)=>{
          if(e.key === 'Enter'){
            e.preventDefault();
            commitValue();
          } else if(e.key === 'Escape'){
            display.style.display = '';
            input.remove();
          }
        });
        
        display.style.display = 'none';
        display.parentNode.insertBefore(input, display);
        input.focus();
        input.select();
      });
    }
    
    makeValueEditable(spinZoomMaxDisplay, spinZoomMaxSlider, 1, 10, false);
    makeValueEditable(spinSpeedDisplay, spinSpeedSlider, 0.1, 2.0, true);
    
    // Zoom slider - update display on input, save on change
    if(spinZoomMaxSlider && !spinZoomMaxSlider.dataset.listenerAdded){
      spinZoomMaxSlider.dataset.listenerAdded = 'true';
      spinZoomMaxSlider.addEventListener('input', ()=>{
        spinZoomMaxDisplay.textContent = spinZoomMaxSlider.value;
      });
      spinZoomMaxSlider.addEventListener('change', ()=>{
        // Don't update window.spinGlobals - settings will be applied on next page load
        autoSaveMapSettings();
      });
    }
    
    // Speed slider - update display on input, save on change
    if(spinSpeedSlider && !spinSpeedSlider.dataset.listenerAdded){
      spinSpeedSlider.dataset.listenerAdded = 'true';
      spinSpeedSlider.addEventListener('input', ()=>{
        spinSpeedDisplay.textContent = parseFloat(spinSpeedSlider.value).toFixed(1);
      });
      spinSpeedSlider.addEventListener('change', ()=>{
        // Don't update window.spinGlobals - settings will be applied on next page load
        autoSaveMapSettings();
      });
    }
    
    // Auto-save when toggles/radios change
    if(spinLoadStartCheckbox && !spinLoadStartCheckbox.dataset.autoSaveAdded){
      spinLoadStartCheckbox.dataset.autoSaveAdded = 'true';
      spinLoadStartCheckbox.addEventListener('change', ()=>{
        // Don't update window.spinGlobals - that triggers the spin animation
        // Settings will be applied on next page load
        autoSaveMapSettings();
      });
    }
    if(spinLogoClickCheckbox && !spinLogoClickCheckbox.dataset.autoSaveAdded){
      spinLogoClickCheckbox.dataset.autoSaveAdded = 'true';
      spinLogoClickCheckbox.addEventListener('change', ()=>{
        // Don't update window.spinGlobals - that triggers the spin animation
        // Settings will be applied on next page load
        autoSaveMapSettings();
      });
    }
    if(waitForMapTilesCheckbox && !waitForMapTilesCheckbox.dataset.autoSaveAdded){
      waitForMapTilesCheckbox.dataset.autoSaveAdded = 'true';
      waitForMapTilesCheckbox.addEventListener('change', ()=>{
        // Settings will be applied on next page load
        autoSaveMapSettings();
      });
    }
    spinTypeRadios.forEach(radio => {
      if(radio.dataset.autoSaveAdded) return;
      radio.dataset.autoSaveAdded = 'true';
      radio.addEventListener('change', ()=>{
        // Don't update window.spinGlobals - that triggers the spin animation
        // Settings will be applied on next page load
        autoSaveMapSettings();
      });
    });
    
    // Auto-save icon folder setting on blur
    const iconFolderInput = document.getElementById('adminIconFolder');
    if(iconFolderInput && !iconFolderInput.dataset.autoSaveAdded){
      iconFolderInput.dataset.autoSaveAdded = 'true';
      iconFolderInput.addEventListener('blur', ()=>{
        autoSaveMapSettings();
      });
      iconFolderInput.addEventListener('change', ()=>{
        autoSaveMapSettings();
      });
    }
    
    // Auto-save system images folder setting on blur
    const systemImagesFolderInput = document.getElementById('adminSystemImagesFolder');
    if(systemImagesFolderInput && !systemImagesFolderInput.dataset.autoSaveAdded){
      systemImagesFolderInput.dataset.autoSaveAdded = 'true';
      systemImagesFolderInput.addEventListener('blur', async ()=>{
        const settings = {};
        const folderValue = systemImagesFolderInput.value.trim();
        if(folderValue){
          settings.system_images_folder = folderValue;
          try {
            await fetch('/gateway.php?action=save-admin-settings', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' },
              body: JSON.stringify(settings)
            });
          } catch(err){
            console.warn('Auto-save failed:', err);
          }
        }
      });
      systemImagesFolderInput.addEventListener('change', async ()=>{
        const settings = {};
        const folderValue = systemImagesFolderInput.value.trim();
        if(folderValue){
          settings.system_images_folder = folderValue;
          try {
            await fetch('/gateway.php?action=save-admin-settings', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' },
              body: JSON.stringify(settings)
            });
          } catch(err){
            console.warn('Auto-save failed:', err);
          }
        }
      });
    }
    
    // Initialize Starting Location Geocoder in admin panel
    const startingAddressInput = document.getElementById('adminStartingAddress');
    const startingLatInput = document.getElementById('adminStartingLat');
    const startingLngInput = document.getElementById('adminStartingLng');
    const startingGeocoderContainer = document.getElementById('geocoder-admin-starting');
    const startingAddressDisplay = document.getElementById('startingAddressDisplay');
    
    if(startingGeocoderContainer && !startingGeocoderContainer.dataset.geocoderAdded){
      startingGeocoderContainer.dataset.geocoderAdded = 'true';
      
      const showGeocoderInput = ()=>{
        startingGeocoderContainer.hidden = false;
        if(startingAddressDisplay) startingAddressDisplay.hidden = true;
        setTimeout(()=>{
          const input = startingGeocoderContainer.querySelector('.google-places-geocoder input') || 
                        startingGeocoderContainer.querySelector('input');
          if(input) input.focus();
        }, 50);
      };
      
      const showAddressDisplay = ()=>{
        const addr = window._startingAddress || '';
        if(addr.trim() && startingAddressDisplay){
          startingAddressDisplay.textContent = addr;
          startingGeocoderContainer.hidden = true;
          startingAddressDisplay.hidden = false;
        } else {
          startingGeocoderContainer.hidden = false;
          if(startingAddressDisplay) startingAddressDisplay.hidden = true;
        }
      };
      
      // Click on display to edit
      if(startingAddressDisplay){
        startingAddressDisplay.addEventListener('click', showGeocoderInput);
      }
      
      const saveStartingLocation = async (address, lat, lng)=>{
        window._startingAddress = address || null;
        window._startingLat = lat || null;
        window._startingLng = lng || null;
        
        if(startingAddressInput) startingAddressInput.value = address || '';
        if(startingLatInput) startingLatInput.value = lat || '';
        if(startingLngInput) startingLngInput.value = lng || '';
        
        const settings = { starting_address: address || '' };
        if(lat && lng){
          settings.starting_lat = lat;
          settings.starting_lng = lng;
        }
        
        try {
          await fetch('/gateway.php?action=save-admin-settings', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' },
            body: JSON.stringify(settings)
          });
        } catch(err){
          console.warn('Auto-save starting location failed:', err);
        }
        
        showAddressDisplay();
      };
      
      const googleReady = typeof google !== 'undefined' && google.maps && google.maps.places;
      if(googleReady){
        // Create Google Places geocoder wrapper
        const wrapper = document.createElement('div');
        wrapper.className = 'google-places-geocoder';
        wrapper.style.cssText = 'background:rgba(0,0,0,0.35);';
        const input = document.createElement('input');
        input.type = 'text';
        input.placeholder = 'Search for a location...';
        input.style.cssText = 'background:transparent;color:#fff;caret-color:#fff;';
        input.setAttribute('autocomplete', 'off');
        wrapper.appendChild(input);
        startingGeocoderContainer.appendChild(wrapper);
        
        // Initialize Google Places Autocomplete
        const autocomplete = new google.maps.places.Autocomplete(input, {
          fields: ['formatted_address', 'geometry', 'name', 'place_id']
        });
        
        // Handle result selection - extract coordinates
        autocomplete.addListener('place_changed', ()=>{
          const place = autocomplete.getPlace();
          if(place && place.geometry && place.geometry.location){
            const placeName = place.formatted_address || place.name || '';
            const lat = place.geometry.location.lat();
            const lng = place.geometry.location.lng();
            saveStartingLocation(placeName, lat, lng);
          }
        });
        
        // Set initial value and show display if exists - wait for settings to load first
        (async ()=>{
          if(!window._adminSettingsLoaded){
            await window._adminSettingsReady;
          }
          
          if(window._startingAddress){
            input.value = window._startingAddress;
          }
          
          // Save on blur if user types custom text
          if(!input.dataset.blurAdded){
            input.dataset.blurAdded = 'true';
            input.addEventListener('blur', ()=>{
              const value = input.value.trim();
              if(value !== (window._startingAddress || '')){
                // Custom text entered - no coordinates
                saveStartingLocation(value, null, null);
              } else if(window._startingAddress){
                // Value unchanged, just show display
                showAddressDisplay();
              }
            });
          }
          
          // Show display if we have an address
          showAddressDisplay();
        })();
      } else {
        // Fallback: create simple input if Google Places not ready
        (async ()=>{
          if(!window._adminSettingsLoaded){
            await window._adminSettingsReady;
          }
          
          const fallback = document.createElement('input');
          fallback.type = 'text';
          fallback.placeholder = 'Search for a location...';
          fallback.className = 'google-places-geocoder-fallback';
          fallback.style.cssText = 'width:100%;height:36px;padding:0 12px;border:1px solid var(--border);border-radius:8px;background:rgba(0,0,0,0.35);color:#fff;font:inherit;';
          if(window._startingAddress){
            fallback.value = window._startingAddress;
          }
          fallback.addEventListener('blur', ()=>{
            saveStartingLocation(fallback.value.trim(), null, null);
          });
          fallback.addEventListener('change', ()=>{
            saveStartingLocation(fallback.value.trim(), null, null);
          });
          startingGeocoderContainer.appendChild(fallback);
          showAddressDisplay();
        })();
      }
    }
    
    // Auto-save Starting Zoom slider
    const startingZoomSlider = document.getElementById('startingZoom');
    const startingZoomDisplay = document.getElementById('startingZoomDisplay');
    if(startingZoomSlider && !startingZoomSlider.dataset.autoSaveAdded){
      startingZoomSlider.dataset.autoSaveAdded = 'true';
      
      // Update display on input
      startingZoomSlider.addEventListener('input', ()=>{
        const value = parseInt(startingZoomSlider.value, 10);
        if(startingZoomDisplay) startingZoomDisplay.textContent = value.toString();
      });
      
      // Auto-save on change
      startingZoomSlider.addEventListener('change', async ()=>{
        const value = parseInt(startingZoomSlider.value, 10);
        window._startingZoom = value;
        if(startingZoomDisplay) startingZoomDisplay.textContent = value.toString();
        
        try {
          await fetch('/gateway.php?action=save-admin-settings', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' },
            body: JSON.stringify({ starting_zoom: value })
          });
        } catch(err){
          console.warn('Auto-save starting zoom failed:', err);
        }
      });
      
      // Make value display editable on click (like other sliders)
      if(startingZoomDisplay && !startingZoomDisplay.dataset.editableAdded){
        startingZoomDisplay.dataset.editableAdded = 'true';
        startingZoomDisplay.style.cursor = 'pointer';
        
        startingZoomDisplay.addEventListener('click', ()=>{
          const currentValue = startingZoomDisplay.textContent;
          const input = document.createElement('input');
          input.type = 'number';
          input.value = currentValue;
          input.min = '1';
          input.max = '18';
          input.step = '1';
          input.className = 'slider-value-input';
          input.style.width = '60px';
          input.style.textAlign = 'center';
          input.style.fontSize = '16px';
          input.style.fontWeight = 'bold';
          input.style.background = 'rgba(0,0,0,0.5)';
          input.style.color = '#fff';
          input.style.border = '1px solid #2e3a72';
          input.style.borderRadius = '4px';
          input.style.padding = '2px';
          
          const commitValue = async ()=>{
            let newValue = parseInt(input.value, 10);
            if(isNaN(newValue)) newValue = parseInt(currentValue, 10);
            newValue = Math.max(1, Math.min(18, newValue));
            startingZoomDisplay.textContent = newValue.toString();
            startingZoomDisplay.style.display = '';
            input.remove();
            startingZoomSlider.value = newValue;
            window._startingZoom = newValue;
            
            try {
              await fetch('/gateway.php?action=save-admin-settings', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' },
                body: JSON.stringify({ starting_zoom: newValue })
              });
            } catch(err){
              console.warn('Auto-save starting zoom failed:', err);
            }
          };
          
          input.addEventListener('blur', commitValue);
          input.addEventListener('keydown', (e)=>{
            if(e.key === 'Enter'){
              e.preventDefault();
              commitValue();
            } else if(e.key === 'Escape'){
              startingZoomDisplay.style.display = '';
              input.remove();
            }
          });
          
          startingZoomDisplay.style.display = 'none';
          startingZoomDisplay.parentNode.insertBefore(input, startingZoomDisplay);
          input.focus();
          input.select();
        });
      }
    }
    
    // Auto-save welcome message enabled checkbox
    const welcomeEnabledCheckbox = document.getElementById('adminWelcomeEnabled');
    if(welcomeEnabledCheckbox && !welcomeEnabledCheckbox.dataset.autoSaveAdded){
      welcomeEnabledCheckbox.dataset.autoSaveAdded = 'true';
      welcomeEnabledCheckbox.addEventListener('change', async ()=>{
        // Update in-memory state
        window._welcomeEnabled = welcomeEnabledCheckbox.checked;
        
        try {
          await fetch('/gateway.php?action=save-admin-settings', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ 
              welcome_enabled: welcomeEnabledCheckbox.checked
            })
          });
        } catch(error){
          console.error('Error auto-saving welcome enabled setting:', error);
        }
      });
    }
    
    // IMPORTANT: Reset dirty state after initializing admin panel values
    // This prevents showing "unsaved changes" when first opening the panel
    setTimeout(() => {
      if(window.adminPanelModule && typeof window.adminPanelModule.markSaved === 'function'){
        window.adminPanelModule.markSaved();
      }
    }, 100);
  }
  
  const content = m.querySelector('.panel-content') || m.querySelector('.modal-content');
  if(content && m.id !== 'welcome-modal'){
    content.style.width = '';
    content.style.height = '';
  }
  let shouldScheduleEntrance = false;
  if(content){
    const rootStyles = getComputedStyle(document.documentElement);
    const headerH = parseFloat(rootStyles.getPropertyValue('--header-h')) || 0;
    const subH = parseFloat(rootStyles.getPropertyValue('--subheader-h')) || 0;
    const footerH = parseFloat(rootStyles.getPropertyValue('--footer-h')) || 0;
    const safeTop = parseFloat(rootStyles.getPropertyValue('--safe-top')) || 0;
    const viewportHeight = getViewportHeight();
    const innerWidth = window.innerWidth;
    if(m.id==='adminPanel' || m.id==='memberPanel'){
      const topPos = headerH + safeTop;
      const availableHeight = Math.max(0, viewportHeight - footerH - topPos);
      content.style.left='auto';
      content.style.right='0';
      content.style.top=`${topPos}px`;
      content.style.bottom=`${footerH}px`;
      content.style.maxHeight = availableHeight ? `${availableHeight}px` : '';
      content.dataset.side='right';
      if(!content.classList.contains('panel-visible')){
        content.classList.remove('panel-visible');
        shouldScheduleEntrance = true;
      }
    } else if(m.id==='filterPanel'){
      const topPos = headerH + subH + safeTop;
      if(innerWidth < 450){
        content.style.left='0';
        content.style.right='0';
        content.style.top=`${topPos}px`;
        content.style.bottom=`${footerH}px`;
        content.style.maxHeight='';
      } else {
        const availableHeight = Math.max(0, viewportHeight - footerH - topPos);
        content.style.left='0';
        content.style.right='';
        content.style.top=`${topPos}px`;
        content.style.bottom='';
        content.style.maxHeight = availableHeight ? `${availableHeight}px` : '';
      }
      content.dataset.side='left';
      if(!content.classList.contains('panel-visible')){
        content.classList.remove('panel-visible');
        shouldScheduleEntrance = true;
      }
    } else if(m.id==='welcome-modal'){
      const topPos = headerH + safeTop + 10;
      content.style.left='50%';
      content.style.top=`${topPos}px`;
      content.style.transform='translateX(-50%)';
    } else {
      content.style.left='50%';
      content.style.top='50%';
      content.style.transform='translate(-50%, -50%)';
      if(m.id !== 'welcome-modal' && !['adminPanel','memberPanel','filterPanel'].includes(m.id)){
        loadPanelState(m);
      }
    }
  }
  m.classList.add('show');
  m.removeAttribute('aria-hidden');
  m.removeAttribute('inert');
  // Re-enable member auth inputs when member panel opens
  if(m.id === 'memberPanel'){
    const loginPanel = document.getElementById('memberLoginPanel');
    const registerPanel = document.getElementById('memberRegisterPanel');
    // Remove inert from auth panels to ensure inputs are focusable
    if(loginPanel && !loginPanel.hidden){
      loginPanel.removeAttribute('inert');
      loginPanel.querySelectorAll('input').forEach(input => {
        input.disabled = false;
      });
    }
    if(registerPanel && !registerPanel.hidden){
      registerPanel.removeAttribute('inert');
      registerPanel.querySelectorAll('input').forEach(input => {
        input.disabled = false;
      });
    }
  }
  if(m.id === 'welcome-modal'){
    const mc = document.querySelector('.map-controls-map');
    if(mc) mc.style.display = 'none';
  }
  const btnId = panelButtons[m && m.id];
  if(btnId){
    const btn = document.getElementById(btnId);
    btn && btn.setAttribute('aria-pressed','true');
  }
  localStorage.setItem(`panel-open-${m.id}`,'true');
  if(content && shouldScheduleEntrance){
    schedulePanelEntrance(content);
  }
  if(!m.__bringToTopAdded){
    m.addEventListener('mousedown', ()=> bringToTop(m));
    m.__bringToTopAdded = true;
  }
  bringToTop(m);
  if(map && typeof map.resize === 'function') setTimeout(()=> map.resize(),0);
  if(typeof window.adjustBoards === 'function') setTimeout(()=> window.adjustBoards(), 0);
  if(typeof window.updateHeaderMapControls === 'function') window.updateHeaderMapControls();
}

const memberPanelChangeManager = (()=>{
  const DRAFT_KEY = 'member-form-draft-v1';
  let panel = null;
  let form = null;
  let saveButton = null;
  let discardButton = null;
  let prompt = null;
  let promptCancelButton = null;
  let promptSaveButton = null;
  let promptDiscardButton = null;
  let promptKeydownListener = null;
  let promptKeydownTarget = null;
  let promptOpener = null;
  let statusMessage = null;
  let dirty = false;
  let savedState = {};
  let applying = false;
  let initialized = false;
  let statusTimer = null;
  let pendingCloseTarget = null;

  function ensureElements(){
    panel = document.getElementById('memberPanel');
    form = panel ? panel.querySelector('.panel-body') : null;
    if(panel){
      saveButton = panel.querySelector('.save-changes');
      discardButton = panel.querySelector('.discard-changes');
    }
    prompt = document.getElementById('memberUnsavedPrompt');
    if(prompt){
      promptCancelButton = prompt.querySelector('.confirm-cancel');
      promptSaveButton = prompt.querySelector('.confirm-save');
      promptDiscardButton = prompt.querySelector('.confirm-discard');
    } else {
      promptCancelButton = null;
      promptSaveButton = null;
      promptDiscardButton = null;
    }
    statusMessage = document.getElementById('memberStatusMessage');
  }

  function getKey(el){
    if(!el) return '';
    return el.name || el.id || '';
  }

  function serializeState(){
    if(!form) return {};
    const data = {};
    form.querySelectorAll('input, select, textarea').forEach(el => {
      const key = getKey(el);
      if(!key) return;
      if(el.type === 'file'){
        data[key] = el.files && el.files.length ? '__FILE_SELECTED__' : '';
        return;
      }
      if(el.type === 'checkbox'){
        data[key] = !!el.checked;
        return;
      }
      if(el.type === 'radio'){
        if(!(key in data)) data[key] = null;
        if(el.checked) data[key] = el.value;
        return;
      }
      data[key] = el.value;
    });
    // Include checkout options in state for comparison
    // Normalize to ensure consistent format (sort by id, normalize all values)
    const checkoutOptions = getCheckoutOptionsFromUI();
    const normalized = checkoutOptions.map(opt => ({
      id: opt.id,
      checkout_title: String(opt.checkout_title || ''),
      checkout_description: String(opt.checkout_description || ''),
      checkout_flagfall_price: Math.round((parseFloat(opt.checkout_flagfall_price) || 0) * 100) / 100,
      checkout_basic_day_rate: opt.checkout_basic_day_rate !== null && opt.checkout_basic_day_rate !== undefined ? Math.round((parseFloat(opt.checkout_basic_day_rate) || 0) * 100) / 100 : null,
      checkout_discount_day_rate: opt.checkout_discount_day_rate !== null && opt.checkout_discount_day_rate !== undefined ? Math.round((parseFloat(opt.checkout_discount_day_rate) || 0) * 100) / 100 : null,
      checkout_featured: opt.checkout_featured === 1 || opt.checkout_featured === true ? 1 : 0,
      checkout_sidebar_ad: opt.checkout_sidebar_ad === 1 || opt.checkout_sidebar_ad === true ? 1 : 0,
      is_active: opt.is_active === 1 || opt.is_active === true ? 1 : 0
    })).sort((a, b) => {
      // Sort by id for consistent comparison
      const aId = typeof a.id === 'string' && a.id.startsWith('new-') ? 999999 : parseInt(a.id) || 0;
      const bId = typeof b.id === 'string' && b.id.startsWith('new-') ? 999999 : parseInt(b.id) || 0;
      return aId - bId;
    });
    data['__checkout_options__'] = JSON.stringify(normalized);
    return data;
  }

  function saveDraft(state){
    try{
      const payload = { ts: Date.now(), state: state || {} };
      localStorage.setItem(DRAFT_KEY, JSON.stringify(payload));
    }catch(_e){}
  }

  function loadDraft(){
    try{
      const raw = localStorage.getItem(DRAFT_KEY);
      if(!raw) return null;
      const parsed = JSON.parse(raw);
      if(parsed && parsed.state && typeof parsed.state === 'object'){
        return parsed.state;
      }
    }catch(_e){}
    return null;
  }
  function stateEquals(a, b){
    const keys = new Set([
      ...Object.keys(a || {}),
      ...Object.keys(b || {})
    ]);
    for(const key of keys){
      if(a[key] !== b[key]){
        return false;
      }
    }
    return true;
  }

  function setDirty(value){
    dirty = !!value;
    if(panel){
      panel.classList.toggle('has-unsaved', dirty);
      panel.setAttribute('data-unsaved', dirty ? 'true' : 'false');
    }
    if(saveButton){
      saveButton.disabled = !dirty;
    }
    if(discardButton){
      discardButton.disabled = !dirty;
    }
    if(promptDiscardButton){
      promptDiscardButton.disabled = !dirty;
    }
  }

  function updateDirty(){
    if(applying) return;
    ensureElements();
    const current = serializeState();
    // Always persist draft; disable prompt for member panel
    saveDraft(current);
    setDirty(false);
  }

  async function showStatus(message){
    ensureElements();
    if(!statusMessage) return;
    
    // If message looks like a message key (starts with 'msg_'), fetch from DB
    let displayMessage = message;
    if(typeof message === 'string' && message.startsWith('msg_')){
      displayMessage = await getMessage(message, {}, true) || message;
    }
    
    statusMessage.textContent = displayMessage;
    statusMessage.setAttribute('aria-hidden','false');
    statusMessage.classList.add('show');
    clearTimeout(statusTimer);
    statusTimer = setTimeout(()=>{
      statusMessage.classList.remove('show');
      statusMessage.setAttribute('aria-hidden','true');
    }, 2000);
  }

  function applyState(state){
    if(!form || !state) return;
    applying = true;
    try{
      form.querySelectorAll('input, select, textarea').forEach(el => {
        const key = getKey(el);
        if(!key || !(key in state)) return;
        const value = state[key];
        if(el.type === 'file'){
          const shouldClear = !value;
          if(shouldClear && el.value){
            el.value = '';
          }
          return;
        }
        if(el.type === 'checkbox'){
          const nextChecked = !!value;
          if(el.checked !== nextChecked){
            el.checked = nextChecked;
          }
          return;
        }
        if(el.type === 'radio'){
          const shouldCheck = value === el.value;
          if(el.checked !== shouldCheck){
            el.checked = shouldCheck;
          }
          return;
        }
        const nextValue = value == null ? '' : String(value);
        if(el.value !== nextValue){
          el.value = nextValue;
        }
      });
    } finally {
      applying = false;
      updateDirty();
    }
  }

  function refreshSavedState(){
    savedState = serializeState();
    setDirty(false);
  }

  function isFocusableCandidate(el){
    if(!el || typeof el.focus !== 'function'){ return false; }
    if('disabled' in el && el.disabled){ return false; }
    if(el.classList && el.classList.contains('primary-action')){ return false; }
    return true;
  }

  function findFocusTarget(){
    if(isFocusableCandidate(promptOpener) && promptOpener.isConnected){
      return promptOpener;
    }
    const roots = [];
    if(pendingCloseTarget && typeof pendingCloseTarget.querySelector === 'function'){
      roots.push(pendingCloseTarget);
    }
    if(panel && typeof panel.querySelector === 'function' && !roots.includes(panel)){
      roots.push(panel);
    }
    for(const root of roots){
      const closeButton = root.querySelector('.close-panel');
      if(isFocusableCandidate(closeButton)){
        return closeButton;
      }
      const discardButtonCandidate = root.querySelector('.discard-changes');
      if(isFocusableCandidate(discardButtonCandidate)){
        return discardButtonCandidate;
      }
      const fallback = root.querySelector('button:not([disabled]):not(.primary-action), [href], input:not([disabled]):not([type="hidden"]), select:not([disabled]), textarea:not([disabled]), [tabindex]:not([tabindex="-1"])');
      if(isFocusableCandidate(fallback)){
        return fallback;
      }
    }
    return null;
  }

  function closePrompt(){
    if(prompt){
      const active = document.activeElement;
      if(active && prompt.contains(active)){
        const focusTarget = findFocusTarget();
        if(!focusTarget && panel){
          const previousTabIndex = panel.getAttribute('tabindex');
          panel.setAttribute('tabindex','-1');
          panel.focus({ preventScroll: true });
          if(previousTabIndex === null){
            panel.removeAttribute('tabindex');
          } else {
            panel.setAttribute('tabindex', previousTabIndex);
          }
        } else if(focusTarget){
          focusTarget.focus({ preventScroll: true });
        }
      }
      prompt.classList.remove('show');
      prompt.setAttribute('aria-hidden','true');
      prompt.setAttribute('inert','');
      promptOpener = null;
    }
  }

  function cancelPrompt(){
    pendingCloseTarget = null;
    closePrompt();
  }

  function openPrompt(target){
    pendingCloseTarget = target || panel;
    promptOpener = document.activeElement && document.activeElement !== document.body ? document.activeElement : null;
    if(prompt){
      prompt.classList.add('show');
      prompt.setAttribute('aria-hidden','false');
      prompt.removeAttribute('inert');
      setTimeout(()=>{
        if(promptCancelButton && !promptCancelButton.disabled){
          promptCancelButton.focus();
        } else if(promptSaveButton && !promptSaveButton.disabled){
          promptSaveButton.focus();
        }
      }, 0);
    }
  }

  async function handleSave({ closeAfter } = {}){
    refreshSavedState();
    await showStatus('msg_admin_saved');
    if(closeAfter){
      const target = pendingCloseTarget;
      pendingCloseTarget = null;
      closePrompt();
      if(target) closePanel(target);
    } else {
      pendingCloseTarget = null;
    }
  }

  function notifyDiscard(detail = {}){
    try{
      document.dispatchEvent(new CustomEvent('member-panel:discarded', { detail }));
    }catch(err){
      console.error('Failed to dispatch member discard event', err);
    }
  }

  async function discardChanges({ closeAfter } = {}){
    if(form && typeof form.reset === 'function'){
      applying = true;
      try{
        form.reset();
      } finally {
        applying = false;
      }
    }
    applyState(savedState);
    setDirty(false);
    await showStatus('msg_admin_discarded');
    notifyDiscard({ closeAfter: !!closeAfter });
    if(closeAfter){
      const target = pendingCloseTarget;
      pendingCloseTarget = null;
      closePrompt();
      if(target) closePanel(target);
    } else {
      pendingCloseTarget = null;
      closePrompt();
    }
  }

  function formChanged(){
    if(applying) return;
    updateDirty();
  }

  function attachListeners(){
    if(initialized) return;
    ensureElements();
    if(!panel || !form) return;
    
// === Added Confirm Password Field ===
(function ensureConfirmPasswordField(){
  const registerPanel = document.getElementById('memberRegisterPanel');
  if(!registerPanel) return;
  const pwd = registerPanel.querySelector('input[type="password"]');
  if(!pwd) return;
  if(registerPanel.querySelector('#memberRegisterPasswordConfirm')) return;
  const confirm = document.createElement('input');
  confirm.type = 'password';
  confirm.id = 'memberRegisterPasswordConfirm';
  confirm.placeholder = 'Confirm Password';
  if(pwd.className) confirm.className = pwd.className;
  confirm.required = true;
  pwd.insertAdjacentElement('afterend', confirm);
})();
// === End Added Confirm Password Field ===

// Filter out auth inputs from triggering dirty state
function formChangedWrapper(event){
  if(event && event.target){
    const target = event.target;
    // Ignore all interactions inside sandbox (form preview)
    if(target.closest('[data-sandbox="true"]')) return;
    const isAuthInput = target.closest('.member-auth-panel') || 
                       target.id === 'memberLoginEmail' || 
                       target.id === 'memberLoginPassword' ||
                       target.id === 'memberRegisterName' ||
                       target.id === 'memberRegisterEmail' ||
                       target.id === 'memberRegisterPassword' ||
                       target.id === 'memberRegisterPasswordConfirm' ||
                       target.id === 'memberRegisterAvatar';
    if(isAuthInput) return;
    // Exclude venue field inputs - they should not trigger form change
    const isVenueField = target.closest('.venue-session-editor') || 
                        target.closest('.venue-card') ||
                        target.closest('.venue-session-venues') ||
                        target.closest('.mapboxgl-ctrl-geocoder') ||
                        target.closest('.google-places-geocoder');
    if(isVenueField) return;
  }
  formChanged();
}

form.addEventListener('input', formChangedWrapper, true);
    form.addEventListener('change', formChangedWrapper, true);
    if(saveButton){
      saveButton.addEventListener('click', e=>{
        e.preventDefault();
        pendingCloseTarget = null;
        handleSave({ closeAfter:false });
      });
    }
    if(discardButton){
      discardButton.addEventListener('click', e=>{
        e.preventDefault();
        pendingCloseTarget = null;
        discardChanges({ closeAfter:false });
      });
    }
    if(promptCancelButton){
      promptCancelButton.addEventListener('click', e=>{
        e.preventDefault();
        cancelPrompt();
      });
    }
    if(promptSaveButton){
      promptSaveButton.addEventListener('click', e=>{
        e.preventDefault();
        handleSave({ closeAfter:true });
      });
    }
    if(promptDiscardButton){
      promptDiscardButton.addEventListener('click', e=>{
        e.preventDefault();
        discardChanges({ closeAfter:true });
      });
    }
    if(prompt){
      if(promptKeydownTarget && promptKeydownTarget !== prompt && promptKeydownListener){
        promptKeydownTarget.removeEventListener('keydown', promptKeydownListener);
      }
      if(!promptKeydownListener){
        promptKeydownListener = event => handlePromptKeydown(event, {
          prompt,
          cancelButton: promptCancelButton,
          cancelPrompt
        });
      }
      promptKeydownTarget = prompt;
      prompt.addEventListener('keydown', promptKeydownListener);
      prompt.addEventListener('click', e=>{
        if(e.target === prompt) cancelPrompt();
      });
    }
    initialized = true;
    refreshSavedState();
  }

  ensureElements();
  attachListeners();
  document.addEventListener('DOMContentLoaded', () => {
    setTimeout(()=>{
      ensureElements();
      attachListeners();
      const draft = loadDraft();
      if(draft){ applyState(draft); }
      refreshSavedState();
    }, 0);
  });

  function isPromptOpen(){
    return !!(prompt && prompt.classList.contains('show'));
  }

  return {
    handlePanelClose(_panelEl){ return false; },
    handleEscape(_panelEl){ return false; }
  };
})();

// Extracted from <script>
(function(){
  const SAVE_ENDPOINT = '/gateway.php?action=save-form';
  const JSON_HEADERS = { 'Content-Type': 'application/json' };
  const STATUS_TIMER_KEY = '__adminStatusMessageTimer';
  const ERROR_CLASS = 'error';
  const ERROR_TIMEOUT = 5000;

  function showErrorBanner(message){
    const banner = document.getElementById('adminStatusMessage');
    if(!banner) return;
    const text = typeof message === 'string' && message.trim() ? message.trim() : 'Failed to save changes.';
    banner.textContent = text;
    banner.setAttribute('aria-hidden', 'false');
    banner.classList.add('show');
    banner.classList.add(ERROR_CLASS);
    if(window[STATUS_TIMER_KEY]){
      clearTimeout(window[STATUS_TIMER_KEY]);
    }
    window[STATUS_TIMER_KEY] = setTimeout(()=>{
      banner.classList.remove('show');
      banner.classList.remove(ERROR_CLASS);
      banner.setAttribute('aria-hidden', 'true');
      window[STATUS_TIMER_KEY] = null;
    }, ERROR_TIMEOUT);
  }

  async function saveAdminChanges(){
    // SAFEGUARD: Prevent saving if admin settings haven't fully loaded yet
    // This prevents wiping database fields with empty values due to timing issues
    if(!window._adminSettingsLoaded){
      console.error('[Admin Save] BLOCKED - Settings not yet loaded. Refusing to save to prevent data loss.');
      return;
    }
    
    // Collect modified admin messages
    const modifiedMessages = [];
    document.querySelectorAll('.message-text-input').forEach(textarea => {
      // Skip fieldset tooltip inputs (they have data-fieldset-id, not data-message-id)
      if(textarea.dataset.fieldsetId) return;
      if(textarea.value !== textarea.dataset.originalValue){
        modifiedMessages.push({
          id: parseInt(textarea.dataset.messageId),
          message_text: textarea.value
        });
      }
    });
    
    // Collect modified fieldset tooltips
    const modifiedFieldsetTooltips = [];
    document.querySelectorAll('.message-text-input[data-fieldset-id]').forEach(textarea => {
      if(textarea.value !== textarea.dataset.originalValue){
        modifiedFieldsetTooltips.push({
          id: parseInt(textarea.dataset.fieldsetId),
          fieldset_tooltip: textarea.value.trim()
        });
      }
    });
    
    // Collect general website settings
    const websiteSettings = {};
    
    const websiteNameInput = document.getElementById('adminWebsiteName');
    if(websiteNameInput){
      websiteSettings.site_name = websiteNameInput.value.trim();
    }
    
    const websiteTaglineInput = document.getElementById('adminWebsiteTagline');
    if(websiteTaglineInput){
      websiteSettings.site_tagline = websiteTaglineInput.value.trim();
    }
    
    const websiteCurrencyInput = document.getElementById('adminWebsiteCurrency');
    if(websiteCurrencyInput){
      websiteSettings.site_currency = (websiteCurrencyInput.dataset.value || websiteCurrencyInput.value || '').trim();
    }
    
    const contactEmailInput = document.getElementById('adminContactEmail');
    if(contactEmailInput){
      websiteSettings.contact_email = contactEmailInput.value.trim();
    }
    
    const supportEmailInput = document.getElementById('adminSupportEmail');
    if(supportEmailInput){
      websiteSettings.support_email = supportEmailInput.value.trim();
    }
    
    const maintenanceModeCheckbox = document.getElementById('adminMaintenanceMode');
    if(maintenanceModeCheckbox){
      websiteSettings.maintenance_mode = maintenanceModeCheckbox.checked;
    }
    
    const welcomeEnabledCheckbox = document.getElementById('adminWelcomeEnabled');
    if(welcomeEnabledCheckbox){
      websiteSettings.welcome_enabled = welcomeEnabledCheckbox.checked;
    }
    
    // Collect checkout options from UI
    const checkoutOptions = getCheckoutOptionsFromUI();
    // Debug: Log collected checkout options
    if(checkoutOptions.length > 0){
      console.log('[SaveAdminChanges] Collected checkout options:', checkoutOptions);
    }
    // Always include checkout options if they exist (even if empty array, to handle deletions)
    websiteSettings.checkout_options = checkoutOptions;
    
    // Save messages and fieldset tooltips separately to admin-settings endpoint (not formbuilder)
    if(modifiedMessages.length > 0 || modifiedFieldsetTooltips.length > 0){
      try {
        const savePayload = {};
        if(modifiedMessages.length > 0){
          savePayload.messages = modifiedMessages;
        }
        if(modifiedFieldsetTooltips.length > 0){
          savePayload.fieldset_tooltips = modifiedFieldsetTooltips;
        }
        
        const messageResponse = await fetch('/gateway.php?action=save-admin-settings', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(savePayload)
        });
        
        if(!messageResponse.ok){
          console.error('Failed to save messages/tooltips - HTTP status:', messageResponse.status);
        } else {
          const messageResult = await messageResponse.json();
          if(!messageResult.success){
            console.error('Failed to save messages/tooltips:', messageResult.message || 'Unknown error');
          } else {
            if(modifiedMessages.length > 0){
              console.log(`Messages saved successfully (${messageResult.messages_updated || 0} updated)`);
            }
            if(modifiedFieldsetTooltips.length > 0){
              console.log(`Fieldset tooltips saved successfully (${messageResult.fieldset_tooltips_updated || 0} updated)`);
            }
            
            // Invalidate message cache so new messages are fetched
            if(typeof invalidateMessagesCache === 'function'){
              invalidateMessagesCache();
            }
            
            // Update originalValue for all successfully saved messages
            modifiedMessages.forEach(savedMessage => {
              const textArea = document.querySelector(`.message-text-input[data-message-id="${savedMessage.id}"]`);
              if(textArea){
                // Update the originalValue to the current value (now saved)
                textArea.dataset.originalValue = textArea.value;
                
                // Update the display
                const messageItem = textArea.closest('.message-item');
                if(messageItem){
                  const messageTextDisplay = messageItem.querySelector('.message-text-display');
                  if(messageTextDisplay){
                    messageTextDisplay.innerHTML = textArea.value;
                  }
                  
                  // Remove modified class since it's now saved
                  messageItem.classList.remove('modified');
                }
              }
            });
            
            // Update originalValue for all successfully saved fieldset tooltips
            modifiedFieldsetTooltips.forEach(savedTooltip => {
              const textArea = document.querySelector(`.message-text-input[data-fieldset-id="${savedTooltip.id}"]`);
              if(textArea){
                // Update the originalValue to the current value (now saved)
                textArea.dataset.originalValue = textArea.value;
                
                // Update the display
                const tooltipItem = textArea.closest('.message-item');
                if(tooltipItem){
                  const tooltipDisplay = tooltipItem.querySelector('.message-text-display');
                  if(tooltipDisplay){
                    tooltipDisplay.textContent = textArea.value || '(empty)';
                    if(!textArea.value){
                      tooltipDisplay.style.color = 'var(--text-muted, #888)';
                      tooltipDisplay.style.fontStyle = 'italic';
                    } else {
                      tooltipDisplay.style.color = '';
                      tooltipDisplay.style.fontStyle = '';
                    }
                  }
                  
                  // Remove modified class since it's now saved
                  tooltipItem.classList.remove('modified');
                }
              }
            });
          }
        }
      } catch(err) {
        console.error('Failed to save messages/tooltips:', err);
      }
    }
    
    // Save general settings to database if any exist
    if(Object.keys(websiteSettings).length > 0){
      try {
        const response = await fetch('/gateway.php?action=save-admin-settings', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(websiteSettings)
        });
        
        if(!response.ok){
          console.error('Failed to save website settings - HTTP status:', response.status);
        } else {
          const result = await response.json();
          if(!result.success){
            console.error('Failed to save website settings:', result.message || 'Unknown error');
          } else {
            console.log('Website settings saved successfully');
          }
        }
      } catch(err) {
        console.error('Failed to save website settings:', err);
      }
    }
    
    // Collect form data (separate from messages and settings)
    let payload = null;
    if(window.formbuilderStateManager){
      // Ensure formbuilder data is loaded before capturing
      if(!window.formbuilderStateManager._loaded && typeof window.formbuilderStateManager.ensureLoaded === 'function'){
        await window.formbuilderStateManager.ensureLoaded();
      }
      if(typeof window.formbuilderStateManager.capture === 'function'){
        try {
          payload = window.formbuilderStateManager.capture();
          // DEBUG: Log captured payload to verify customPlaceholder/customTooltip
          console.log('[SaveAdminChanges] Captured payload categories:', payload?.categories?.map(c => ({
            name: c.name,
            subFields: Object.fromEntries(Object.entries(c.subFields || {}).map(([sub, fields]) => [
              sub,
              fields.map(f => ({ name: f.name, customPlaceholder: f.customPlaceholder, customTooltip: f.customTooltip }))
            ]))
          })));
        } catch (err) {
          console.error('formbuilderStateManager.capture failed', err);
        }
      }
    }
    if(!payload || typeof payload !== 'object'){
      payload = {};
    }

    // Only save form data if there's actual form data (not just empty object)
    let response;
    try {
      // Only send form data if there's something to save
      if(Object.keys(payload).length > 0){
        response = await fetch(SAVE_ENDPOINT, {
          method: 'POST',
          headers: JSON_HEADERS,
          credentials: 'same-origin',
          body: JSON.stringify(payload)
        });
      } else {
        // No form data to save, create a successful response object
        response = {
          ok: true,
          text: async () => JSON.stringify({ success: true })
        };
      }
    } catch (networkError) {
      const errorMsg = await getMessage('msg_admin_save_error_network', {}, true) || 'Unable to reach the server. Please try again.';
      showErrorBanner(errorMsg);
      throw networkError;
    }

    const responseText = await response.text();
    let data = {};
    if(responseText){
      try {
        data = JSON.parse(responseText);
      } catch (parseError) {
        console.error('[SaveAdminChanges] JSON parse error:', parseError, 'Response text:', responseText);
        const errorMsg = await getMessage('msg_admin_save_error_response', {}, true) || 'Unexpected response while saving changes.';
        showErrorBanner(errorMsg);
        const error = new Error('Invalid JSON response');
        error.responseText = responseText;
        throw error;
      }
    }

    if(!response.ok || typeof data !== 'object' || data === null || data.success !== true){
      console.error('[SaveAdminChanges] Save failed:', { responseOk: response.ok, data });
      const message = data && typeof data.message === 'string' && data.message.trim()
        ? data.message.trim()
        : `Failed to save changes${response.ok ? '' : ` (HTTP ${response.status})`}.`;
      showErrorBanner(message);
      const error = new Error(message);
      error.response = response;
      error.payload = data;
      throw error;
    }

    if(Array.isArray(data.new_category_ids) && data.new_category_ids.length){
      let idIndex = 0;
      categories.forEach(cat => {
        if(cat && (cat.id === null || cat.id === undefined)){
          if(idIndex < data.new_category_ids.length){
            cat.id = data.new_category_ids[idIndex];
            idIndex++;
          }
        }
      });
    }

    if(Array.isArray(data.new_subcategory_ids) && data.new_subcategory_ids.length){
      let idIndex = 0;
      categories.forEach(cat => {
        if(!cat || !Array.isArray(cat.subs)) return;
        cat.subs.forEach((subName, subIdx) => {
          const subId = cat.subIds && cat.subIds[subName];
          if(subId === null || subId === undefined){
            if(idIndex < data.new_subcategory_ids.length){
              if(!cat.subIds) cat.subIds = {};
              cat.subIds[subName] = data.new_subcategory_ids[idIndex];
              idIndex++;
            }
          }
        });
      });
    }

    if(window.formbuilderStateManager && typeof window.formbuilderStateManager.save === 'function'){
      try{
        window.formbuilderStateManager.save();
      }catch(err){
        console.error('Failed to update saved formbuilder state after ID assignment', err);
      }
    }

    // Update original values for messages after successful save
    if(modifiedMessages.length > 0){
      document.querySelectorAll('.message-text-input').forEach(textarea => {
        textarea.dataset.originalValue = textarea.value;
        const messageItem = textarea.closest('.message-item');
        if(messageItem){
          messageItem.classList.remove('modified');
        }
      });
    }

    return data;
  }

  window.saveAdminChanges = saveAdminChanges;
})();

const adminPanelChangeManager = (()=>{
  let panel = null;
  let form = null;
  let saveButton = null;
  let discardButton = null;
  let prompt = null;
  let promptCancelButton = null;
  let promptSaveButton = null;
  let promptDiscardButton = null;
  let promptKeydownListener = null;
  let promptKeydownTarget = null;
  let promptOpener = null;
  let statusMessage = null;
  let dirty = false;
  let formbuilderDirty = false; // Separate tracking for formbuilder changes
  let savedState = {};
  let applying = false;
  let statusTimer = null;
  let initialized = false;
  let pendingCloseTarget = null;

  function ensureElements(){
    panel = document.getElementById('adminPanel');
    form = panel ? panel.querySelector('.panel-body') : null;
    if(panel){
      saveButton = panel.querySelector('.save-changes');
      discardButton = panel.querySelector('.discard-changes');
    }
    prompt = document.getElementById('adminUnsavedPrompt');
    if(prompt){
      promptCancelButton = prompt.querySelector('.confirm-cancel');
      promptSaveButton = prompt.querySelector('.confirm-save');
      promptDiscardButton = prompt.querySelector('.confirm-discard');
    } else {
      promptCancelButton = null;
      promptSaveButton = null;
      promptDiscardButton = null;
    }
    statusMessage = document.getElementById('adminStatusMessage');
  }

  function trigger(el, type){
    el.dispatchEvent(new Event(type, { bubbles: true }));
  }

  function serializeState(){
    if(!form) return {};
    const data = {};
    const elements = form.querySelectorAll('input, select, textarea');
    elements.forEach(el => {
      if(!el) return;
      // Exclude formbuilder inputs - their state is tracked separately via formbuilderStateManager
      if(el.closest('#formbuilderCats')) return;
      const key = el.name || el.id;
      if(!key) return;
      if(el.type === 'file') return;
      if(el.tagName === 'SELECT' && el.multiple){
        data[key] = Array.from(el.options || []).filter(opt => opt.selected).map(opt => opt.value);
        return;
      }
      if(el.type === 'checkbox'){
        data[key] = el.checked;
        return;
      }
      if(el.type === 'radio'){
        if(!(key in data)) data[key] = null;
        if(el.checked) data[key] = el.value;
        return;
      }
      data[key] = el.value;
    });
    form.querySelectorAll('[contenteditable][id]').forEach(el => {
      if(el.closest('#formbuilderCats')) return;
      data[el.id] = el.innerHTML;
    });
    
    // Include checkout options in state for comparison
    // Normalize to ensure consistent format (sort by id, normalize all values)
    const checkoutOptions = getCheckoutOptionsFromUI();
    const normalized = checkoutOptions.map(opt => ({
      id: opt.id,
      checkout_title: String(opt.checkout_title || ''),
      checkout_description: String(opt.checkout_description || ''),
      checkout_flagfall_price: Math.round((parseFloat(opt.checkout_flagfall_price) || 0) * 100) / 100,
      checkout_basic_day_rate: opt.checkout_basic_day_rate !== null && opt.checkout_basic_day_rate !== undefined ? Math.round((parseFloat(opt.checkout_basic_day_rate) || 0) * 100) / 100 : null,
      checkout_discount_day_rate: opt.checkout_discount_day_rate !== null && opt.checkout_discount_day_rate !== undefined ? Math.round((parseFloat(opt.checkout_discount_day_rate) || 0) * 100) / 100 : null,
      checkout_featured: opt.checkout_featured === 1 || opt.checkout_featured === true ? 1 : 0,
      checkout_sidebar_ad: opt.checkout_sidebar_ad === 1 || opt.checkout_sidebar_ad === true ? 1 : 0,
      is_active: opt.is_active === 1 || opt.is_active === true ? 1 : 0
    })).sort((a, b) => {
      // Sort by id for consistent comparison
      const aId = typeof a.id === 'string' && a.id.startsWith('new-') ? 999999 : parseInt(a.id) || 0;
      const bId = typeof b.id === 'string' && b.id.startsWith('new-') ? 999999 : parseInt(b.id) || 0;
      return aId - bId;
    });
    data['__checkout_options__'] = JSON.stringify(normalized);
    
    return data;
  }

  function applyState(state){
    if(!form || !state) return;
    applying = true;
    try{
      const elements = form.querySelectorAll('input, select, textarea');
      elements.forEach(el => {
        if(!el) return;
        const key = el.name || el.id;
        if(!key || !(key in state)) return;
        if(el.type === 'file') return;
        if(el.tagName === 'SELECT' && el.multiple){
          const values = Array.isArray(state[key]) ? state[key].map(String) : [];
          let changed = false;
          Array.from(el.options || []).forEach(opt => {
            const shouldSelect = values.includes(opt.value);
            if(opt.selected !== shouldSelect){
              opt.selected = shouldSelect;
              changed = true;
            }
          });
          if(changed) trigger(el, 'change');
          return;
        }
        if(el.type === 'checkbox'){
          const shouldCheck = !!state[key];
          if(el.checked !== shouldCheck){
            el.checked = shouldCheck;
            trigger(el, 'change');
          }
          return;
        }
        if(el.type === 'radio'){
          const shouldCheck = state[key] === el.value;
          if(el.checked !== shouldCheck){
            el.checked = shouldCheck;
            if(shouldCheck) trigger(el, 'change');
          }
          return;
        }
        const nextValue = state[key] === null || state[key] === undefined ? '' : String(state[key]);
        if(el.value !== nextValue){
          el.value = nextValue;
          trigger(el, 'input');
          trigger(el, 'change');
        }
      });
      form.querySelectorAll('[contenteditable][id]').forEach(el => {
        if(!(el.id in state)) return;
        const html = state[el.id] ?? '';
        if(el.innerHTML !== html){
          el.innerHTML = html;
          trigger(el, 'input');
          trigger(el, 'change');
        }
      });
    } finally {
      applying = false;
    }
  }

  function setDirty(value){
    dirty = !!value;
    if(panel){
      panel.classList.toggle('has-unsaved', dirty);
      panel.setAttribute('data-unsaved', dirty ? 'true' : 'false');
    }
    if(saveButton){
      saveButton.disabled = !dirty;
    }
    if(discardButton){
      discardButton.disabled = !dirty;
    }
    if(promptDiscardButton){
      promptDiscardButton.disabled = !dirty;
    }
  }

  function stateEquals(a, b){
    const keys = new Set([
      ...Object.keys(a || {}),
      ...Object.keys(b || {})
    ]);
    for(const key of keys){
      const aVal = a[key];
      const bVal = b[key];
      // Handle arrays (for multi-select)
      if(Array.isArray(aVal) && Array.isArray(bVal)){
        if(aVal.length !== bVal.length) return false;
        for(let i = 0; i < aVal.length; i++){
          if(aVal[i] !== bVal[i]) return false;
        }
        continue;
      }
      if(Array.isArray(aVal) || Array.isArray(bVal)) return false;
      if(aVal !== bVal) return false;
    }
    return true;
  }

  function updateDirty(){
    if(applying) return;
    // Don't mark as dirty until saved state is initialized
    if(!savedStateInitialized) return;
    ensureElements();
    const current = serializeState();
    const formDirty = !stateEquals(current, savedState);
    // Combine form state dirty with formbuilder dirty
    setDirty(formDirty || formbuilderDirty);
  }

  function refreshSavedState({ skipManagerSave } = {}){
    if(!form) return;
    savedState = serializeState();
    formbuilderDirty = false; // Clear formbuilder dirty state on save
    if(!skipManagerSave && window.formbuilderStateManager && typeof window.formbuilderStateManager.save === 'function'){
      window.formbuilderStateManager.save();
    }
    setDirty(false);
  }

  let savedStateInitializationPromise = null;
  let savedStateInitialized = false;

  async function initializeSavedState(){
    if(savedStateInitialized) return Promise.resolve();
    if(savedStateInitializationPromise) return savedStateInitializationPromise;
    let formWasFound = false;
    savedStateInitializationPromise = (async ()=>{
      if(typeof window === 'undefined') return;
      ensureElements();
      formWasFound = !!form;
      const manager = window.formbuilderStateManager;
      let snapshot = null;
      // NO FALLBACKS - only use backend snapshot
      const fetchSnapshot = typeof window.fetchSavedFormbuilderSnapshot === 'function'
        ? window.fetchSavedFormbuilderSnapshot
        : null;
      if(!fetchSnapshot){
        throw new Error('Formbuilder snapshot fetch function not available');
      }
      try{
        snapshot = await fetchSnapshot();
        if(!snapshot || typeof snapshot !== 'object'){
          throw new Error('Invalid formbuilder snapshot received from server');
        }
      }catch(err){
        console.error('Failed to fetch admin formbuilder snapshot from server:', err);
        throw err; // Don't fall back to localStorage
      }
      if(manager && typeof manager.restore === 'function' && snapshot){
        try{
          manager.restore(snapshot);
        }catch(err){
          console.error('Failed to hydrate admin formbuilder snapshot:', err);
          throw err; // Don't silently fail
        }
      }
      refreshSavedState({ skipManagerSave: true });
      if(manager && typeof manager.save === 'function'){
        try{
          manager.save();
        }catch(err){
          console.warn('Failed to persist hydrated admin formbuilder snapshot', err);
        }
      }
    })()
    .catch(err => {
      console.warn('Failed to initialize admin saved state', err);
    })
    .finally(()=>{
      savedStateInitializationPromise = null;
      if(formWasFound){
        savedStateInitialized = true;
      }
    });
    return savedStateInitializationPromise;
  }

  function showStatus(message){
    if(!statusMessage) statusMessage = document.getElementById('adminStatusMessage');
    if(!statusMessage) return;
    statusMessage.textContent = message;
    statusMessage.setAttribute('aria-hidden','false');
    statusMessage.classList.remove('error');
    if(window.__adminStatusMessageTimer){
      clearTimeout(window.__adminStatusMessageTimer);
      window.__adminStatusMessageTimer = null;
    }
    statusMessage.classList.add('show');
    clearTimeout(statusTimer);
    statusTimer = setTimeout(()=>{
      statusMessage.classList.remove('show');
      statusMessage.setAttribute('aria-hidden','true');
    }, 2000);
  }

  function isFocusableCandidate(el){
    if(!el || typeof el.focus !== 'function'){ return false; }
    if('disabled' in el && el.disabled){ return false; }
    if(el.classList && el.classList.contains('primary-action')){ return false; }
    return true;
  }

  function findFocusTarget(){
    if(isFocusableCandidate(promptOpener) && promptOpener.isConnected){
      return promptOpener;
    }
    const roots = [];
    if(pendingCloseTarget && typeof pendingCloseTarget.querySelector === 'function'){
      roots.push(pendingCloseTarget);
    }
    if(panel && typeof panel.querySelector === 'function' && !roots.includes(panel)){
      roots.push(panel);
    }
    for(const root of roots){
      const closeButton = root.querySelector('.close-panel');
      if(isFocusableCandidate(closeButton)){
        return closeButton;
      }
      const discardButtonCandidate = root.querySelector('.discard-changes');
      if(isFocusableCandidate(discardButtonCandidate)){
        return discardButtonCandidate;
      }
      const fallback = root.querySelector('button:not([disabled]):not(.primary-action), [href], input:not([disabled]):not([type="hidden"]), select:not([disabled]), textarea:not([disabled]), [tabindex]:not([tabindex="-1"])');
      if(isFocusableCandidate(fallback)){
        return fallback;
      }
    }
    return null;
  }

  function closePrompt(){
    if(prompt){
      const active = document.activeElement;
      if(active && prompt.contains(active)){
        const focusTarget = findFocusTarget();
        if(!focusTarget && panel){
          const previousTabIndex = panel.getAttribute('tabindex');
          panel.setAttribute('tabindex','-1');
          panel.focus({ preventScroll: true });
          if(previousTabIndex === null){
            panel.removeAttribute('tabindex');
          } else {
            panel.setAttribute('tabindex', previousTabIndex);
          }
        } else if(focusTarget){
          focusTarget.focus({ preventScroll: true });
        }
      }
      prompt.classList.remove('show');
      prompt.setAttribute('aria-hidden','true');
      prompt.setAttribute('inert','');
      promptOpener = null;
    }
  }

  function cancelPrompt(){
    pendingCloseTarget = null;
    closePrompt();
  }

  function openPrompt(target){
    pendingCloseTarget = target;
    promptOpener = document.activeElement && document.activeElement !== document.body ? document.activeElement : null;
    if(prompt){
      prompt.classList.add('show');
      prompt.setAttribute('aria-hidden','false');
      prompt.removeAttribute('inert');
      setTimeout(()=>{
        if(promptCancelButton && !promptCancelButton.disabled){
          promptCancelButton.focus();
        } else if(promptSaveButton && !promptSaveButton.disabled){
          promptSaveButton.focus();
        }
      }, 0);
    }
  }

  async function runSave({ closeAfter } = {}){
    ensureElements();
    let result = null;
    try{
      if(typeof window.saveAdminChanges === 'function'){
        result = window.saveAdminChanges();
      }
      // Map settings (spin controls) auto-save on change, no need to save here
    }catch(err){
      const message = err && typeof err.message === 'string' ? err.message : '';
      if(message && message.toLowerCase().includes('database connection not configured')){
        console.warn('Skipped saving admin changes because the database connection is not configured.');
      } else {
        console.error('Failed to save admin changes', err);
      }
      if(!closeAfter) cancelPrompt();
      return;
    }
    Promise.resolve(result).then(()=>{
      refreshSavedState();
      showStatus('Saved');
      const panelToClose = closeAfter ? pendingCloseTarget : null;
      if(closeAfter) pendingCloseTarget = null;
      closePrompt();
      if(panelToClose) closePanel(panelToClose);
    }).catch(err => {
      const message = err && typeof err.message === 'string' ? err.message : '';
      if(message && message.toLowerCase().includes('database connection not configured')){
        console.warn('Skipped saving admin changes because the database connection is not configured.');
      } else {
        console.error('Failed to save admin changes', err);
      }
    });
  }

  function notifyDiscard(detail = {}){
    try{
      document.dispatchEvent(new CustomEvent('admin-panel:discarded', { detail }));
    }catch(err){
      console.error('Failed to dispatch admin discard event', err);
    }
  }

  function discardChanges({ closeAfter } = {}){
    if(form && typeof form.reset === 'function'){
      applying = true;
      try{
        form.reset();
      } finally {
        applying = false;
      }
    }
    // Don't re-render formbuilder - keep edit panels open, just restore data values
    // Formbuilder auto-saves on each action anyway
    // Reset admin messages to original values
    document.querySelectorAll('.message-text-input').forEach(textarea => {
      // Skip fieldset tooltip inputs (they have data-fieldset-id, not data-message-id)
      if(textarea.dataset.fieldsetId){
        textarea.value = textarea.dataset.originalValue;
        const tooltipItem = textarea.closest('.message-item');
        if(tooltipItem){
          tooltipItem.classList.remove('modified');
          const tooltipDisplay = tooltipItem.querySelector('.message-text-display');
          if(tooltipDisplay){
            tooltipDisplay.textContent = textarea.dataset.originalValue || '(empty)';
            if(!textarea.dataset.originalValue){
              tooltipDisplay.style.color = 'var(--text-muted, #888)';
              tooltipDisplay.style.fontStyle = 'italic';
            } else {
              tooltipDisplay.style.color = '';
              tooltipDisplay.style.fontStyle = '';
            }
          }
        }
        return;
      }
      textarea.value = textarea.dataset.originalValue;
      const messageItem = textarea.closest('.message-item');
      if(messageItem){
        messageItem.classList.remove('modified');
      }
      const textPreview = messageItem?.querySelector('.message-text-preview');
      if(textPreview){
        textPreview.textContent = textarea.dataset.originalValue;
      }
    });
    if(savedState) applyState(savedState);
    formbuilderDirty = false; // Clear formbuilder dirty state on discard
    setDirty(false);
    showStatus('Changes Discarded');
    notifyDiscard({ closeAfter: !!closeAfter });
    const panelToClose = closeAfter ? pendingCloseTarget : null;
    pendingCloseTarget = null;
    closePrompt();
    if(panelToClose) closePanel(panelToClose);
  }

  function formChanged(){
    if(applying) return;
    updateDirty();
  }

  function attachListeners(){
    if(initialized) return;
    ensureElements();
    if(!panel || !form) return;
    
    // Filter out auth inputs from triggering dirty state (adminPanel version)
    function formChangedWrapper(event){
      if(event && event.target){
        const target = event.target;
        // Ignore all interactions inside sandbox (form preview)
        if(target.closest('[data-sandbox="true"]')) return;
        const isAuthInput = target.closest('.member-auth-panel') || 
                           target.id === 'memberLoginEmail' || 
                           target.id === 'memberLoginPassword' ||
                           target.id === 'memberRegisterName' ||
                           target.id === 'memberRegisterEmail' ||
                           target.id === 'memberRegisterPassword' ||
                           target.id === 'memberRegisterPasswordConfirm' ||
                           target.id === 'memberRegisterAvatar';
        if(isAuthInput) return;
        // Exclude venue field inputs - they should not trigger form change
        const isVenueField = target.closest('.venue-session-editor') || 
                            target.closest('.venue-card') ||
                            target.closest('.venue-session-venues') ||
                            target.closest('.mapboxgl-ctrl-geocoder') ||
                            target.closest('.google-places-geocoder');
        if(isVenueField) return;
      }
      formChanged();
    }
    
    form.addEventListener('input', formChangedWrapper, true);
    form.addEventListener('change', formChangedWrapper, true);
    if(saveButton){
      saveButton.addEventListener('click', e=>{
        e.preventDefault();
        pendingCloseTarget = null;
        runSave({ closeAfter:false });
      });
    }
    if(discardButton){
      discardButton.addEventListener('click', e=>{
        e.preventDefault();
        discardChanges({ closeAfter:false });
      });
    }
    if(promptCancelButton){
      promptCancelButton.addEventListener('click', e=>{
        e.preventDefault();
        cancelPrompt();
      });
    }
    if(promptSaveButton){
      promptSaveButton.addEventListener('click', e=>{
        e.preventDefault();
        runSave({ closeAfter:true });
      });
    }
    if(promptDiscardButton){
      promptDiscardButton.addEventListener('click', e=>{
        e.preventDefault();
        discardChanges({ closeAfter:true });
      });
    }
    if(prompt){
      if(promptKeydownTarget && promptKeydownTarget !== prompt && promptKeydownListener){
        promptKeydownTarget.removeEventListener('keydown', promptKeydownListener);
      }
      if(!promptKeydownListener){
        promptKeydownListener = event => handlePromptKeydown(event, {
          prompt,
          cancelButton: promptCancelButton,
          cancelPrompt
        });
      }
      promptKeydownTarget = prompt;
      prompt.addEventListener('keydown', promptKeydownListener);
      prompt.addEventListener('click', e=>{
        if(e.target === prompt) cancelPrompt();
      });
    }
    initialized = true;
  }

  ensureElements();
  attachListeners();
  // Initialize saved state immediately for Settings tab dirty tracking (no formbuilder wait)
  // Formbuilder data loads lazily when Forms tab is opened
  if(form){
    savedState = serializeState();
    savedStateInitialized = true;
  }
  document.addEventListener('DOMContentLoaded', () => {
    setTimeout(()=>{
      ensureElements();
      attachListeners();
      // Initialize saved state if not already done
      if(!savedStateInitialized && form){
        savedState = serializeState();
        savedStateInitialized = true;
      }
    }, 0);
  });

  function isPromptOpen(){
    return !!(prompt && prompt.classList.contains('show'));
  }

  return {
    hasUnsaved(){
      return !!dirty;
    },
    handlePanelClose(panelEl){
      if(!panel || panelEl !== panel) return false;
      if(isPromptOpen()) return true;
      if(dirty){
        openPrompt(panelEl);
        return true;
      }
      return false;
    },
    handleEscape(panelEl){
      if(isPromptOpen()){
        cancelPrompt();
        return true;
      }
      if(panel && panelEl === panel && dirty){
        openPrompt(panelEl);
        return true;
      }
      return false;
    },
    markSaved(message){
      ensureElements();
      refreshSavedState();
      if(message) showStatus(message);
    },
    markDirty(){
      ensureElements();
      formbuilderDirty = true; // Track formbuilder changes separately
      setDirty(true);
    },
    runSave
  };
})();
window.adminPanelModule = adminPanelChangeManager;

function closePanel(m){
  const btnId = panelButtons[m && m.id];
  if(btnId){
    const btn = document.getElementById(btnId);
    btn && btn.setAttribute('aria-pressed','false');
  }
  const content = m.querySelector('.panel-content') || m.querySelector('.modal-content');
  const active = document.activeElement;
  if(active && m.contains(active)) active.blur();
  if(m.id === 'welcome-modal'){
    const mc = document.querySelector('.map-controls-map');
    if(mc) mc.style.display = '';
    // Note: We don't set welcome-seen flag anymore - welcome can always be shown via logo click or page refresh
  }
  m.setAttribute('inert','');
  if(content && content.dataset.side){
    content.classList.remove('panel-visible');
    content.addEventListener('transitionend', function handler(){
      content.removeEventListener('transitionend', handler);
      m.classList.remove('show');
      m.setAttribute('aria-hidden','true');
      localStorage.setItem(`panel-open-${m.id}`,'false');
      const idx = panelStack.indexOf(m);
      if(idx!==-1) panelStack.splice(idx,1);
      updateHeaderButtonStates();
      if(map && typeof map.resize === 'function') setTimeout(()=> map.resize(),0);
      if(typeof window.adjustBoards === 'function') setTimeout(()=> window.adjustBoards(), 0);
    }, {once:true});
  } else {
    m.classList.remove('show');
    m.setAttribute('aria-hidden','true');
    localStorage.setItem(`panel-open-${m.id}`,'false');
    const idx = panelStack.indexOf(m);
    if(idx!==-1) panelStack.splice(idx,1);
    updateHeaderButtonStates();
    if(map && typeof map.resize === 'function') setTimeout(()=> map.resize(),0);
    if(typeof window.adjustBoards === 'function') setTimeout(()=> window.adjustBoards(), 0);
  }
  if(typeof window.updateHeaderMapControls === 'function') window.updateHeaderMapControls();
}

const adminAuthManager = (()=>{
  const STORAGE_KEY = 'admin-authenticated';
  const IDENTITY_KEY = 'admin-identity';
  const adminPanel = document.getElementById('adminPanel');
  const memberPanel = document.getElementById('memberPanel');

  // Validate admin-authenticated against actual stored user to prevent flash
  let authenticated = false;
  if(localStorage.getItem(STORAGE_KEY) === 'true'){
    try {
      const storedUser = JSON.parse(localStorage.getItem('member-auth-current') || 'null');
      authenticated = storedUser && storedUser.isAdmin === true;
    } catch(e) {
      authenticated = false;
    }
  }
  let adminIdentity = authenticated ? (localStorage.getItem(IDENTITY_KEY) || '') : '';

  function updateUI(){
    // Re-fetch adminBtn each time to avoid stale reference
    const adminBtn = document.getElementById('adminBtn');
    if(adminBtn){
      // Only show admin button when authenticated as admin
      if(authenticated){
        adminBtn.hidden = false;
        adminBtn.style.display = 'flex';
        adminBtn.setAttribute('aria-hidden', 'false');
      } else {
        adminBtn.hidden = true;
        adminBtn.style.display = 'none';
        adminBtn.setAttribute('aria-hidden', 'true');
      }
    }
  }

  function setAuthenticatedState(value, identity){
    const next = !!value;
    if(next === authenticated){
      updateUI();
      return;
    }
    authenticated = next;
    localStorage.setItem(STORAGE_KEY, authenticated ? 'true' : 'false');
    if(authenticated){
      const normalizedIdentity = typeof identity === 'string' ? identity.trim() : '';
      adminIdentity = normalizedIdentity || adminIdentity;
      if(adminIdentity){
        localStorage.setItem(IDENTITY_KEY, adminIdentity);
      }
    } else {
      adminIdentity = '';
      localStorage.removeItem(IDENTITY_KEY);
    }
    updateUI();
    if(!authenticated){
      localStorage.setItem('panel-open-adminPanel','false');
      if(adminPanel && adminPanel.classList.contains('show')){
        closePanel(adminPanel);
      }
    }
  }

  function ensureAuthenticated(){
    if(authenticated) return true;
    if(memberPanel && !memberPanel.classList.contains('show')){
      openPanel(memberPanel);
    }
    const memberBtn = document.getElementById('memberBtn');
    if(memberBtn){
      memberBtn.focus();
    }
    return false;
  }

  updateUI();
  if(!authenticated){
    localStorage.setItem('panel-open-adminPanel','false');
    if(adminPanel && adminPanel.classList.contains('show')){
      closePanel(adminPanel);
    }
  }

  return {
    isAuthenticated(){
      return authenticated;
    },
    ensureAuthenticated,
    setAuthenticated(value, identity){
      setAuthenticatedState(value, identity);
    },
    getAdminUser(){
      const identifier = adminIdentity || localStorage.getItem(IDENTITY_KEY) || 'admin';
      const trimmed = identifier.trim();
      const emailNormalized = trimmed ? trimmed.toLowerCase() : 'admin';
      return {
        name: 'Administrator',
        email: trimmed || 'admin',
        emailNormalized,
        username: trimmed || 'admin',
        avatar: '',
        isAdmin: true
      };
    }
  };
})();
window.adminAuthManager = adminAuthManager;

const welcomeModalEl = document.getElementById('welcome-modal');
if(welcomeModalEl){
  const welcomeControls = welcomeModalEl.querySelector('.map-controls-welcome');
  welcomeModalEl.addEventListener('click', e => {
    if(welcomeControls && welcomeControls.contains(e.target)) return;
    closePanel(welcomeModalEl);
  });
  const welcomeContent = welcomeModalEl.querySelector('.modal-content');
  if(welcomeContent){
    welcomeContent.addEventListener('click', e => {
      if(welcomeControls && welcomeControls.contains(e.target)) return;
      closePanel(welcomeModalEl);
    });
  }
}

function requestClosePanel(m){
  if(m){
    if(m.id === 'adminPanel' && adminPanelChangeManager.handlePanelClose(m)){
      return;
    }
    if(m.id === 'memberPanel' && memberPanelChangeManager.handlePanelClose(m)){
      return;
    }
  }
  closePanel(m);
}
function togglePanel(m){
  if(m.classList.contains('show')){
    requestClosePanel(m);
  } else {
    openPanel(m);
  }
}
function showPanel(m){
  if(!m.classList.contains('show')){
    openPanel(m);
  } else {
    bringToTop(m);
  }
}
function movePanelToEdge(panel, side){
  if(!panel) return;
  const content = panel.querySelector('.panel-content') || panel.querySelector('.modal-content');
  if(!content) return;
  const header = document.querySelector('.container--header');
  const topPos = header ? header.getBoundingClientRect().bottom : 0;
  content.style.top = `${topPos}px`;
  if(side === 'left'){
    content.dataset.side='left';
    content.style.left = '0';
    content.style.right = 'auto';
    schedulePanelEntrance(content, true);
  } else {
    content.dataset.side='right';
    content.style.left = 'auto';
    content.style.right = '0';
    schedulePanelEntrance(content, true);
  }
}
function repositionPanels(){
  ['adminPanel','memberPanel','filterPanel'].forEach(id=>{
    const panel = document.getElementById(id);
    if(panel && panel.classList.contains('show')){
      const content = panel.querySelector('.panel-content');
      if(!content) return;
      const w = content.style.width;
      const h = content.style.height;
      openPanel(panel);
      content.style.width = w;
      content.style.height = h;
    }
  });
}
function handleEsc(){
  const top = panelStack[panelStack.length-1];
  if(!top){
    const {container} = ensureImageModalReady();
    if(container && !container.classList.contains('hidden')){
      closeImageModal(container);
    }
    return;
  }
  if(top instanceof Element){
    if(top.id === 'adminPanel' && adminPanelChangeManager.handleEscape(top)){
      return;
    }
    if(top.id === 'memberPanel' && memberPanelChangeManager.handleEscape(top)){
      return;
    }
    if(top.id === 'post-modal-container'){
      closePostModal();
    } else {
      requestClosePanel(top);
    }
  } else if(typeof top.remove==='function'){
    panelStack.pop();
    top.remove();
  }
}
document.addEventListener('keydown', e=>{
  if(e.key==='Escape') handleEsc();
});

let pointerStartedInFilterContent = false;

function handleDocInteract(e){
  if(e.target.closest('.image-modal-container')) return;
  if(logoEls.some(el => el.contains(e.target))) return;
  if(e.target.closest('#filterBtn')) return;
  const welcome = document.getElementById('welcome-modal');
  if(welcome && welcome.classList.contains('show')){
    const controls = welcome.querySelector('.map-controls-welcome');
    if(!controls || !controls.contains(e.target)){
      closePanel(welcome);
    }
  }
  const filterPanel = document.getElementById('filterPanel');
  const fromPointerDown = !!e.__fromPointerDown;
  if(filterPanel && filterPanel.classList.contains('show')){
    const content = filterPanel.querySelector('.panel-content');
    const pinBtn = filterPanel.querySelector('.pin-panel');
    const pinned = pinBtn && pinBtn.getAttribute('aria-pressed')==='true';
    const startedInside = pointerStartedInFilterContent;
    if(content && !content.contains(e.target) && !pinned){
      if(startedInside && !fromPointerDown){
        pointerStartedInFilterContent = false;
        return;
      }
      closePanel(filterPanel);
      pointerStartedInFilterContent = false;
      return;
    }
    if(!fromPointerDown){
      pointerStartedInFilterContent = false;
    }
  } else if(!fromPointerDown){
    pointerStartedInFilterContent = false;
  }
}

document.addEventListener('click', handleDocInteract);
document.addEventListener('pointerdown', (e) => {
  const target = e.target;
  const filterPanel = document.getElementById('filterPanel');
  const content = filterPanel ? filterPanel.querySelector('.panel-content') : null;
  pointerStartedInFilterContent = !!(filterPanel && filterPanel.classList.contains('show') && content && content.contains(target));
  requestAnimationFrame(() => handleDocInteract({ target, __fromPointerDown: true }));
});

// Panels and admin/member interactions
(function(){
  const memberBtn = document.getElementById('memberBtn');
  const adminBtn = document.getElementById('adminBtn');
  const filterBtn = document.getElementById('filterBtn');
  const memberPanel = document.getElementById('memberPanel');
  const adminPanel = document.getElementById('adminPanel');
  const filterPanel = document.getElementById('filterPanel');

  if(memberBtn && memberPanel){
    memberBtn.addEventListener('click', ()=> showPanel(memberPanel));
  }
  if(adminBtn && adminPanel){
    adminBtn.addEventListener('click', ()=> showPanel(adminPanel));
  }
  filterBtn && filterBtn.addEventListener('click', ()=> {
    closeWelcomeModalIfOpen();
    togglePanel(filterPanel);
  });
  document.querySelectorAll('.panel .close-panel').forEach(btn=>{
    btn.addEventListener('click', ()=>{
      const panel = btn.closest('.panel');
      requestClosePanel(panel);
    });
  });
  document.querySelectorAll('.panel .move-left').forEach(btn=>{
    btn.addEventListener('click', e=>{
      e.stopPropagation();
      const panel = btn.closest('.panel');
      movePanelToEdge(panel, 'left');
    });
  });
  document.querySelectorAll('.panel .move-right').forEach(btn=>{
    btn.addEventListener('click', e=>{
      e.stopPropagation();
      const panel = btn.closest('.panel');
      movePanelToEdge(panel, 'right');
    });
  });

  document.querySelectorAll('#filterPanel .pin-panel').forEach(btn=>{
    btn.addEventListener('click', e=>{
      e.stopPropagation();
      const pressed = btn.getAttribute('aria-pressed')==='true';
      btn.setAttribute('aria-pressed', pressed ? 'false' : 'true');
      if(typeof window.adjustBoards === 'function') setTimeout(()=> window.adjustBoards(), 0);
    });
  });

  document.querySelectorAll('.panel .panel-header').forEach(header=>{
    header.addEventListener('mousedown', e=>{
      if(e.target.closest('button')) return;
      const panel = header.closest('.panel');
      const content = panel ? panel.querySelector('.panel-content') : null;
      if(!content) return;
      bringToTop(panel);
      const rect = content.getBoundingClientRect();
      const startX = e.clientX;
      const startLeft = rect.left;
      const onMove = (ev)=>{
        const dx = ev.clientX - startX;
        let newLeft = startLeft + dx;
        const maxLeft = window.innerWidth - rect.width;
        if(newLeft < 0) newLeft = 0;
        if(newLeft > maxLeft) newLeft = maxLeft;
        content.style.left = `${newLeft}px`;
        content.style.right = 'auto';
      };
      const throttledMove = rafThrottle(onMove);
      function onUp(){
        document.removeEventListener('mousemove', throttledMove);
        document.removeEventListener('mouseup', onUp);
      }
      document.addEventListener('mousemove', throttledMove);
      document.addEventListener('mouseup', onUp);
    });
  });

    const welcomeModal = document.getElementById('welcome-modal');
    const panelsToRestore = [memberPanel, adminPanel, welcomeModal];
    panelsToRestore.forEach(m=>{
      if(!m) return;
      if(m.id === 'adminPanel' && window.adminAuthManager && !window.adminAuthManager.isAuthenticated()){
        localStorage.setItem(`panel-open-${m.id}`,'false');
        return;
      }
      if(localStorage.getItem(`panel-open-${m.id}`) === 'true'){
        openPanel(m);
      }
    });
    // Welcome modal will be shown after settings load (see loadAdminSettings function)
    // This ensures it always respects the database setting, even after localStorage is cleared
    const shouldOpenFilter = window.innerWidth >= 1300 && localStorage.getItem('panel-open-filterPanel') === 'true';
    if(filterPanel && shouldOpenFilter){
      openPanel(filterPanel);
    }
  document.querySelectorAll('.panel').forEach(panel=>{
    const content = panel.querySelector('.panel-content');
    if(content){
      const defaultWidth = panel.id === 'filterPanel' ? '380px' : '440px';
      content.style.width = defaultWidth;
      content.style.maxWidth = defaultWidth;
      content.style.top = 'calc(var(--header-h) + var(--safe-top))';
      content.style.bottom = 'var(--footer-h)';
      content.style.height = 'calc(100vh - var(--header-h) - var(--safe-top) - var(--footer-h))';
      content.style.maxHeight = 'calc(100vh - var(--header-h) - var(--safe-top) - var(--footer-h))';
    }
  });

  const adminTabs = document.querySelectorAll('#adminPanel .tab-bar button');
  const adminPanels = document.querySelectorAll('#adminPanel .tab-panel');
  adminTabs.forEach(btn=>{
    btn.addEventListener('click', ()=>{
      adminTabs.forEach(b=>b.setAttribute('aria-selected','false'));
      adminPanels.forEach(p=>p.classList.remove('active'));
      btn.setAttribute('aria-selected','true');
      const panel = document.getElementById(`tab-${btn.dataset.tab}`);
      panel && panel.classList.add('active');
      // LAZY LOAD: Load formbuilder UI when admin opens Forms tab (only when tab is clicked, not on startup)
      // Tab opens immediately, content loads asynchronously
      if(btn.dataset.tab === 'forms' && window.formbuilderStateManager){
        // Open tab first, then load content asynchronously
        setTimeout(() => {
          // Load full formbuilder UI (renderFormbuilderCats) which was skipped on startup
          window.formbuilderStateManager.ensureLoaded({ skipFormbuilderUI: false });
        }, 0);
      }
      // Reload fieldset tooltips when messages tab is opened (data already loaded when admin panel opened)
      if(btn.dataset.tab === 'messages' && typeof loadFieldsetTooltips === 'function'){
        loadFieldsetTooltips();
      }
    });
  });

  const memberTabs = document.querySelectorAll('#memberPanel .tab-bar .tab-btn');
  const memberPanels = document.querySelectorAll('#memberPanel .member-tab-panel');
  memberTabs.forEach(btn=>{
    btn.addEventListener('click', ()=>{
      memberTabs.forEach(b=>b.setAttribute('aria-selected','false'));
      memberPanels.forEach(p=>{
        p.classList.remove('active');
        p.setAttribute('hidden','');
      });
      btn.setAttribute('aria-selected','true');
      const panel = document.getElementById(`memberTab-${btn.dataset.tab}`);
      if(panel){
        panel.classList.add('active');
        panel.removeAttribute('hidden');
      }
      // LAZY LOAD: Load formbuilder when member opens Create Post tab
      // Tab opens immediately, content loads asynchronously
      if(btn.dataset.tab === 'create'){
        // Open tab first, then load content asynchronously
        if(typeof window.initializeMemberFormbuilderSnapshot === 'function'){
          // Use setTimeout to ensure tab opens first, then load content
          setTimeout(() => {
            window.initializeMemberFormbuilderSnapshot();
          }, 0);
        } else {
          console.error('initializeMemberFormbuilderSnapshot not available - forms.js may not be loaded');
        }
      }
    });
  });

  const adminPaypalClientId = document.getElementById('adminPaypalClientId');
  const adminPaypalClientSecret = document.getElementById('adminPaypalClientSecret');

  // Form code has been moved to forms.js
  // The member form initialization is now handled in that separate file

  const colorAreas = [
    {key:'header', label:'Header', selectors:{bg:['.container--header'], text:['.container--header']}},
    {key:'body', label:'Body', selectors:{bg:['body'], border:[], hoverBorder:[], activeBorder:[]}},
    {key:'list', label:'List', selectors:{bg:['.quick-list-board'], text:['.quick-list-board'], title:['.quick-list-board .recents-card .t','.quick-list-board .recents-card .title'], btn:['.quick-list-board button','.quick-list-board .sq','.quick-list-board .tiny','.quick-list-board .btn'], btnText:['.quick-list-board button','.quick-list-board .sq','.quick-list-board .tiny','.quick-list-board .btn'], card:['.quick-list-board .recents-card']}},
    {key:'post-board', label:'Closed Posts', selectors:{bg:['.post-board'], text:['.post-board','.post-board .posts'], title:['.post-board .post-card .t','.post-board .post-card .title','.post-board .open-post .t','.post-board .open-post .title'], btn:['.post-board button'], btnText:['.post-board button'], card:['.post-board .post-card','.post-board .open-post']}},
    {key:'open-post', label:'Open Posts', selectors:{text:['.open-post','.open-post .venue-info','.open-post .session-info'], title:['.open-post .t','.open-post .title'], btn:['.open-post button'], btnText:['.open-post button'], card:['.open-post'], header:['.open-post .post-card'], image:['.open-post .image-box'], menu:['.open-post .venue-menu button','.open-post .session-menu button']}},
    {key:'map', label:'Map', selectors:{popupBg:[], popupText:[], title:[]}},
    {key:'filter', label:'Filter Panel', selectors:{bg:['#filterPanel .panel-content'], text:['#filterPanel .panel-content'], title:['#filterPanel .panel-content .t','#filterPanel .panel-content .title'], btn:['#filterPanel button:not([class*="mapboxgl-"])','#filterPanel .sq','#filterPanel .tiny'], btnText:['#filterPanel button:not([class*="mapboxgl-"])','#filterPanel .sq','#filterPanel .tiny']}},
    {key:'calendar', label:'Calendar', selectors:{bg:['.calendar'], text:['.calendar .day'], weekday:['.calendar .weekday'], title:['.calendar .calendar-header'], header:['.calendar .calendar-header']}},
  {key:'adminPanel', label:'Admin Panel', selectors:{bg:['#adminPanel .panel-content'], text:['#adminPanel .panel-content'], title:['#adminPanel .panel-content .t','#adminPanel .panel-content .title'], btn:['#adminPanel button','#adminPanel #spinType span'], btnText:['#adminPanel button','#adminPanel #spinType span']}},
  {key:'welcome-modal', label:'Welcome Modal', selectors:{bg:['#welcome-modal .modal-content'], text:['#welcome-modal .modal-content'], title:['#welcome-modal .modal-content .t','#welcome-modal .modal-content .title'], btn:['#welcome-modal button:not([class*"mapboxgl-"])'], btnText:['#welcome-modal button:not([class*"mapboxgl-"])']}},
  {key:'memberPanel', label:'Member Panel', selectors:{bg:['#memberPanel .panel-content'], text:['#memberPanel .panel-content'], title:['#memberPanel .panel-content .t','#memberPanel .panel-content .title'], btn:['#memberPanel button'], btnText:['#memberPanel button']}},
  {key:'imagePanel', label:'Image Modal', selectors:{bg:['.image-modal-container'], text:['.image-modal-container .image-modal']}}
];

  function storeTitleDefaults(){
    colorAreas.forEach(area=>{
      (area.selectors.title||[]).forEach(sel=>{
        document.querySelectorAll(sel).forEach(el=>{
          const cs = getComputedStyle(el);
          el.dataset.titleDefaultColor = cs.color;
          el.dataset.titleDefaultFont = cs.fontFamily;
          el.dataset.titleDefaultSize = cs.fontSize;
          el.dataset.titleDefaultWeight = cs.fontWeight;
          el.dataset.titleDefaultShadow = cs.textShadow;
        });
      });
    });
    const varMap = {'today-c':'--today', 'sessionAvailable-c':'--session-available', 'sessionSelected-c':'--session-selected'};
    Object.entries(varMap).forEach(([id,varName])=>{
      const el = document.getElementById(id);
      if(el){
        const val = getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
        if(val) el.value = val;
      }
    });
  }

  function restoreTitleDefaults(area){
    (area.selectors.title||[]).forEach(sel=>{
      document.querySelectorAll(sel).forEach(el=>{
        if(el.dataset.titleDefaultColor) el.style.color = el.dataset.titleDefaultColor;
        if(el.dataset.titleDefaultFont) el.style.fontFamily = el.dataset.titleDefaultFont;
        if(el.dataset.titleDefaultSize) el.style.fontSize = el.dataset.titleDefaultSize;
        if(el.dataset.titleDefaultWeight) el.style.fontWeight = el.dataset.titleDefaultWeight;
        if(el.dataset.titleDefaultShadow) el.style.textShadow = el.dataset.titleDefaultShadow;
      });
    });
  }

  storeTitleDefaults();

  const headerEl = document.querySelector('.container--header');
  if(headerEl && 'ResizeObserver' in window){
    const headerObserver = new ResizeObserver(()=>{
      updateLayoutVars();
    });
    headerObserver.observe(headerEl);
  }

  window.addEventListener('resize', updateLayoutVars);
  window.addEventListener('resize', updateStickyImages);
  window.addEventListener('load', updateLayoutVars);
  updateLayoutVars();
  if (typeof updateStickyImages === 'function') {
    updateStickyImages();
  }
  if(typeof window.__wrapForInputYield === 'function'){
    ['openPost','updateVenue','togglePanel','ensureMapForVenue'].forEach(name => window.__wrapForInputYield(name));
  }
})();

// Extracted from <script>
document.addEventListener('DOMContentLoaded', () => {
  document.querySelectorAll('#adminPanel input[type="checkbox"]').forEach(cb => {
    if (cb.closest('.switch')) return;
    if (cb.closest('.subcategory-form-toggle')) return;
    const wrapper = document.createElement('label');
    wrapper.className = 'switch';
    cb.parentNode.insertBefore(wrapper, cb);
    wrapper.appendChild(cb);
    const slider = document.createElement('span');
    slider.className = 'slider';
    cb.after(slider);
  });
});

// Extracted from <script>
document.addEventListener('DOMContentLoaded', () => {
  const opacityInput = document.getElementById('postModeBgOpacity');
  const opacityVal = document.getElementById('postModeBgOpacityVal');
  const root = document.documentElement;

  function apply(){
    if(!opacityInput || !opacityVal) return;
    
    const opacity = opacityInput.value;
    const shadowMode = window._mapShadowMode || 'post_mode_only';
    const isPostMode = document.body.classList.contains('mode-posts');
    
    // Only apply shadow if mode is 'always' or if mode is 'post_mode_only' and we're in post mode
    const shouldShowShadow = shadowMode === 'always' || (shadowMode === 'post_mode_only' && isPostMode);
    const finalOpacity = shouldShowShadow ? opacity : 0;
    
    // Show/hide the shadow element based on mode
    const shadowElement = document.querySelector('.post-mode-background');
    if(shadowElement){
      if(shadowMode === 'always'){
        shadowElement.style.display = 'block';
      } else if(shadowMode === 'post_mode_only'){
        // Let CSS handle it (it shows in .mode-posts via CSS rule)
        shadowElement.style.display = '';
      } else {
        shadowElement.style.display = 'none';
      }
    }
    
    root.style.setProperty('--post-mode-bg-color', '0,0,0'); // Always black
    root.style.setProperty('--post-mode-bg-opacity', finalOpacity);
    opacityVal.textContent = Number(opacity).toFixed(2);
  }
  
  // Make apply function globally accessible
  window.applyMapShadow = apply;
  
  // Auto-save function for map shadow
  async function autoSaveMapShadow(){
    const shadowValue = parseFloat(opacityInput.value);
    if(isNaN(shadowValue)) {
      console.error('Invalid shadow value:', opacityInput.value);
      return;
    }
    window._mapShadow = shadowValue;
    try {
      const response = await fetch('/gateway.php?action=save-admin-settings', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ map_shadow: shadowValue })
      });
      if(!response.ok){
        console.error('Failed to save map shadow: HTTP', response.status, response.statusText);
        const text = await response.text();
        console.error('Response:', text);
      } else {
        const result = await response.json();
        if(result && result.success !== false){
          console.log('Map shadow saved successfully:', shadowValue, result);
          if(result.settings_saved !== undefined){
            console.log('Settings saved count:', result.settings_saved);
          }
        } else {
          console.error('Failed to save map shadow:', result);
        }
      }
    } catch (e) {
      console.error('Failed to save map shadow:', e);
    }
  }

  // Auto-save function for map shadow mode
  async function autoSaveMapShadowMode(modeValue){
    window._mapShadowMode = modeValue;
    try {
      const response = await fetch('/gateway.php?action=save-admin-settings', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ map_shadow_mode: modeValue })
      });
      if(!response.ok){
        console.error('Failed to save map shadow mode: HTTP', response.status, response.statusText);
        const text = await response.text();
        console.error('Response:', text);
      } else {
        const result = await response.json();
        if(result && result.success !== false){
          console.log('Map shadow mode saved successfully:', modeValue, result);
          if(result.settings_saved !== undefined){
            console.log('Settings saved count:', result.settings_saved);
          }
        } else {
          console.error('Failed to save map shadow mode:', result);
        }
      }
    } catch (e) {
      console.error('Failed to save map shadow mode:', e);
    }
  }

  if(opacityInput && opacityVal){
    // Load from memory (which is populated from database on page load)
    const savedValue = window._mapShadow;
    if(savedValue !== undefined && savedValue !== null){
      opacityInput.value = savedValue;
    } else {
      opacityInput.value = 0;
    }
    
    // Ensure shadow mode is set in memory
    if(!window._mapShadowMode){
      window._mapShadowMode = 'post_mode_only';
    }
    
    // Apply immediately
    apply();
    
    // Also re-apply after a short delay to catch any async settings loading
    setTimeout(() => {
      const updatedValue = window._mapShadow;
      if(updatedValue !== undefined && updatedValue !== null && String(updatedValue) !== opacityInput.value){
        opacityInput.value = updatedValue;
      }
      apply();
    }, 500);
    
    // Update display and shadow in real-time on slider input
    opacityInput.addEventListener('input', () => {
      apply(); // Update shadow in real-time
      opacityVal.textContent = parseFloat(opacityInput.value).toFixed(2);
    });
    
    // Auto-save on slider change
    opacityInput.addEventListener('change', () => {
      apply();
      autoSaveMapShadow();
    });
    
    // Make value display editable on click
    if(!opacityVal.dataset.editableAdded){
      opacityVal.dataset.editableAdded = 'true';
      opacityVal.style.cursor = 'pointer';
      
      opacityVal.addEventListener('click', ()=>{
        const currentValue = opacityVal.textContent;
        const input = document.createElement('input');
        input.type = 'number';
        input.value = currentValue;
        input.min = 0;
        input.max = 1;
        input.step = 0.01;
        input.className = 'slider-value-input';
        input.style.width = '60px';
        input.style.textAlign = 'center';
        input.style.fontSize = '16px';
        input.style.fontWeight = 'bold';
        input.style.background = 'rgba(0,0,0,0.5)';
        input.style.color = '#fff';
        input.style.border = '1px solid #2e3a72';
        input.style.borderRadius = '4px';
        input.style.padding = '2px';
        
        const commitValue = ()=>{
          let newValue = parseFloat(input.value);
          if(isNaN(newValue)) newValue = parseFloat(currentValue);
          newValue = Math.max(0, Math.min(1, newValue));
          const formattedValue = newValue.toFixed(2);
          opacityVal.textContent = formattedValue;
          opacityVal.style.display = '';
          input.remove();
          opacityInput.value = newValue;
          apply();
          autoSaveMapShadow();
        };
        
        input.addEventListener('blur', commitValue);
        input.addEventListener('keydown', (e)=>{
          if(e.key === 'Enter'){
            e.preventDefault();
            commitValue();
          } else if(e.key === 'Escape'){
            opacityVal.style.display = '';
            input.remove();
          }
        });
        
        opacityVal.style.display = 'none';
        opacityVal.parentNode.insertBefore(input, opacityVal);
        input.focus();
        input.select();
      });
    }
  }

  // Add event listeners for map shadow mode radio buttons
  const postOnlyRadio = document.getElementById('mapShadowModePostOnly');
  const alwaysRadio = document.getElementById('mapShadowModeAlways');
  if(postOnlyRadio && alwaysRadio){
    // Set initial state from memory
    const savedMode = window._mapShadowMode || 'post_mode_only';
    if(savedMode === 'always'){
      alwaysRadio.checked = true;
    } else {
      postOnlyRadio.checked = true;
    }
    
    postOnlyRadio.addEventListener('change', () => {
      if(postOnlyRadio.checked){
        autoSaveMapShadowMode('post_mode_only');
        apply(); // Update shadow immediately when mode changes
      }
    });
    alwaysRadio.addEventListener('change', () => {
      if(alwaysRadio.checked){
        autoSaveMapShadowMode('always');
        apply(); // Update shadow immediately when mode changes
      }
    });
  }
  
  // Watch for mode changes to update shadow visibility (when body class changes)
  if(opacityInput && opacityVal){
    const observer = new MutationObserver(() => {
      apply();
    });
    observer.observe(document.body, {
      attributes: true,
      attributeFilter: ['class']
    });
  }
});

// Extracted from <script>
document.addEventListener('DOMContentLoaded', () => {
  const vp = document.getElementById('viewport');
  const updateViewport = () => {
    if (!vp) return;
    if (window.innerWidth < 650) {
      vp.setAttribute('content','width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no');
    } else {
      vp.setAttribute('content','width=device-width, initial-scale=1');
    }
  };
  updateViewport();
  window.addEventListener('resize', updateViewport);
  window.addEventListener('orientationchange', updateViewport);

  const fsBtn = document.getElementById('fullscreenBtn');
  if (fsBtn) {
    const docEl = document.documentElement;
    const canFS = docEl.requestFullscreen || docEl.webkitRequestFullscreen || docEl.mozRequestFullScreen || docEl.msRequestFullscreen;
    const enabled = document.fullscreenEnabled || document.webkitFullscreenEnabled || document.mozFullScreenEnabled || document.msFullscreenEnabled;
    if (!canFS || enabled === false) {
      fsBtn.style.display = 'none';
    } else {
      const getFull = () => document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement;
      const updateFsState = () => {
        const isFull = getFull();
        fsBtn.setAttribute('aria-pressed', isFull ? 'true' : 'false');
        fsBtn.classList.toggle('is-fullscreen', !!isFull);
      };
      updateFsState();
      ['fullscreenchange','webkitfullscreenchange','mozfullscreenchange','MSFullscreenChange'].forEach(evt => {
        document.addEventListener(evt, updateFsState);
      });
      fsBtn.addEventListener('click', () => {
        const isFull = getFull();
        if (!isFull) {
          const req = docEl.requestFullscreen || docEl.webkitRequestFullscreen || docEl.mozRequestFullScreen || docEl.msRequestFullscreen;
          if (req) {
            try {
              const result = req.call(docEl);
              if (result && typeof result.catch === 'function') result.catch(() => {});
            } catch (err) {
              updateFsState();
            }
          }
        } else {
          const exit = document.exitFullscreen || document.webkitExitFullscreen || document.mozCancelFullScreen || document.msExitFullscreen;
          if (exit) {
            try {
              const result = exit.call(document);
              if (result && typeof result.catch === 'function') result.catch(() => {});
            } catch (err) {
              updateFsState();
            }
          }
        }
      });
    }
  }

  if (window.innerWidth >= 650) return;

  const posts = document.querySelector('.post-board');
  if (!posts) return;

  let defaultSize = parseFloat(getComputedStyle(posts).fontSize);
  let startDist = null;
  let enlarged = false;

  function distance(t1, t2){
    return Math.hypot(t1.clientX - t2.clientX, t1.clientY - t2.clientY);
  }

  posts.addEventListener('touchstart', e => {
    if (e.target.tagName === 'IMG') return;
    if (e.touches.length === 2) {
      startDist = distance(e.touches[0], e.touches[1]);
    }
  });

  posts.addEventListener('touchmove', e => {
    if (e.target.tagName === 'IMG') return;
    if (e.touches.length === 2 && startDist) {
      const scale = distance(e.touches[0], e.touches[1]) / startDist;
      if (!enlarged && scale > 1.2) {
        posts.style.fontSize = (defaultSize * 1.2) + 'px';
        enlarged = true;
      } else if (enlarged && scale < 0.8) {
        posts.style.fontSize = defaultSize + 'px';
        enlarged = false;
      }
      e.preventDefault();
    }
  }, { passive: false });

  posts.addEventListener('touchend', e => {
    if (e.touches.length < 2) startDist = null;
  });

  posts.querySelectorAll('img').forEach(img => {
    img.addEventListener('click', e => { e.stopPropagation(); openImageModal(img.src, {origin: img}); });
    img.addEventListener('touchstart', e => {
      if (e.touches.length === 2) {
        e.preventDefault();
        e.stopPropagation();
        openImageModal(img.src, {origin: img});
      }
    }, { passive: false });
  });
});


// Extracted from <script>
document.addEventListener('DOMContentLoaded', () => {
  document.addEventListener('wheel', e => {
    if(e.target.closest('.post-board, .panel-content, .options-menu, .calendar-scroll')){
      e.stopPropagation();
    }
  });
  const postsPanel = document.querySelector('.post-board');
  const postsBg = document.querySelector('.post-mode-background');
  if(postsPanel){
    postsPanel.addEventListener('click', e => {
      if(e.target === postsPanel || e.target.classList.contains('posts')){
        e.stopPropagation();
      }
    });
  }
  if(postsBg){
    postsBg.addEventListener('click', e => e.stopPropagation());
  }
});

// Extracted from <script>
let boardAdjustCleanup = null;

function ensureImageModalReady(){
  const container = document.querySelector('.image-modal-container');
  if(!container) return {container:null, modal:null};
  const modal = container.querySelector('.image-modal');
  if(!container._listenerAdded){
    container.addEventListener('click', e => {
      if(e.target === container){
        closeImageModal(container);
      }
    });
    container._listenerAdded = true;
  }
  if(modal && !modal._closeListenerAdded){
    modal.addEventListener('click', e => {
      if(!e.target.closest('img')){
        closeImageModal(container);
      }
    });
    modal._closeListenerAdded = true;
  }
  return {container, modal};
}

function closeImageModal(container){
  const target = container || ensureImageModalReady().container;
  if(!target) return;
  const modal = target.querySelector('.image-modal');
  if(modal) modal.innerHTML = '';
  target.classList.add('hidden');
  if(target.dataset){
    delete target.dataset.activeSrc;
    delete target.dataset.activeIndex;
  }
  target._imageModalState = null;
  target._imageModalImg = null;
}

function advanceImageModal(container, modal, step=1){
  if(!container || !modal) return;
  const state = container._imageModalState;
  if(!state || !Array.isArray(state.images) || state.images.length <= 1) return;
  const len = state.images.length;
  state.index = ((state.index + step) % len + len) % len;
  renderImageModalImage(container, modal);
}

function renderImageModalImage(container, modal){
  if(!container || !modal) return;
  const state = container._imageModalState;
  if(!state || !Array.isArray(state.images) || !state.images.length) return;
  let img = container._imageModalImg;
  if(!img || img.parentNode !== modal){
    modal.innerHTML = '';
    img = document.createElement('img');
    img.addEventListener('click', e => {
      e.stopPropagation();
      advanceImageModal(container, modal, 1);
    });
    container._imageModalImg = img;
    modal.appendChild(img);
  }
  const src = state.images[state.index];
  if(img.getAttribute('src') !== src){
    img.src = src;
  }
  if(container.dataset){
    container.dataset.activeSrc = src;
    container.dataset.activeIndex = String(state.index);
  }
}

function normalizeImageModalSrc(value){
  if(!value) return '';
  try {
    return new URL(value, window.location.href).href;
  } catch(err){
    return String(value);
  }
}

function resolveImageModalContext(config){
  const result = {images: [], index: 0, gallery: null};
  if(!config) return result;
  const src = typeof config.src === 'string' ? config.src : '';
  const providedImages = Array.isArray(config.images) ? config.images.filter(Boolean) : null;
  const originEl = config.origin instanceof Element ? config.origin : null;
  let galleryRoot = config.gallery instanceof Element ? config.gallery : null;
  const findGalleryFrom = el => {
    if(!el) return null;
    const fromImageBox = el.closest && el.closest('.image-box');
    if(fromImageBox) return fromImageBox;
    const postImages = el.closest && el.closest('.post-images');
    if(postImages){
      const box = postImages.querySelector('.image-box');
      if(box) return box;
    }
    const openPost = el.closest && el.closest('.open-post');
    if(openPost){
      const box = openPost.querySelector('.image-box');
      if(box) return box;
    }
    return null;
  };
  if(!galleryRoot && originEl){
    galleryRoot = findGalleryFrom(originEl);
  }
  let images = providedImages && providedImages.length ? providedImages.slice() : null;
  if((!images || !images.length) && galleryRoot){
    if(Array.isArray(galleryRoot._modalImages) && galleryRoot._modalImages.length){
      images = galleryRoot._modalImages.slice();
    } else if(galleryRoot.dataset && galleryRoot.dataset.modalImages){
      try {
        const parsed = JSON.parse(galleryRoot.dataset.modalImages);
        if(Array.isArray(parsed) && parsed.length){
          images = parsed.slice();
        }
      } catch(err){}
    }
  }
  if((!images || !images.length) && galleryRoot){
    const trackImgs = Array.from(galleryRoot.querySelectorAll('.image-track img'));
    if(trackImgs.length){
      images = trackImgs.map(im => (im.dataset && im.dataset.full) ? im.dataset.full : im.src);
    }
  }
  if(!images || !images.length){
    images = src ? [src] : [];
  }
  let index = null;
  if(typeof config.startIndex === 'number' && Number.isFinite(config.startIndex)){
    index = config.startIndex;
  } else if(typeof config.startIndex === 'string'){
    const parsedStart = parseInt(config.startIndex, 10);
    if(Number.isFinite(parsedStart)){
      index = parsedStart;
    }
  }
  const originImg = originEl && originEl.tagName === 'IMG' ? originEl : (originEl && originEl.querySelector ? originEl.querySelector('img') : null);
  if(index === null && originImg && originImg.dataset && originImg.dataset.index){
    const parsed = parseInt(originImg.dataset.index, 10);
    if(Number.isFinite(parsed)){
      index = parsed;
    }
  }
  if(index === null && galleryRoot && galleryRoot.dataset && galleryRoot.dataset.index){
    const parsed = parseInt(galleryRoot.dataset.index, 10);
    if(Number.isFinite(parsed)){
      index = parsed;
    }
  }
  if(index === null && src){
    const found = images.indexOf(src);
    if(found !== -1){
      index = found;
    } else {
      const normalizedSrc = normalizeImageModalSrc(src);
      for(let i=0;i<images.length;i++){
        if(normalizeImageModalSrc(images[i]) === normalizedSrc){
          index = i;
          break;
        }
      }
    }
  }
  if(index === null){
    index = 0;
  }
  index = Math.max(0, Math.min(index, images.length ? images.length - 1 : 0));
  result.images = images;
  result.index = index;
  result.gallery = galleryRoot;
  return result;
}

function openImageModal(srcOrConfig, options){
  const base = (typeof srcOrConfig === 'object' && srcOrConfig !== null && !Array.isArray(srcOrConfig))
    ? Object.assign({}, srcOrConfig)
    : {src: srcOrConfig};
  if(options && typeof options === 'object'){
    Object.assign(base, options);
  }
  if(typeof base.src !== 'string' || !base.src){
    return;
  }
  const {container, modal} = ensureImageModalReady();
  if(!container || !modal) return;
  document.querySelectorAll('.image-modal-container').forEach(other => {
    if(other !== container && !other.classList.contains('hidden')){
      closeImageModal(other);
    }
  });
  const context = resolveImageModalContext(base);
  if(!context.images.length) return;
  container._imageModalState = {
    images: context.images.slice(),
    index: context.index,
    gallery: context.gallery || null
  };
  renderImageModalImage(container, modal);
  container.classList.remove('hidden');
}

function initPostLayout(board){
  if(typeof boardAdjustCleanup === 'function'){
    boardAdjustCleanup();
    boardAdjustCleanup = null;
  }
  const scheduleMapResize = mapInstance => {
    if(!mapInstance) return;
    if(typeof mapInstance.resize === 'function'){
      requestAnimationFrame(()=>{
        try { mapInstance.resize(); } catch(err){}
      });
    }
  };
  if(!(board instanceof Element)){
    document.documentElement.style.removeProperty('--post-header-h');
    if(typeof window.adjustBoards === 'function') window.adjustBoards();
    return;
  }
  const openPost = board.querySelector('.open-post');
  if(!openPost){
    document.body.classList.remove('detail-open');
    document.body.classList.remove('hide-map-calendar');
    document.documentElement.style.removeProperty('--post-header-h');
    if(typeof window.adjustBoards === 'function') window.adjustBoards();
    return;
  }
  document.body.classList.add('detail-open');
  document.body.classList.remove('hide-map-calendar');
  const postBody = openPost.querySelector('.post-body');
  if(postBody){
    postBody.removeAttribute('hidden');
    postBody.classList.remove('is-visible');
    if(postBody.dataset) delete postBody.dataset.openPostId;
  }
  const triggerDetailMapResize = target => {
    if(!target) return;
    const mapNode = target.querySelector ? target.querySelector('.post-map') : null;
    const ref = target._detailMap || (mapNode && mapNode._detailMap) || null;
    const mapInstance = ref && ref.map;
    if(mapInstance && typeof mapInstance.resize === 'function'){
      scheduleMapResize(mapInstance);
    }
  };
  triggerDetailMapResize(postBody);
  const thumbRow = postBody ? postBody.querySelector('.thumbnail-row') : null;
  const selectedImageBox = postBody ? postBody.querySelector('.selected-image, .image-box') : null;
  ensureImageModalReady();
  if(thumbRow){
    thumbRow.scrollLeft = 0;
  }
  if(thumbRow && !thumbRow._imageModalListener){
    thumbRow.addEventListener('dblclick', e => {
      const img = e.target.closest('img');
      if(img){
        e.preventDefault();
        e.stopPropagation();
        openImageModal(img.src, {origin: img});
      }
    });
    thumbRow._imageModalListener = true;
  }
  if(selectedImageBox && !selectedImageBox._imageModalListener){
    selectedImageBox.addEventListener('click', evt => {
      const currentTarget = (evt && evt.currentTarget instanceof Element)
        ? evt.currentTarget
        : selectedImageBox;
      const clickedImageBox = (evt && evt.target instanceof Element)
        ? evt.target.closest('.image-box')
        : null;
      if(clickedImageBox){
        return;
      }
      const parseIndex = value => {
        if(typeof value === 'undefined') return null;
        const parsed = parseInt(value, 10);
        return Number.isFinite(parsed) ? parsed : null;
      };
      let galleryRoot = null;
      if(currentTarget instanceof Element){
        if(currentTarget.classList.contains('image-box')){
          galleryRoot = currentTarget;
        } else {
          const postImages = typeof currentTarget.closest === 'function'
            ? currentTarget.closest('.post-images')
            : null;
          const parent = currentTarget.parentElement;
          const host = postImages || parent;
          if(host instanceof Element){
            galleryRoot = host.querySelector('.image-box');
          }
        }
      }
      const activeImg = galleryRoot ? galleryRoot.querySelector('.image-track img.active') : null;
      let img = activeImg || (currentTarget instanceof Element ? currentTarget.querySelector('img') : null);
      if(!img && galleryRoot){
        img = galleryRoot.querySelector('img');
      }
      if(!(img instanceof Element)){
        return;
      }
      if(evt && typeof evt.preventDefault === 'function') evt.preventDefault();
      if(evt && typeof evt.stopPropagation === 'function') evt.stopPropagation();
      let startIndex = null;
      if(activeImg && activeImg.dataset){
        startIndex = parseIndex(activeImg.dataset.index);
      }
      if(startIndex === null && galleryRoot && galleryRoot.dataset){
        startIndex = parseIndex(galleryRoot.dataset.index);
      }
      if(startIndex === null && img.dataset){
        startIndex = parseIndex(img.dataset.index);
      }
      const options = {origin: img};
      if(galleryRoot){
        options.gallery = galleryRoot;
      }
      if(startIndex !== null){
        options.startIndex = startIndex;
      }
      const src = (img.dataset && img.dataset.full) ? img.dataset.full : img.src;
      openImageModal(src, options);
    });
    selectedImageBox._imageModalListener = true;
  }
  if(typeof updateStickyImages === 'function'){
    updateStickyImages();
  }
  const updateMetrics = () => {
    if(typeof updateStickyImages === 'function'){
      updateStickyImages();
    }
    if(openPost){
      const cardHeader = openPost.querySelector('.post-card');
      if(cardHeader){
        document.documentElement.style.setProperty('--post-header-h', cardHeader.offsetHeight + 'px');
      } else {
        document.documentElement.style.removeProperty('--post-header-h');
      }
    }
    triggerDetailMapResize(postBody);
    if(typeof window.adjustBoards === 'function') window.adjustBoards();
  };
  updateMetrics();
  window.addEventListener('resize', updateMetrics);
  window.addEventListener('load', updateMetrics);
  boardAdjustCleanup = () => {
    window.removeEventListener('resize', updateMetrics);
    window.removeEventListener('load', updateMetrics);
  };
}

document.addEventListener('DOMContentLoaded', () => {
  initPostLayout(document.querySelector('.post-board'));
});

// Extracted from <script>
(function(){
  const MESSAGE = 'Please enter a valid URL with a dot and letters after it.';
  const DOT_PATTERN = /\.[A-Za-z]{2,}(?=[^A-Za-z]|$)/;
  const processed = new WeakSet();
  let observerStarted = false;

  function normalizeUrl(value){
    const raw = typeof value === 'string' ? value.trim() : '';
    if(!raw) return '';
    const hasScheme = /^[a-zA-Z][a-zA-Z0-9+.-]*:/.test(raw);
    const candidate = hasScheme ? raw : `https://${raw}`;
    try {
      const normalized = new URL(candidate);
      return normalized.href;
    } catch(err){
      return '';
    }
  }

  function disableLink(link){
    if(!link) return;
    link.setAttribute('aria-disabled','true');
    link.removeAttribute('href');
    link.tabIndex = -1;
  }

  function enableLink(link, href){
    if(!link) return;
    link.removeAttribute('aria-disabled');
    link.href = href;
    if(!link.hasAttribute('target')){
      link.target = '_blank';
    }
    const rel = link.getAttribute('rel') || '';
    const relParts = new Set(rel.split(/\s+/).filter(Boolean));
    relParts.add('noopener');
    relParts.add('noreferrer');
    link.setAttribute('rel', Array.from(relParts).join(' '));
    if(link.tabIndex < 0) link.tabIndex = 0;
  }

  function applyUrlBehavior(input){
    if(!(input instanceof HTMLInputElement)) return;
    if(processed.has(input)) return;
    processed.add(input);
    if(!input.dataset.urlMessage){
      input.dataset.urlMessage = MESSAGE;
    }
    input.setAttribute('pattern', '.*\\.[A-Za-z]{2,}.*');
    input.autocomplete = input.autocomplete || 'url';
    input.inputMode = input.inputMode || 'url';
    input.setAttribute('title', input.dataset.urlMessage);
    const linkId = input.dataset.urlLinkId || '';
    const link = linkId ? document.getElementById(linkId) : null;

    if(link){
      link.addEventListener('click', event => {
        if(link.getAttribute('aria-disabled') === 'true'){
          event.preventDefault();
          event.stopPropagation();
        }
      });
    }

    const validate = ()=>{
      const value = input.value != null ? String(input.value).trim() : '';
      if(!value){
        input.setCustomValidity('');
        if(link) disableLink(link);
        return;
      }
      if(!DOT_PATTERN.test(value)){
        input.setCustomValidity(input.dataset.urlMessage || MESSAGE);
        if(link) disableLink(link);
        return;
      }
      const normalized = normalizeUrl(value);
      if(normalized){
        input.setCustomValidity('');
        if(link) enableLink(link, normalized);
      } else {
        input.setCustomValidity(input.dataset.urlMessage || MESSAGE);
        if(link) disableLink(link);
      }
    };

    input.addEventListener('input', validate);
    input.addEventListener('change', validate);
    input.addEventListener('blur', validate);
    validate();
  }

  function scan(root){
    if(!root) return;
    const list = root.querySelectorAll ? root.querySelectorAll('input[data-url-type]') : [];
    list.forEach(applyUrlBehavior);
  }

  function startObserver(){
    if(observerStarted || !document.body) return;
    observerStarted = true;
    const observer = new MutationObserver(mutations => {
      for(const mutation of mutations){
        if(mutation.type === 'childList'){
          mutation.addedNodes.forEach(node => {
            if(!(node instanceof Element)) return;
            if(node.matches && node.matches('input[data-url-type]')){
              applyUrlBehavior(node);
            }
            if(node.querySelectorAll){
              node.querySelectorAll('input[data-url-type]').forEach(applyUrlBehavior);
            }
          });
        } else if(mutation.type === 'attributes'){
          const target = mutation.target;
          if(target instanceof HTMLInputElement && target.hasAttribute('data-url-type')){
            applyUrlBehavior(target);
          }
        }
      }
    });
    observer.observe(document.body, {
      childList: true,
      subtree: true,
      attributes: true,
      attributeFilter: ['data-url-type']
    });
  }

  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', () => {
      scan(document);
      startObserver();
    }, { once: true });
  } else {
    scan(document);
    startObserver();
  }
})();

// Extracted from <script>
(function(){
  const DEFAULT_MAX = 10;
  const processed = new WeakSet();
  let observerStarted = false;
  let dragState = null;

  function handleThumbDragStart(event){
    const targetEl = event.target instanceof Element ? event.target : null;
    if(targetEl && targetEl.closest('.form-image-remove')){
      event.preventDefault();
      return;
    }
    let thumb = targetEl ? targetEl.closest('.form-image-thumb') : null;
    if(!thumb && event.currentTarget instanceof Element){
      thumb = event.currentTarget.closest('.form-image-thumb');
    }
    if(!thumb) return;
    const previewEl = thumb ? thumb.parentElement : null;
    if(!previewEl || !previewEl._imageInput) return;
    const index = Number.parseInt(thumb.dataset.index || '', 10);
    dragState = {
      input: previewEl._imageInput,
      fromIndex: Number.isNaN(index) ? -1 : index,
      thumb
    };
    thumb.classList.add('is-dragging');
    if(event.dataTransfer){
      event.dataTransfer.effectAllowed = 'move';
      try{ event.dataTransfer.setData('text/plain', thumb.dataset.index || ''); }catch(err){}
    }
  }

  function handleThumbDragEnd(event){
    let thumb = event.target instanceof Element ? event.target.closest('.form-image-thumb') : null;
    if(!thumb && event.currentTarget instanceof Element){
      thumb = event.currentTarget.closest('.form-image-thumb');
    }
    if(!thumb) return;
    thumb.classList.remove('is-dragging');
    if(dragState && dragState.thumb === thumb){
      dragState = null;
    }
  }

  function handlePreviewDragOver(event){
    if(!dragState) return;
    const previewEl = event.currentTarget;
    if(!previewEl || previewEl._imageInput !== dragState.input) return;
    event.preventDefault();
    if(event.dataTransfer){
      event.dataTransfer.dropEffect = 'move';
    }
  }

  function handlePreviewDrop(event){
    if(!dragState) return;
    const previewEl = event.currentTarget;
    if(!previewEl || previewEl._imageInput !== dragState.input) return;
    event.preventDefault();
    event.stopPropagation();
    const files = getStoredFiles(dragState.input);
    const from = dragState.fromIndex;
    if(from < 0 || from >= files.length){
      if(dragState.thumb){
        dragState.thumb.classList.remove('is-dragging');
      }
      dragState = null;
      return;
    }
    let insertIndex = getDropInsertIndex(previewEl, event);
    if(!Number.isInteger(insertIndex) || insertIndex < 0){
      insertIndex = files.length;
    }
    const [moved] = files.splice(from, 1);
    if(insertIndex > files.length){
      insertIndex = files.length;
    }
    if(from < insertIndex){
      insertIndex--;
    }
    if(insertIndex < 0){
      insertIndex = 0;
    }
    files.splice(insertIndex, 0, moved);
    if(dragState.thumb){
      dragState.thumb.classList.remove('is-dragging');
    }
    const input = dragState.input;
    dragState = null;
    storeFiles(input, files);
    renderPreviews(input);
  }

  function getDropInsertIndex(previewEl, event){
    if(!previewEl) return 0;
    const thumbs = Array.from(previewEl.querySelectorAll('.form-image-thumb'));
    if(thumbs.length === 0) return 0;
    const pointerX = event.clientX;
    const pointerY = event.clientY;
    let fallbackIndex = 0;
    for(const thumb of thumbs){
      if(dragState && dragState.thumb === thumb) continue;
      const rect = thumb.getBoundingClientRect();
      const datasetIndex = Number.parseInt(thumb.dataset.index || '', 10);
      if(Number.isNaN(datasetIndex)) continue;
      const centerX = rect.left + rect.width / 2;
      if(pointerY < rect.top){
        return datasetIndex;
      }
      if(pointerY <= rect.bottom){
        if(pointerX < centerX){
          return datasetIndex;
        }
        fallbackIndex = datasetIndex + 1;
        continue;
      }
      fallbackIndex = datasetIndex + 1;
    }
    return fallbackIndex;
  }

  function getMax(input){
    return Number.parseInt(input.dataset.maxImages, 10) || DEFAULT_MAX;
  }

  function getStoredFiles(input){
    if(Array.isArray(input._imageFiles)){
      return input._imageFiles.slice();
    }
    const files = Array.from(input.files || []);
    input._imageFiles = files.slice();
    return files;
  }

  function storeFiles(input, files){
    const copy = files.slice();
    if(typeof DataTransfer !== 'undefined'){
      try {
        const dt = new DataTransfer();
        copy.forEach(file => {
          try { dt.items.add(file); } catch(err){}
        });
        input.files = dt.files;
      } catch(err){}
    }
    input._imageFiles = copy;
    if(copy.length === 0){
      try { input.value = ''; } catch(err){}
    }
  }

  function updateLimitMessage(input, totalSelected){
    const max = getMax(input);
    if(totalSelected > max){
      input._imageLimitMessage = `Only the first ${max} images will be used.`;
    } else {
      input._imageLimitMessage = '';
    }
  }

  function removeImageAt(input, index){
    const files = getStoredFiles(input);
    if(index < 0 || index >= files.length) return;
    files.splice(index, 1);
    updateLimitMessage(input, files.length);
    storeFiles(input, files);
    renderPreviews(input);
  }

  function renderPreviews(input){
    if(!(input instanceof HTMLInputElement)) return;
    const previewId = input.dataset.imagePreviewTarget || '';
    const messageId = input.dataset.imageMessageTarget || '';
    const previewEl = previewId ? document.getElementById(previewId) : null;
    const messageEl = messageId ? document.getElementById(messageId) : null;
    const files = getStoredFiles(input);
    if(messageEl){
      const message = input._imageLimitMessage || '';
      if(message){
        messageEl.textContent = message;
        messageEl.hidden = false;
      } else {
        messageEl.textContent = '';
        messageEl.hidden = true;
      }
    }
    if(previewEl){
      previewEl._imageInput = input;
      if(!previewEl._dragHandlersAttached){
        previewEl.addEventListener('dragover', handlePreviewDragOver);
        previewEl.addEventListener('drop', handlePreviewDrop);
        previewEl._dragHandlersAttached = true;
      }
      previewEl.innerHTML = '';
      files.forEach((file, index) => {
        const thumb = document.createElement('div');
        thumb.className = 'form-image-thumb';
        thumb.dataset.index = String(index);
        thumb.draggable = true;
        thumb.addEventListener('dragstart', handleThumbDragStart);
        thumb.addEventListener('dragend', handleThumbDragEnd);
        const removeBtn = document.createElement('button');
        removeBtn.type = 'button';
        removeBtn.className = 'form-image-remove';
        removeBtn.setAttribute('aria-label', file.name ? `Remove ${file.name}` : `Remove image ${index + 1}`);
        removeBtn.innerHTML = '<span aria-hidden="true">&times;</span>';
        removeBtn.addEventListener('click', event => {
          event.preventDefault();
          event.stopPropagation();
          if(typeof event.stopImmediatePropagation === 'function'){
            event.stopImmediatePropagation();
          }
          removeImageAt(input, index);
        });
        const img = document.createElement('img');
        img.alt = file.name ? `${file.name} preview` : `Image preview ${index + 1}`;
        img.draggable = true;
        img.addEventListener('dragstart', handleThumbDragStart);
        img.addEventListener('dragend', handleThumbDragEnd);
        thumb.append(removeBtn, img);
        previewEl.appendChild(thumb);
        const reader = new FileReader();
        reader.addEventListener('load', () => {
          if(typeof reader.result === 'string'){
            img.src = reader.result;
          }
        });
        try {
          reader.readAsDataURL(file);
        } catch(err){}
      });
    }
  }

  function handleSelectionChange(input){
    const newFiles = Array.from(input.files || []);
    const existing = getStoredFiles(input);
    if(newFiles.length === 0){
      storeFiles(input, existing);
      renderPreviews(input);
      return;
    }
    const combined = existing.concat(newFiles);
    updateLimitMessage(input, combined.length);
    const max = getMax(input);
    const limited = combined.slice(0, max);
    storeFiles(input, limited);
    renderPreviews(input);
  }

  function applyImageBehavior(input){
    if(!(input instanceof HTMLInputElement)) return;
    if(input.type !== 'file') return;
    if(processed.has(input)) return;
    processed.add(input);
    input.multiple = true;
    if(!input.accept) input.accept = 'image/*';
    const initialFiles = Array.from(input.files || []);
    updateLimitMessage(input, initialFiles.length);
    const max = getMax(input);
    const limited = initialFiles.slice(0, max);
    storeFiles(input, limited);
    renderPreviews(input);
    input.addEventListener('change', () => handleSelectionChange(input));
  }

  function scan(root){
    if(!root) return;
    const list = root.querySelectorAll ? root.querySelectorAll('input[data-images-field]') : [];
    list.forEach(applyImageBehavior);
  }

  function startObserver(){
    if(observerStarted || !document.body) return;
    observerStarted = true;
    const observer = new MutationObserver(mutations => {
      for(const mutation of mutations){
        if(mutation.type === 'childList'){
          mutation.addedNodes.forEach(node => {
            if(!(node instanceof Element)) return;
            if(node.matches && node.matches('input[data-images-field]')){
              applyImageBehavior(node);
            }
            if(node.querySelectorAll){
              node.querySelectorAll('input[data-images-field]').forEach(applyImageBehavior);
            }
          });
        } else if(mutation.type === 'attributes'){
          const target = mutation.target;
          if(target instanceof HTMLInputElement && target.hasAttribute('data-images-field')){
            applyImageBehavior(target);
          }
        }
      }
    });
    observer.observe(document.body, {
      childList: true,
      subtree: true,
      attributes: true,
      attributeFilter: ['data-images-field']
    });
  }

  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', () => {
      scan(document);
      startObserver();
    }, { once: true });
  } else {
    scan(document);
    startObserver();
  }
})();

// Extracted from <script>
(function(){
  const MESSAGE = 'Please include "@" and "." in the email address.';
  const processedForms = new WeakSet();

  function ensureFormListener(form){
    if(!form || processedForms.has(form)) return;
    form.addEventListener('submit', () => {
      const candidates = form.querySelectorAll('input[data-email-textboxified="true"]');
      candidates.forEach(input => {
        if(typeof input._emailTextboxValidate === 'function'){
          input._emailTextboxValidate();
        }
      });
    }, true);
    processedForms.add(form);
  }

  function applyEmailBehavior(input){
    if(!(input instanceof HTMLInputElement)) return;
    if(input.dataset.emailTextboxified === 'true') return;
    input.dataset.emailTextboxified = 'true';
    try {
      input.type = 'text';
    } catch(err) {}
    ensureFormListener(input.form || null);

    const validate = () => {
      const value = input.value != null ? String(input.value).trim() : '';
      if(!value){
        input.setCustomValidity('');
        return;
      }
      if(value.includes('@') && value.includes('.')){
        input.setCustomValidity('');
      } else {
        input.setCustomValidity(MESSAGE);
      }
    };

    input._emailTextboxValidate = validate;
    input.addEventListener('input', validate);
    input.addEventListener('change', validate);
    input.addEventListener('blur', validate);
    if(typeof input.setAttribute === 'function'){
      input.setAttribute('title', MESSAGE);
    }
    validate();
  }

  function scan(root){
    if(!root) return;
    const list = root.querySelectorAll ? root.querySelectorAll('input[type="email"]') : [];
    list.forEach(applyEmailBehavior);
  }

  function handleMutations(mutations){
    for(const mutation of mutations){
      if(mutation.type === 'childList'){
        mutation.addedNodes.forEach(node => {
          if(!(node instanceof Element)) return;
          if(node.matches && node.matches('input[type="email"]')){
            applyEmailBehavior(node);
          }
          if(node.querySelectorAll){
            node.querySelectorAll('input[type="email"]').forEach(applyEmailBehavior);
          }
        });
      } else if(mutation.type === 'attributes'){
        const target = mutation.target;
        if(target instanceof HTMLInputElement && target.type === 'email'){
          applyEmailBehavior(target);
        }
      }
    }
  }

  function init(){
    if(!document.body){
      return;
    }
    scan(document);
    const observer = new MutationObserver(handleMutations);
    observer.observe(document.body, {
      childList: true,
      subtree: true,
      attributes: true,
      attributeFilter: ['type']
    });
  }

  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', init, { once: true });
  } else {
    init();
  }
})();

// Extracted from <script>
(function(){
  const USERS_KEY = 'member-auth-users';
  const CURRENT_KEY = 'member-auth-current';
  let users = [];
  let currentUser = null;
  let statusTimer = null;
  let lastAction = 'login';

  let form = null;
  let container = null;
  let tabsWrap = null;
  let loginTab = null;
  let registerTab = null;
  let loginPanel = null;
  let registerPanel = null;
  let profilePanel = null;
  let loginInputs = [];
  let registerInputs = [];
  let profileAvatar = null;
  let profileName = null;
  let profileEmail = null;
  let logoutBtn = null;

  function normalizeUser(user){
    if(!user || typeof user !== 'object') return null;
    const emailRaw = typeof user.email === 'string' ? user.email.trim() : '';
    const normalized = typeof user.emailNormalized === 'string' && user.emailNormalized.trim()
      ? user.emailNormalized.trim().toLowerCase()
      : emailRaw.toLowerCase();
    if(!normalized) return null;
    const usernameRaw = typeof user.username === 'string' ? user.username.trim() : '';
    const username = usernameRaw || normalized;
    return {
      name: typeof user.name === 'string' ? user.name.trim() : '',
      email: emailRaw,
      emailNormalized: normalized,
      username,
      password: typeof user.password === 'string' ? user.password : '',
      avatar: typeof user.avatar === 'string' ? user.avatar.trim() : ''
    };
  }

  function loadUsers(){
    try{
      const raw = localStorage.getItem(USERS_KEY);
      if(!raw) return [];
      const parsed = JSON.parse(raw);
      if(!Array.isArray(parsed)) return [];
      return parsed.map(normalizeUser).filter(Boolean);
    }catch(err){
      return [];
    }
  }

  function saveUsers(list){
    users = Array.isArray(list) ? list.map(normalizeUser).filter(Boolean) : [];
    try{
      localStorage.setItem(USERS_KEY, JSON.stringify(users));
    }catch(err){}
  }

  function extractRoleFlags(source){
    if(!source || typeof source !== 'object') return {};
    const flags = {};
    Object.keys(source).forEach(key => {
      if(typeof source[key] === 'boolean' && (key.startsWith('is') || key.startsWith('can'))){
        flags[key] = source[key];
      }
    });
    if(Array.isArray(source.roles)){
      const cleaned = source.roles
        .map(role => typeof role === 'string' ? role.trim() : '')
        .filter(Boolean);
      if(cleaned.length){
        flags.roles = cleaned;
      }
    }
    if(typeof source.role === 'string'){
      const trimmedRole = source.role.trim();
      if(trimmedRole){
        flags.role = trimmedRole;
      }
    }
    return flags;
  }

  function storeCurrent(user){
    try{
      if(user){
        const idValue = (()=>{
          if(typeof user.id === 'number' && Number.isFinite(user.id)) return user.id;
          if(typeof user.id === 'string'){
            const trimmed = user.id.trim();
            if(!trimmed) return null;
            const numeric = Number(trimmed);
            return Number.isFinite(numeric) ? numeric : trimmed;
          }
          return null;
        })();
        const storedType = (()=>{
          if(user && user.isAdmin) return 'admin';
          if(typeof user.type === 'string'){
            const trimmedType = user.type.trim();
            if(trimmedType){
              return trimmedType.toLowerCase() === 'admin' ? 'admin' : trimmedType;
            }
          }
          return 'member';
        })();
        const payload = {
          type: storedType,
          username: typeof user.username === 'string' ? user.username : '',
          email: typeof user.email === 'string' ? user.email : '',
          name: typeof user.name === 'string' ? user.name : '',
          avatar: typeof user.avatar === 'string' ? user.avatar : ''
        };
        if(idValue !== null){
          payload.id = idValue;
        }
        const roleData = extractRoleFlags(user);
        Object.keys(roleData).forEach(key => {
          payload[key] = roleData[key];
        });
        if(typeof user.emailNormalized === 'string' && user.emailNormalized){
          payload.emailNormalized = user.emailNormalized;
        }
        localStorage.setItem(CURRENT_KEY, JSON.stringify(payload));
      } else {
        localStorage.removeItem(CURRENT_KEY);
      }
    }catch(err){}
  }

  function loadStoredCurrent(){
    try{
      const raw = localStorage.getItem(CURRENT_KEY);
      if(!raw) return null;
      const parsed = JSON.parse(raw);
      if(!parsed || typeof parsed !== 'object') return null;
      const rawType = typeof parsed.type === 'string' ? parsed.type.trim() : '';
      const typeLower = rawType.toLowerCase();
      const type = typeLower === 'admin' ? 'admin' : (rawType || 'member');
      const username = typeof parsed.username === 'string' ? parsed.username : '';
      const emailRaw = typeof parsed.email === 'string' ? parsed.email : username;
      const storedNormalizedEmail = typeof parsed.emailNormalized === 'string'
        ? parsed.emailNormalized.trim().toLowerCase()
        : '';
      const normalized = storedNormalizedEmail || (typeof emailRaw === 'string' ? emailRaw.trim().toLowerCase() : '');
      const storedId = (()=>{
        if(typeof parsed.id === 'number' && Number.isFinite(parsed.id)) return parsed.id;
        if(typeof parsed.id === 'string'){
          const trimmed = parsed.id.trim();
          if(!trimmed) return null;
          const numeric = Number(trimmed);
          return Number.isFinite(numeric) ? numeric : trimmed;
        }
        return null;
      })();
      const storedRoles = extractRoleFlags(parsed);
      if(type === 'admin'){
        if(window.adminAuthManager){
          window.adminAuthManager.setAuthenticated(true, username || emailRaw || 'admin');
        }
        return {
          id: storedId,
          name: parsed.name || 'Administrator',
          email: emailRaw,
          emailNormalized: normalized || 'admin',
          username: username || emailRaw || 'admin',
          avatar: parsed.avatar || '',
          type: 'admin',
          ...storedRoles,
          isAdmin: true
        };
      }
      if(normalized){
        const existing = users.find(u => u.emailNormalized === normalized);
        if(existing){
          return { ...existing, id: storedId, ...storedRoles, type };
        }
      }
      if(!emailRaw){
        return null;
      }
      return {
        id: storedId,
        name: parsed.name || '',
        email: emailRaw,
        emailNormalized: normalized || emailRaw.toLowerCase(),
        username: username || normalized || emailRaw,
        avatar: parsed.avatar || '',
        type,
        ...storedRoles,
        isAdmin: !!storedRoles.isAdmin && storedRoles.isAdmin === true
      };
    }catch(err){}
    return null;
  }

  function svgPlaceholder(letter){
    const palette = ['#2e3a72','#0ea5e9','#f97316','#14b8a6','#a855f7'];
    const color = palette[letter.charCodeAt(0) % palette.length];
    const svg = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 80 80"><rect width="80" height="80" rx="40" fill="${color}"/><text x="50%" y="50%" text-anchor="middle" dominant-baseline="central" font-size="36" font-family="system-ui, sans-serif" fill="#ffffff">${letter}</text></svg>`;
    try{
      return `data:image/svg+xml;base64,${btoa(unescape(encodeURIComponent(svg)))}`;
    }catch(err){
      return `data:image/svg+xml;base64,${btoa(svg)}`;
    }
  }

  function createPlaceholder(name){
    const trimmed = (name || '').trim();
    const initial = trimmed ? trimmed[0].toUpperCase() : 'U';
    return svgPlaceholder(initial);
  }

  function getAvatarSource(user){
    if(!user) return createPlaceholder('');
    const raw = user.avatar ? String(user.avatar).trim() : '';
    if(raw) return raw;
    return createPlaceholder(user.name || user.email || 'U');
  }

  function ensureMemberAvatarImage(){
    const memberBtn = document.getElementById('memberBtn');
    if(!memberBtn) return null;
    let img = memberBtn.querySelector('.member-avatar');
    if(!img){
      img = document.createElement('img');
      img.className = 'member-avatar';
      img.alt = '';
      img.setAttribute('aria-hidden','true');
      memberBtn.appendChild(img);
    }
    return img;
  }

  function updateMemberButton(user){
    const memberBtn = document.getElementById('memberBtn');
    if(!memberBtn) return;
    const img = ensureMemberAvatarImage();
    if(!img) return;
    img.onerror = null;
    img.removeAttribute('data-fallback-applied');
    if(user){
      const descriptor = user.name || user.email || 'Member';
      img.dataset.fallbackApplied = '';
      img.onerror = () => {
        if(img.dataset.fallbackApplied === '1') return;
        img.dataset.fallbackApplied = '1';
        img.src = createPlaceholder(descriptor);
      };
      img.loading = 'lazy';
      img.decoding = 'async';
      img.src = getAvatarSource(user);
      memberBtn.classList.add('has-avatar');
      memberBtn.setAttribute('aria-label', `Open members area for ${descriptor}`);
    } else {
      img.removeAttribute('src');
      img.removeAttribute('data-fallback-applied');
      memberBtn.classList.remove('has-avatar');
      memberBtn.setAttribute('aria-label', 'Open members area');
    }
  }

  async function showStatus(message, options = {}){
    const statusEl = document.getElementById('memberStatusMessage');
    if(!statusEl) return;
    const isError = !!options.error;
    
    // If message looks like a message key (starts with 'msg_'), fetch from DB
    let displayMessage = message;
    if(typeof message === 'string' && message.startsWith('msg_')){
      displayMessage = await getMessage(message, options.placeholders || {}, false) || message;
    }
    
    statusEl.textContent = displayMessage;
    statusEl.classList.remove('error','success','show');
    statusEl.classList.add(isError ? 'error' : 'success');
    statusEl.setAttribute('aria-hidden','false');
    void statusEl.offsetWidth;
    statusEl.classList.add('show');
    if(statusTimer) clearTimeout(statusTimer);
    statusTimer = setTimeout(() => {
      statusEl.classList.remove('show');
      statusEl.classList.remove('error','success');
      statusEl.setAttribute('aria-hidden','true');
    }, 2400);
  }

  function disableInputs(list, disabled){
    list.forEach(input => {
      input.disabled = !!disabled;
    });
  }

  function clearInputs(list){
    list.forEach(input => {
      if('value' in input){
        input.value = '';
      }
    });
  }

  function setAuthPanelState(panelEl, isActive, inputs){
    if(!panelEl) return;
    if(Array.isArray(inputs)){
      disableInputs(inputs, !isActive);
    }
    const submitBtn = panelEl.querySelector('.member-auth-submit');
    if(submitBtn){
      if(!isActive){
        submitBtn.dataset.memberAuthPrevDisabled = submitBtn.disabled ? 'true' : 'false';
        submitBtn.disabled = true;
      } else if('memberAuthPrevDisabled' in submitBtn.dataset){
        submitBtn.disabled = submitBtn.dataset.memberAuthPrevDisabled === 'true';
        delete submitBtn.dataset.memberAuthPrevDisabled;
      } else {
        submitBtn.disabled = false;
      }
    }
    if(!isActive){
      const activeEl = document.activeElement;
      if(activeEl && panelEl.contains(activeEl) && typeof activeEl.blur === 'function'){
        activeEl.blur();
      }
      panelEl.setAttribute('inert','');
    } else {
      panelEl.removeAttribute('inert');
    }
    panelEl.hidden = !isActive;
    panelEl.setAttribute('aria-hidden', (!isActive).toString());
  }

  function focusFirstAuthField(panelEl){
    if(!panelEl || panelEl.hidden) return;
    let ancestor = panelEl.parentElement;
    while(ancestor){
      if(ancestor.hidden || ancestor.getAttribute && ancestor.getAttribute('aria-hidden') === 'true'){
        return;
      }
      ancestor = ancestor.parentElement;
    }
    const target = panelEl.querySelector('input:not([type="hidden"]):not([disabled])')
      || panelEl.querySelector('select:not([disabled])')
      || panelEl.querySelector('textarea:not([disabled])')
      || panelEl.querySelector('button:not([disabled])');
    if(target && typeof target.focus === 'function'){
      requestAnimationFrame(() => target.focus());
    }
  }

  function setActivePanel(panel){
    if(!container || container.dataset.state === 'logged-in') return;
    const target = panel === 'register' ? 'register' : 'login';
    const isLogin = target === 'login';
    if(loginTab) loginTab.setAttribute('aria-selected', isLogin ? 'true' : 'false');
    if(registerTab) registerTab.setAttribute('aria-selected', !isLogin ? 'true' : 'false');
    setAuthPanelState(loginPanel, isLogin, loginInputs);
    setAuthPanelState(registerPanel, !isLogin, registerInputs);
    container.dataset.active = target;
    lastAction = target;
    focusFirstAuthField(isLogin ? loginPanel : registerPanel);
  }

  function render(){
    if(window.adminAuthManager){
      if(currentUser && currentUser.isAdmin){
        const identity = currentUser.username || currentUser.email || 'admin';
        window.adminAuthManager.setAuthenticated(true, identity);
      } else {
        window.adminAuthManager.setAuthenticated(false);
      }
    }
    if(!container) return;
    if(currentUser){
      container.dataset.state = 'logged-in';
      setAuthPanelState(loginPanel, false, loginInputs);
      setAuthPanelState(registerPanel, false, registerInputs);
      clearInputs(loginInputs);
      clearInputs(registerInputs);
      if(profilePanel){
        profilePanel.hidden = false;
        profilePanel.setAttribute('aria-hidden','false');
        profilePanel.removeAttribute('inert');
      }
      if(profileAvatar){
        const descriptor = currentUser.name || currentUser.email || 'Member';
        profileAvatar.dataset.fallbackApplied = '';
        profileAvatar.onerror = () => {
          if(profileAvatar.dataset.fallbackApplied === '1') return;
          profileAvatar.dataset.fallbackApplied = '1';
          profileAvatar.src = createPlaceholder(descriptor);
        };
        profileAvatar.loading = 'lazy';
        profileAvatar.decoding = 'async';
        profileAvatar.src = getAvatarSource(currentUser);
        profileAvatar.alt = `${descriptor}'s avatar`;
      }
      if(profileName) profileName.textContent = currentUser.name || 'Member';
      if(profileEmail) profileEmail.textContent = currentUser.email || '';
      if(tabsWrap) tabsWrap.setAttribute('aria-hidden','true');
      updateMemberButton(currentUser);
      lastAction = 'login';
      if(window.memberPanelChangeManager && typeof window.memberPanelChangeManager.markSaved === 'function'){
        window.memberPanelChangeManager.markSaved();
      }
    } else {
      container.dataset.state = 'logged-out';
      if(profilePanel){
        profilePanel.hidden = true;
        profilePanel.setAttribute('aria-hidden','true');
        profilePanel.setAttribute('inert','');
      }
      if(profileAvatar){
        profileAvatar.onerror = null;
        profileAvatar.removeAttribute('src');
        profileAvatar.removeAttribute('data-fallback-applied');
        profileAvatar.alt = '';
      }
      if(profileName) profileName.textContent = '';
      if(profileEmail) profileEmail.textContent = '';
      if(tabsWrap) tabsWrap.removeAttribute('aria-hidden');
      const active = container.dataset.active === 'register' ? 'register' : 'login';
      setActivePanel(active);
      clearInputs(loginInputs);
      clearInputs(registerInputs);
      updateMemberButton(null);
      if(window.memberPanelChangeManager && typeof window.memberPanelChangeManager.markSaved === 'function'){
        window.memberPanelChangeManager.markSaved();
      }
    }
  }

  async function handleLogin(){
    const emailInput = document.getElementById('memberLoginEmail');
    const passwordInput = document.getElementById('memberLoginPassword');
    const usernameRaw = emailInput ? emailInput.value.trim() : '';
    const password = passwordInput ? passwordInput.value : '';
    if(!usernameRaw || !password){
      await showStatus('msg_auth_login_empty', { error: true });
      if(!usernameRaw && emailInput){
        emailInput.focus();
      } else if(passwordInput){
        passwordInput.focus();
      }
      return;
    }
    let verification = null;
    try{
      verification = await verifyUserLogin(usernameRaw, password);
    }catch(err){
      console.error('Login verification failed', err);
      await showStatus('msg_auth_login_failed', { error: true });
      return;
    }
    if(!verification || verification.success !== true){
      await showStatus('msg_auth_login_incorrect', { error: true });
      if(passwordInput){
        passwordInput.focus();
        passwordInput.select();
      }
      return;
    }
    const payload = verification && verification.user && typeof verification.user === 'object'
      ? verification.user
      : {};
    const payloadEmailRaw = typeof payload.email === 'string' ? payload.email.trim() : '';
    const email = payloadEmailRaw || usernameRaw;
    const normalizedEmail = typeof email === 'string' && email ? email.toLowerCase() : '';
    const payloadUsername = typeof payload.username === 'string' ? payload.username.trim() : '';
    const username = payloadUsername || email || usernameRaw;
    const payloadName = typeof payload.name === 'string' ? payload.name.trim() : '';
    const payloadAvatar = typeof payload.avatar === 'string' ? payload.avatar.trim() : '';
    const payloadId = (()=>{
      if(typeof payload.id === 'number' && Number.isFinite(payload.id)) return payload.id;
      if(typeof payload.id === 'string'){
        const trimmed = payload.id.trim();
        if(!trimmed) return null;
        const numeric = Number(trimmed);
        return Number.isFinite(numeric) ? numeric : trimmed;
      }
      if(typeof payload.user_id === 'number' && Number.isFinite(payload.user_id)) return payload.user_id;
      if(typeof payload.user_id === 'string'){
        const trimmed = payload.user_id.trim();
        if(!trimmed) return null;
        const numeric = Number(trimmed);
        return Number.isFinite(numeric) ? numeric : trimmed;
      }
      if(typeof payload.userId === 'number' && Number.isFinite(payload.userId)) return payload.userId;
      if(typeof payload.userId === 'string'){
        const trimmed = payload.userId.trim();
        if(!trimmed) return null;
        const numeric = Number(trimmed);
        return Number.isFinite(numeric) ? numeric : trimmed;
      }
      return null;
    })();
    const roleFlags = extractRoleFlags(payload);
    const { isAdmin: extractedIsAdmin, roles: extractedRoles, role: extractedRole, ...otherRoleFlags } = roleFlags;
    const rolesList = Array.isArray(extractedRoles)
      ? extractedRoles
      : (Array.isArray(payload.roles)
        ? payload.roles
            .map(role => typeof role === 'string' ? role.trim() : '')
            .filter(Boolean)
        : []);
    const usernameLower = typeof username === 'string' ? username.toLowerCase() : '';
    // Check singular 'role' field - backend returns it at TOP level of response, not inside user object
    const topLevelRole = typeof verification.role === 'string' ? verification.role.toLowerCase() : '';
    const singleRole = topLevelRole || (typeof extractedRole === 'string' ? extractedRole.toLowerCase() : '');
    let isAdmin = false;
    if(typeof payload.isAdmin === 'boolean'){
      isAdmin = payload.isAdmin;
    } else if(typeof extractedIsAdmin === 'boolean'){
      isAdmin = extractedIsAdmin;
    } else if(singleRole === 'admin'){
      // Backend returns { role: 'admin' } for admin users
      isAdmin = true;
    } else if(rolesList.includes('admin')){
      isAdmin = true;
    } else if(normalizedEmail === 'admin' || usernameLower === 'admin'){
      isAdmin = true;
    }
    currentUser = {
      id: payloadId,
      name: payloadName,
      email,
      emailNormalized: normalizedEmail || usernameRaw.toLowerCase(),
      username,
      avatar: payloadAvatar,
      type: isAdmin ? 'admin' : (typeof payload.type === 'string' && payload.type.trim() ? payload.type.trim() : 'member'),
      ...otherRoleFlags,
      ...(rolesList.length ? { roles: rolesList } : {}),
      isAdmin
    };
    if(!currentUser.emailNormalized){
      if(typeof currentUser.email === 'string' && currentUser.email){
        currentUser.emailNormalized = currentUser.email.toLowerCase();
      } else {
        currentUser.emailNormalized = usernameLower;
      }
    }
    if(!currentUser.username){
      currentUser.username = currentUser.email || usernameRaw;
    }
    storeCurrent(currentUser);
    render();
    const displayName = currentUser.name || currentUser.email || currentUser.username;
    await showStatus('msg_auth_login_success', { placeholders: { name: displayName } });
  }

  async function handleRegister(){
    const nameInput = document.getElementById('memberRegisterName');
    const emailInput = document.getElementById('memberRegisterEmail');
    const passwordInput = document.getElementById('memberRegisterPassword');
    const passwordConfirmInput = document.getElementById('memberRegisterPasswordConfirm');
    const avatarInput = document.getElementById('memberRegisterAvatar');
    const name = nameInput ? nameInput.value.trim() : '';
    const emailRaw = emailInput ? emailInput.value.trim() : '';
    const password = passwordInput ? passwordInput.value : '';
    const passwordConfirm = passwordConfirmInput ? passwordConfirmInput.value : '';
    const avatar = avatarInput ? avatarInput.value.trim() : '';
    if(!name || !emailRaw || !password){
      await showStatus('msg_auth_register_empty', { error: true });
      if(!name && nameInput){
        nameInput.focus();
        return;
      }
      if(!emailRaw && emailInput){
        emailInput.focus();
        return;
      }
      if(!password && passwordInput){
        passwordInput.focus();
      }
      return;
    }
    if(password.length < 4){
      await showStatus('msg_auth_register_password_short', { error: true });
      if(passwordInput) passwordInput.focus();
      return;
    }
    if(!passwordConfirm){
      await showStatus('msg_auth_register_empty', { error: true });
      if(passwordConfirmInput) passwordConfirmInput.focus();
      return;
    }
    if(password !== passwordConfirm){
      await showStatus('msg_auth_register_password_mismatch', { error: true });
      if(passwordConfirmInput){
        passwordConfirmInput.focus();
        if(typeof passwordConfirmInput.select === 'function'){
          passwordConfirmInput.select();
        }
      }
      return;
    }
    const normalized = emailRaw.toLowerCase();
    const formData = new FormData();
    formData.set('display_name', name);
    formData.set('email', emailRaw);
    formData.set('password', password);
    formData.set('confirm', passwordConfirm);
    formData.set('avatar_url', avatar);
    let response;
    try{
      response = await fetch('/gateway.php?action=add-member', {
        method: 'POST',
        body: formData
      });
    }catch(err){
      console.error('Registration request failed', err);
      await showStatus('msg_auth_register_failed', { error: true });
      return;
    }
    let responseText = '';
    try{
      responseText = await response.text();
    }catch(err){
      console.error('Failed to read registration response', err);
      await showStatus('msg_auth_register_failed', { error: true });
      return;
    }
    let payload = null;
    if(responseText){
      try{
        payload = JSON.parse(responseText);
      }catch(err){
        payload = null;
      }
    }
    if(!response.ok || !payload || payload.success === false){
      let errorMessage = await getMessage('msg_auth_register_failed', {}, false) || 'Registration failed.';
      if(payload && typeof payload === 'object'){
        const possible = payload.error || payload.message;
        if(typeof possible === 'string' && possible.trim()){
          errorMessage = possible.trim();
        }
      } else if(responseText && responseText.trim()){
        errorMessage = responseText.trim();
      }
      await showStatus(errorMessage, { error: true });
      return;
    }
    const memberData = payload && typeof payload === 'object'
      ? (payload.member || payload.user || payload.data || payload.payload || null)
      : null;
    const resolvedMember = memberData && typeof memberData === 'object' ? memberData : {};
    const memberNameRaw = typeof resolvedMember.display_name === 'string' && resolvedMember.display_name.trim()
      ? resolvedMember.display_name.trim()
      : (typeof resolvedMember.name === 'string' && resolvedMember.name.trim() ? resolvedMember.name.trim() : name);
    const memberEmailRaw = typeof resolvedMember.email === 'string' && resolvedMember.email.trim()
      ? resolvedMember.email.trim()
      : emailRaw;
    const memberAvatarRaw = typeof resolvedMember.avatar_url === 'string' && resolvedMember.avatar_url.trim()
      ? resolvedMember.avatar_url.trim()
      : (typeof resolvedMember.avatar === 'string' && resolvedMember.avatar.trim()
        ? resolvedMember.avatar.trim()
        : avatar);
    const memberUsernameRaw = typeof resolvedMember.username === 'string' && resolvedMember.username.trim()
      ? resolvedMember.username.trim()
      : (memberEmailRaw || normalized);
    const finalEmailRaw = memberEmailRaw || emailRaw;
    const finalEmail = typeof finalEmailRaw === 'string' ? finalEmailRaw.trim() : '';
    const finalNormalized = finalEmail ? finalEmail.toLowerCase() : normalized;
    currentUser = {
      name: memberNameRaw || name,
      email: finalEmail,
      emailNormalized: finalNormalized,
      username: memberUsernameRaw || finalEmail || finalNormalized,
      avatar: memberAvatarRaw || '',
      isAdmin: finalNormalized === 'admin'
    };
    storeCurrent(currentUser);
    if(form && typeof form.reset === 'function'){
      form.reset();
    } else {
      clearInputs(registerInputs);
    }
    render();
    const displayName = currentUser.name || currentUser.email;
    await showStatus('msg_auth_register_success', { placeholders: { name: displayName } });
  }

  async function handleLogout(){
    currentUser = null;
    storeCurrent(null);
    render();
    await showStatus('msg_auth_logout_success');
  }

  function setup(){
    const memberPanel = document.getElementById('memberPanel');
    // Use the actual form element if it exists, otherwise fall back to panel-body
    const authForm = document.getElementById('memberAuthForm');
    form = authForm || (memberPanel ? memberPanel.querySelector('.panel-body') : null);
    if(!form) return;
    container = authForm || form.querySelector('.member-auth');
    if(!container) return;
    tabsWrap = container.querySelector('.member-auth-tabs');
    loginTab = document.getElementById('memberAuthTabLogin');
    registerTab = document.getElementById('memberAuthTabRegister');
    loginPanel = document.getElementById('memberLoginPanel');
    registerPanel = document.getElementById('memberRegisterPanel');
    profilePanel = document.getElementById('memberProfilePanel');
    profileAvatar = document.getElementById('memberProfileAvatar');
    profileName = document.getElementById('memberProfileName');
    profileEmail = document.getElementById('memberProfileEmail');
    logoutBtn = document.getElementById('memberLogoutBtn');
    loginInputs = loginPanel ? Array.from(loginPanel.querySelectorAll('input')) : [];
    registerInputs = registerPanel ? Array.from(registerPanel.querySelectorAll('input')) : [];

    // Handle form submission
    form.addEventListener('submit', event => {
      event.preventDefault();
      let submitter = event.submitter || null;
      if(!submitter){
        const active = document.activeElement || null;
        if(active && form.contains(active)){
          submitter = active;
        }
      }
      const action = submitter && submitter.dataset && submitter.dataset.action ? submitter.dataset.action : lastAction;
      if(action === 'register'){
        handleRegister();
      } else {
        Promise.resolve(handleLogin()).catch(err => {
          console.error('Login handler failed', err);
          showStatus('Unable to process login. Please try again.', { error: true });
        });
      }
    });

    // Add click handlers to submit buttons as fallback
    const submitButtons = form.querySelectorAll('.member-auth-submit');
    submitButtons.forEach(btn => {
      btn.addEventListener('click', (e) => {
        lastAction = btn.dataset.action || 'login';
        // If the form doesn't have native submit behavior, handle click directly
        if(!authForm){
          e.preventDefault();
          if(lastAction === 'register'){
            handleRegister();
          } else {
            Promise.resolve(handleLogin()).catch(err => {
              console.error('Login handler failed', err);
              showStatus('Unable to process login. Please try again.', { error: true });
            });
          }
        }
      });
    });

    if(loginTab){
      loginTab.addEventListener('click', () => {
        setActivePanel('login');
      });
    }
    if(registerTab){
      registerTab.addEventListener('click', () => {
        setActivePanel('register');
      });
    }
    if(logoutBtn){
      logoutBtn.addEventListener('click', event => {
        event.preventDefault();
        if(currentUser){
          handleLogout();
        }
      });
    }

    users = loadUsers();
    currentUser = loadStoredCurrent();
    render();
  }

  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', setup, { once: true });
  } else {
    setup();
  }
})();

// Extracted from <script>
// Wait helpers if your app exposes callWhenDefined; otherwise poll.
(function(){
  function whenDefined(name, cb){
    if (window.callWhenDefined) return window.callWhenDefined(name, cb);
    const iv = setInterval(() => {
      if (typeof window[name] === 'function') { clearInterval(iv); cb(window[name]); }
    }, 20);
  }

  // Debounce/guard in-flight jobs by name
  const _inflight = new Map();
  function guardOnce(name, fn){
    return async function guarded(...args){
      if (_inflight.get(name)) return; // drop duplicates
      _inflight.set(name, true);
      try { return await fn.apply(this, args); }
      finally { _inflight.delete(name); }
    };
  }

  const factories = new Map([
    ['hookDetailActions', (orig) => {
      const wrapped = rafThrottle(function(...args){
        scheduleIdle(() => orig.apply(this, args));
      });
      return guardOnce('hookDetailActions', wrapped);
    }],
    ['ensureMapForVenue', (orig) => {
      let token = 0;
      return guardOnce('ensureMapForVenue', function(...args){
        const myToken = ++token;
        // Defer heavy create to idle; newest call wins.
        scheduleIdle(async () => {
          if (myToken !== token) return;
          try { await orig.apply(this, args); } catch(e) { /* swallow */ }
        }, 300);
      });
    }]
  ]);

  function applyWrapper(name){
    const factory = factories.get(name);
    if (!factory) return;
    whenDefined(name, (orig) => {
      if (typeof orig !== 'function' || orig.__inputWrapped) return;
      const wrapped = factory(orig);
      if (typeof wrapped === 'function'){
        wrapped.__inputWrapped = true;
        window[name] = wrapped;
      }
    });
  }

  ['hookDetailActions','ensureMapForVenue'].forEach(applyWrapper);

  window.__wrapForInputYield = function(name){
    applyWrapper(name);
  };
})();

// LocalStorage Clear Button Handler
(function(){
  async function initClearLocalStorageBtn(){
    const btn = document.getElementById('clearLocalStorageBtn');
    if(!btn) {
      // Retry if button not ready yet
      setTimeout(initClearLocalStorageBtn, 100);
      return;
    }
    
    btn.addEventListener('click', async function(e){
      e.preventDefault();
      e.stopPropagation();
      
      try {
        // Clear localStorage
        const keys = Object.keys(localStorage);
        const keyCount = keys.length;
        localStorage.clear();
        console.log(`[Clear] Cleared ${keyCount} localStorage items`);
        
        // Clear sessionStorage
        if(typeof sessionStorage !== 'undefined'){
          try {
            const sessionKeys = Object.keys(sessionStorage);
            const sessionCount = sessionKeys.length;
            sessionStorage.clear();
            console.log(`[Clear] Cleared ${sessionCount} sessionStorage items`);
          } catch(err){
            console.warn('[Clear] sessionStorage error:', err);
          }
        }
        
        // Clear service workers
        if('serviceWorker' in navigator){
          try {
            const registrations = await navigator.serviceWorker.getRegistrations();
            for(let registration of registrations){
              await registration.unregister();
            }
            console.log(`[Clear] Unregistered ${registrations.length} service worker(s)`);
          } catch(err){
            console.warn('[Clear] Service worker error:', err);
          }
        }
        
        // Clear browser caches (Cache API)
        if('caches' in window){
          try {
            const cacheNames = await caches.keys();
            await Promise.all(cacheNames.map(name => caches.delete(name)));
            console.log(`[Clear] Cleared ${cacheNames.length} cache(s)`);
          } catch(err){
            console.warn('[Clear] Cache error:', err);
          }
        }
        
        // Clear application cache (deprecated but may still exist)
        if(typeof applicationCache !== 'undefined' && applicationCache.status !== applicationCache.UNCACHED){
          try {
            applicationCache.update();
            console.log('[Clear] Application cache update triggered');
          } catch(err){
            console.warn('[Clear] Application cache error:', err);
          }
        }
        
        // Force refetch CSS files to bust HTTP cache
        const timestamp = Date.now();
        const cssPromises = [];
        document.querySelectorAll('link[rel="stylesheet"]').forEach(link => {
          const href = link.href.split('?')[0];
          cssPromises.push(
            fetch(href + '?_cb=' + timestamp, { cache: 'no-store' })
              .catch(err => console.warn('[Clear] CSS fetch error:', err))
          );
        });
        
        // Also fetch main JS with no-store
        cssPromises.push(
          fetch('index.js?_cb=' + timestamp, { cache: 'no-store' })
            .catch(err => console.warn('[Clear] JS fetch error:', err))
        );
        cssPromises.push(
          fetch('style.css?_cb=' + timestamp, { cache: 'no-store' })
            .catch(err => console.warn('[Clear] CSS fetch error:', err))
        );
        
        await Promise.all(cssPromises);
        console.log('[Clear] All storage cleared! Reloading...');
        
        // Navigate with cache buster to force full reload
        const url = new URL(window.location.href);
        url.searchParams.set('_nocache', timestamp);
        window.location.replace(url.toString());
      } catch(err){
        console.error('[Clear] Error:', err);
        // Still reload with cache buster even if there's an error
        const url = new URL(window.location.href);
        url.searchParams.set('_nocache', Date.now());
        window.location.replace(url.toString());
      }
    });
    
    console.log('[Clear] Clear button initialized');
  }
  
  // Initialize when DOM is ready
  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', initClearLocalStorageBtn);
  } else {
    initClearLocalStorageBtn();
  }
})();

 


